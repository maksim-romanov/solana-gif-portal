(function(){const Re=document.createElement("link").relList;if(Re&&Re.supports&&Re.supports("modulepreload"))return;for(const We of document.querySelectorAll('link[rel="modulepreload"]'))qe(We);new MutationObserver(We=>{for(const Ze of We)if(Ze.type==="childList")for(const Xe of Ze.addedNodes)Xe.tagName==="LINK"&&Xe.rel==="modulepreload"&&qe(Xe)}).observe(document,{childList:!0,subtree:!0});function Fe(We){const Ze={};return We.integrity&&(Ze.integrity=We.integrity),We.referrerpolicy&&(Ze.referrerPolicy=We.referrerpolicy),We.crossorigin==="use-credentials"?Ze.credentials="include":We.crossorigin==="anonymous"?Ze.credentials="omit":Ze.credentials="same-origin",Ze}function qe(We){if(We.ep)return;We.ep=!0;const Ze=Fe(We);fetch(We.href,Ze)}})();var commonjsGlobal=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{};function getAugmentedNamespace(Ke){var Re=Ke.default;if(typeof Re=="function"){var Fe=function(){return Re.apply(this,arguments)};Fe.prototype=Re.prototype}else Fe={};return Object.defineProperty(Fe,"__esModule",{value:!0}),Object.keys(Ke).forEach(function(qe){var We=Object.getOwnPropertyDescriptor(Ke,qe);Object.defineProperty(Fe,qe,We.get?We:{enumerable:!0,get:function(){return Ke[qe]}})}),Fe}var buffer$1={},base64Js={};base64Js.byteLength=byteLength;var toByteArray_1=base64Js.toByteArray=toByteArray,fromByteArray_1=base64Js.fromByteArray=fromByteArray,lookup=[],revLookup=[],Arr=typeof Uint8Array<"u"?Uint8Array:Array,code="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";for(var i$2=0,len=code.length;i$2<len;++i$2)lookup[i$2]=code[i$2],revLookup[code.charCodeAt(i$2)]=i$2;revLookup["-".charCodeAt(0)]=62;revLookup["_".charCodeAt(0)]=63;function getLens(Ke){var Re=Ke.length;if(Re%4>0)throw new Error("Invalid string. Length must be a multiple of 4");var Fe=Ke.indexOf("=");Fe===-1&&(Fe=Re);var qe=Fe===Re?0:4-Fe%4;return[Fe,qe]}function byteLength(Ke){var Re=getLens(Ke),Fe=Re[0],qe=Re[1];return(Fe+qe)*3/4-qe}function _byteLength(Ke,Re,Fe){return(Re+Fe)*3/4-Fe}function toByteArray(Ke){var Re,Fe=getLens(Ke),qe=Fe[0],We=Fe[1],Ze=new Arr(_byteLength(Ke,qe,We)),Xe=0,Je=We>0?qe-4:qe,tr;for(tr=0;tr<Je;tr+=4)Re=revLookup[Ke.charCodeAt(tr)]<<18|revLookup[Ke.charCodeAt(tr+1)]<<12|revLookup[Ke.charCodeAt(tr+2)]<<6|revLookup[Ke.charCodeAt(tr+3)],Ze[Xe++]=Re>>16&255,Ze[Xe++]=Re>>8&255,Ze[Xe++]=Re&255;return We===2&&(Re=revLookup[Ke.charCodeAt(tr)]<<2|revLookup[Ke.charCodeAt(tr+1)]>>4,Ze[Xe++]=Re&255),We===1&&(Re=revLookup[Ke.charCodeAt(tr)]<<10|revLookup[Ke.charCodeAt(tr+1)]<<4|revLookup[Ke.charCodeAt(tr+2)]>>2,Ze[Xe++]=Re>>8&255,Ze[Xe++]=Re&255),Ze}function tripletToBase64(Ke){return lookup[Ke>>18&63]+lookup[Ke>>12&63]+lookup[Ke>>6&63]+lookup[Ke&63]}function encodeChunk(Ke,Re,Fe){for(var qe,We=[],Ze=Re;Ze<Fe;Ze+=3)qe=(Ke[Ze]<<16&16711680)+(Ke[Ze+1]<<8&65280)+(Ke[Ze+2]&255),We.push(tripletToBase64(qe));return We.join("")}function fromByteArray(Ke){for(var Re,Fe=Ke.length,qe=Fe%3,We=[],Ze=16383,Xe=0,Je=Fe-qe;Xe<Je;Xe+=Ze)We.push(encodeChunk(Ke,Xe,Xe+Ze>Je?Je:Xe+Ze));return qe===1?(Re=Ke[Fe-1],We.push(lookup[Re>>2]+lookup[Re<<4&63]+"==")):qe===2&&(Re=(Ke[Fe-2]<<8)+Ke[Fe-1],We.push(lookup[Re>>10]+lookup[Re>>4&63]+lookup[Re<<2&63]+"=")),We.join("")}var ieee754={};/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */ieee754.read=function(Ke,Re,Fe,qe,We){var Ze,Xe,Je=We*8-qe-1,tr=(1<<Je)-1,er=tr>>1,ir=-7,ur=Fe?We-1:0,fr=Fe?-1:1,ar=Ke[Re+ur];for(ur+=fr,Ze=ar&(1<<-ir)-1,ar>>=-ir,ir+=Je;ir>0;Ze=Ze*256+Ke[Re+ur],ur+=fr,ir-=8);for(Xe=Ze&(1<<-ir)-1,Ze>>=-ir,ir+=qe;ir>0;Xe=Xe*256+Ke[Re+ur],ur+=fr,ir-=8);if(Ze===0)Ze=1-er;else{if(Ze===tr)return Xe?NaN:(ar?-1:1)*(1/0);Xe=Xe+Math.pow(2,qe),Ze=Ze-er}return(ar?-1:1)*Xe*Math.pow(2,Ze-qe)};ieee754.write=function(Ke,Re,Fe,qe,We,Ze){var Xe,Je,tr,er=Ze*8-We-1,ir=(1<<er)-1,ur=ir>>1,fr=We===23?Math.pow(2,-24)-Math.pow(2,-77):0,ar=qe?0:Ze-1,yr=qe?1:-1,mr=Re<0||Re===0&&1/Re<0?1:0;for(Re=Math.abs(Re),isNaN(Re)||Re===1/0?(Je=isNaN(Re)?1:0,Xe=ir):(Xe=Math.floor(Math.log(Re)/Math.LN2),Re*(tr=Math.pow(2,-Xe))<1&&(Xe--,tr*=2),Xe+ur>=1?Re+=fr/tr:Re+=fr*Math.pow(2,1-ur),Re*tr>=2&&(Xe++,tr/=2),Xe+ur>=ir?(Je=0,Xe=ir):Xe+ur>=1?(Je=(Re*tr-1)*Math.pow(2,We),Xe=Xe+ur):(Je=Re*Math.pow(2,ur-1)*Math.pow(2,We),Xe=0));We>=8;Ke[Fe+ar]=Je&255,ar+=yr,Je/=256,We-=8);for(Xe=Xe<<We|Je,er+=We;er>0;Ke[Fe+ar]=Xe&255,ar+=yr,Xe/=256,er-=8);Ke[Fe+ar-yr]|=mr*128};/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */(function(Ke){const Re=base64Js,Fe=ieee754,qe=typeof Symbol=="function"&&typeof Symbol.for=="function"?Symbol.for("nodejs.util.inspect.custom"):null;Ke.Buffer=Je,Ke.SlowBuffer=Ar,Ke.INSPECT_MAX_BYTES=50;const We=2147483647;Ke.kMaxLength=We,Je.TYPED_ARRAY_SUPPORT=Ze(),!Je.TYPED_ARRAY_SUPPORT&&typeof console<"u"&&typeof console.error=="function"&&console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");function Ze(){try{const nr=new Uint8Array(1),Qe={foo:function(){return 42}};return Object.setPrototypeOf(Qe,Uint8Array.prototype),Object.setPrototypeOf(nr,Qe),nr.foo()===42}catch{return!1}}Object.defineProperty(Je.prototype,"parent",{enumerable:!0,get:function(){if(!!Je.isBuffer(this))return this.buffer}}),Object.defineProperty(Je.prototype,"offset",{enumerable:!0,get:function(){if(!!Je.isBuffer(this))return this.byteOffset}});function Xe(nr){if(nr>We)throw new RangeError('The value "'+nr+'" is invalid for option "size"');const Qe=new Uint8Array(nr);return Object.setPrototypeOf(Qe,Je.prototype),Qe}function Je(nr,Qe,dt){if(typeof nr=="number"){if(typeof Qe=="string")throw new TypeError('The "string" argument must be of type string. Received type number');return ur(nr)}return tr(nr,Qe,dt)}Je.poolSize=8192;function tr(nr,Qe,dt){if(typeof nr=="string")return fr(nr,Qe);if(ArrayBuffer.isView(nr))return yr(nr);if(nr==null)throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof nr);if(Cn(nr,ArrayBuffer)||nr&&Cn(nr.buffer,ArrayBuffer)||typeof SharedArrayBuffer<"u"&&(Cn(nr,SharedArrayBuffer)||nr&&Cn(nr.buffer,SharedArrayBuffer)))return mr(nr,Qe,dt);if(typeof nr=="number")throw new TypeError('The "value" argument must not be of type number. Received type number');const or=nr.valueOf&&nr.valueOf();if(or!=null&&or!==nr)return Je.from(or,Qe,dt);const dr=wr(nr);if(dr)return dr;if(typeof Symbol<"u"&&Symbol.toPrimitive!=null&&typeof nr[Symbol.toPrimitive]=="function")return Je.from(nr[Symbol.toPrimitive]("string"),Qe,dt);throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof nr)}Je.from=function(nr,Qe,dt){return tr(nr,Qe,dt)},Object.setPrototypeOf(Je.prototype,Uint8Array.prototype),Object.setPrototypeOf(Je,Uint8Array);function er(nr){if(typeof nr!="number")throw new TypeError('"size" argument must be of type number');if(nr<0)throw new RangeError('The value "'+nr+'" is invalid for option "size"')}function ir(nr,Qe,dt){return er(nr),nr<=0?Xe(nr):Qe!==void 0?typeof dt=="string"?Xe(nr).fill(Qe,dt):Xe(nr).fill(Qe):Xe(nr)}Je.alloc=function(nr,Qe,dt){return ir(nr,Qe,dt)};function ur(nr){return er(nr),Xe(nr<0?0:Sr(nr)|0)}Je.allocUnsafe=function(nr){return ur(nr)},Je.allocUnsafeSlow=function(nr){return ur(nr)};function fr(nr,Qe){if((typeof Qe!="string"||Qe==="")&&(Qe="utf8"),!Je.isEncoding(Qe))throw new TypeError("Unknown encoding: "+Qe);const dt=vr(nr,Qe)|0;let or=Xe(dt);const dr=or.write(nr,Qe);return dr!==dt&&(or=or.slice(0,dr)),or}function ar(nr){const Qe=nr.length<0?0:Sr(nr.length)|0,dt=Xe(Qe);for(let or=0;or<Qe;or+=1)dt[or]=nr[or]&255;return dt}function yr(nr){if(Cn(nr,Uint8Array)){const Qe=new Uint8Array(nr);return mr(Qe.buffer,Qe.byteOffset,Qe.byteLength)}return ar(nr)}function mr(nr,Qe,dt){if(Qe<0||nr.byteLength<Qe)throw new RangeError('"offset" is outside of buffer bounds');if(nr.byteLength<Qe+(dt||0))throw new RangeError('"length" is outside of buffer bounds');let or;return Qe===void 0&&dt===void 0?or=new Uint8Array(nr):dt===void 0?or=new Uint8Array(nr,Qe):or=new Uint8Array(nr,Qe,dt),Object.setPrototypeOf(or,Je.prototype),or}function wr(nr){if(Je.isBuffer(nr)){const Qe=Sr(nr.length)|0,dt=Xe(Qe);return dt.length===0||nr.copy(dt,0,0,Qe),dt}if(nr.length!==void 0)return typeof nr.length!="number"||Fn(nr.length)?Xe(0):ar(nr);if(nr.type==="Buffer"&&Array.isArray(nr.data))return ar(nr.data)}function Sr(nr){if(nr>=We)throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x"+We.toString(16)+" bytes");return nr|0}function Ar(nr){return+nr!=nr&&(nr=0),Je.alloc(+nr)}Je.isBuffer=function(Qe){return Qe!=null&&Qe._isBuffer===!0&&Qe!==Je.prototype},Je.compare=function(Qe,dt){if(Cn(Qe,Uint8Array)&&(Qe=Je.from(Qe,Qe.offset,Qe.byteLength)),Cn(dt,Uint8Array)&&(dt=Je.from(dt,dt.offset,dt.byteLength)),!Je.isBuffer(Qe)||!Je.isBuffer(dt))throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');if(Qe===dt)return 0;let or=Qe.length,dr=dt.length;for(let br=0,Er=Math.min(or,dr);br<Er;++br)if(Qe[br]!==dt[br]){or=Qe[br],dr=dt[br];break}return or<dr?-1:dr<or?1:0},Je.isEncoding=function(Qe){switch(String(Qe).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"latin1":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return!0;default:return!1}},Je.concat=function(Qe,dt){if(!Array.isArray(Qe))throw new TypeError('"list" argument must be an Array of Buffers');if(Qe.length===0)return Je.alloc(0);let or;if(dt===void 0)for(dt=0,or=0;or<Qe.length;++or)dt+=Qe[or].length;const dr=Je.allocUnsafe(dt);let br=0;for(or=0;or<Qe.length;++or){let Er=Qe[or];if(Cn(Er,Uint8Array))br+Er.length>dr.length?(Je.isBuffer(Er)||(Er=Je.from(Er)),Er.copy(dr,br)):Uint8Array.prototype.set.call(dr,Er,br);else if(Je.isBuffer(Er))Er.copy(dr,br);else throw new TypeError('"list" argument must be an Array of Buffers');br+=Er.length}return dr};function vr(nr,Qe){if(Je.isBuffer(nr))return nr.length;if(ArrayBuffer.isView(nr)||Cn(nr,ArrayBuffer))return nr.byteLength;if(typeof nr!="string")throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type '+typeof nr);const dt=nr.length,or=arguments.length>2&&arguments[2]===!0;if(!or&&dt===0)return 0;let dr=!1;for(;;)switch(Qe){case"ascii":case"latin1":case"binary":return dt;case"utf8":case"utf-8":return Qr(nr).length;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return dt*2;case"hex":return dt>>>1;case"base64":return $n(nr).length;default:if(dr)return or?-1:Qr(nr).length;Qe=(""+Qe).toLowerCase(),dr=!0}}Je.byteLength=vr;function Ir(nr,Qe,dt){let or=!1;if((Qe===void 0||Qe<0)&&(Qe=0),Qe>this.length||((dt===void 0||dt>this.length)&&(dt=this.length),dt<=0)||(dt>>>=0,Qe>>>=0,dt<=Qe))return"";for(nr||(nr="utf8");;)switch(nr){case"hex":return xr(this,Qe,dt);case"utf8":case"utf-8":return Dt(this,Qe,dt);case"ascii":return gr(this,Qe,dt);case"latin1":case"binary":return _r(this,Qe,dt);case"base64":return cr(this,Qe,dt);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return kr(this,Qe,dt);default:if(or)throw new TypeError("Unknown encoding: "+nr);nr=(nr+"").toLowerCase(),or=!0}}Je.prototype._isBuffer=!0;function Tr(nr,Qe,dt){const or=nr[Qe];nr[Qe]=nr[dt],nr[dt]=or}Je.prototype.swap16=function(){const Qe=this.length;if(Qe%2!==0)throw new RangeError("Buffer size must be a multiple of 16-bits");for(let dt=0;dt<Qe;dt+=2)Tr(this,dt,dt+1);return this},Je.prototype.swap32=function(){const Qe=this.length;if(Qe%4!==0)throw new RangeError("Buffer size must be a multiple of 32-bits");for(let dt=0;dt<Qe;dt+=4)Tr(this,dt,dt+3),Tr(this,dt+1,dt+2);return this},Je.prototype.swap64=function(){const Qe=this.length;if(Qe%8!==0)throw new RangeError("Buffer size must be a multiple of 64-bits");for(let dt=0;dt<Qe;dt+=8)Tr(this,dt,dt+7),Tr(this,dt+1,dt+6),Tr(this,dt+2,dt+5),Tr(this,dt+3,dt+4);return this},Je.prototype.toString=function(){const Qe=this.length;return Qe===0?"":arguments.length===0?Dt(this,0,Qe):Ir.apply(this,arguments)},Je.prototype.toLocaleString=Je.prototype.toString,Je.prototype.equals=function(Qe){if(!Je.isBuffer(Qe))throw new TypeError("Argument must be a Buffer");return this===Qe?!0:Je.compare(this,Qe)===0},Je.prototype.inspect=function(){let Qe="";const dt=Ke.INSPECT_MAX_BYTES;return Qe=this.toString("hex",0,dt).replace(/(.{2})/g,"$1 ").trim(),this.length>dt&&(Qe+=" ... "),"<Buffer "+Qe+">"},qe&&(Je.prototype[qe]=Je.prototype.inspect),Je.prototype.compare=function(Qe,dt,or,dr,br){if(Cn(Qe,Uint8Array)&&(Qe=Je.from(Qe,Qe.offset,Qe.byteLength)),!Je.isBuffer(Qe))throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type '+typeof Qe);if(dt===void 0&&(dt=0),or===void 0&&(or=Qe?Qe.length:0),dr===void 0&&(dr=0),br===void 0&&(br=this.length),dt<0||or>Qe.length||dr<0||br>this.length)throw new RangeError("out of range index");if(dr>=br&&dt>=or)return 0;if(dr>=br)return-1;if(dt>=or)return 1;if(dt>>>=0,or>>>=0,dr>>>=0,br>>>=0,this===Qe)return 0;let Er=br-dr,Dr=or-dt;const Vr=Math.min(Er,Dr),Kr=this.slice(dr,br),jr=Qe.slice(dt,or);for(let Hr=0;Hr<Vr;++Hr)if(Kr[Hr]!==jr[Hr]){Er=Kr[Hr],Dr=jr[Hr];break}return Er<Dr?-1:Dr<Er?1:0};function Pr(nr,Qe,dt,or,dr){if(nr.length===0)return-1;if(typeof dt=="string"?(or=dt,dt=0):dt>2147483647?dt=2147483647:dt<-2147483648&&(dt=-2147483648),dt=+dt,Fn(dt)&&(dt=dr?0:nr.length-1),dt<0&&(dt=nr.length+dt),dt>=nr.length){if(dr)return-1;dt=nr.length-1}else if(dt<0)if(dr)dt=0;else return-1;if(typeof Qe=="string"&&(Qe=Je.from(Qe,or)),Je.isBuffer(Qe))return Qe.length===0?-1:Rr(nr,Qe,dt,or,dr);if(typeof Qe=="number")return Qe=Qe&255,typeof Uint8Array.prototype.indexOf=="function"?dr?Uint8Array.prototype.indexOf.call(nr,Qe,dt):Uint8Array.prototype.lastIndexOf.call(nr,Qe,dt):Rr(nr,[Qe],dt,or,dr);throw new TypeError("val must be string, number or Buffer")}function Rr(nr,Qe,dt,or,dr){let br=1,Er=nr.length,Dr=Qe.length;if(or!==void 0&&(or=String(or).toLowerCase(),or==="ucs2"||or==="ucs-2"||or==="utf16le"||or==="utf-16le")){if(nr.length<2||Qe.length<2)return-1;br=2,Er/=2,Dr/=2,dt/=2}function Vr(jr,Hr){return br===1?jr[Hr]:jr.readUInt16BE(Hr*br)}let Kr;if(dr){let jr=-1;for(Kr=dt;Kr<Er;Kr++)if(Vr(nr,Kr)===Vr(Qe,jr===-1?0:Kr-jr)){if(jr===-1&&(jr=Kr),Kr-jr+1===Dr)return jr*br}else jr!==-1&&(Kr-=Kr-jr),jr=-1}else for(dt+Dr>Er&&(dt=Er-Dr),Kr=dt;Kr>=0;Kr--){let jr=!0;for(let Hr=0;Hr<Dr;Hr++)if(Vr(nr,Kr+Hr)!==Vr(Qe,Hr)){jr=!1;break}if(jr)return Kr}return-1}Je.prototype.includes=function(Qe,dt,or){return this.indexOf(Qe,dt,or)!==-1},Je.prototype.indexOf=function(Qe,dt,or){return Pr(this,Qe,dt,or,!0)},Je.prototype.lastIndexOf=function(Qe,dt,or){return Pr(this,Qe,dt,or,!1)};function Br(nr,Qe,dt,or){dt=Number(dt)||0;const dr=nr.length-dt;or?(or=Number(or),or>dr&&(or=dr)):or=dr;const br=Qe.length;or>br/2&&(or=br/2);let Er;for(Er=0;Er<or;++Er){const Dr=parseInt(Qe.substr(Er*2,2),16);if(Fn(Dr))return Er;nr[dt+Er]=Dr}return Er}function Mr(nr,Qe,dt,or){return Jr(Qr(Qe,nr.length-dt),nr,dt,or)}function Lr(nr,Qe,dt,or){return Jr(jn(Qe),nr,dt,or)}function $r(nr,Qe,dt,or){return Jr($n(Qe),nr,dt,or)}function Nr(nr,Qe,dt,or){return Jr(fi(Qe,nr.length-dt),nr,dt,or)}Je.prototype.write=function(Qe,dt,or,dr){if(dt===void 0)dr="utf8",or=this.length,dt=0;else if(or===void 0&&typeof dt=="string")dr=dt,or=this.length,dt=0;else if(isFinite(dt))dt=dt>>>0,isFinite(or)?(or=or>>>0,dr===void 0&&(dr="utf8")):(dr=or,or=void 0);else throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");const br=this.length-dt;if((or===void 0||or>br)&&(or=br),Qe.length>0&&(or<0||dt<0)||dt>this.length)throw new RangeError("Attempt to write outside buffer bounds");dr||(dr="utf8");let Er=!1;for(;;)switch(dr){case"hex":return Br(this,Qe,dt,or);case"utf8":case"utf-8":return Mr(this,Qe,dt,or);case"ascii":case"latin1":case"binary":return Lr(this,Qe,dt,or);case"base64":return $r(this,Qe,dt,or);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return Nr(this,Qe,dt,or);default:if(Er)throw new TypeError("Unknown encoding: "+dr);dr=(""+dr).toLowerCase(),Er=!0}},Je.prototype.toJSON=function(){return{type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}};function cr(nr,Qe,dt){return Qe===0&&dt===nr.length?Re.fromByteArray(nr):Re.fromByteArray(nr.slice(Qe,dt))}function Dt(nr,Qe,dt){dt=Math.min(nr.length,dt);const or=[];let dr=Qe;for(;dr<dt;){const br=nr[dr];let Er=null,Dr=br>239?4:br>223?3:br>191?2:1;if(dr+Dr<=dt){let Vr,Kr,jr,Hr;switch(Dr){case 1:br<128&&(Er=br);break;case 2:Vr=nr[dr+1],(Vr&192)===128&&(Hr=(br&31)<<6|Vr&63,Hr>127&&(Er=Hr));break;case 3:Vr=nr[dr+1],Kr=nr[dr+2],(Vr&192)===128&&(Kr&192)===128&&(Hr=(br&15)<<12|(Vr&63)<<6|Kr&63,Hr>2047&&(Hr<55296||Hr>57343)&&(Er=Hr));break;case 4:Vr=nr[dr+1],Kr=nr[dr+2],jr=nr[dr+3],(Vr&192)===128&&(Kr&192)===128&&(jr&192)===128&&(Hr=(br&15)<<18|(Vr&63)<<12|(Kr&63)<<6|jr&63,Hr>65535&&Hr<1114112&&(Er=Hr))}}Er===null?(Er=65533,Dr=1):Er>65535&&(Er-=65536,or.push(Er>>>10&1023|55296),Er=56320|Er&1023),or.push(Er),dr+=Dr}return lr(or)}const sr=4096;function lr(nr){const Qe=nr.length;if(Qe<=sr)return String.fromCharCode.apply(String,nr);let dt="",or=0;for(;or<Qe;)dt+=String.fromCharCode.apply(String,nr.slice(or,or+=sr));return dt}function gr(nr,Qe,dt){let or="";dt=Math.min(nr.length,dt);for(let dr=Qe;dr<dt;++dr)or+=String.fromCharCode(nr[dr]&127);return or}function _r(nr,Qe,dt){let or="";dt=Math.min(nr.length,dt);for(let dr=Qe;dr<dt;++dr)or+=String.fromCharCode(nr[dr]);return or}function xr(nr,Qe,dt){const or=nr.length;(!Qe||Qe<0)&&(Qe=0),(!dt||dt<0||dt>or)&&(dt=or);let dr="";for(let br=Qe;br<dt;++br)dr+=Kn[nr[br]];return dr}function kr(nr,Qe,dt){const or=nr.slice(Qe,dt);let dr="";for(let br=0;br<or.length-1;br+=2)dr+=String.fromCharCode(or[br]+or[br+1]*256);return dr}Je.prototype.slice=function(Qe,dt){const or=this.length;Qe=~~Qe,dt=dt===void 0?or:~~dt,Qe<0?(Qe+=or,Qe<0&&(Qe=0)):Qe>or&&(Qe=or),dt<0?(dt+=or,dt<0&&(dt=0)):dt>or&&(dt=or),dt<Qe&&(dt=Qe);const dr=this.subarray(Qe,dt);return Object.setPrototypeOf(dr,Je.prototype),dr};function pr(nr,Qe,dt){if(nr%1!==0||nr<0)throw new RangeError("offset is not uint");if(nr+Qe>dt)throw new RangeError("Trying to access beyond buffer length")}Je.prototype.readUintLE=Je.prototype.readUIntLE=function(Qe,dt,or){Qe=Qe>>>0,dt=dt>>>0,or||pr(Qe,dt,this.length);let dr=this[Qe],br=1,Er=0;for(;++Er<dt&&(br*=256);)dr+=this[Qe+Er]*br;return dr},Je.prototype.readUintBE=Je.prototype.readUIntBE=function(Qe,dt,or){Qe=Qe>>>0,dt=dt>>>0,or||pr(Qe,dt,this.length);let dr=this[Qe+--dt],br=1;for(;dt>0&&(br*=256);)dr+=this[Qe+--dt]*br;return dr},Je.prototype.readUint8=Je.prototype.readUInt8=function(Qe,dt){return Qe=Qe>>>0,dt||pr(Qe,1,this.length),this[Qe]},Je.prototype.readUint16LE=Je.prototype.readUInt16LE=function(Qe,dt){return Qe=Qe>>>0,dt||pr(Qe,2,this.length),this[Qe]|this[Qe+1]<<8},Je.prototype.readUint16BE=Je.prototype.readUInt16BE=function(Qe,dt){return Qe=Qe>>>0,dt||pr(Qe,2,this.length),this[Qe]<<8|this[Qe+1]},Je.prototype.readUint32LE=Je.prototype.readUInt32LE=function(Qe,dt){return Qe=Qe>>>0,dt||pr(Qe,4,this.length),(this[Qe]|this[Qe+1]<<8|this[Qe+2]<<16)+this[Qe+3]*16777216},Je.prototype.readUint32BE=Je.prototype.readUInt32BE=function(Qe,dt){return Qe=Qe>>>0,dt||pr(Qe,4,this.length),this[Qe]*16777216+(this[Qe+1]<<16|this[Qe+2]<<8|this[Qe+3])},Je.prototype.readBigUInt64LE=qn(function(Qe){Qe=Qe>>>0,Hn(Qe,"offset");const dt=this[Qe],or=this[Qe+7];(dt===void 0||or===void 0)&&Xr(Qe,this.length-8);const dr=dt+this[++Qe]*2**8+this[++Qe]*2**16+this[++Qe]*2**24,br=this[++Qe]+this[++Qe]*2**8+this[++Qe]*2**16+or*2**24;return BigInt(dr)+(BigInt(br)<<BigInt(32))}),Je.prototype.readBigUInt64BE=qn(function(Qe){Qe=Qe>>>0,Hn(Qe,"offset");const dt=this[Qe],or=this[Qe+7];(dt===void 0||or===void 0)&&Xr(Qe,this.length-8);const dr=dt*2**24+this[++Qe]*2**16+this[++Qe]*2**8+this[++Qe],br=this[++Qe]*2**24+this[++Qe]*2**16+this[++Qe]*2**8+or;return(BigInt(dr)<<BigInt(32))+BigInt(br)}),Je.prototype.readIntLE=function(Qe,dt,or){Qe=Qe>>>0,dt=dt>>>0,or||pr(Qe,dt,this.length);let dr=this[Qe],br=1,Er=0;for(;++Er<dt&&(br*=256);)dr+=this[Qe+Er]*br;return br*=128,dr>=br&&(dr-=Math.pow(2,8*dt)),dr},Je.prototype.readIntBE=function(Qe,dt,or){Qe=Qe>>>0,dt=dt>>>0,or||pr(Qe,dt,this.length);let dr=dt,br=1,Er=this[Qe+--dr];for(;dr>0&&(br*=256);)Er+=this[Qe+--dr]*br;return br*=128,Er>=br&&(Er-=Math.pow(2,8*dt)),Er},Je.prototype.readInt8=function(Qe,dt){return Qe=Qe>>>0,dt||pr(Qe,1,this.length),this[Qe]&128?(255-this[Qe]+1)*-1:this[Qe]},Je.prototype.readInt16LE=function(Qe,dt){Qe=Qe>>>0,dt||pr(Qe,2,this.length);const or=this[Qe]|this[Qe+1]<<8;return or&32768?or|4294901760:or},Je.prototype.readInt16BE=function(Qe,dt){Qe=Qe>>>0,dt||pr(Qe,2,this.length);const or=this[Qe+1]|this[Qe]<<8;return or&32768?or|4294901760:or},Je.prototype.readInt32LE=function(Qe,dt){return Qe=Qe>>>0,dt||pr(Qe,4,this.length),this[Qe]|this[Qe+1]<<8|this[Qe+2]<<16|this[Qe+3]<<24},Je.prototype.readInt32BE=function(Qe,dt){return Qe=Qe>>>0,dt||pr(Qe,4,this.length),this[Qe]<<24|this[Qe+1]<<16|this[Qe+2]<<8|this[Qe+3]},Je.prototype.readBigInt64LE=qn(function(Qe){Qe=Qe>>>0,Hn(Qe,"offset");const dt=this[Qe],or=this[Qe+7];(dt===void 0||or===void 0)&&Xr(Qe,this.length-8);const dr=this[Qe+4]+this[Qe+5]*2**8+this[Qe+6]*2**16+(or<<24);return(BigInt(dr)<<BigInt(32))+BigInt(dt+this[++Qe]*2**8+this[++Qe]*2**16+this[++Qe]*2**24)}),Je.prototype.readBigInt64BE=qn(function(Qe){Qe=Qe>>>0,Hn(Qe,"offset");const dt=this[Qe],or=this[Qe+7];(dt===void 0||or===void 0)&&Xr(Qe,this.length-8);const dr=(dt<<24)+this[++Qe]*2**16+this[++Qe]*2**8+this[++Qe];return(BigInt(dr)<<BigInt(32))+BigInt(this[++Qe]*2**24+this[++Qe]*2**16+this[++Qe]*2**8+or)}),Je.prototype.readFloatLE=function(Qe,dt){return Qe=Qe>>>0,dt||pr(Qe,4,this.length),Fe.read(this,Qe,!0,23,4)},Je.prototype.readFloatBE=function(Qe,dt){return Qe=Qe>>>0,dt||pr(Qe,4,this.length),Fe.read(this,Qe,!1,23,4)},Je.prototype.readDoubleLE=function(Qe,dt){return Qe=Qe>>>0,dt||pr(Qe,8,this.length),Fe.read(this,Qe,!0,52,8)},Je.prototype.readDoubleBE=function(Qe,dt){return Qe=Qe>>>0,dt||pr(Qe,8,this.length),Fe.read(this,Qe,!1,52,8)};function rr(nr,Qe,dt,or,dr,br){if(!Je.isBuffer(nr))throw new TypeError('"buffer" argument must be a Buffer instance');if(Qe>dr||Qe<br)throw new RangeError('"value" argument is out of bounds');if(dt+or>nr.length)throw new RangeError("Index out of range")}Je.prototype.writeUintLE=Je.prototype.writeUIntLE=function(Qe,dt,or,dr){if(Qe=+Qe,dt=dt>>>0,or=or>>>0,!dr){const Dr=Math.pow(2,8*or)-1;rr(this,Qe,dt,or,Dr,0)}let br=1,Er=0;for(this[dt]=Qe&255;++Er<or&&(br*=256);)this[dt+Er]=Qe/br&255;return dt+or},Je.prototype.writeUintBE=Je.prototype.writeUIntBE=function(Qe,dt,or,dr){if(Qe=+Qe,dt=dt>>>0,or=or>>>0,!dr){const Dr=Math.pow(2,8*or)-1;rr(this,Qe,dt,or,Dr,0)}let br=or-1,Er=1;for(this[dt+br]=Qe&255;--br>=0&&(Er*=256);)this[dt+br]=Qe/Er&255;return dt+or},Je.prototype.writeUint8=Je.prototype.writeUInt8=function(Qe,dt,or){return Qe=+Qe,dt=dt>>>0,or||rr(this,Qe,dt,1,255,0),this[dt]=Qe&255,dt+1},Je.prototype.writeUint16LE=Je.prototype.writeUInt16LE=function(Qe,dt,or){return Qe=+Qe,dt=dt>>>0,or||rr(this,Qe,dt,2,65535,0),this[dt]=Qe&255,this[dt+1]=Qe>>>8,dt+2},Je.prototype.writeUint16BE=Je.prototype.writeUInt16BE=function(Qe,dt,or){return Qe=+Qe,dt=dt>>>0,or||rr(this,Qe,dt,2,65535,0),this[dt]=Qe>>>8,this[dt+1]=Qe&255,dt+2},Je.prototype.writeUint32LE=Je.prototype.writeUInt32LE=function(Qe,dt,or){return Qe=+Qe,dt=dt>>>0,or||rr(this,Qe,dt,4,4294967295,0),this[dt+3]=Qe>>>24,this[dt+2]=Qe>>>16,this[dt+1]=Qe>>>8,this[dt]=Qe&255,dt+4},Je.prototype.writeUint32BE=Je.prototype.writeUInt32BE=function(Qe,dt,or){return Qe=+Qe,dt=dt>>>0,or||rr(this,Qe,dt,4,4294967295,0),this[dt]=Qe>>>24,this[dt+1]=Qe>>>16,this[dt+2]=Qe>>>8,this[dt+3]=Qe&255,dt+4};function hr(nr,Qe,dt,or,dr){Gr(Qe,or,dr,nr,dt,7);let br=Number(Qe&BigInt(4294967295));nr[dt++]=br,br=br>>8,nr[dt++]=br,br=br>>8,nr[dt++]=br,br=br>>8,nr[dt++]=br;let Er=Number(Qe>>BigInt(32)&BigInt(4294967295));return nr[dt++]=Er,Er=Er>>8,nr[dt++]=Er,Er=Er>>8,nr[dt++]=Er,Er=Er>>8,nr[dt++]=Er,dt}function Cr(nr,Qe,dt,or,dr){Gr(Qe,or,dr,nr,dt,7);let br=Number(Qe&BigInt(4294967295));nr[dt+7]=br,br=br>>8,nr[dt+6]=br,br=br>>8,nr[dt+5]=br,br=br>>8,nr[dt+4]=br;let Er=Number(Qe>>BigInt(32)&BigInt(4294967295));return nr[dt+3]=Er,Er=Er>>8,nr[dt+2]=Er,Er=Er>>8,nr[dt+1]=Er,Er=Er>>8,nr[dt]=Er,dt+8}Je.prototype.writeBigUInt64LE=qn(function(Qe,dt=0){return hr(this,Qe,dt,BigInt(0),BigInt("0xffffffffffffffff"))}),Je.prototype.writeBigUInt64BE=qn(function(Qe,dt=0){return Cr(this,Qe,dt,BigInt(0),BigInt("0xffffffffffffffff"))}),Je.prototype.writeIntLE=function(Qe,dt,or,dr){if(Qe=+Qe,dt=dt>>>0,!dr){const Vr=Math.pow(2,8*or-1);rr(this,Qe,dt,or,Vr-1,-Vr)}let br=0,Er=1,Dr=0;for(this[dt]=Qe&255;++br<or&&(Er*=256);)Qe<0&&Dr===0&&this[dt+br-1]!==0&&(Dr=1),this[dt+br]=(Qe/Er>>0)-Dr&255;return dt+or},Je.prototype.writeIntBE=function(Qe,dt,or,dr){if(Qe=+Qe,dt=dt>>>0,!dr){const Vr=Math.pow(2,8*or-1);rr(this,Qe,dt,or,Vr-1,-Vr)}let br=or-1,Er=1,Dr=0;for(this[dt+br]=Qe&255;--br>=0&&(Er*=256);)Qe<0&&Dr===0&&this[dt+br+1]!==0&&(Dr=1),this[dt+br]=(Qe/Er>>0)-Dr&255;return dt+or},Je.prototype.writeInt8=function(Qe,dt,or){return Qe=+Qe,dt=dt>>>0,or||rr(this,Qe,dt,1,127,-128),Qe<0&&(Qe=255+Qe+1),this[dt]=Qe&255,dt+1},Je.prototype.writeInt16LE=function(Qe,dt,or){return Qe=+Qe,dt=dt>>>0,or||rr(this,Qe,dt,2,32767,-32768),this[dt]=Qe&255,this[dt+1]=Qe>>>8,dt+2},Je.prototype.writeInt16BE=function(Qe,dt,or){return Qe=+Qe,dt=dt>>>0,or||rr(this,Qe,dt,2,32767,-32768),this[dt]=Qe>>>8,this[dt+1]=Qe&255,dt+2},Je.prototype.writeInt32LE=function(Qe,dt,or){return Qe=+Qe,dt=dt>>>0,or||rr(this,Qe,dt,4,2147483647,-2147483648),this[dt]=Qe&255,this[dt+1]=Qe>>>8,this[dt+2]=Qe>>>16,this[dt+3]=Qe>>>24,dt+4},Je.prototype.writeInt32BE=function(Qe,dt,or){return Qe=+Qe,dt=dt>>>0,or||rr(this,Qe,dt,4,2147483647,-2147483648),Qe<0&&(Qe=4294967295+Qe+1),this[dt]=Qe>>>24,this[dt+1]=Qe>>>16,this[dt+2]=Qe>>>8,this[dt+3]=Qe&255,dt+4},Je.prototype.writeBigInt64LE=qn(function(Qe,dt=0){return hr(this,Qe,dt,-BigInt("0x8000000000000000"),BigInt("0x7fffffffffffffff"))}),Je.prototype.writeBigInt64BE=qn(function(Qe,dt=0){return Cr(this,Qe,dt,-BigInt("0x8000000000000000"),BigInt("0x7fffffffffffffff"))});function Or(nr,Qe,dt,or,dr,br){if(dt+or>nr.length)throw new RangeError("Index out of range");if(dt<0)throw new RangeError("Index out of range")}function Ur(nr,Qe,dt,or,dr){return Qe=+Qe,dt=dt>>>0,dr||Or(nr,Qe,dt,4),Fe.write(nr,Qe,dt,or,23,4),dt+4}Je.prototype.writeFloatLE=function(Qe,dt,or){return Ur(this,Qe,dt,!0,or)},Je.prototype.writeFloatBE=function(Qe,dt,or){return Ur(this,Qe,dt,!1,or)};function qr(nr,Qe,dt,or,dr){return Qe=+Qe,dt=dt>>>0,dr||Or(nr,Qe,dt,8),Fe.write(nr,Qe,dt,or,52,8),dt+8}Je.prototype.writeDoubleLE=function(Qe,dt,or){return qr(this,Qe,dt,!0,or)},Je.prototype.writeDoubleBE=function(Qe,dt,or){return qr(this,Qe,dt,!1,or)},Je.prototype.copy=function(Qe,dt,or,dr){if(!Je.isBuffer(Qe))throw new TypeError("argument should be a Buffer");if(or||(or=0),!dr&&dr!==0&&(dr=this.length),dt>=Qe.length&&(dt=Qe.length),dt||(dt=0),dr>0&&dr<or&&(dr=or),dr===or||Qe.length===0||this.length===0)return 0;if(dt<0)throw new RangeError("targetStart out of bounds");if(or<0||or>=this.length)throw new RangeError("Index out of range");if(dr<0)throw new RangeError("sourceEnd out of bounds");dr>this.length&&(dr=this.length),Qe.length-dt<dr-or&&(dr=Qe.length-dt+or);const br=dr-or;return this===Qe&&typeof Uint8Array.prototype.copyWithin=="function"?this.copyWithin(dt,or,dr):Uint8Array.prototype.set.call(Qe,this.subarray(or,dr),dt),br},Je.prototype.fill=function(Qe,dt,or,dr){if(typeof Qe=="string"){if(typeof dt=="string"?(dr=dt,dt=0,or=this.length):typeof or=="string"&&(dr=or,or=this.length),dr!==void 0&&typeof dr!="string")throw new TypeError("encoding must be a string");if(typeof dr=="string"&&!Je.isEncoding(dr))throw new TypeError("Unknown encoding: "+dr);if(Qe.length===1){const Er=Qe.charCodeAt(0);(dr==="utf8"&&Er<128||dr==="latin1")&&(Qe=Er)}}else typeof Qe=="number"?Qe=Qe&255:typeof Qe=="boolean"&&(Qe=Number(Qe));if(dt<0||this.length<dt||this.length<or)throw new RangeError("Out of range index");if(or<=dt)return this;dt=dt>>>0,or=or===void 0?this.length:or>>>0,Qe||(Qe=0);let br;if(typeof Qe=="number")for(br=dt;br<or;++br)this[br]=Qe;else{const Er=Je.isBuffer(Qe)?Qe:Je.from(Qe,dr),Dr=Er.length;if(Dr===0)throw new TypeError('The value "'+Qe+'" is invalid for argument "value"');for(br=0;br<or-dt;++br)this[br+dt]=Er[br%Dr]}return this};const Fr={};function zr(nr,Qe,dt){Fr[nr]=class extends dt{constructor(){super(),Object.defineProperty(this,"message",{value:Qe.apply(this,arguments),writable:!0,configurable:!0}),this.name=`${this.name} [${nr}]`,this.stack,delete this.name}get code(){return nr}set code(dr){Object.defineProperty(this,"code",{configurable:!0,enumerable:!0,value:dr,writable:!0})}toString(){return`${this.name} [${nr}]: ${this.message}`}}}zr("ERR_BUFFER_OUT_OF_BOUNDS",function(nr){return nr?`${nr} is outside of buffer bounds`:"Attempt to access memory outside buffer bounds"},RangeError),zr("ERR_INVALID_ARG_TYPE",function(nr,Qe){return`The "${nr}" argument must be of type number. Received type ${typeof Qe}`},TypeError),zr("ERR_OUT_OF_RANGE",function(nr,Qe,dt){let or=`The value of "${nr}" is out of range.`,dr=dt;return Number.isInteger(dt)&&Math.abs(dt)>2**32?dr=Yr(String(dt)):typeof dt=="bigint"&&(dr=String(dt),(dt>BigInt(2)**BigInt(32)||dt<-(BigInt(2)**BigInt(32)))&&(dr=Yr(dr)),dr+="n"),or+=` It must be ${Qe}. Received ${dr}`,or},RangeError);function Yr(nr){let Qe="",dt=nr.length;const or=nr[0]==="-"?1:0;for(;dt>=or+4;dt-=3)Qe=`_${nr.slice(dt-3,dt)}${Qe}`;return`${nr.slice(0,dt)}${Qe}`}function Wr(nr,Qe,dt){Hn(Qe,"offset"),(nr[Qe]===void 0||nr[Qe+dt]===void 0)&&Xr(Qe,nr.length-(dt+1))}function Gr(nr,Qe,dt,or,dr,br){if(nr>dt||nr<Qe){const Er=typeof Qe=="bigint"?"n":"";let Dr;throw br>3?Qe===0||Qe===BigInt(0)?Dr=`>= 0${Er} and < 2${Er} ** ${(br+1)*8}${Er}`:Dr=`>= -(2${Er} ** ${(br+1)*8-1}${Er}) and < 2 ** ${(br+1)*8-1}${Er}`:Dr=`>= ${Qe}${Er} and <= ${dt}${Er}`,new Fr.ERR_OUT_OF_RANGE("value",Dr,nr)}Wr(or,dr,br)}function Hn(nr,Qe){if(typeof nr!="number")throw new Fr.ERR_INVALID_ARG_TYPE(Qe,"number",nr)}function Xr(nr,Qe,dt){throw Math.floor(nr)!==nr?(Hn(nr,dt),new Fr.ERR_OUT_OF_RANGE(dt||"offset","an integer",nr)):Qe<0?new Fr.ERR_BUFFER_OUT_OF_BOUNDS:new Fr.ERR_OUT_OF_RANGE(dt||"offset",`>= ${dt?1:0} and <= ${Qe}`,nr)}const Zr=/[^+/0-9A-Za-z-_]/g;function Wn(nr){if(nr=nr.split("=")[0],nr=nr.trim().replace(Zr,""),nr.length<2)return"";for(;nr.length%4!==0;)nr=nr+"=";return nr}function Qr(nr,Qe){Qe=Qe||1/0;let dt;const or=nr.length;let dr=null;const br=[];for(let Er=0;Er<or;++Er){if(dt=nr.charCodeAt(Er),dt>55295&&dt<57344){if(!dr){if(dt>56319){(Qe-=3)>-1&&br.push(239,191,189);continue}else if(Er+1===or){(Qe-=3)>-1&&br.push(239,191,189);continue}dr=dt;continue}if(dt<56320){(Qe-=3)>-1&&br.push(239,191,189),dr=dt;continue}dt=(dr-55296<<10|dt-56320)+65536}else dr&&(Qe-=3)>-1&&br.push(239,191,189);if(dr=null,dt<128){if((Qe-=1)<0)break;br.push(dt)}else if(dt<2048){if((Qe-=2)<0)break;br.push(dt>>6|192,dt&63|128)}else if(dt<65536){if((Qe-=3)<0)break;br.push(dt>>12|224,dt>>6&63|128,dt&63|128)}else if(dt<1114112){if((Qe-=4)<0)break;br.push(dt>>18|240,dt>>12&63|128,dt>>6&63|128,dt&63|128)}else throw new Error("Invalid code point")}return br}function jn(nr){const Qe=[];for(let dt=0;dt<nr.length;++dt)Qe.push(nr.charCodeAt(dt)&255);return Qe}function fi(nr,Qe){let dt,or,dr;const br=[];for(let Er=0;Er<nr.length&&!((Qe-=2)<0);++Er)dt=nr.charCodeAt(Er),or=dt>>8,dr=dt%256,br.push(dr),br.push(or);return br}function $n(nr){return Re.toByteArray(Wn(nr))}function Jr(nr,Qe,dt,or){let dr;for(dr=0;dr<or&&!(dr+dt>=Qe.length||dr>=nr.length);++dr)Qe[dr+dt]=nr[dr];return dr}function Cn(nr,Qe){return nr instanceof Qe||nr!=null&&nr.constructor!=null&&nr.constructor.name!=null&&nr.constructor.name===Qe.name}function Fn(nr){return nr!==nr}const Kn=function(){const nr="0123456789abcdef",Qe=new Array(256);for(let dt=0;dt<16;++dt){const or=dt*16;for(let dr=0;dr<16;++dr)Qe[or+dr]=nr[dt]+nr[dr]}return Qe}();function qn(nr){return typeof BigInt>"u"?Un:nr}function Un(){throw new Error("BigInt not supported")}})(buffer$1);window.Buffer=buffer$1.Buffer;const index="";var n,l$1,u$2,t$1,o$2,r$2,f$2={},e$1=[],c$1=/acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;function s$2(Ke,Re){for(var Fe in Re)Ke[Fe]=Re[Fe];return Ke}function a$1(Ke){var Re=Ke.parentNode;Re&&Re.removeChild(Ke)}function h$1(Ke,Re,Fe){var qe,We,Ze,Xe={};for(Ze in Re)Ze=="key"?qe=Re[Ze]:Ze=="ref"?We=Re[Ze]:Xe[Ze]=Re[Ze];if(arguments.length>2&&(Xe.children=arguments.length>3?n.call(arguments,2):Fe),typeof Ke=="function"&&Ke.defaultProps!=null)for(Ze in Ke.defaultProps)Xe[Ze]===void 0&&(Xe[Ze]=Ke.defaultProps[Ze]);return v$2(Ke,Xe,qe,We,null)}function v$2(Ke,Re,Fe,qe,We){var Ze={type:Ke,props:Re,key:Fe,ref:qe,__k:null,__:null,__b:0,__e:null,__d:void 0,__c:null,__h:null,constructor:void 0,__v:We==null?++u$2:We};return We==null&&l$1.vnode!=null&&l$1.vnode(Ze),Ze}function y$2(){return{current:null}}function p$1(Ke){return Ke.children}function d$1(Ke,Re){this.props=Ke,this.context=Re}function _$3(Ke,Re){if(Re==null)return Ke.__?_$3(Ke.__,Ke.__.__k.indexOf(Ke)+1):null;for(var Fe;Re<Ke.__k.length;Re++)if((Fe=Ke.__k[Re])!=null&&Fe.__e!=null)return Fe.__e;return typeof Ke.type=="function"?_$3(Ke):null}function k$3(Ke){var Re,Fe;if((Ke=Ke.__)!=null&&Ke.__c!=null){for(Ke.__e=Ke.__c.base=null,Re=0;Re<Ke.__k.length;Re++)if((Fe=Ke.__k[Re])!=null&&Fe.__e!=null){Ke.__e=Ke.__c.base=Fe.__e;break}return k$3(Ke)}}function b$2(Ke){(!Ke.__d&&(Ke.__d=!0)&&t$1.push(Ke)&&!g$2.__r++||o$2!==l$1.debounceRendering)&&((o$2=l$1.debounceRendering)||setTimeout)(g$2)}function g$2(){for(var Ke;g$2.__r=t$1.length;)Ke=t$1.sort(function(Re,Fe){return Re.__v.__b-Fe.__v.__b}),t$1=[],Ke.some(function(Re){var Fe,qe,We,Ze,Xe,Je;Re.__d&&(Xe=(Ze=(Fe=Re).__v).__e,(Je=Fe.__P)&&(qe=[],(We=s$2({},Ze)).__v=Ze.__v+1,j$3(Je,Ze,We,Fe.__n,Je.ownerSVGElement!==void 0,Ze.__h!=null?[Xe]:null,qe,Xe==null?_$3(Ze):Xe,Ze.__h),z$3(qe,Ze),Ze.__e!=Xe&&k$3(Ze)))})}function w$3(Ke,Re,Fe,qe,We,Ze,Xe,Je,tr,er){var ir,ur,fr,ar,yr,mr,wr,Sr=qe&&qe.__k||e$1,Ar=Sr.length;for(Fe.__k=[],ir=0;ir<Re.length;ir++)if((ar=Fe.__k[ir]=(ar=Re[ir])==null||typeof ar=="boolean"?null:typeof ar=="string"||typeof ar=="number"||typeof ar=="bigint"?v$2(null,ar,null,null,ar):Array.isArray(ar)?v$2(p$1,{children:ar},null,null,null):ar.__b>0?v$2(ar.type,ar.props,ar.key,ar.ref?ar.ref:null,ar.__v):ar)!=null){if(ar.__=Fe,ar.__b=Fe.__b+1,(fr=Sr[ir])===null||fr&&ar.key==fr.key&&ar.type===fr.type)Sr[ir]=void 0;else for(ur=0;ur<Ar;ur++){if((fr=Sr[ur])&&ar.key==fr.key&&ar.type===fr.type){Sr[ur]=void 0;break}fr=null}j$3(Ke,ar,fr=fr||f$2,We,Ze,Xe,Je,tr,er),yr=ar.__e,(ur=ar.ref)&&fr.ref!=ur&&(wr||(wr=[]),fr.ref&&wr.push(fr.ref,null,ar),wr.push(ur,ar.__c||yr,ar)),yr!=null?(mr==null&&(mr=yr),typeof ar.type=="function"&&ar.__k===fr.__k?ar.__d=tr=m$1(ar,tr,Ke):tr=A$3(Ke,ar,fr,Sr,yr,tr),typeof Fe.type=="function"&&(Fe.__d=tr)):tr&&fr.__e==tr&&tr.parentNode!=Ke&&(tr=_$3(fr))}for(Fe.__e=mr,ir=Ar;ir--;)Sr[ir]!=null&&N$2(Sr[ir],Sr[ir]);if(wr)for(ir=0;ir<wr.length;ir++)M$2(wr[ir],wr[++ir],wr[++ir])}function m$1(Ke,Re,Fe){for(var qe,We=Ke.__k,Ze=0;We&&Ze<We.length;Ze++)(qe=We[Ze])&&(qe.__=Ke,Re=typeof qe.type=="function"?m$1(qe,Re,Fe):A$3(Fe,qe,qe,We,qe.__e,Re));return Re}function x$3(Ke,Re){return Re=Re||[],Ke==null||typeof Ke=="boolean"||(Array.isArray(Ke)?Ke.some(function(Fe){x$3(Fe,Re)}):Re.push(Ke)),Re}function A$3(Ke,Re,Fe,qe,We,Ze){var Xe,Je,tr;if(Re.__d!==void 0)Xe=Re.__d,Re.__d=void 0;else if(Fe==null||We!=Ze||We.parentNode==null)e:if(Ze==null||Ze.parentNode!==Ke)Ke.appendChild(We),Xe=null;else{for(Je=Ze,tr=0;(Je=Je.nextSibling)&&tr<qe.length;tr+=2)if(Je==We)break e;Ke.insertBefore(We,Ze),Xe=Ze}return Xe!==void 0?Xe:We.nextSibling}function C$2(Ke,Re,Fe,qe,We){var Ze;for(Ze in Fe)Ze==="children"||Ze==="key"||Ze in Re||H$2(Ke,Ze,null,Fe[Ze],qe);for(Ze in Re)We&&typeof Re[Ze]!="function"||Ze==="children"||Ze==="key"||Ze==="value"||Ze==="checked"||Fe[Ze]===Re[Ze]||H$2(Ke,Ze,Re[Ze],Fe[Ze],qe)}function $$2(Ke,Re,Fe){Re[0]==="-"?Ke.setProperty(Re,Fe):Ke[Re]=Fe==null?"":typeof Fe!="number"||c$1.test(Re)?Fe:Fe+"px"}function H$2(Ke,Re,Fe,qe,We){var Ze;e:if(Re==="style")if(typeof Fe=="string")Ke.style.cssText=Fe;else{if(typeof qe=="string"&&(Ke.style.cssText=qe=""),qe)for(Re in qe)Fe&&Re in Fe||$$2(Ke.style,Re,"");if(Fe)for(Re in Fe)qe&&Fe[Re]===qe[Re]||$$2(Ke.style,Re,Fe[Re])}else if(Re[0]==="o"&&Re[1]==="n")Ze=Re!==(Re=Re.replace(/Capture$/,"")),Re=Re.toLowerCase()in Ke?Re.toLowerCase().slice(2):Re.slice(2),Ke.l||(Ke.l={}),Ke.l[Re+Ze]=Fe,Fe?qe||Ke.addEventListener(Re,Ze?T$3:I$2,Ze):Ke.removeEventListener(Re,Ze?T$3:I$2,Ze);else if(Re!=="dangerouslySetInnerHTML"){if(We)Re=Re.replace(/xlink(H|:h)/,"h").replace(/sName$/,"s");else if(Re!=="href"&&Re!=="list"&&Re!=="form"&&Re!=="tabIndex"&&Re!=="download"&&Re in Ke)try{Ke[Re]=Fe==null?"":Fe;break e}catch{}typeof Fe=="function"||(Fe==null||Fe===!1&&Re.indexOf("-")==-1?Ke.removeAttribute(Re):Ke.setAttribute(Re,Fe))}}function I$2(Ke){this.l[Ke.type+!1](l$1.event?l$1.event(Ke):Ke)}function T$3(Ke){this.l[Ke.type+!0](l$1.event?l$1.event(Ke):Ke)}function j$3(Ke,Re,Fe,qe,We,Ze,Xe,Je,tr){var er,ir,ur,fr,ar,yr,mr,wr,Sr,Ar,vr,Ir,Tr,Pr,Rr,Br=Re.type;if(Re.constructor!==void 0)return null;Fe.__h!=null&&(tr=Fe.__h,Je=Re.__e=Fe.__e,Re.__h=null,Ze=[Je]),(er=l$1.__b)&&er(Re);try{e:if(typeof Br=="function"){if(wr=Re.props,Sr=(er=Br.contextType)&&qe[er.__c],Ar=er?Sr?Sr.props.value:er.__:qe,Fe.__c?mr=(ir=Re.__c=Fe.__c).__=ir.__E:("prototype"in Br&&Br.prototype.render?Re.__c=ir=new Br(wr,Ar):(Re.__c=ir=new d$1(wr,Ar),ir.constructor=Br,ir.render=O$2),Sr&&Sr.sub(ir),ir.props=wr,ir.state||(ir.state={}),ir.context=Ar,ir.__n=qe,ur=ir.__d=!0,ir.__h=[],ir._sb=[]),ir.__s==null&&(ir.__s=ir.state),Br.getDerivedStateFromProps!=null&&(ir.__s==ir.state&&(ir.__s=s$2({},ir.__s)),s$2(ir.__s,Br.getDerivedStateFromProps(wr,ir.__s))),fr=ir.props,ar=ir.state,ur)Br.getDerivedStateFromProps==null&&ir.componentWillMount!=null&&ir.componentWillMount(),ir.componentDidMount!=null&&ir.__h.push(ir.componentDidMount);else{if(Br.getDerivedStateFromProps==null&&wr!==fr&&ir.componentWillReceiveProps!=null&&ir.componentWillReceiveProps(wr,Ar),!ir.__e&&ir.shouldComponentUpdate!=null&&ir.shouldComponentUpdate(wr,ir.__s,Ar)===!1||Re.__v===Fe.__v){for(ir.props=wr,ir.state=ir.__s,Re.__v!==Fe.__v&&(ir.__d=!1),ir.__v=Re,Re.__e=Fe.__e,Re.__k=Fe.__k,Re.__k.forEach(function(Mr){Mr&&(Mr.__=Re)}),vr=0;vr<ir._sb.length;vr++)ir.__h.push(ir._sb[vr]);ir._sb=[],ir.__h.length&&Xe.push(ir);break e}ir.componentWillUpdate!=null&&ir.componentWillUpdate(wr,ir.__s,Ar),ir.componentDidUpdate!=null&&ir.__h.push(function(){ir.componentDidUpdate(fr,ar,yr)})}if(ir.context=Ar,ir.props=wr,ir.__v=Re,ir.__P=Ke,Ir=l$1.__r,Tr=0,"prototype"in Br&&Br.prototype.render){for(ir.state=ir.__s,ir.__d=!1,Ir&&Ir(Re),er=ir.render(ir.props,ir.state,ir.context),Pr=0;Pr<ir._sb.length;Pr++)ir.__h.push(ir._sb[Pr]);ir._sb=[]}else do ir.__d=!1,Ir&&Ir(Re),er=ir.render(ir.props,ir.state,ir.context),ir.state=ir.__s;while(ir.__d&&++Tr<25);ir.state=ir.__s,ir.getChildContext!=null&&(qe=s$2(s$2({},qe),ir.getChildContext())),ur||ir.getSnapshotBeforeUpdate==null||(yr=ir.getSnapshotBeforeUpdate(fr,ar)),Rr=er!=null&&er.type===p$1&&er.key==null?er.props.children:er,w$3(Ke,Array.isArray(Rr)?Rr:[Rr],Re,Fe,qe,We,Ze,Xe,Je,tr),ir.base=Re.__e,Re.__h=null,ir.__h.length&&Xe.push(ir),mr&&(ir.__E=ir.__=null),ir.__e=!1}else Ze==null&&Re.__v===Fe.__v?(Re.__k=Fe.__k,Re.__e=Fe.__e):Re.__e=L$2(Fe.__e,Re,Fe,qe,We,Ze,Xe,tr);(er=l$1.diffed)&&er(Re)}catch(Mr){Re.__v=null,(tr||Ze!=null)&&(Re.__e=Je,Re.__h=!!tr,Ze[Ze.indexOf(Je)]=null),l$1.__e(Mr,Re,Fe)}}function z$3(Ke,Re){l$1.__c&&l$1.__c(Re,Ke),Ke.some(function(Fe){try{Ke=Fe.__h,Fe.__h=[],Ke.some(function(qe){qe.call(Fe)})}catch(qe){l$1.__e(qe,Fe.__v)}})}function L$2(Ke,Re,Fe,qe,We,Ze,Xe,Je){var tr,er,ir,ur=Fe.props,fr=Re.props,ar=Re.type,yr=0;if(ar==="svg"&&(We=!0),Ze!=null){for(;yr<Ze.length;yr++)if((tr=Ze[yr])&&"setAttribute"in tr==!!ar&&(ar?tr.localName===ar:tr.nodeType===3)){Ke=tr,Ze[yr]=null;break}}if(Ke==null){if(ar===null)return document.createTextNode(fr);Ke=We?document.createElementNS("http://www.w3.org/2000/svg",ar):document.createElement(ar,fr.is&&fr),Ze=null,Je=!1}if(ar===null)ur===fr||Je&&Ke.data===fr||(Ke.data=fr);else{if(Ze=Ze&&n.call(Ke.childNodes),er=(ur=Fe.props||f$2).dangerouslySetInnerHTML,ir=fr.dangerouslySetInnerHTML,!Je){if(Ze!=null)for(ur={},yr=0;yr<Ke.attributes.length;yr++)ur[Ke.attributes[yr].name]=Ke.attributes[yr].value;(ir||er)&&(ir&&(er&&ir.__html==er.__html||ir.__html===Ke.innerHTML)||(Ke.innerHTML=ir&&ir.__html||""))}if(C$2(Ke,fr,ur,We,Je),ir)Re.__k=[];else if(yr=Re.props.children,w$3(Ke,Array.isArray(yr)?yr:[yr],Re,Fe,qe,We&&ar!=="foreignObject",Ze,Xe,Ze?Ze[0]:Fe.__k&&_$3(Fe,0),Je),Ze!=null)for(yr=Ze.length;yr--;)Ze[yr]!=null&&a$1(Ze[yr]);Je||("value"in fr&&(yr=fr.value)!==void 0&&(yr!==Ke.value||ar==="progress"&&!yr||ar==="option"&&yr!==ur.value)&&H$2(Ke,"value",yr,ur.value,!1),"checked"in fr&&(yr=fr.checked)!==void 0&&yr!==Ke.checked&&H$2(Ke,"checked",yr,ur.checked,!1))}return Ke}function M$2(Ke,Re,Fe){try{typeof Ke=="function"?Ke(Re):Ke.current=Re}catch(qe){l$1.__e(qe,Fe)}}function N$2(Ke,Re,Fe){var qe,We;if(l$1.unmount&&l$1.unmount(Ke),(qe=Ke.ref)&&(qe.current&&qe.current!==Ke.__e||M$2(qe,null,Re)),(qe=Ke.__c)!=null){if(qe.componentWillUnmount)try{qe.componentWillUnmount()}catch(Ze){l$1.__e(Ze,Re)}qe.base=qe.__P=null,Ke.__c=void 0}if(qe=Ke.__k)for(We=0;We<qe.length;We++)qe[We]&&N$2(qe[We],Re,Fe||typeof Ke.type!="function");Fe||Ke.__e==null||a$1(Ke.__e),Ke.__=Ke.__e=Ke.__d=void 0}function O$2(Ke,Re,Fe){return this.constructor(Ke,Fe)}function P$2(Ke,Re,Fe){var qe,We,Ze;l$1.__&&l$1.__(Ke,Re),We=(qe=typeof Fe=="function")?null:Fe&&Fe.__k||Re.__k,Ze=[],j$3(Re,Ke=(!qe&&Fe||Re).__k=h$1(p$1,null,[Ke]),We||f$2,f$2,Re.ownerSVGElement!==void 0,!qe&&Fe?[Fe]:We?null:Re.firstChild?n.call(Re.childNodes):null,Ze,!qe&&Fe?Fe:We?We.__e:Re.firstChild,qe),z$3(Ze,Ke)}function S$1(Ke,Re){P$2(Ke,Re,S$1)}function q$3(Ke,Re,Fe){var qe,We,Ze,Xe=s$2({},Ke.props);for(Ze in Re)Ze=="key"?qe=Re[Ze]:Ze=="ref"?We=Re[Ze]:Xe[Ze]=Re[Ze];return arguments.length>2&&(Xe.children=arguments.length>3?n.call(arguments,2):Fe),v$2(Ke.type,Xe,qe||Ke.key,We||Ke.ref,null)}function B$3(Ke,Re){var Fe={__c:Re="__cC"+r$2++,__:Ke,Consumer:function(qe,We){return qe.children(We)},Provider:function(qe){var We,Ze;return this.getChildContext||(We=[],(Ze={})[Re]=this,this.getChildContext=function(){return Ze},this.shouldComponentUpdate=function(Xe){this.props.value!==Xe.value&&We.some(b$2)},this.sub=function(Xe){We.push(Xe);var Je=Xe.componentWillUnmount;Xe.componentWillUnmount=function(){We.splice(We.indexOf(Xe),1),Je&&Je.call(Xe)}}),qe.children}};return Fe.Provider.__=Fe.Consumer.contextType=Fe}n=e$1.slice,l$1={__e:function(Ke,Re,Fe,qe){for(var We,Ze,Xe;Re=Re.__;)if((We=Re.__c)&&!We.__)try{if((Ze=We.constructor)&&Ze.getDerivedStateFromError!=null&&(We.setState(Ze.getDerivedStateFromError(Ke)),Xe=We.__d),We.componentDidCatch!=null&&(We.componentDidCatch(Ke,qe||{}),Xe=We.__d),Xe)return We.__E=We}catch(Je){Ke=Je}throw Ke}},u$2=0,d$1.prototype.setState=function(Ke,Re){var Fe;Fe=this.__s!=null&&this.__s!==this.state?this.__s:this.__s=s$2({},this.state),typeof Ke=="function"&&(Ke=Ke(s$2({},Fe),this.props)),Ke&&s$2(Fe,Ke),Ke!=null&&this.__v&&(Re&&this._sb.push(Re),b$2(this))},d$1.prototype.forceUpdate=function(Ke){this.__v&&(this.__e=!0,Ke&&this.__h.push(Ke),b$2(this))},d$1.prototype.render=p$1,t$1=[],g$2.__r=0,r$2=0;const ReactToastify="";var classnames={exports:{}};/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/(function(Ke){(function(){var Re={}.hasOwnProperty;function Fe(){for(var qe=[],We=0;We<arguments.length;We++){var Ze=arguments[We];if(!!Ze){var Xe=typeof Ze;if(Xe==="string"||Xe==="number")qe.push(Ze);else if(Array.isArray(Ze)){if(Ze.length){var Je=Fe.apply(null,Ze);Je&&qe.push(Je)}}else if(Xe==="object"){if(Ze.toString!==Object.prototype.toString&&!Ze.toString.toString().includes("[native code]")){qe.push(Ze.toString());continue}for(var tr in Ze)Re.call(Ze,tr)&&Ze[tr]&&qe.push(tr)}}}return qe.join(" ")}Ke.exports?(Fe.default=Fe,Ke.exports=Fe):window.classNames=Fe})()})(classnames);const cl=classnames.exports;var t,r$1,u$1,i$1,o$1=0,f$1=[],c=[],e=l$1.__b,a=l$1.__r,v$1=l$1.diffed,l=l$1.__c,m=l$1.unmount;function d(Ke,Re){l$1.__h&&l$1.__h(r$1,Ke,o$1||Re),o$1=0;var Fe=r$1.__H||(r$1.__H={__:[],__h:[]});return Ke>=Fe.__.length&&Fe.__.push({__V:c}),Fe.__[Ke]}function p(Ke){return o$1=1,y$1(B$2,Ke)}function y$1(Ke,Re,Fe){var qe=d(t++,2);if(qe.t=Ke,!qe.__c&&(qe.__=[Fe?Fe(Re):B$2(void 0,Re),function(Ze){var Xe=qe.__N?qe.__N[0]:qe.__[0],Je=qe.t(Xe,Ze);Xe!==Je&&(qe.__N=[Je,qe.__[1]],qe.__c.setState({}))}],qe.__c=r$1,!r$1.u)){r$1.u=!0;var We=r$1.shouldComponentUpdate;r$1.shouldComponentUpdate=function(Ze,Xe,Je){if(!qe.__c.__H)return!0;var tr=qe.__c.__H.__.filter(function(ir){return ir.__c});if(tr.every(function(ir){return!ir.__N}))return!We||We.call(this,Ze,Xe,Je);var er=!1;return tr.forEach(function(ir){if(ir.__N){var ur=ir.__[0];ir.__=ir.__N,ir.__N=void 0,ur!==ir.__[0]&&(er=!0)}}),!(!er&&qe.__c.props===Ze)&&(!We||We.call(this,Ze,Xe,Je))}}return qe.__N||qe.__}function h(Ke,Re){var Fe=d(t++,3);!l$1.__s&&z$2(Fe.__H,Re)&&(Fe.__=Ke,Fe.i=Re,r$1.__H.__h.push(Fe))}function s$1(Ke,Re){var Fe=d(t++,4);!l$1.__s&&z$2(Fe.__H,Re)&&(Fe.__=Ke,Fe.i=Re,r$1.__h.push(Fe))}function _$2(Ke){return o$1=5,F$2(function(){return{current:Ke}},[])}function A$2(Ke,Re,Fe){o$1=6,s$1(function(){return typeof Ke=="function"?(Ke(Re()),function(){return Ke(null)}):Ke?(Ke.current=Re(),function(){return Ke.current=null}):void 0},Fe==null?Fe:Fe.concat(Ke))}function F$2(Ke,Re){var Fe=d(t++,7);return z$2(Fe.__H,Re)?(Fe.__V=Ke(),Fe.i=Re,Fe.__h=Ke,Fe.__V):Fe.__}function T$2(Ke,Re){return o$1=8,F$2(function(){return Ke},Re)}function q$2(Ke){var Re=r$1.context[Ke.__c],Fe=d(t++,9);return Fe.c=Ke,Re?(Fe.__==null&&(Fe.__=!0,Re.sub(r$1)),Re.props.value):Ke.__}function x$2(Ke,Re){l$1.useDebugValue&&l$1.useDebugValue(Re?Re(Ke):Ke)}function V$2(){var Ke=d(t++,11);return Ke.__||(Ke.__="P"+function(Re){for(var Fe=0,qe=Re.length;qe>0;)Fe=(Fe<<5)-Fe+Re.charCodeAt(--qe)|0;return Fe}(r$1.__v.__m)+t),Ke.__}function b$1(){for(var Ke;Ke=f$1.shift();)if(Ke.__P&&Ke.__H)try{Ke.__H.__h.forEach(k$2),Ke.__H.__h.forEach(w$2),Ke.__H.__h=[]}catch(Re){Ke.__H.__h=[],l$1.__e(Re,Ke.__v)}}l$1.__b=function(Ke){typeof Ke.type!="function"||Ke.__m||Ke.__===null?Ke.__m||(Ke.__m=Ke.__&&Ke.__.__m?Ke.__.__m:""):Ke.__m=(Ke.__&&Ke.__.__m?Ke.__.__m:"")+(Ke.__&&Ke.__.__k?Ke.__.__k.indexOf(Ke):0),r$1=null,e&&e(Ke)},l$1.__r=function(Ke){a&&a(Ke),t=0;var Re=(r$1=Ke.__c).__H;Re&&(u$1===r$1?(Re.__h=[],r$1.__h=[],Re.__.forEach(function(Fe){Fe.__N&&(Fe.__=Fe.__N),Fe.__V=c,Fe.__N=Fe.i=void 0})):(Re.__h.forEach(k$2),Re.__h.forEach(w$2),Re.__h=[])),u$1=r$1},l$1.diffed=function(Ke){v$1&&v$1(Ke);var Re=Ke.__c;Re&&Re.__H&&(Re.__H.__h.length&&(f$1.push(Re)!==1&&i$1===l$1.requestAnimationFrame||((i$1=l$1.requestAnimationFrame)||j$2)(b$1)),Re.__H.__.forEach(function(Fe){Fe.i&&(Fe.__H=Fe.i),Fe.__V!==c&&(Fe.__=Fe.__V),Fe.i=void 0,Fe.__V=c})),u$1=r$1=null},l$1.__c=function(Ke,Re){Re.some(function(Fe){try{Fe.__h.forEach(k$2),Fe.__h=Fe.__h.filter(function(qe){return!qe.__||w$2(qe)})}catch(qe){Re.some(function(We){We.__h&&(We.__h=[])}),Re=[],l$1.__e(qe,Fe.__v)}}),l&&l(Ke,Re)},l$1.unmount=function(Ke){m&&m(Ke);var Re,Fe=Ke.__c;Fe&&Fe.__H&&(Fe.__H.__.forEach(function(qe){try{k$2(qe)}catch(We){Re=We}}),Fe.__H=void 0,Re&&l$1.__e(Re,Fe.__v))};var g$1=typeof requestAnimationFrame=="function";function j$2(Ke){var Re,Fe=function(){clearTimeout(qe),g$1&&cancelAnimationFrame(Re),setTimeout(Ke)},qe=setTimeout(Fe,100);g$1&&(Re=requestAnimationFrame(Fe))}function k$2(Ke){var Re=r$1,Fe=Ke.__c;typeof Fe=="function"&&(Ke.__c=void 0,Fe()),r$1=Re}function w$2(Ke){var Re=r$1;Ke.__c=Ke.__(),r$1=Re}function z$2(Ke,Re){return!Ke||Ke.length!==Re.length||Re.some(function(Fe,qe){return Fe!==Ke[qe]})}function B$2(Ke,Re){return typeof Re=="function"?Re(Ke):Re}function g(Ke,Re){for(var Fe in Re)Ke[Fe]=Re[Fe];return Ke}function C$1(Ke,Re){for(var Fe in Ke)if(Fe!=="__source"&&!(Fe in Re))return!0;for(var qe in Re)if(qe!=="__source"&&Ke[qe]!==Re[qe])return!0;return!1}function E$1(Ke){this.props=Ke}function w$1(Ke,Re){function Fe(We){var Ze=this.props.ref,Xe=Ze==We.ref;return!Xe&&Ze&&(Ze.call?Ze(null):Ze.current=null),Re?!Re(this.props,We)||!Xe:C$1(this.props,We)}function qe(We){return this.shouldComponentUpdate=Fe,h$1(Ke,We)}return qe.displayName="Memo("+(Ke.displayName||Ke.name)+")",qe.prototype.isReactComponent=!0,qe.__f=!0,qe}(E$1.prototype=new d$1).isPureReactComponent=!0,E$1.prototype.shouldComponentUpdate=function(Ke,Re){return C$1(this.props,Ke)||C$1(this.state,Re)};var R$1=l$1.__b;l$1.__b=function(Ke){Ke.type&&Ke.type.__f&&Ke.ref&&(Ke.props.ref=Ke.ref,Ke.ref=null),R$1&&R$1(Ke)};var x$1=typeof Symbol<"u"&&Symbol.for&&Symbol.for("react.forward_ref")||3911;function N$1(Ke){function Re(Fe){var qe=g({},Fe);return delete qe.ref,Ke(qe,Fe.ref||null)}return Re.$$typeof=x$1,Re.render=Re,Re.prototype.isReactComponent=Re.__f=!0,Re.displayName="ForwardRef("+(Ke.displayName||Ke.name)+")",Re}var k$1=function(Ke,Re){return Ke==null?null:x$3(x$3(Ke).map(Re))},A$1={map:k$1,forEach:k$1,count:function(Ke){return Ke?x$3(Ke).length:0},only:function(Ke){var Re=x$3(Ke);if(Re.length!==1)throw"Children.only";return Re[0]},toArray:x$3},O$1=l$1.__e;l$1.__e=function(Ke,Re,Fe,qe){if(Ke.then){for(var We,Ze=Re;Ze=Ze.__;)if((We=Ze.__c)&&We.__c)return Re.__e==null&&(Re.__e=Fe.__e,Re.__k=Fe.__k),We.__c(Ke,Re)}O$1(Ke,Re,Fe,qe)};var T$1=l$1.unmount;function I$1(Ke,Re,Fe){return Ke&&(Ke.__c&&Ke.__c.__H&&(Ke.__c.__H.__.forEach(function(qe){typeof qe.__c=="function"&&qe.__c()}),Ke.__c.__H=null),(Ke=g({},Ke)).__c!=null&&(Ke.__c.__P===Fe&&(Ke.__c.__P=Re),Ke.__c=null),Ke.__k=Ke.__k&&Ke.__k.map(function(qe){return I$1(qe,Re,Fe)})),Ke}function L$1(Ke,Re,Fe){return Ke&&(Ke.__v=null,Ke.__k=Ke.__k&&Ke.__k.map(function(qe){return L$1(qe,Re,Fe)}),Ke.__c&&Ke.__c.__P===Re&&(Ke.__e&&Fe.insertBefore(Ke.__e,Ke.__d),Ke.__c.__e=!0,Ke.__c.__P=Fe)),Ke}function U$1(){this.__u=0,this.t=null,this.__b=null}function D$1(Ke){var Re=Ke.__.__c;return Re&&Re.__a&&Re.__a(Ke)}function F$1(Ke){var Re,Fe,qe;function We(Ze){if(Re||(Re=Ke()).then(function(Xe){Fe=Xe.default||Xe},function(Xe){qe=Xe}),qe)throw qe;if(!Fe)throw Re;return h$1(Fe,Ze)}return We.displayName="Lazy",We.__f=!0,We}function M$1(){this.u=null,this.o=null}l$1.unmount=function(Ke){var Re=Ke.__c;Re&&Re.__R&&Re.__R(),Re&&Ke.__h===!0&&(Ke.type=null),T$1&&T$1(Ke)},(U$1.prototype=new d$1).__c=function(Ke,Re){var Fe=Re.__c,qe=this;qe.t==null&&(qe.t=[]),qe.t.push(Fe);var We=D$1(qe.__v),Ze=!1,Xe=function(){Ze||(Ze=!0,Fe.__R=null,We?We(Je):Je())};Fe.__R=Xe;var Je=function(){if(!--qe.__u){if(qe.state.__a){var er=qe.state.__a;qe.__v.__k[0]=L$1(er,er.__c.__P,er.__c.__O)}var ir;for(qe.setState({__a:qe.__b=null});ir=qe.t.pop();)ir.forceUpdate()}},tr=Re.__h===!0;qe.__u++||tr||qe.setState({__a:qe.__b=qe.__v.__k[0]}),Ke.then(Xe,Xe)},U$1.prototype.componentWillUnmount=function(){this.t=[]},U$1.prototype.render=function(Ke,Re){if(this.__b){if(this.__v.__k){var Fe=document.createElement("div"),qe=this.__v.__k[0].__c;this.__v.__k[0]=I$1(this.__b,Fe,qe.__O=qe.__P)}this.__b=null}var We=Re.__a&&h$1(p$1,null,Ke.fallback);return We&&(We.__h=null),[h$1(p$1,null,Re.__a?null:Ke.children),We]};var V$1=function(Ke,Re,Fe){if(++Fe[1]===Fe[0]&&Ke.o.delete(Re),Ke.props.revealOrder&&(Ke.props.revealOrder[0]!=="t"||!Ke.o.size))for(Fe=Ke.u;Fe;){for(;Fe.length>3;)Fe.pop()();if(Fe[1]<Fe[0])break;Ke.u=Fe=Fe[2]}};function W$1(Ke){return this.getChildContext=function(){return Ke.context},Ke.children}function P$1(Ke){var Re=this,Fe=Ke.i;Re.componentWillUnmount=function(){P$2(null,Re.l),Re.l=null,Re.i=null},Re.i&&Re.i!==Fe&&Re.componentWillUnmount(),Ke.__v?(Re.l||(Re.i=Fe,Re.l={nodeType:1,parentNode:Fe,childNodes:[],appendChild:function(qe){this.childNodes.push(qe),Re.i.appendChild(qe)},insertBefore:function(qe,We){this.childNodes.push(qe),Re.i.appendChild(qe)},removeChild:function(qe){this.childNodes.splice(this.childNodes.indexOf(qe)>>>1,1),Re.i.removeChild(qe)}}),P$2(h$1(W$1,{context:Re.context},Ke.__v),Re.l)):Re.l&&Re.componentWillUnmount()}function $$1(Ke,Re){var Fe=h$1(P$1,{__v:Ke,i:Re});return Fe.containerInfo=Re,Fe}(M$1.prototype=new d$1).__a=function(Ke){var Re=this,Fe=D$1(Re.__v),qe=Re.o.get(Ke);return qe[0]++,function(We){var Ze=function(){Re.props.revealOrder?(qe.push(We),V$1(Re,Ke,qe)):We()};Fe?Fe(Ze):Ze()}},M$1.prototype.render=function(Ke){this.u=null,this.o=new Map;var Re=x$3(Ke.children);Ke.revealOrder&&Ke.revealOrder[0]==="b"&&Re.reverse();for(var Fe=Re.length;Fe--;)this.o.set(Re[Fe],this.u=[1,0,this.u]);return Ke.children},M$1.prototype.componentDidUpdate=M$1.prototype.componentDidMount=function(){var Ke=this;this.o.forEach(function(Re,Fe){V$1(Ke,Fe,Re)})};var j$1=typeof Symbol<"u"&&Symbol.for&&Symbol.for("react.element")||60103,z$1=/^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|dominant|fill|flood|font|glyph(?!R)|horiz|image|letter|lighting|marker(?!H|W|U)|overline|paint|pointer|shape|stop|strikethrough|stroke|text(?!L)|transform|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/,B$1=typeof document<"u",H$1=function(Ke){return(typeof Symbol<"u"&&typeof Symbol()=="symbol"?/fil|che|rad/i:/fil|che|ra/i).test(Ke)};function Z$1(Ke,Re,Fe){return Re.__k==null&&(Re.textContent=""),P$2(Ke,Re),typeof Fe=="function"&&Fe(),Ke?Ke.__c:null}function Y$1(Ke,Re,Fe){return S$1(Ke,Re),typeof Fe=="function"&&Fe(),Ke?Ke.__c:null}d$1.prototype.isReactComponent={},["componentWillMount","componentWillReceiveProps","componentWillUpdate"].forEach(function(Ke){Object.defineProperty(d$1.prototype,Ke,{configurable:!0,get:function(){return this["UNSAFE_"+Ke]},set:function(Re){Object.defineProperty(this,Ke,{configurable:!0,writable:!0,value:Re})}})});var q$1=l$1.event;function G$1(){}function J$1(){return this.cancelBubble}function K$1(){return this.defaultPrevented}l$1.event=function(Ke){return q$1&&(Ke=q$1(Ke)),Ke.persist=G$1,Ke.isPropagationStopped=J$1,Ke.isDefaultPrevented=K$1,Ke.nativeEvent=Ke};var Q$1,X$1={configurable:!0,get:function(){return this.class}},nn$1=l$1.vnode;l$1.vnode=function(Ke){var Re=Ke.type,Fe=Ke.props,qe=Fe;if(typeof Re=="string"){var We=Re.indexOf("-")===-1;for(var Ze in qe={},Fe){var Xe=Fe[Ze];B$1&&Ze==="children"&&Re==="noscript"||Ze==="value"&&"defaultValue"in Fe&&Xe==null||(Ze==="defaultValue"&&"value"in Fe&&Fe.value==null?Ze="value":Ze==="download"&&Xe===!0?Xe="":/ondoubleclick/i.test(Ze)?Ze="ondblclick":/^onchange(textarea|input)/i.test(Ze+Re)&&!H$1(Fe.type)?Ze="oninput":/^onfocus$/i.test(Ze)?Ze="onfocusin":/^onblur$/i.test(Ze)?Ze="onfocusout":/^on(Ani|Tra|Tou|BeforeInp|Compo)/.test(Ze)?Ze=Ze.toLowerCase():We&&z$1.test(Ze)?Ze=Ze.replace(/[A-Z0-9]/g,"-$&").toLowerCase():Xe===null&&(Xe=void 0),/^oninput$/i.test(Ze)&&(Ze=Ze.toLowerCase(),qe[Ze]&&(Ze="oninputCapture")),qe[Ze]=Xe)}Re=="select"&&qe.multiple&&Array.isArray(qe.value)&&(qe.value=x$3(Fe.children).forEach(function(Je){Je.props.selected=qe.value.indexOf(Je.props.value)!=-1})),Re=="select"&&qe.defaultValue!=null&&(qe.value=x$3(Fe.children).forEach(function(Je){Je.props.selected=qe.multiple?qe.defaultValue.indexOf(Je.props.value)!=-1:qe.defaultValue==Je.props.value})),Ke.props=qe,Fe.class!=Fe.className&&(X$1.enumerable="className"in Fe,Fe.className!=null&&(qe.class=Fe.className),Object.defineProperty(qe,"className",X$1))}Ke.$$typeof=j$1,nn$1&&nn$1(Ke)};var tn$1=l$1.__r;l$1.__r=function(Ke){tn$1&&tn$1(Ke),Q$1=Ke.__c};var en$1={ReactCurrentDispatcher:{current:{readContext:function(Ke){return Q$1.__n[Ke.__c].props.value}}}};function un$1(Ke){return h$1.bind(null,Ke)}function on$1(Ke){return!!Ke&&Ke.$$typeof===j$1}function ln$1(Ke){return on$1(Ke)?q$3.apply(null,arguments):Ke}function cn$1(Ke){return!!Ke.__k&&(P$2(null,Ke),!0)}function fn$1(Ke){return Ke&&(Ke.base||Ke.nodeType===1&&Ke)||null}var an$1=function(Ke,Re){return Ke(Re)},sn$1=function(Ke,Re){return Ke(Re)},hn$1=p$1;function vn$1(Ke){Ke()}function dn$1(Ke){return Ke}function pn$1(){return[!1,vn$1]}var mn$1=s$1;function yn(Ke,Re){var Fe=Re(),qe=p({h:{__:Fe,v:Re}}),We=qe[0].h,Ze=qe[1];return s$1(function(){We.__=Fe,We.v=Re,We.__!==Re()&&Ze({h:We})},[Ke,Fe,Re]),h(function(){return We.__!==We.v()&&Ze({h:We}),Ke(function(){We.__!==We.v()&&Ze({h:We})})},[Ke]),Fe}var _n$1={useState:p,useId:V$2,useReducer:y$1,useEffect:h,useLayoutEffect:s$1,useInsertionEffect:mn$1,useTransition:pn$1,useDeferredValue:dn$1,useSyncExternalStore:yn,startTransition:vn$1,useRef:_$2,useImperativeHandle:A$2,useMemo:F$2,useCallback:T$2,useContext:q$2,useDebugValue:x$2,version:"17.0.2",Children:A$1,render:Z$1,hydrate:Y$1,unmountComponentAtNode:cn$1,createPortal:$$1,createElement:h$1,createContext:B$3,createFactory:un$1,cloneElement:ln$1,createRef:y$2,Fragment:p$1,isValidElement:on$1,findDOMNode:fn$1,Component:d$1,PureComponent:E$1,memo:w$1,forwardRef:N$1,flushSync:sn$1,unstable_batchedUpdates:an$1,StrictMode:hn$1,Suspense:U$1,SuspenseList:M$1,lazy:F$1,__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED:en$1};function r(Ke){var Re,Fe,qe="";if(typeof Ke=="string"||typeof Ke=="number")qe+=Ke;else if(typeof Ke=="object")if(Array.isArray(Ke))for(Re=0;Re<Ke.length;Re++)Ke[Re]&&(Fe=r(Ke[Re]))&&(qe&&(qe+=" "),qe+=Fe);else for(Re in Ke)Ke[Re]&&(qe&&(qe+=" "),qe+=Re);return qe}function clsx(){for(var Ke,Re,Fe=0,qe="";Fe<arguments.length;)(Ke=arguments[Fe++])&&(Re=r(Ke))&&(qe&&(qe+=" "),qe+=Re);return qe}function isNum(Ke){return typeof Ke=="number"&&!isNaN(Ke)}function isBool(Ke){return typeof Ke=="boolean"}function isStr(Ke){return typeof Ke=="string"}function isFn(Ke){return typeof Ke=="function"}function parseClassName(Ke){return isStr(Ke)||isFn(Ke)?Ke:null}function isToastIdValid(Ke){return Ke!=null}function getAutoCloseDelay(Ke,Re){return Ke===!1||isNum(Ke)&&Ke>0?Ke:Re}function canBeRendered(Ke){return on$1(Ke)||isStr(Ke)||isFn(Ke)||isNum(Ke)}const POSITION={TOP_LEFT:"top-left",TOP_RIGHT:"top-right",TOP_CENTER:"top-center",BOTTOM_LEFT:"bottom-left",BOTTOM_RIGHT:"bottom-right",BOTTOM_CENTER:"bottom-center"},TYPE$2={INFO:"info",SUCCESS:"success",WARNING:"warning",ERROR:"error",DEFAULT:"default"};function collapseToast(Ke,Re,Fe){Fe===void 0&&(Fe=300);const{scrollHeight:qe,style:We}=Ke;requestAnimationFrame(()=>{We.minHeight="initial",We.height=qe+"px",We.transition="all "+Fe+"ms",requestAnimationFrame(()=>{We.height="0",We.padding="0",We.margin="0",setTimeout(Re,Fe)})})}function cssTransition(Ke){let{enter:Re,exit:Fe,appendPosition:qe=!1,collapse:We=!0,collapseDuration:Ze=300}=Ke;return function(Je){let{children:tr,position:er,preventExitTransition:ir,done:ur,nodeRef:fr,isIn:ar}=Je;const yr=qe?Re+"--"+er:Re,mr=qe?Fe+"--"+er:Fe,wr=_$2(0);return s$1(()=>{const Sr=fr.current,Ar=yr.split(" "),vr=Tr=>{Tr.target===fr.current&&(Sr.dispatchEvent(new Event("d")),Sr.removeEventListener("animationend",vr),Sr.removeEventListener("animationcancel",vr),wr.current===0&&Tr.type!=="animationcancel"&&Sr.classList.remove(...Ar))};(()=>{Sr.classList.add(...Ar),Sr.addEventListener("animationend",vr),Sr.addEventListener("animationcancel",vr)})()},[]),h(()=>{const Sr=fr.current,Ar=()=>{Sr.removeEventListener("animationend",Ar),We?collapseToast(Sr,ur,Ze):ur()};ar||(ir?Ar():(()=>{wr.current=1,Sr.className+=" "+mr,Sr.addEventListener("animationend",Ar)})())},[ar]),_n$1.createElement(_n$1.Fragment,null,tr)}}function toToastItem(Ke,Re){return{content:Ke.content,containerId:Ke.props.containerId,id:Ke.props.toastId,theme:Ke.props.theme,type:Ke.props.type,data:Ke.props.data||{},isLoading:Ke.props.isLoading,icon:Ke.props.icon,status:Re}}const eventManager={list:new Map,emitQueue:new Map,on(Ke,Re){return this.list.has(Ke)||this.list.set(Ke,[]),this.list.get(Ke).push(Re),this},off(Ke,Re){if(Re){const Fe=this.list.get(Ke).filter(qe=>qe!==Re);return this.list.set(Ke,Fe),this}return this.list.delete(Ke),this},cancelEmit(Ke){const Re=this.emitQueue.get(Ke);return Re&&(Re.forEach(clearTimeout),this.emitQueue.delete(Ke)),this},emit(Ke){this.list.has(Ke)&&this.list.get(Ke).forEach(Re=>{const Fe=setTimeout(()=>{Re(...[].slice.call(arguments,1))},0);this.emitQueue.has(Ke)||this.emitQueue.set(Ke,[]),this.emitQueue.get(Ke).push(Fe)})}},Svg=Ke=>{let{theme:Re,type:Fe,...qe}=Ke;return _n$1.createElement("svg",{viewBox:"0 0 24 24",width:"100%",height:"100%",fill:Re==="colored"?"currentColor":"var(--toastify-icon-color-"+Fe+")",...qe})};function Warning(Ke){return _n$1.createElement(Svg,{...Ke},_n$1.createElement("path",{d:"M23.32 17.191L15.438 2.184C14.728.833 13.416 0 11.996 0c-1.42 0-2.733.833-3.443 2.184L.533 17.448a4.744 4.744 0 000 4.368C1.243 23.167 2.555 24 3.975 24h16.05C22.22 24 24 22.044 24 19.632c0-.904-.251-1.746-.68-2.44zm-9.622 1.46c0 1.033-.724 1.823-1.698 1.823s-1.698-.79-1.698-1.822v-.043c0-1.028.724-1.822 1.698-1.822s1.698.79 1.698 1.822v.043zm.039-12.285l-.84 8.06c-.057.581-.408.943-.897.943-.49 0-.84-.367-.896-.942l-.84-8.065c-.057-.624.25-1.095.779-1.095h1.91c.528.005.84.476.784 1.1z"}))}function Info(Ke){return _n$1.createElement(Svg,{...Ke},_n$1.createElement("path",{d:"M12 0a12 12 0 1012 12A12.013 12.013 0 0012 0zm.25 5a1.5 1.5 0 11-1.5 1.5 1.5 1.5 0 011.5-1.5zm2.25 13.5h-4a1 1 0 010-2h.75a.25.25 0 00.25-.25v-4.5a.25.25 0 00-.25-.25h-.75a1 1 0 010-2h1a2 2 0 012 2v4.75a.25.25 0 00.25.25h.75a1 1 0 110 2z"}))}function Success(Ke){return _n$1.createElement(Svg,{...Ke},_n$1.createElement("path",{d:"M12 0a12 12 0 1012 12A12.014 12.014 0 0012 0zm6.927 8.2l-6.845 9.289a1.011 1.011 0 01-1.43.188l-4.888-3.908a1 1 0 111.25-1.562l4.076 3.261 6.227-8.451a1 1 0 111.61 1.183z"}))}function Error$1(Ke){return _n$1.createElement(Svg,{...Ke},_n$1.createElement("path",{d:"M11.983 0a12.206 12.206 0 00-8.51 3.653A11.8 11.8 0 000 12.207 11.779 11.779 0 0011.8 24h.214A12.111 12.111 0 0024 11.791 11.766 11.766 0 0011.983 0zM10.5 16.542a1.476 1.476 0 011.449-1.53h.027a1.527 1.527 0 011.523 1.47 1.475 1.475 0 01-1.449 1.53h-.027a1.529 1.529 0 01-1.523-1.47zM11 12.5v-6a1 1 0 012 0v6a1 1 0 11-2 0z"}))}function Spinner(){return _n$1.createElement("div",{className:"Toastify__spinner"})}const Icons={info:Info,warning:Warning,success:Success,error:Error$1,spinner:Spinner},maybeIcon=Ke=>Ke in Icons;function getIcon(Ke){let{theme:Re,type:Fe,isLoading:qe,icon:We}=Ke,Ze=null;const Xe={theme:Re,type:Fe};return We===!1||(isFn(We)?Ze=We(Xe):on$1(We)?Ze=ln$1(We,Xe):isStr(We)||isNum(We)?Ze=We:qe?Ze=Icons.spinner():maybeIcon(Fe)&&(Ze=Icons[Fe](Xe))),Ze}function useToastContainer(Ke){const[,Re]=y$1(mr=>mr+1,0),[Fe,qe]=p([]),We=_$2(null),Ze=_$2(new Map).current,Xe=mr=>Fe.indexOf(mr)!==-1,Je=_$2({toastKey:1,displayedToast:0,count:0,queue:[],props:Ke,containerId:null,isToastActive:Xe,getToast:mr=>Ze.get(mr)}).current;h(()=>(Je.containerId=Ke.containerId,eventManager.cancelEmit(3).on(0,fr).on(1,mr=>We.current&&er(mr)).on(5,tr).emit(2,Je),()=>{Ze.clear(),eventManager.emit(3,Je)}),[]),h(()=>{Je.props=Ke,Je.isToastActive=Xe,Je.displayedToast=Fe.length});function tr(mr){let{containerId:wr}=mr;const{limit:Sr}=Je.props;Sr&&(!wr||Je.containerId===wr)&&(Je.count-=Je.queue.length,Je.queue=[])}function er(mr){qe(wr=>isToastIdValid(mr)?wr.filter(Sr=>Sr!==mr):[])}function ir(){const{toastContent:mr,toastProps:wr,staleId:Sr}=Je.queue.shift();ar(mr,wr,Sr)}function ur(mr){return!We.current||Je.props.enableMultiContainer&&mr.containerId!==Je.props.containerId||Ze.has(mr.toastId)&&mr.updateId==null}function fr(mr,wr){let{delay:Sr,staleId:Ar,...vr}=wr;if(!canBeRendered(mr)||ur(vr))return;const{toastId:Ir,updateId:Tr,data:Pr}=vr,{props:Rr}=Je,Br=()=>er(Ir),Mr=Tr==null;Mr&&Je.count++;const Lr={toastId:Ir,updateId:Tr,data:Pr,containerId:vr.containerId,isLoading:vr.isLoading,theme:vr.theme||Rr.theme,icon:vr.icon!=null?vr.icon:Rr.icon,isIn:!1,key:vr.key||Je.toastKey++,type:vr.type,closeToast:Br,closeButton:vr.closeButton,rtl:Rr.rtl,position:vr.position||Rr.position,transition:vr.transition||Rr.transition,className:parseClassName(vr.className||Rr.toastClassName),bodyClassName:parseClassName(vr.bodyClassName||Rr.bodyClassName),style:vr.style||Rr.toastStyle,bodyStyle:vr.bodyStyle||Rr.bodyStyle,onClick:vr.onClick||Rr.onClick,pauseOnHover:isBool(vr.pauseOnHover)?vr.pauseOnHover:Rr.pauseOnHover,pauseOnFocusLoss:isBool(vr.pauseOnFocusLoss)?vr.pauseOnFocusLoss:Rr.pauseOnFocusLoss,draggable:isBool(vr.draggable)?vr.draggable:Rr.draggable,draggablePercent:vr.draggablePercent||Rr.draggablePercent,draggableDirection:vr.draggableDirection||Rr.draggableDirection,closeOnClick:isBool(vr.closeOnClick)?vr.closeOnClick:Rr.closeOnClick,progressClassName:parseClassName(vr.progressClassName||Rr.progressClassName),progressStyle:vr.progressStyle||Rr.progressStyle,autoClose:vr.isLoading?!1:getAutoCloseDelay(vr.autoClose,Rr.autoClose),hideProgressBar:isBool(vr.hideProgressBar)?vr.hideProgressBar:Rr.hideProgressBar,progress:vr.progress,role:vr.role||Rr.role,deleteToast(){const Nr=toToastItem(Ze.get(Ir),"removed");Ze.delete(Ir),eventManager.emit(4,Nr);const cr=Je.queue.length;if(Je.count=isToastIdValid(Ir)?Je.count-1:Je.count-Je.displayedToast,Je.count<0&&(Je.count=0),cr>0){const Dt=isToastIdValid(Ir)?1:Je.props.limit;if(cr===1||Dt===1)Je.displayedToast++,ir();else{const sr=Dt>cr?cr:Dt;Je.displayedToast=sr;for(let lr=0;lr<sr;lr++)ir()}}else Re()}};Lr.iconOut=getIcon(Lr),isFn(vr.onOpen)&&(Lr.onOpen=vr.onOpen),isFn(vr.onClose)&&(Lr.onClose=vr.onClose),Lr.closeButton=Rr.closeButton,vr.closeButton===!1||canBeRendered(vr.closeButton)?Lr.closeButton=vr.closeButton:vr.closeButton===!0&&(Lr.closeButton=canBeRendered(Rr.closeButton)?Rr.closeButton:!0);let $r=mr;on$1(mr)&&!isStr(mr.type)?$r=ln$1(mr,{closeToast:Br,toastProps:Lr,data:Pr}):isFn(mr)&&($r=mr({closeToast:Br,toastProps:Lr,data:Pr})),Rr.limit&&Rr.limit>0&&Je.count>Rr.limit&&Mr?Je.queue.push({toastContent:$r,toastProps:Lr,staleId:Ar}):isNum(Sr)?setTimeout(()=>{ar($r,Lr,Ar)},Sr):ar($r,Lr,Ar)}function ar(mr,wr,Sr){const{toastId:Ar}=wr;Sr&&Ze.delete(Sr);const vr={content:mr,props:wr};Ze.set(Ar,vr),qe(Ir=>[...Ir,Ar].filter(Tr=>Tr!==Sr)),eventManager.emit(4,toToastItem(vr,vr.props.updateId==null?"added":"updated"))}function yr(mr){const wr=new Map,Sr=Array.from(Ze.values());return Ke.newestOnTop&&Sr.reverse(),Sr.forEach(Ar=>{const{position:vr}=Ar.props;wr.has(vr)||wr.set(vr,[]),wr.get(vr).push(Ar)}),Array.from(wr,Ar=>mr(Ar[0],Ar[1]))}return{getToastToRender:yr,containerRef:We,isToastActive:Xe}}function getX(Ke){return Ke.targetTouches&&Ke.targetTouches.length>=1?Ke.targetTouches[0].clientX:Ke.clientX}function getY(Ke){return Ke.targetTouches&&Ke.targetTouches.length>=1?Ke.targetTouches[0].clientY:Ke.clientY}function useToast(Ke){const[Re,Fe]=p(!1),[qe,We]=p(!1),Ze=_$2(null),Xe=_$2({start:0,x:0,y:0,delta:0,removalDistance:0,canCloseOnClick:!0,canDrag:!1,boundingRect:null,didMove:!1}).current,Je=_$2(Ke),{autoClose:tr,pauseOnHover:er,closeToast:ir,onClick:ur,closeOnClick:fr}=Ke;h(()=>{Je.current=Ke}),h(()=>(Ze.current&&Ze.current.addEventListener("d",mr,{once:!0}),isFn(Ke.onOpen)&&Ke.onOpen(on$1(Ke.children)&&Ke.children.props),()=>{const Br=Je.current;isFn(Br.onClose)&&Br.onClose(on$1(Br.children)&&Br.children.props)}),[]),h(()=>(Ke.pauseOnFocusLoss&&Sr(),()=>{Ke.pauseOnFocusLoss&&Ar()}),[Ke.pauseOnFocusLoss]);function ar(Br){if(Ke.draggable){vr();const Mr=Ze.current;Xe.canCloseOnClick=!0,Xe.canDrag=!0,Xe.boundingRect=Mr.getBoundingClientRect(),Mr.style.transition="",Xe.x=getX(Br.nativeEvent),Xe.y=getY(Br.nativeEvent),Ke.draggableDirection==="x"?(Xe.start=Xe.x,Xe.removalDistance=Mr.offsetWidth*(Ke.draggablePercent/100)):(Xe.start=Xe.y,Xe.removalDistance=Mr.offsetHeight*(Ke.draggablePercent===80?Ke.draggablePercent*1.5:Ke.draggablePercent/100))}}function yr(){if(Xe.boundingRect){const{top:Br,bottom:Mr,left:Lr,right:$r}=Xe.boundingRect;Ke.pauseOnHover&&Xe.x>=Lr&&Xe.x<=$r&&Xe.y>=Br&&Xe.y<=Mr?wr():mr()}}function mr(){Fe(!0)}function wr(){Fe(!1)}function Sr(){document.hasFocus()||wr(),window.addEventListener("focus",mr),window.addEventListener("blur",wr)}function Ar(){window.removeEventListener("focus",mr),window.removeEventListener("blur",wr)}function vr(){Xe.didMove=!1,document.addEventListener("mousemove",Tr),document.addEventListener("mouseup",Pr),document.addEventListener("touchmove",Tr),document.addEventListener("touchend",Pr)}function Ir(){document.removeEventListener("mousemove",Tr),document.removeEventListener("mouseup",Pr),document.removeEventListener("touchmove",Tr),document.removeEventListener("touchend",Pr)}function Tr(Br){const Mr=Ze.current;Xe.canDrag&&Mr&&(Xe.didMove=!0,Re&&wr(),Xe.x=getX(Br),Xe.y=getY(Br),Ke.draggableDirection==="x"?Xe.delta=Xe.x-Xe.start:Xe.delta=Xe.y-Xe.start,Xe.start!==Xe.x&&(Xe.canCloseOnClick=!1),Mr.style.transform="translate"+Ke.draggableDirection+"("+Xe.delta+"px)",Mr.style.opacity=""+(1-Math.abs(Xe.delta/Xe.removalDistance)))}function Pr(){Ir();const Br=Ze.current;if(Xe.canDrag&&Xe.didMove&&Br){if(Xe.canDrag=!1,Math.abs(Xe.delta)>Xe.removalDistance){We(!0),Ke.closeToast();return}Br.style.transition="transform 0.2s, opacity 0.2s",Br.style.transform="translate"+Ke.draggableDirection+"(0)",Br.style.opacity="1"}}const Rr={onMouseDown:ar,onTouchStart:ar,onMouseUp:yr,onTouchEnd:yr};return tr&&er&&(Rr.onMouseEnter=wr,Rr.onMouseLeave=mr),fr&&(Rr.onClick=Br=>{ur&&ur(Br),Xe.canCloseOnClick&&ir()}),{playToast:mr,pauseToast:wr,isRunning:Re,preventExitTransition:qe,toastRef:Ze,eventHandlers:Rr}}function CloseButton(Ke){let{closeToast:Re,theme:Fe,ariaLabel:qe="close"}=Ke;return _n$1.createElement("button",{className:"Toastify__close-button Toastify__close-button--"+Fe,type:"button",onClick:We=>{We.stopPropagation(),Re(We)},"aria-label":qe},_n$1.createElement("svg",{"aria-hidden":"true",viewBox:"0 0 14 16"},_n$1.createElement("path",{fillRule:"evenodd",d:"M7.71 8.23l3.75 3.75-1.48 1.48-3.75-3.75-3.75 3.75L1 11.98l3.75-3.75L1 4.48 2.48 3l3.75 3.75L9.98 3l1.48 1.48-3.75 3.75z"})))}function ProgressBar(Ke){let{delay:Re,isRunning:Fe,closeToast:qe,type:We,hide:Ze,className:Xe,style:Je,controlledProgress:tr,progress:er,rtl:ir,isIn:ur,theme:fr}=Ke;const ar={...Je,animationDuration:Re+"ms",animationPlayState:Fe?"running":"paused",opacity:Ze?0:1};tr&&(ar.transform="scaleX("+er+")");const yr=clsx("Toastify__progress-bar",tr?"Toastify__progress-bar--controlled":"Toastify__progress-bar--animated","Toastify__progress-bar-theme--"+fr,"Toastify__progress-bar--"+We,{["Toastify__progress-bar--rtl"]:ir}),mr=isFn(Xe)?Xe({rtl:ir,type:We,defaultClassName:yr}):clsx(yr,Xe),wr={[tr&&er>=1?"onTransitionEnd":"onAnimationEnd"]:tr&&er<1?null:()=>{ur&&qe()}};return _n$1.createElement("div",{role:"progressbar","aria-hidden":Ze?"true":"false","aria-label":"notification timer",className:mr,style:ar,...wr})}ProgressBar.defaultProps={type:TYPE$2.DEFAULT,hide:!1};const Toast=Ke=>{const{isRunning:Re,preventExitTransition:Fe,toastRef:qe,eventHandlers:We}=useToast(Ke),{closeButton:Ze,children:Xe,autoClose:Je,onClick:tr,type:er,hideProgressBar:ir,closeToast:ur,transition:fr,position:ar,className:yr,style:mr,bodyClassName:wr,bodyStyle:Sr,progressClassName:Ar,progressStyle:vr,updateId:Ir,role:Tr,progress:Pr,rtl:Rr,toastId:Br,deleteToast:Mr,isIn:Lr,isLoading:$r,iconOut:Nr,theme:cr}=Ke,Dt=clsx("Toastify__toast","Toastify__toast-theme--"+cr,"Toastify__toast--"+er,{["Toastify__toast--rtl"]:Rr}),sr=isFn(yr)?yr({rtl:Rr,position:ar,type:er,defaultClassName:Dt}):clsx(Dt,yr),lr=!!Pr,gr={closeToast:ur,type:er,theme:cr};let _r=null;return Ze===!1||(isFn(Ze)?_r=Ze(gr):_n$1.isValidElement(Ze)?_r=_n$1.cloneElement(Ze,gr):_r=CloseButton(gr)),_n$1.createElement(fr,{isIn:Lr,done:Mr,position:ar,preventExitTransition:Fe,nodeRef:qe},_n$1.createElement("div",{id:Br,onClick:tr,className:sr,...We,style:mr,ref:qe},_n$1.createElement("div",{...Lr&&{role:Tr},className:isFn(wr)?wr({type:er}):clsx("Toastify__toast-body",wr),style:Sr},Nr!=null&&_n$1.createElement("div",{className:clsx("Toastify__toast-icon",{["Toastify--animate-icon Toastify__zoom-enter"]:!$r})},Nr),_n$1.createElement("div",null,Xe)),_r,(Je||lr)&&_n$1.createElement(ProgressBar,{...Ir&&!lr?{key:"pb-"+Ir}:{},rtl:Rr,theme:cr,delay:Je,isRunning:Re,isIn:Lr,closeToast:ur,hide:ir,type:er,style:vr,className:Ar,controlledProgress:lr,progress:Pr})))},Bounce=cssTransition({enter:"Toastify--animate Toastify__bounce-enter",exit:"Toastify--animate Toastify__bounce-exit",appendPosition:!0}),ToastContainer=N$1((Ke,Re)=>{const{getToastToRender:Fe,containerRef:qe,isToastActive:We}=useToastContainer(Ke),{className:Ze,style:Xe,rtl:Je,containerId:tr}=Ke;function er(ir){const ur=clsx("Toastify__toast-container","Toastify__toast-container--"+ir,{["Toastify__toast-container--rtl"]:Je});return isFn(Ze)?Ze({position:ir,rtl:Je,defaultClassName:ur}):clsx(ur,parseClassName(Ze))}return h(()=>{Re&&(Re.current=qe.current)},[]),_n$1.createElement("div",{ref:qe,className:"Toastify",id:tr},Fe((ir,ur)=>{const fr=ur.length?{...Xe}:{...Xe,pointerEvents:"none"};return _n$1.createElement("div",{className:er(ir),style:fr,key:"container-"+ir},ur.map((ar,yr)=>{let{content:mr,props:wr}=ar;return _n$1.createElement(Toast,{...wr,isIn:We(wr.toastId),style:{...wr.style,"--nth":yr+1,"--len":ur.length},key:"toast-"+wr.key},mr)}))}))});ToastContainer.displayName="ToastContainer";ToastContainer.defaultProps={position:POSITION.TOP_RIGHT,transition:Bounce,rtl:!1,autoClose:5e3,hideProgressBar:!1,closeButton:CloseButton,pauseOnHover:!0,pauseOnFocusLoss:!0,closeOnClick:!0,newestOnTop:!1,draggable:!0,draggablePercent:80,draggableDirection:"x",role:"alert",theme:"light"};let containers=new Map,latestInstance,queue=[];function getToast(Ke,Re){let{containerId:Fe}=Re;const qe=containers.get(Fe||latestInstance);return qe?qe.getToast(Ke):null}function generateToastId(){return Math.random().toString(36).substring(2,9)}function getToastId(Ke){return Ke&&(isStr(Ke.toastId)||isNum(Ke.toastId))?Ke.toastId:generateToastId()}function dispatchToast(Ke,Re){return containers.size>0?eventManager.emit(0,Ke,Re):queue.push({content:Ke,options:Re}),Re.toastId}function mergeOptions(Ke,Re){return{...Re,type:Re&&Re.type||Ke,toastId:getToastId(Re)}}function createToastByType(Ke){return(Re,Fe)=>dispatchToast(Re,mergeOptions(Ke,Fe))}function toast(Ke,Re){return dispatchToast(Ke,mergeOptions(TYPE$2.DEFAULT,Re))}toast.loading=(Ke,Re)=>dispatchToast(Ke,mergeOptions(TYPE$2.DEFAULT,{isLoading:!0,autoClose:!1,closeOnClick:!1,closeButton:!1,draggable:!1,...Re}));function handlePromise(Ke,Re,Fe){let{pending:qe,error:We,success:Ze}=Re,Xe;qe&&(Xe=isStr(qe)?toast.loading(qe,Fe):toast.loading(qe.render,{...Fe,...qe}));const Je={isLoading:null,autoClose:null,closeOnClick:null,closeButton:null,draggable:null,delay:100},tr=(ir,ur,fr)=>{if(ur==null){toast.dismiss(Xe);return}const ar={type:ir,...Je,...Fe,data:fr},yr=isStr(ur)?{render:ur}:ur;return Xe?toast.update(Xe,{...ar,...yr}):toast(yr.render,{...ar,...yr}),fr},er=isFn(Ke)?Ke():Ke;return er.then(ir=>tr("success",Ze,ir)).catch(ir=>tr("error",We,ir)),er}toast.promise=handlePromise;toast.success=createToastByType(TYPE$2.SUCCESS);toast.info=createToastByType(TYPE$2.INFO);toast.error=createToastByType(TYPE$2.ERROR);toast.warning=createToastByType(TYPE$2.WARNING);toast.warn=toast.warning;toast.dark=(Ke,Re)=>dispatchToast(Ke,mergeOptions(TYPE$2.DEFAULT,{theme:"dark",...Re}));toast.dismiss=Ke=>{containers.size>0?eventManager.emit(1,Ke):queue=queue.filter(Re=>isToastIdValid(Ke)&&Re.options.toastId!==Ke)};toast.clearWaitingQueue=function(Ke){return Ke===void 0&&(Ke={}),eventManager.emit(5,Ke)};toast.isActive=Ke=>{let Re=!1;return containers.forEach(Fe=>{Fe.isToastActive&&Fe.isToastActive(Ke)&&(Re=!0)}),Re};toast.update=function(Ke,Re){Re===void 0&&(Re={}),setTimeout(()=>{const Fe=getToast(Ke,Re);if(Fe){const{props:qe,content:We}=Fe,Ze={...qe,...Re,toastId:Re.toastId||Ke,updateId:generateToastId()};Ze.toastId!==Ke&&(Ze.staleId=Ke);const Xe=Ze.render||We;delete Ze.render,dispatchToast(Xe,Ze)}},0)};toast.done=Ke=>{toast.update(Ke,{progress:1})};toast.onChange=Ke=>(eventManager.on(4,Ke),()=>{eventManager.off(4,Ke)});toast.POSITION=POSITION;toast.TYPE=TYPE$2;eventManager.on(2,Ke=>{latestInstance=Ke.containerId||Ke,containers.set(latestInstance,Ke),queue.forEach(Re=>{eventManager.emit(0,Re.content,Re.options)}),queue=[]}).on(3,Ke=>{containers.delete(Ke.containerId||Ke),containers.size===0&&eventManager.off(0).off(1).off(5)});function _extends(){return _extends=Object.assign?Object.assign.bind():function(Ke){for(var Re=1;Re<arguments.length;Re++){var Fe=arguments[Re];for(var qe in Fe)Object.prototype.hasOwnProperty.call(Fe,qe)&&(Ke[qe]=Fe[qe])}return Ke},_extends.apply(this,arguments)}function _objectWithoutPropertiesLoose(Ke,Re){if(Ke==null)return{};var Fe={},qe=Object.keys(Ke),We,Ze;for(Ze=0;Ze<qe.length;Ze++)We=qe[Ze],!(Re.indexOf(We)>=0)&&(Fe[We]=Ke[We]);return Fe}var charCodeOfDot=".".charCodeAt(0),reEscapeChar=/\\(\\)?/g,rePropName=RegExp(`[^.[\\]]+|\\[(?:([^"'][^[]*)|(["'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))`,"g"),stringToPath=function(Re){var Fe=[];return Re.charCodeAt(0)===charCodeOfDot&&Fe.push(""),Re.replace(rePropName,function(qe,We,Ze,Xe){var Je=qe;Ze?Je=Xe.replace(reEscapeChar,"$1"):We&&(Je=We.trim()),Fe.push(Je)}),Fe},keysCache={},toPath=function(Re){if(Re==null||!Re.length)return[];if(typeof Re!="string")throw new Error("toPath() expects a string");return keysCache[Re]==null&&(keysCache[Re]=stringToPath(Re)),keysCache[Re]},getIn=function(Re,Fe){for(var qe=toPath(Fe),We=Re,Ze=0;Ze<qe.length;Ze++){var Xe=qe[Ze];if(We==null||typeof We!="object"||Array.isArray(We)&&isNaN(Xe))return;We=We[Xe]}return We};function _toPropertyKey(Ke){var Re=_toPrimitive(Ke,"string");return typeof Re=="symbol"?Re:String(Re)}function _toPrimitive(Ke,Re){if(typeof Ke!="object"||Ke===null)return Ke;var Fe=Ke[Symbol.toPrimitive];if(Fe!==void 0){var qe=Fe.call(Ke,Re||"default");if(typeof qe!="object")return qe;throw new TypeError("@@toPrimitive must return a primitive value.")}return(Re==="string"?String:Number)(Ke)}var setInRecursor=function Ke(Re,Fe,qe,We,Ze){if(Fe>=qe.length)return We;var Xe=qe[Fe];if(isNaN(Xe)){var Je;if(Re==null){var tr,er=Ke(void 0,Fe+1,qe,We,Ze);return er===void 0?void 0:(tr={},tr[Xe]=er,tr)}if(Array.isArray(Re))throw new Error("Cannot set a non-numeric property on an array");var ir=Ke(Re[Xe],Fe+1,qe,We,Ze);if(ir===void 0){var ur=Object.keys(Re).length;if(Re[Xe]===void 0&&ur===0)return;if(Re[Xe]!==void 0&&ur<=1)return!isNaN(qe[Fe-1])&&!Ze?{}:void 0;Re[Xe];var fr=_objectWithoutPropertiesLoose(Re,[Xe].map(_toPropertyKey));return fr}return _extends({},Re,(Je={},Je[Xe]=ir,Je))}var ar=Number(Xe);if(Re==null){var yr=Ke(void 0,Fe+1,qe,We,Ze);if(yr===void 0)return;var mr=[];return mr[ar]=yr,mr}if(!Array.isArray(Re))throw new Error("Cannot set a numeric property on an object");var wr=Re[ar],Sr=Ke(wr,Fe+1,qe,We,Ze),Ar=[].concat(Re);if(Ze&&Sr===void 0){if(Ar.splice(ar,1),Ar.length===0)return}else Ar[ar]=Sr;return Ar},setIn=function(Re,Fe,qe,We){if(We===void 0&&(We=!1),Re==null)throw new Error("Cannot call setIn() with "+String(Re)+" state");if(Fe==null)throw new Error("Cannot call setIn() with "+String(Fe)+" key");return setInRecursor(Re,0,toPath(Fe),qe,We)},FORM_ERROR="FINAL_FORM/form-error",ARRAY_ERROR="FINAL_FORM/array-error";function publishFieldState(Ke,Re){var Fe=Ke.errors,qe=Ke.initialValues,We=Ke.lastSubmittedValues,Ze=Ke.submitErrors,Xe=Ke.submitFailed,Je=Ke.submitSucceeded,tr=Ke.submitting,er=Ke.values,ir=Re.active,ur=Re.blur,fr=Re.change,ar=Re.data,yr=Re.focus,mr=Re.modified,wr=Re.modifiedSinceLastSubmit,Sr=Re.name,Ar=Re.touched,vr=Re.validating,Ir=Re.visited,Tr=getIn(er,Sr),Pr=getIn(Fe,Sr);Pr&&Pr[ARRAY_ERROR]&&(Pr=Pr[ARRAY_ERROR]);var Rr=Ze&&getIn(Ze,Sr),Br=qe&&getIn(qe,Sr),Mr=Re.isEqual(Br,Tr),Lr=!!(We&&!Re.isEqual(getIn(We,Sr),Tr)),$r=!Pr&&!Rr;return{active:ir,blur:ur,change:fr,data:ar,dirty:!Mr,dirtySinceLastSubmit:Lr,error:Pr,focus:yr,initial:Br,invalid:!$r,length:Array.isArray(Tr)?Tr.length:void 0,modified:mr,modifiedSinceLastSubmit:wr,name:Sr,pristine:Mr,submitError:Rr,submitFailed:Xe,submitSucceeded:Je,submitting:tr,touched:Ar,valid:$r,value:Tr,visited:Ir,validating:vr}}var fieldSubscriptionItems=["active","data","dirty","dirtySinceLastSubmit","error","initial","invalid","length","modified","modifiedSinceLastSubmit","pristine","submitError","submitFailed","submitSucceeded","submitting","touched","valid","value","visited","validating"],shallowEqual$1=function(Re,Fe){if(Re===Fe)return!0;if(typeof Re!="object"||!Re||typeof Fe!="object"||!Fe)return!1;var qe=Object.keys(Re),We=Object.keys(Fe);if(qe.length!==We.length)return!1;for(var Ze=Object.prototype.hasOwnProperty.bind(Fe),Xe=0;Xe<qe.length;Xe++){var Je=qe[Xe];if(!Ze(Je)||Re[Je]!==Fe[Je])return!1}return!0};function subscriptionFilter(Ke,Re,Fe,qe,We,Ze){var Xe=!1;return We.forEach(function(Je){qe[Je]&&(Ke[Je]=Re[Je],(!Fe||(~Ze.indexOf(Je)?!shallowEqual$1(Re[Je],Fe[Je]):Re[Je]!==Fe[Je]))&&(Xe=!0))}),Xe}var shallowEqualKeys$1=["data"],filterFieldState=function(Re,Fe,qe,We){var Ze={blur:Re.blur,change:Re.change,focus:Re.focus,name:Re.name},Xe=subscriptionFilter(Ze,Re,Fe,qe,fieldSubscriptionItems,shallowEqualKeys$1)||!Fe;return Xe||We?Ze:void 0},formSubscriptionItems=["active","dirty","dirtyFields","dirtyFieldsSinceLastSubmit","dirtySinceLastSubmit","error","errors","hasSubmitErrors","hasValidationErrors","initialValues","invalid","modified","modifiedSinceLastSubmit","pristine","submitting","submitError","submitErrors","submitFailed","submitSucceeded","touched","valid","validating","values","visited"],shallowEqualKeys=["touched","visited"];function filterFormState(Ke,Re,Fe,qe){var We={},Ze=subscriptionFilter(We,Ke,Re,Fe,formSubscriptionItems,shallowEqualKeys)||!Re;return Ze||qe?We:void 0}var memoize=function(Re){var Fe,qe;return function(){for(var We=arguments.length,Ze=new Array(We),Xe=0;Xe<We;Xe++)Ze[Xe]=arguments[Xe];return(!Fe||Ze.length!==Fe.length||Ze.some(function(Je,tr){return!shallowEqual$1(Fe[tr],Je)}))&&(Fe=Ze,qe=Re.apply(void 0,Ze)),qe}},isPromise=function(Ke){return!!Ke&&(typeof Ke=="object"||typeof Ke=="function")&&typeof Ke.then=="function"},version$2="4.20.7",tripleEquals=function(Re,Fe){return Re===Fe},hasAnyError=function Ke(Re){return Object.keys(Re).some(function(Fe){var qe=Re[Fe];return qe&&typeof qe=="object"&&!(qe instanceof Error)?Ke(qe):typeof qe<"u"})};function convertToExternalFormState(Ke){var Re=Ke.active,Fe=Ke.dirtySinceLastSubmit,qe=Ke.modifiedSinceLastSubmit,We=Ke.error,Ze=Ke.errors,Xe=Ke.initialValues,Je=Ke.pristine,tr=Ke.submitting,er=Ke.submitFailed,ir=Ke.submitSucceeded,ur=Ke.submitError,fr=Ke.submitErrors,ar=Ke.valid,yr=Ke.validating,mr=Ke.values;return{active:Re,dirty:!Je,dirtySinceLastSubmit:Fe,modifiedSinceLastSubmit:qe,error:We,errors:Ze,hasSubmitErrors:!!(ur||fr&&hasAnyError(fr)),hasValidationErrors:!!(We||hasAnyError(Ze)),invalid:!ar,initialValues:Xe,pristine:Je,submitting:tr,submitFailed:er,submitSucceeded:ir,submitError:ur,submitErrors:fr,valid:ar,validating:yr>0,values:mr}}function notifySubscriber(Ke,Re,Fe,qe,We,Ze){var Xe=We(Fe,qe,Re,Ze);return Xe?(Ke(Xe),!0):!1}function notify(Ke,Re,Fe,qe,We){var Ze=Ke.entries;Object.keys(Ze).forEach(function(Xe){var Je=Ze[Number(Xe)];if(Je){var tr=Je.subscription,er=Je.subscriber,ir=Je.notified;notifySubscriber(er,tr,Re,Fe,qe,We||!ir)&&(Je.notified=!0)}})}function createForm(Ke){if(!Ke)throw new Error("No config specified");var Re=Ke.debug,Fe=Ke.destroyOnUnregister,qe=Ke.keepDirtyOnReinitialize,We=Ke.initialValues,Ze=Ke.mutators,Xe=Ke.onSubmit,Je=Ke.validate,tr=Ke.validateOnBlur;if(!Xe)throw new Error("No onSubmit function specified");var er={subscribers:{index:0,entries:{}},fieldSubscribers:{},fields:{},formState:{asyncErrors:{},dirtySinceLastSubmit:!1,modifiedSinceLastSubmit:!1,errors:{},initialValues:We&&_extends({},We),invalid:!1,pristine:!0,submitting:!1,submitFailed:!1,submitSucceeded:!1,resetWhileSubmitting:!1,valid:!0,validating:0,values:We?_extends({},We):{}},lastFormState:void 0},ir=0,ur=!1,fr=!1,ar=!1,yr=0,mr={},wr=function(rr){return function(hr){return delete mr[rr],hr}},Sr=function(rr,hr,Cr){var Or=getIn(rr.formState.values,hr),Ur=Cr(Or);rr.formState.values=setIn(rr.formState.values,hr,Ur)||{}},Ar=function(rr,hr,Cr){if(rr.fields[hr]){var Or,Ur;rr.fields=_extends({},rr.fields,(Or={},Or[Cr]=_extends({},rr.fields[hr],{name:Cr,blur:function(){return kr.blur(Cr)},change:function(zr){return kr.change(Cr,zr)},focus:function(){return kr.focus(Cr)},lastFieldState:void 0}),Or)),delete rr.fields[hr],rr.fieldSubscribers=_extends({},rr.fieldSubscribers,(Ur={},Ur[Cr]=rr.fieldSubscribers[hr],Ur)),delete rr.fieldSubscribers[hr];var qr=getIn(rr.formState.values,hr);rr.formState.values=setIn(rr.formState.values,hr,void 0)||{},rr.formState.values=setIn(rr.formState.values,Cr,qr),delete rr.lastFormState}},vr=function(rr){return function(){if(Ze){for(var hr={formState:er.formState,fields:er.fields,fieldSubscribers:er.fieldSubscribers,lastFormState:er.lastFormState},Cr=arguments.length,Or=new Array(Cr),Ur=0;Ur<Cr;Ur++)Or[Ur]=arguments[Ur];var qr=Ze[rr](Or,hr,{changeValue:Sr,getIn,renameField:Ar,resetFieldState:kr.resetFieldState,setIn,shallowEqual:shallowEqual$1});return er.formState=hr.formState,er.fields=hr.fields,er.fieldSubscribers=hr.fieldSubscribers,er.lastFormState=hr.lastFormState,Br(void 0,function(){Mr(),lr()}),qr}}},Ir=Ze?Object.keys(Ze).reduce(function(pr,rr){return pr[rr]=vr(rr),pr},{}):{},Tr=function(rr){var hr=[];if(Je){var Cr=Je(_extends({},er.formState.values));isPromise(Cr)?hr.push(Cr.then(function(Or){return rr(Or,!0)})):rr(Cr,!1)}return hr},Pr=function(rr){return Object.keys(rr.validators).reduce(function(hr,Cr){var Or=rr.validators[Number(Cr)]();return Or&&hr.push(Or),hr},[])},Rr=function(rr,hr){var Cr=[],Or=Pr(rr);if(Or.length){var Ur;Or.forEach(function(qr){var Fr=qr(getIn(er.formState.values,rr.name),er.formState.values,qr.length===0||qr.length===3?publishFieldState(er.formState,er.fields[rr.name]):void 0);if(Fr&&isPromise(Fr)){rr.validating=!0;var zr=Fr.then(function(Yr){er.fields[rr.name]&&(er.fields[rr.name].validating=!1,hr(Yr))});Cr.push(zr)}else Ur||(Ur=Fr)}),hr(Ur)}return Cr},Br=function(rr,hr){if(ur){fr=!0,hr();return}var Cr=er.fields,Or=er.formState,Ur=_extends({},Cr),qr=Object.keys(Ur);if(!Je&&!qr.some(function($n){return Pr(Ur[$n]).length})){hr();return}var Fr=!1;if(rr){var zr=Ur[rr];if(zr){var Yr=zr.validateFields;Yr&&(Fr=!0,qr=Yr.length?Yr.concat(rr):[rr])}}var Wr={},Gr={},Hn={},Xr=[].concat(Tr(function($n,Jr){Jr?Gr=$n||{}:Wr=$n||{}}),qr.reduce(function($n,Jr){return $n.concat(Rr(Cr[Jr],function(Cn){Hn[Jr]=Cn}))},[])),Zr=Xr.length>0,Wn=++yr,Qr=Promise.all(Xr).then(wr(Wn));Zr&&(mr[Wn]=Qr);var jn=function(Jr){var Cn=_extends({},Fr?Or.errors:{},Wr,Jr?Gr:Or.asyncErrors),Fn=function(qn){qr.forEach(function(Un){if(Cr[Un]){var nr=getIn(Wr,Un),Qe=getIn(Cn,Un),dt=Pr(Ur[Un]).length,or=Hn[Un];qn(Un,dt&&or||Je&&nr||(!nr&&!Fr?Qe:void 0))}})};Fn(function(Kn,qn){Cn=setIn(Cn,Kn,qn)||{}}),Fn(function(Kn,qn){if(qn&&qn[ARRAY_ERROR]){var Un=getIn(Cn,Kn),nr=[].concat(Un);nr[ARRAY_ERROR]=qn[ARRAY_ERROR],Cn=setIn(Cn,Kn,nr)}}),shallowEqual$1(Or.errors,Cn)||(Or.errors=Cn),Jr&&(Or.asyncErrors=Gr),Or.error=Wr[FORM_ERROR]};if(Zr&&(er.formState.validating++,hr()),jn(!1),hr(),Zr){var fi=function(){er.formState.validating--,hr()};Qr.then(function(){yr>Wn||jn(!0)}).then(fi,fi)}},Mr=function(rr){if(!ir){var hr=er.fields,Cr=er.fieldSubscribers,Or=er.formState,Ur=_extends({},hr),qr=function(zr){var Yr=Ur[zr],Wr=publishFieldState(Or,Yr),Gr=Yr.lastFieldState;Yr.lastFieldState=Wr;var Hn=Cr[zr];Hn&&notify(Hn,Wr,Gr,filterFieldState,Gr===void 0)};rr?qr(rr):Object.keys(Ur).forEach(qr)}},Lr=function(){Object.keys(er.fields).forEach(function(rr){er.fields[rr].touched=!0})},$r=function(){return!!(er.formState.error||hasAnyError(er.formState.errors))},Nr=function(){var rr=er.fields,hr=er.formState,Cr=er.lastFormState,Or=_extends({},rr),Ur=Object.keys(Or),qr=!1,Fr=Ur.reduce(function(Zr,Wn){var Qr=!Or[Wn].isEqual(getIn(hr.values,Wn),getIn(hr.initialValues||{},Wn));return Qr&&(qr=!0,Zr[Wn]=!0),Zr},{}),zr=Ur.reduce(function(Zr,Wn){var Qr=hr.lastSubmittedValues||{};return Or[Wn].isEqual(getIn(hr.values,Wn),getIn(Qr,Wn))||(Zr[Wn]=!0),Zr},{});hr.pristine=!qr,hr.dirtySinceLastSubmit=!!(hr.lastSubmittedValues&&Object.values(zr).some(function(Zr){return Zr})),hr.modifiedSinceLastSubmit=!!(hr.lastSubmittedValues&&Object.keys(Or).some(function(Zr){return Or[Zr].modifiedSinceLastSubmit})),hr.valid=!hr.error&&!hr.submitError&&!hasAnyError(hr.errors)&&!(hr.submitErrors&&hasAnyError(hr.submitErrors));var Yr=convertToExternalFormState(hr),Wr=Ur.reduce(function(Zr,Wn){return Zr.modified[Wn]=Or[Wn].modified,Zr.touched[Wn]=Or[Wn].touched,Zr.visited[Wn]=Or[Wn].visited,Zr},{modified:{},touched:{},visited:{}}),Gr=Wr.modified,Hn=Wr.touched,Xr=Wr.visited;return Yr.dirtyFields=Cr&&shallowEqual$1(Cr.dirtyFields,Fr)?Cr.dirtyFields:Fr,Yr.dirtyFieldsSinceLastSubmit=Cr&&shallowEqual$1(Cr.dirtyFieldsSinceLastSubmit,zr)?Cr.dirtyFieldsSinceLastSubmit:zr,Yr.modified=Cr&&shallowEqual$1(Cr.modified,Gr)?Cr.modified:Gr,Yr.touched=Cr&&shallowEqual$1(Cr.touched,Hn)?Cr.touched:Hn,Yr.visited=Cr&&shallowEqual$1(Cr.visited,Xr)?Cr.visited:Xr,Cr&&shallowEqual$1(Cr,Yr)?Cr:Yr},cr=function(){return Re&&!0&&Re(Nr(),Object.keys(er.fields).reduce(function(rr,hr){return rr[hr]=er.fields[hr],rr},{}))},Dt=!1,sr=!1,lr=function pr(){if(Dt)sr=!0;else{if(Dt=!0,cr(),!ir&&!(ur&&ar)){var rr=er.lastFormState,hr=Nr();hr!==rr&&(er.lastFormState=hr,notify(er.subscribers,hr,rr,filterFormState))}Dt=!1,sr&&(sr=!1,pr())}},gr=function(){return Object.keys(er.fields).some(function(rr){return er.fields[rr].beforeSubmit&&er.fields[rr].beforeSubmit()===!1})},_r=function(){return Object.keys(er.fields).forEach(function(rr){return er.fields[rr].afterSubmit&&er.fields[rr].afterSubmit()})},xr=function(){return Object.keys(er.fields).forEach(function(rr){return er.fields[rr].modifiedSinceLastSubmit=!1})};Br(void 0,function(){lr()});var kr={batch:function(rr){ir++,rr(),ir--,Mr(),lr()},blur:function(rr){var hr=er.fields,Cr=er.formState,Or=hr[rr];Or&&(delete Cr.active,hr[rr]=_extends({},Or,{active:!1,touched:!0}),tr?Br(rr,function(){Mr(),lr()}):(Mr(),lr()))},change:function(rr,hr){var Cr=er.fields,Or=er.formState;if(getIn(Or.values,rr)!==hr){Sr(er,rr,function(){return hr});var Ur=Cr[rr];Ur&&(Cr[rr]=_extends({},Ur,{modified:!0,modifiedSinceLastSubmit:!!Or.lastSubmittedValues})),tr?(Mr(),lr()):Br(rr,function(){Mr(),lr()})}},get destroyOnUnregister(){return!!Fe},set destroyOnUnregister(pr){Fe=pr},focus:function(rr){var hr=er.fields[rr];hr&&!hr.active&&(er.formState.active=rr,hr.active=!0,hr.visited=!0,Mr(),lr())},mutators:Ir,getFieldState:function(rr){var hr=er.fields[rr];return hr&&hr.lastFieldState},getRegisteredFields:function(){return Object.keys(er.fields)},getState:function(){return Nr()},initialize:function(rr){var hr=er.fields,Cr=er.formState,Or=_extends({},hr),Ur=typeof rr=="function"?rr(Cr.values):rr;qe||(Cr.values=Ur);var qr=qe?Object.keys(Or).reduce(function(Fr,zr){var Yr=Or[zr],Wr=Yr.isEqual(getIn(Cr.values,zr),getIn(Cr.initialValues||{},zr));return Wr||(Fr[zr]=getIn(Cr.values,zr)),Fr},{}):{};Cr.initialValues=Ur,Cr.values=Ur,Object.keys(qr).forEach(function(Fr){Cr.values=setIn(Cr.values,Fr,qr[Fr])||{}}),Br(void 0,function(){Mr(),lr()})},isValidationPaused:function(){return ur},pauseValidation:function(rr){rr===void 0&&(rr=!0),ur=!0,ar=rr},registerField:function(rr,hr,Cr,Or){Cr===void 0&&(Cr={}),er.fieldSubscribers[rr]||(er.fieldSubscribers[rr]={index:0,entries:{}});var Ur=er.fieldSubscribers[rr].index++;er.fieldSubscribers[rr].entries[Ur]={subscriber:memoize(hr),subscription:Cr,notified:!1},er.fields[rr]||(er.fields[rr]={active:!1,afterSubmit:Or&&Or.afterSubmit,beforeSubmit:Or&&Or.beforeSubmit,blur:function(){return kr.blur(rr)},change:function(Gr){return kr.change(rr,Gr)},data:Or&&Or.data||{},focus:function(){return kr.focus(rr)},isEqual:Or&&Or.isEqual||tripleEquals,lastFieldState:void 0,modified:!1,modifiedSinceLastSubmit:!1,name:rr,touched:!1,valid:!0,validateFields:Or&&Or.validateFields,validators:{},validating:!1,visited:!1});var qr=!1,Fr=Or&&Or.silent,zr=function(){Fr?Mr(rr):(lr(),Mr())};if(Or){qr=!!(Or.getValidator&&Or.getValidator()),Or.getValidator&&(er.fields[rr].validators[Ur]=Or.getValidator);var Yr=getIn(er.formState.values,rr)===void 0;Or.initialValue!==void 0&&(Yr||getIn(er.formState.values,rr)===getIn(er.formState.initialValues,rr))&&(er.formState.initialValues=setIn(er.formState.initialValues||{},rr,Or.initialValue),er.formState.values=setIn(er.formState.values,rr,Or.initialValue),Br(void 0,zr)),Or.defaultValue!==void 0&&Or.initialValue===void 0&&getIn(er.formState.initialValues,rr)===void 0&&Yr&&(er.formState.values=setIn(er.formState.values,rr,Or.defaultValue))}return qr?Br(void 0,zr):zr(),function(){var Wr=!1;er.fields[rr]&&(Wr=!!(er.fields[rr].validators[Ur]&&er.fields[rr].validators[Ur]()),delete er.fields[rr].validators[Ur]);var Gr=!!er.fieldSubscribers[rr];Gr&&delete er.fieldSubscribers[rr].entries[Ur];var Hn=Gr&&!Object.keys(er.fieldSubscribers[rr].entries).length;Hn&&(delete er.fieldSubscribers[rr],delete er.fields[rr],Wr&&(er.formState.errors=setIn(er.formState.errors,rr,void 0)||{}),Fe&&(er.formState.values=setIn(er.formState.values,rr,void 0,!0)||{})),Fr||(Wr?Br(void 0,function(){lr(),Mr()}):Hn&&lr())}},reset:function(rr){rr===void 0&&(rr=er.formState.initialValues),er.formState.submitting&&(er.formState.resetWhileSubmitting=!0),er.formState.submitFailed=!1,er.formState.submitSucceeded=!1,delete er.formState.submitError,delete er.formState.submitErrors,delete er.formState.lastSubmittedValues,kr.initialize(rr||{})},resetFieldState:function(rr){er.fields[rr]=_extends({},er.fields[rr],{active:!1,lastFieldState:void 0,modified:!1,touched:!1,valid:!0,validating:!1,visited:!1}),Br(void 0,function(){Mr(),lr()})},restart:function(rr){rr===void 0&&(rr=er.formState.initialValues),kr.batch(function(){for(var hr in er.fields)kr.resetFieldState(hr),er.fields[hr]=_extends({},er.fields[hr],{active:!1,lastFieldState:void 0,modified:!1,modifiedSinceLastSubmit:!1,touched:!1,valid:!0,validating:!1,visited:!1});kr.reset(rr)})},resumeValidation:function(){ur=!1,ar=!1,fr&&Br(void 0,function(){Mr(),lr()}),fr=!1},setConfig:function(rr,hr){switch(rr){case"debug":Re=hr;break;case"destroyOnUnregister":Fe=hr;break;case"initialValues":kr.initialize(hr);break;case"keepDirtyOnReinitialize":qe=hr;break;case"mutators":Ze=hr,hr?(Object.keys(Ir).forEach(function(Cr){Cr in hr||delete Ir[Cr]}),Object.keys(hr).forEach(function(Cr){Ir[Cr]=vr(Cr)})):Object.keys(Ir).forEach(function(Cr){delete Ir[Cr]});break;case"onSubmit":Xe=hr;break;case"validate":Je=hr,Br(void 0,function(){Mr(),lr()});break;case"validateOnBlur":tr=hr;break;default:throw new Error("Unrecognised option "+rr)}},submit:function(){var rr=er.formState;if(!rr.submitting){if(delete rr.submitErrors,delete rr.submitError,rr.lastSubmittedValues=_extends({},rr.values),$r()){Lr(),xr(),er.formState.submitFailed=!0,lr(),Mr();return}var hr=Object.keys(mr);if(hr.length){Promise.all(hr.map(function(zr){return mr[Number(zr)]})).then(kr.submit,console.error);return}var Cr=gr();if(!Cr){var Or,Ur=!1,qr=function(Yr){rr.submitting=!1;var Wr=rr.resetWhileSubmitting;return Wr&&(rr.resetWhileSubmitting=!1),Yr&&hasAnyError(Yr)?(rr.submitFailed=!0,rr.submitSucceeded=!1,rr.submitErrors=Yr,rr.submitError=Yr[FORM_ERROR],Lr()):(Wr||(rr.submitFailed=!1,rr.submitSucceeded=!0),_r()),lr(),Mr(),Ur=!0,Or&&Or(Yr),Yr};rr.submitting=!0,rr.submitFailed=!1,rr.submitSucceeded=!1,rr.lastSubmittedValues=_extends({},rr.values),xr();var Fr=Xe(rr.values,kr,qr);if(!Ur){if(Fr&&isPromise(Fr))return lr(),Mr(),Fr.then(qr,function(zr){throw qr(),zr});if(Xe.length>=3)return lr(),Mr(),new Promise(function(zr){Or=zr});qr(Fr)}}}},subscribe:function(rr,hr){if(!rr)throw new Error("No callback given.");if(!hr)throw new Error("No subscription provided. What values do you want to listen to?");var Cr=memoize(rr),Or=er.subscribers,Ur=Or.index++;Or.entries[Ur]={subscriber:Cr,subscription:hr,notified:!1};var qr=Nr();return notifySubscriber(Cr,hr,qr,qr,filterFormState,!0),function(){delete Or.entries[Ur]}}};return kr}var _excluded$3=["render","children","component"];function renderComponent(Ke,Re,Fe){var qe=Ke.render,We=Ke.children,Ze=Ke.component,Xe=_objectWithoutPropertiesLoose(Ke,_excluded$3);if(Ze)return h$1(Ze,Object.assign(Re,Xe,{children:We,render:qe}));if(qe)return qe(We===void 0?Object.assign(Re,Xe):Object.assign(Re,Xe,{children:We}));if(typeof We!="function")throw new Error("Must specify either a render prop, a render function as children, or a component prop to "+Fe);return We(Object.assign(Re,Xe))}function useWhenValueChanges(Ke,Re,Fe){Fe===void 0&&(Fe=function(Ze,Xe){return Ze===Xe});var qe=_n$1.useRef(Ke);_n$1.useEffect(function(){Fe(Ke,qe.current)||(Re(),qe.current=Ke)})}function useConstant(Ke){var Re=_n$1.useRef();return Re.current||(Re.current=Ke()),Re.current}var shallowEqual=function(Re,Fe){if(Re===Fe)return!0;if(typeof Re!="object"||!Re||typeof Fe!="object"||!Fe)return!1;var qe=Object.keys(Re),We=Object.keys(Fe);if(qe.length!==We.length)return!1;for(var Ze=Object.prototype.hasOwnProperty.bind(Fe),Xe=0;Xe<qe.length;Xe++){var Je=qe[Xe];if(!Ze(Je)||Re[Je]!==Fe[Je])return!1}return!0},isSyntheticEvent=function(Re){return!!(Re&&typeof Re.stopPropagation=="function")},ReactFinalFormContext=B$3();function useLatest(Ke){var Re=_n$1.useRef(Ke);return _n$1.useEffect(function(){Re.current=Ke}),Re}var version$1="6.5.8",addLazyState=function(Re,Fe,qe){qe.forEach(function(We){Object.defineProperty(Re,We,{get:function(){return Fe[We]},enumerable:!0})})},addLazyFormState=function(Re,Fe){return addLazyState(Re,Fe,["active","dirty","dirtyFields","dirtySinceLastSubmit","dirtyFieldsSinceLastSubmit","error","errors","hasSubmitErrors","hasValidationErrors","initialValues","invalid","modified","modifiedSinceLastSubmit","pristine","submitError","submitErrors","submitFailed","submitSucceeded","submitting","touched","valid","validating","values","visited"])},addLazyFieldMetaState=function(Re,Fe){return addLazyState(Re,Fe,["active","data","dirty","dirtySinceLastSubmit","error","initial","invalid","length","modified","modifiedSinceLastSubmit","pristine","submitError","submitFailed","submitSucceeded","submitting","touched","valid","validating","visited"])},_excluded$2=["debug","decorators","destroyOnUnregister","form","initialValues","initialValuesEqual","keepDirtyOnReinitialize","mutators","onSubmit","subscription","validate","validateOnBlur"],versions={"final-form":version$2,"react-final-form":version$1},all$1=formSubscriptionItems.reduce(function(Ke,Re){return Ke[Re]=!0,Ke},{});function ReactFinalForm(Ke){var Re=Ke.debug,Fe=Ke.decorators,qe=Fe===void 0?[]:Fe,We=Ke.destroyOnUnregister,Ze=Ke.form,Xe=Ke.initialValues,Je=Ke.initialValuesEqual,tr=Ke.keepDirtyOnReinitialize,er=Ke.mutators,ir=Ke.onSubmit,ur=Ke.subscription,fr=ur===void 0?all$1:ur,ar=Ke.validate,yr=Ke.validateOnBlur,mr=_objectWithoutPropertiesLoose(Ke,_excluded$2),wr={debug:Re,destroyOnUnregister:We,initialValues:Xe,keepDirtyOnReinitialize:tr,mutators:er,onSubmit:ir,validate:ar,validateOnBlur:yr},Sr=useConstant(function(){var Br=Ze||createForm(wr);return Br.pauseValidation(),Br}),Ar=p(function(){var Br={};return Sr.subscribe(function(Mr){Br=Mr},fr)(),Br}),vr=Ar[0],Ir=Ar[1],Tr=useLatest(vr);h(function(){Sr.isValidationPaused()&&Sr.resumeValidation();var Br=[Sr.subscribe(function(Mr){shallowEqual(Mr,Tr.current)||Ir(Mr)},fr)].concat(qe?qe.map(function(Mr){return Mr(Sr)}):[]);return function(){Sr.pauseValidation(),Br.reverse().forEach(function(Mr){return Mr()})}},qe),useWhenValueChanges(Re,function(){Sr.setConfig("debug",Re)}),useWhenValueChanges(We,function(){Sr.destroyOnUnregister=!!We}),useWhenValueChanges(tr,function(){Sr.setConfig("keepDirtyOnReinitialize",tr)}),useWhenValueChanges(Xe,function(){Sr.setConfig("initialValues",Xe)},Je||shallowEqual),useWhenValueChanges(er,function(){Sr.setConfig("mutators",er)}),useWhenValueChanges(ir,function(){Sr.setConfig("onSubmit",ir)}),useWhenValueChanges(ar,function(){Sr.setConfig("validate",ar)}),useWhenValueChanges(yr,function(){Sr.setConfig("validateOnBlur",yr)});var Pr=function(Mr){return Mr&&(typeof Mr.preventDefault=="function"&&Mr.preventDefault(),typeof Mr.stopPropagation=="function"&&Mr.stopPropagation()),Sr.submit()},Rr={form:_extends({},Sr,{reset:function(Mr){isSyntheticEvent(Mr)?Sr.reset():Sr.reset(Mr)}}),handleSubmit:Pr};return addLazyFormState(Rr,vr),h$1(ReactFinalFormContext.Provider,{value:Sr},renderComponent(_extends({},mr,{__versions:versions}),Rr,"ReactFinalForm"))}function useForm(Ke){var Re=q$2(ReactFinalFormContext);if(!Re)throw new Error((Ke||"useForm")+" must be used inside of a <Form> component");return Re}var isReactNative=typeof window<"u"&&window.navigator&&window.navigator.product&&window.navigator.product==="ReactNative",getSelectedValues=function(Re){var Fe=[];if(Re)for(var qe=0;qe<Re.length;qe++){var We=Re[qe];We.selected&&Fe.push(We.value)}return Fe},getValue=function(Re,Fe,qe,We){if(!We&&Re.nativeEvent&&Re.nativeEvent.text!==void 0||We&&Re.nativeEvent)return Re.nativeEvent.text;var Ze=Re,Xe=Ze.target,Je=Xe.type,tr=Xe.value,er=Xe.checked;switch(Je){case"checkbox":if(qe!==void 0){if(er)return Array.isArray(Fe)?Fe.concat(qe):[qe];if(!Array.isArray(Fe))return Fe;var ir=Fe.indexOf(qe);return ir<0?Fe:Fe.slice(0,ir).concat(Fe.slice(ir+1))}else return!!er;case"select-multiple":return getSelectedValues(Re.target.options);default:return tr}};function useConstantCallback(Ke){var Re=_$2(Ke);return h(function(){Re.current=Ke}),T$2(function(){for(var Fe=arguments.length,qe=new Array(Fe),We=0;We<Fe;We++)qe[We]=arguments[We];return Re.current.apply(null,qe)},[])}var all=fieldSubscriptionItems.reduce(function(Ke,Re){return Ke[Re]=!0,Ke},{}),defaultFormat=function(Re,Fe){return Re===void 0?"":Re},defaultParse=function(Re,Fe){return Re===""?void 0:Re},defaultIsEqual=function(Re,Fe){return Re===Fe};function useField(Ke,Re){Re===void 0&&(Re={});var Fe=Re,qe=Fe.afterSubmit,We=Fe.allowNull,Ze=Fe.component,Xe=Fe.data,Je=Fe.defaultValue,tr=Fe.format,er=tr===void 0?defaultFormat:tr,ir=Fe.formatOnBlur,ur=Fe.initialValue,fr=Fe.multiple,ar=Fe.parse,yr=ar===void 0?defaultParse:ar,mr=Fe.subscription,wr=mr===void 0?all:mr,Sr=Fe.type,Ar=Fe.validateFields,vr=Fe.value,Ir=useForm("useField"),Tr=useLatest(Re),Pr=function(sr,lr){return Ir.registerField(Ke,sr,wr,{afterSubmit:qe,beforeSubmit:function(){var _r=Tr.current,xr=_r.beforeSubmit,kr=_r.formatOnBlur,pr=_r.format,rr=pr===void 0?defaultFormat:pr;if(kr){var hr=Ir.getFieldState(Ke),Cr=hr.value,Or=rr(Cr,Ke);Or!==Cr&&Ir.change(Ke,Or)}return xr&&xr()},data:Xe,defaultValue:Je,getValidator:function(){return Tr.current.validate},initialValue:ur,isEqual:function(_r,xr){return(Tr.current.isEqual||defaultIsEqual)(_r,xr)},silent:lr,validateFields:Ar})},Rr=_$2(!0),Br=p(function(){var Dt={},sr=Ir.destroyOnUnregister;return Ir.destroyOnUnregister=!1,Pr(function(lr){Dt=lr},!0)(),Ir.destroyOnUnregister=sr,Dt}),Mr=Br[0],Lr=Br[1];h(function(){return Pr(function(Dt){Rr.current?Rr.current=!1:Lr(Dt)},!1)},[Ke,Xe,Je,ur]);var $r={};addLazyFieldMetaState($r,Mr);var Nr={name:Ke,get value(){var Dt=Mr.value;return ir?Ze==="input"&&(Dt=defaultFormat(Dt)):Dt=er(Dt,Ke),Dt===null&&!We&&(Dt=""),Sr==="checkbox"||Sr==="radio"?vr:Ze==="select"&&fr?Dt||[]:Dt},get checked(){var Dt=Mr.value;if(Sr==="checkbox")return Dt=er(Dt,Ke),vr===void 0?!!Dt:!!(Array.isArray(Dt)&&~Dt.indexOf(vr));if(Sr==="radio")return er(Dt,Ke)===vr},onBlur:useConstantCallback(function(Dt){if(Mr.blur(),ir){var sr=Ir.getFieldState(Mr.name);Mr.change(er(sr.value,Mr.name))}}),onChange:useConstantCallback(function(Dt){var sr=Dt&&Dt.target?getValue(Dt,Mr.value,vr,isReactNative):Dt;Mr.change(yr(sr,Ke))}),onFocus:useConstantCallback(function(Dt){return Mr.focus()})};fr&&(Nr.multiple=fr),Sr!==void 0&&(Nr.type=Sr);var cr={input:Nr,meta:$r};return cr}var _excluded=["afterSubmit","allowNull","beforeSubmit","children","component","data","defaultValue","format","formatOnBlur","initialValue","isEqual","multiple","name","parse","subscription","type","validate","validateFields","value"],Field=N$1(function(Re,Fe){var qe=Re.afterSubmit,We=Re.allowNull,Ze=Re.beforeSubmit,Xe=Re.children,Je=Re.component,tr=Re.data,er=Re.defaultValue,ir=Re.format,ur=Re.formatOnBlur,fr=Re.initialValue,ar=Re.isEqual,yr=Re.multiple,mr=Re.name,wr=Re.parse,Sr=Re.subscription,Ar=Re.type,vr=Re.validate,Ir=Re.validateFields,Tr=Re.value,Pr=_objectWithoutPropertiesLoose(Re,_excluded),Rr=useField(mr,{afterSubmit:qe,allowNull:We,beforeSubmit:Ze,children:Xe,component:Je,data:tr,defaultValue:er,format:ir,formatOnBlur:ur,initialValue:fr,isEqual:ar,multiple:yr,parse:wr,subscription:Sr,type:Ar,validate:vr,validateFields:Ir,value:Tr});if(typeof Xe=="function")return Xe(_extends({},Rr,Pr));if(typeof Je=="string")return h$1(Je,_extends({},Rr.input,{children:Xe,ref:Fe},Pr));if(!mr)throw new Error("prop name cannot be undefined in <Field> component");return renderComponent(_extends({children:Xe,component:Je,ref:Fe},Pr),Rr,"Field("+mr+")")}),_$1=0;function o(Ke,Re,Fe,qe,We){var Ze,Xe,Je={};for(Xe in Re)Xe=="ref"?Ze=Re[Xe]:Je[Xe]=Re[Xe];var tr={type:Ke,props:Je,key:Fe,ref:Ze,__k:null,__:null,__b:0,__e:null,__d:void 0,__c:null,__h:null,constructor:void 0,__v:--_$1,__source:We,__self:qe};if(typeof Ke=="function"&&(Ze=Ke.defaultProps))for(Xe in Ze)Je[Xe]===void 0&&(Je[Xe]=Ze[Xe]);return l$1.vnode&&l$1.vnode(tr),tr}function FormGroup({children:Ke,meta:Re}){const Fe=T$2(()=>Re.touched&&Re.error?o("div",{children:o("span",{children:Re.error})}):null,[Re]);return o("div",{className:"w-full",children:[o("div",{children:Ke}),Fe()]})}function TextInput(Ke){const{input:Re,placeholder:Fe}=Ke;return o("input",{...Re,id:Re.name,placeholder:Fe,className:"outline-0 bg-white border-2 border-black text-gray-900 sm:text-lg rounded-xl group-focus-within:ring-primary-600 group-focus-within:border-primary-600 block w-full p-3 px-4 shadow-[6px_6px_0_0_#000] transition focus:shadow-none focus:border-slate-700 focus:ring ring-purple-500/50"})}function GifLinkForm({onSubmit:Ke}){return o(ReactFinalForm,{onSubmit:Ke,render:({handleSubmit:Re})=>o("form",{onSubmit:Re,className:"w-full",children:o("div",{className:"w-full flex flex-col space-y-8 sm:space-y-0 sm:flex-row justify-between items-center sm:items-stretch space-x-0 sm:space-x-3 group",children:[o(Field,{name:"gifLink",placeholder:"Gif link here to metaverse here ...",children:({meta:Fe,input:qe,placeholder:We})=>o(FormGroup,{meta:Fe,input:qe,children:o(TextInput,{input:qe,placeholder:We})})}),o("button",{type:"submit",className:"flex items-center justify-center rounded-xl border-2 border-black px-6 py-2 font-bold shadow-[6px_6px_0_0_#000] transition hover:shadow-none focus:outline-none focus:ring ring-purple-500/50 active:bg-purple-200/50 max-w-xs",children:["Mint",o("span",{"aria-hidden":"true",className:"ml-1.5",role:"img",children:"\u{1F680}"})]})]})})})}const button="_button_16vgv_1",s={button};var buffer={};/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */(function(Ke){const Re=base64Js,Fe=ieee754,qe=typeof Symbol=="function"&&typeof Symbol.for=="function"?Symbol.for("nodejs.util.inspect.custom"):null;Ke.Buffer=Je,Ke.SlowBuffer=Ar,Ke.INSPECT_MAX_BYTES=50;const We=2147483647;Ke.kMaxLength=We,Je.TYPED_ARRAY_SUPPORT=Ze(),!Je.TYPED_ARRAY_SUPPORT&&typeof console<"u"&&typeof console.error=="function"&&console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");function Ze(){try{const nr=new Uint8Array(1),Qe={foo:function(){return 42}};return Object.setPrototypeOf(Qe,Uint8Array.prototype),Object.setPrototypeOf(nr,Qe),nr.foo()===42}catch{return!1}}Object.defineProperty(Je.prototype,"parent",{enumerable:!0,get:function(){if(!!Je.isBuffer(this))return this.buffer}}),Object.defineProperty(Je.prototype,"offset",{enumerable:!0,get:function(){if(!!Je.isBuffer(this))return this.byteOffset}});function Xe(nr){if(nr>We)throw new RangeError('The value "'+nr+'" is invalid for option "size"');const Qe=new Uint8Array(nr);return Object.setPrototypeOf(Qe,Je.prototype),Qe}function Je(nr,Qe,dt){if(typeof nr=="number"){if(typeof Qe=="string")throw new TypeError('The "string" argument must be of type string. Received type number');return ur(nr)}return tr(nr,Qe,dt)}Je.poolSize=8192;function tr(nr,Qe,dt){if(typeof nr=="string")return fr(nr,Qe);if(ArrayBuffer.isView(nr))return yr(nr);if(nr==null)throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof nr);if(Cn(nr,ArrayBuffer)||nr&&Cn(nr.buffer,ArrayBuffer)||typeof SharedArrayBuffer<"u"&&(Cn(nr,SharedArrayBuffer)||nr&&Cn(nr.buffer,SharedArrayBuffer)))return mr(nr,Qe,dt);if(typeof nr=="number")throw new TypeError('The "value" argument must not be of type number. Received type number');const or=nr.valueOf&&nr.valueOf();if(or!=null&&or!==nr)return Je.from(or,Qe,dt);const dr=wr(nr);if(dr)return dr;if(typeof Symbol<"u"&&Symbol.toPrimitive!=null&&typeof nr[Symbol.toPrimitive]=="function")return Je.from(nr[Symbol.toPrimitive]("string"),Qe,dt);throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof nr)}Je.from=function(nr,Qe,dt){return tr(nr,Qe,dt)},Object.setPrototypeOf(Je.prototype,Uint8Array.prototype),Object.setPrototypeOf(Je,Uint8Array);function er(nr){if(typeof nr!="number")throw new TypeError('"size" argument must be of type number');if(nr<0)throw new RangeError('The value "'+nr+'" is invalid for option "size"')}function ir(nr,Qe,dt){return er(nr),nr<=0?Xe(nr):Qe!==void 0?typeof dt=="string"?Xe(nr).fill(Qe,dt):Xe(nr).fill(Qe):Xe(nr)}Je.alloc=function(nr,Qe,dt){return ir(nr,Qe,dt)};function ur(nr){return er(nr),Xe(nr<0?0:Sr(nr)|0)}Je.allocUnsafe=function(nr){return ur(nr)},Je.allocUnsafeSlow=function(nr){return ur(nr)};function fr(nr,Qe){if((typeof Qe!="string"||Qe==="")&&(Qe="utf8"),!Je.isEncoding(Qe))throw new TypeError("Unknown encoding: "+Qe);const dt=vr(nr,Qe)|0;let or=Xe(dt);const dr=or.write(nr,Qe);return dr!==dt&&(or=or.slice(0,dr)),or}function ar(nr){const Qe=nr.length<0?0:Sr(nr.length)|0,dt=Xe(Qe);for(let or=0;or<Qe;or+=1)dt[or]=nr[or]&255;return dt}function yr(nr){if(Cn(nr,Uint8Array)){const Qe=new Uint8Array(nr);return mr(Qe.buffer,Qe.byteOffset,Qe.byteLength)}return ar(nr)}function mr(nr,Qe,dt){if(Qe<0||nr.byteLength<Qe)throw new RangeError('"offset" is outside of buffer bounds');if(nr.byteLength<Qe+(dt||0))throw new RangeError('"length" is outside of buffer bounds');let or;return Qe===void 0&&dt===void 0?or=new Uint8Array(nr):dt===void 0?or=new Uint8Array(nr,Qe):or=new Uint8Array(nr,Qe,dt),Object.setPrototypeOf(or,Je.prototype),or}function wr(nr){if(Je.isBuffer(nr)){const Qe=Sr(nr.length)|0,dt=Xe(Qe);return dt.length===0||nr.copy(dt,0,0,Qe),dt}if(nr.length!==void 0)return typeof nr.length!="number"||Fn(nr.length)?Xe(0):ar(nr);if(nr.type==="Buffer"&&Array.isArray(nr.data))return ar(nr.data)}function Sr(nr){if(nr>=We)throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x"+We.toString(16)+" bytes");return nr|0}function Ar(nr){return+nr!=nr&&(nr=0),Je.alloc(+nr)}Je.isBuffer=function(Qe){return Qe!=null&&Qe._isBuffer===!0&&Qe!==Je.prototype},Je.compare=function(Qe,dt){if(Cn(Qe,Uint8Array)&&(Qe=Je.from(Qe,Qe.offset,Qe.byteLength)),Cn(dt,Uint8Array)&&(dt=Je.from(dt,dt.offset,dt.byteLength)),!Je.isBuffer(Qe)||!Je.isBuffer(dt))throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');if(Qe===dt)return 0;let or=Qe.length,dr=dt.length;for(let br=0,Er=Math.min(or,dr);br<Er;++br)if(Qe[br]!==dt[br]){or=Qe[br],dr=dt[br];break}return or<dr?-1:dr<or?1:0},Je.isEncoding=function(Qe){switch(String(Qe).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"latin1":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return!0;default:return!1}},Je.concat=function(Qe,dt){if(!Array.isArray(Qe))throw new TypeError('"list" argument must be an Array of Buffers');if(Qe.length===0)return Je.alloc(0);let or;if(dt===void 0)for(dt=0,or=0;or<Qe.length;++or)dt+=Qe[or].length;const dr=Je.allocUnsafe(dt);let br=0;for(or=0;or<Qe.length;++or){let Er=Qe[or];if(Cn(Er,Uint8Array))br+Er.length>dr.length?(Je.isBuffer(Er)||(Er=Je.from(Er)),Er.copy(dr,br)):Uint8Array.prototype.set.call(dr,Er,br);else if(Je.isBuffer(Er))Er.copy(dr,br);else throw new TypeError('"list" argument must be an Array of Buffers');br+=Er.length}return dr};function vr(nr,Qe){if(Je.isBuffer(nr))return nr.length;if(ArrayBuffer.isView(nr)||Cn(nr,ArrayBuffer))return nr.byteLength;if(typeof nr!="string")throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type '+typeof nr);const dt=nr.length,or=arguments.length>2&&arguments[2]===!0;if(!or&&dt===0)return 0;let dr=!1;for(;;)switch(Qe){case"ascii":case"latin1":case"binary":return dt;case"utf8":case"utf-8":return Qr(nr).length;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return dt*2;case"hex":return dt>>>1;case"base64":return $n(nr).length;default:if(dr)return or?-1:Qr(nr).length;Qe=(""+Qe).toLowerCase(),dr=!0}}Je.byteLength=vr;function Ir(nr,Qe,dt){let or=!1;if((Qe===void 0||Qe<0)&&(Qe=0),Qe>this.length||((dt===void 0||dt>this.length)&&(dt=this.length),dt<=0)||(dt>>>=0,Qe>>>=0,dt<=Qe))return"";for(nr||(nr="utf8");;)switch(nr){case"hex":return xr(this,Qe,dt);case"utf8":case"utf-8":return Dt(this,Qe,dt);case"ascii":return gr(this,Qe,dt);case"latin1":case"binary":return _r(this,Qe,dt);case"base64":return cr(this,Qe,dt);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return kr(this,Qe,dt);default:if(or)throw new TypeError("Unknown encoding: "+nr);nr=(nr+"").toLowerCase(),or=!0}}Je.prototype._isBuffer=!0;function Tr(nr,Qe,dt){const or=nr[Qe];nr[Qe]=nr[dt],nr[dt]=or}Je.prototype.swap16=function(){const Qe=this.length;if(Qe%2!==0)throw new RangeError("Buffer size must be a multiple of 16-bits");for(let dt=0;dt<Qe;dt+=2)Tr(this,dt,dt+1);return this},Je.prototype.swap32=function(){const Qe=this.length;if(Qe%4!==0)throw new RangeError("Buffer size must be a multiple of 32-bits");for(let dt=0;dt<Qe;dt+=4)Tr(this,dt,dt+3),Tr(this,dt+1,dt+2);return this},Je.prototype.swap64=function(){const Qe=this.length;if(Qe%8!==0)throw new RangeError("Buffer size must be a multiple of 64-bits");for(let dt=0;dt<Qe;dt+=8)Tr(this,dt,dt+7),Tr(this,dt+1,dt+6),Tr(this,dt+2,dt+5),Tr(this,dt+3,dt+4);return this},Je.prototype.toString=function(){const Qe=this.length;return Qe===0?"":arguments.length===0?Dt(this,0,Qe):Ir.apply(this,arguments)},Je.prototype.toLocaleString=Je.prototype.toString,Je.prototype.equals=function(Qe){if(!Je.isBuffer(Qe))throw new TypeError("Argument must be a Buffer");return this===Qe?!0:Je.compare(this,Qe)===0},Je.prototype.inspect=function(){let Qe="";const dt=Ke.INSPECT_MAX_BYTES;return Qe=this.toString("hex",0,dt).replace(/(.{2})/g,"$1 ").trim(),this.length>dt&&(Qe+=" ... "),"<Buffer "+Qe+">"},qe&&(Je.prototype[qe]=Je.prototype.inspect),Je.prototype.compare=function(Qe,dt,or,dr,br){if(Cn(Qe,Uint8Array)&&(Qe=Je.from(Qe,Qe.offset,Qe.byteLength)),!Je.isBuffer(Qe))throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type '+typeof Qe);if(dt===void 0&&(dt=0),or===void 0&&(or=Qe?Qe.length:0),dr===void 0&&(dr=0),br===void 0&&(br=this.length),dt<0||or>Qe.length||dr<0||br>this.length)throw new RangeError("out of range index");if(dr>=br&&dt>=or)return 0;if(dr>=br)return-1;if(dt>=or)return 1;if(dt>>>=0,or>>>=0,dr>>>=0,br>>>=0,this===Qe)return 0;let Er=br-dr,Dr=or-dt;const Vr=Math.min(Er,Dr),Kr=this.slice(dr,br),jr=Qe.slice(dt,or);for(let Hr=0;Hr<Vr;++Hr)if(Kr[Hr]!==jr[Hr]){Er=Kr[Hr],Dr=jr[Hr];break}return Er<Dr?-1:Dr<Er?1:0};function Pr(nr,Qe,dt,or,dr){if(nr.length===0)return-1;if(typeof dt=="string"?(or=dt,dt=0):dt>2147483647?dt=2147483647:dt<-2147483648&&(dt=-2147483648),dt=+dt,Fn(dt)&&(dt=dr?0:nr.length-1),dt<0&&(dt=nr.length+dt),dt>=nr.length){if(dr)return-1;dt=nr.length-1}else if(dt<0)if(dr)dt=0;else return-1;if(typeof Qe=="string"&&(Qe=Je.from(Qe,or)),Je.isBuffer(Qe))return Qe.length===0?-1:Rr(nr,Qe,dt,or,dr);if(typeof Qe=="number")return Qe=Qe&255,typeof Uint8Array.prototype.indexOf=="function"?dr?Uint8Array.prototype.indexOf.call(nr,Qe,dt):Uint8Array.prototype.lastIndexOf.call(nr,Qe,dt):Rr(nr,[Qe],dt,or,dr);throw new TypeError("val must be string, number or Buffer")}function Rr(nr,Qe,dt,or,dr){let br=1,Er=nr.length,Dr=Qe.length;if(or!==void 0&&(or=String(or).toLowerCase(),or==="ucs2"||or==="ucs-2"||or==="utf16le"||or==="utf-16le")){if(nr.length<2||Qe.length<2)return-1;br=2,Er/=2,Dr/=2,dt/=2}function Vr(jr,Hr){return br===1?jr[Hr]:jr.readUInt16BE(Hr*br)}let Kr;if(dr){let jr=-1;for(Kr=dt;Kr<Er;Kr++)if(Vr(nr,Kr)===Vr(Qe,jr===-1?0:Kr-jr)){if(jr===-1&&(jr=Kr),Kr-jr+1===Dr)return jr*br}else jr!==-1&&(Kr-=Kr-jr),jr=-1}else for(dt+Dr>Er&&(dt=Er-Dr),Kr=dt;Kr>=0;Kr--){let jr=!0;for(let Hr=0;Hr<Dr;Hr++)if(Vr(nr,Kr+Hr)!==Vr(Qe,Hr)){jr=!1;break}if(jr)return Kr}return-1}Je.prototype.includes=function(Qe,dt,or){return this.indexOf(Qe,dt,or)!==-1},Je.prototype.indexOf=function(Qe,dt,or){return Pr(this,Qe,dt,or,!0)},Je.prototype.lastIndexOf=function(Qe,dt,or){return Pr(this,Qe,dt,or,!1)};function Br(nr,Qe,dt,or){dt=Number(dt)||0;const dr=nr.length-dt;or?(or=Number(or),or>dr&&(or=dr)):or=dr;const br=Qe.length;or>br/2&&(or=br/2);let Er;for(Er=0;Er<or;++Er){const Dr=parseInt(Qe.substr(Er*2,2),16);if(Fn(Dr))return Er;nr[dt+Er]=Dr}return Er}function Mr(nr,Qe,dt,or){return Jr(Qr(Qe,nr.length-dt),nr,dt,or)}function Lr(nr,Qe,dt,or){return Jr(jn(Qe),nr,dt,or)}function $r(nr,Qe,dt,or){return Jr($n(Qe),nr,dt,or)}function Nr(nr,Qe,dt,or){return Jr(fi(Qe,nr.length-dt),nr,dt,or)}Je.prototype.write=function(Qe,dt,or,dr){if(dt===void 0)dr="utf8",or=this.length,dt=0;else if(or===void 0&&typeof dt=="string")dr=dt,or=this.length,dt=0;else if(isFinite(dt))dt=dt>>>0,isFinite(or)?(or=or>>>0,dr===void 0&&(dr="utf8")):(dr=or,or=void 0);else throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");const br=this.length-dt;if((or===void 0||or>br)&&(or=br),Qe.length>0&&(or<0||dt<0)||dt>this.length)throw new RangeError("Attempt to write outside buffer bounds");dr||(dr="utf8");let Er=!1;for(;;)switch(dr){case"hex":return Br(this,Qe,dt,or);case"utf8":case"utf-8":return Mr(this,Qe,dt,or);case"ascii":case"latin1":case"binary":return Lr(this,Qe,dt,or);case"base64":return $r(this,Qe,dt,or);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return Nr(this,Qe,dt,or);default:if(Er)throw new TypeError("Unknown encoding: "+dr);dr=(""+dr).toLowerCase(),Er=!0}},Je.prototype.toJSON=function(){return{type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}};function cr(nr,Qe,dt){return Qe===0&&dt===nr.length?Re.fromByteArray(nr):Re.fromByteArray(nr.slice(Qe,dt))}function Dt(nr,Qe,dt){dt=Math.min(nr.length,dt);const or=[];let dr=Qe;for(;dr<dt;){const br=nr[dr];let Er=null,Dr=br>239?4:br>223?3:br>191?2:1;if(dr+Dr<=dt){let Vr,Kr,jr,Hr;switch(Dr){case 1:br<128&&(Er=br);break;case 2:Vr=nr[dr+1],(Vr&192)===128&&(Hr=(br&31)<<6|Vr&63,Hr>127&&(Er=Hr));break;case 3:Vr=nr[dr+1],Kr=nr[dr+2],(Vr&192)===128&&(Kr&192)===128&&(Hr=(br&15)<<12|(Vr&63)<<6|Kr&63,Hr>2047&&(Hr<55296||Hr>57343)&&(Er=Hr));break;case 4:Vr=nr[dr+1],Kr=nr[dr+2],jr=nr[dr+3],(Vr&192)===128&&(Kr&192)===128&&(jr&192)===128&&(Hr=(br&15)<<18|(Vr&63)<<12|(Kr&63)<<6|jr&63,Hr>65535&&Hr<1114112&&(Er=Hr))}}Er===null?(Er=65533,Dr=1):Er>65535&&(Er-=65536,or.push(Er>>>10&1023|55296),Er=56320|Er&1023),or.push(Er),dr+=Dr}return lr(or)}const sr=4096;function lr(nr){const Qe=nr.length;if(Qe<=sr)return String.fromCharCode.apply(String,nr);let dt="",or=0;for(;or<Qe;)dt+=String.fromCharCode.apply(String,nr.slice(or,or+=sr));return dt}function gr(nr,Qe,dt){let or="";dt=Math.min(nr.length,dt);for(let dr=Qe;dr<dt;++dr)or+=String.fromCharCode(nr[dr]&127);return or}function _r(nr,Qe,dt){let or="";dt=Math.min(nr.length,dt);for(let dr=Qe;dr<dt;++dr)or+=String.fromCharCode(nr[dr]);return or}function xr(nr,Qe,dt){const or=nr.length;(!Qe||Qe<0)&&(Qe=0),(!dt||dt<0||dt>or)&&(dt=or);let dr="";for(let br=Qe;br<dt;++br)dr+=Kn[nr[br]];return dr}function kr(nr,Qe,dt){const or=nr.slice(Qe,dt);let dr="";for(let br=0;br<or.length-1;br+=2)dr+=String.fromCharCode(or[br]+or[br+1]*256);return dr}Je.prototype.slice=function(Qe,dt){const or=this.length;Qe=~~Qe,dt=dt===void 0?or:~~dt,Qe<0?(Qe+=or,Qe<0&&(Qe=0)):Qe>or&&(Qe=or),dt<0?(dt+=or,dt<0&&(dt=0)):dt>or&&(dt=or),dt<Qe&&(dt=Qe);const dr=this.subarray(Qe,dt);return Object.setPrototypeOf(dr,Je.prototype),dr};function pr(nr,Qe,dt){if(nr%1!==0||nr<0)throw new RangeError("offset is not uint");if(nr+Qe>dt)throw new RangeError("Trying to access beyond buffer length")}Je.prototype.readUintLE=Je.prototype.readUIntLE=function(Qe,dt,or){Qe=Qe>>>0,dt=dt>>>0,or||pr(Qe,dt,this.length);let dr=this[Qe],br=1,Er=0;for(;++Er<dt&&(br*=256);)dr+=this[Qe+Er]*br;return dr},Je.prototype.readUintBE=Je.prototype.readUIntBE=function(Qe,dt,or){Qe=Qe>>>0,dt=dt>>>0,or||pr(Qe,dt,this.length);let dr=this[Qe+--dt],br=1;for(;dt>0&&(br*=256);)dr+=this[Qe+--dt]*br;return dr},Je.prototype.readUint8=Je.prototype.readUInt8=function(Qe,dt){return Qe=Qe>>>0,dt||pr(Qe,1,this.length),this[Qe]},Je.prototype.readUint16LE=Je.prototype.readUInt16LE=function(Qe,dt){return Qe=Qe>>>0,dt||pr(Qe,2,this.length),this[Qe]|this[Qe+1]<<8},Je.prototype.readUint16BE=Je.prototype.readUInt16BE=function(Qe,dt){return Qe=Qe>>>0,dt||pr(Qe,2,this.length),this[Qe]<<8|this[Qe+1]},Je.prototype.readUint32LE=Je.prototype.readUInt32LE=function(Qe,dt){return Qe=Qe>>>0,dt||pr(Qe,4,this.length),(this[Qe]|this[Qe+1]<<8|this[Qe+2]<<16)+this[Qe+3]*16777216},Je.prototype.readUint32BE=Je.prototype.readUInt32BE=function(Qe,dt){return Qe=Qe>>>0,dt||pr(Qe,4,this.length),this[Qe]*16777216+(this[Qe+1]<<16|this[Qe+2]<<8|this[Qe+3])},Je.prototype.readBigUInt64LE=qn(function(Qe){Qe=Qe>>>0,Hn(Qe,"offset");const dt=this[Qe],or=this[Qe+7];(dt===void 0||or===void 0)&&Xr(Qe,this.length-8);const dr=dt+this[++Qe]*2**8+this[++Qe]*2**16+this[++Qe]*2**24,br=this[++Qe]+this[++Qe]*2**8+this[++Qe]*2**16+or*2**24;return BigInt(dr)+(BigInt(br)<<BigInt(32))}),Je.prototype.readBigUInt64BE=qn(function(Qe){Qe=Qe>>>0,Hn(Qe,"offset");const dt=this[Qe],or=this[Qe+7];(dt===void 0||or===void 0)&&Xr(Qe,this.length-8);const dr=dt*2**24+this[++Qe]*2**16+this[++Qe]*2**8+this[++Qe],br=this[++Qe]*2**24+this[++Qe]*2**16+this[++Qe]*2**8+or;return(BigInt(dr)<<BigInt(32))+BigInt(br)}),Je.prototype.readIntLE=function(Qe,dt,or){Qe=Qe>>>0,dt=dt>>>0,or||pr(Qe,dt,this.length);let dr=this[Qe],br=1,Er=0;for(;++Er<dt&&(br*=256);)dr+=this[Qe+Er]*br;return br*=128,dr>=br&&(dr-=Math.pow(2,8*dt)),dr},Je.prototype.readIntBE=function(Qe,dt,or){Qe=Qe>>>0,dt=dt>>>0,or||pr(Qe,dt,this.length);let dr=dt,br=1,Er=this[Qe+--dr];for(;dr>0&&(br*=256);)Er+=this[Qe+--dr]*br;return br*=128,Er>=br&&(Er-=Math.pow(2,8*dt)),Er},Je.prototype.readInt8=function(Qe,dt){return Qe=Qe>>>0,dt||pr(Qe,1,this.length),this[Qe]&128?(255-this[Qe]+1)*-1:this[Qe]},Je.prototype.readInt16LE=function(Qe,dt){Qe=Qe>>>0,dt||pr(Qe,2,this.length);const or=this[Qe]|this[Qe+1]<<8;return or&32768?or|4294901760:or},Je.prototype.readInt16BE=function(Qe,dt){Qe=Qe>>>0,dt||pr(Qe,2,this.length);const or=this[Qe+1]|this[Qe]<<8;return or&32768?or|4294901760:or},Je.prototype.readInt32LE=function(Qe,dt){return Qe=Qe>>>0,dt||pr(Qe,4,this.length),this[Qe]|this[Qe+1]<<8|this[Qe+2]<<16|this[Qe+3]<<24},Je.prototype.readInt32BE=function(Qe,dt){return Qe=Qe>>>0,dt||pr(Qe,4,this.length),this[Qe]<<24|this[Qe+1]<<16|this[Qe+2]<<8|this[Qe+3]},Je.prototype.readBigInt64LE=qn(function(Qe){Qe=Qe>>>0,Hn(Qe,"offset");const dt=this[Qe],or=this[Qe+7];(dt===void 0||or===void 0)&&Xr(Qe,this.length-8);const dr=this[Qe+4]+this[Qe+5]*2**8+this[Qe+6]*2**16+(or<<24);return(BigInt(dr)<<BigInt(32))+BigInt(dt+this[++Qe]*2**8+this[++Qe]*2**16+this[++Qe]*2**24)}),Je.prototype.readBigInt64BE=qn(function(Qe){Qe=Qe>>>0,Hn(Qe,"offset");const dt=this[Qe],or=this[Qe+7];(dt===void 0||or===void 0)&&Xr(Qe,this.length-8);const dr=(dt<<24)+this[++Qe]*2**16+this[++Qe]*2**8+this[++Qe];return(BigInt(dr)<<BigInt(32))+BigInt(this[++Qe]*2**24+this[++Qe]*2**16+this[++Qe]*2**8+or)}),Je.prototype.readFloatLE=function(Qe,dt){return Qe=Qe>>>0,dt||pr(Qe,4,this.length),Fe.read(this,Qe,!0,23,4)},Je.prototype.readFloatBE=function(Qe,dt){return Qe=Qe>>>0,dt||pr(Qe,4,this.length),Fe.read(this,Qe,!1,23,4)},Je.prototype.readDoubleLE=function(Qe,dt){return Qe=Qe>>>0,dt||pr(Qe,8,this.length),Fe.read(this,Qe,!0,52,8)},Je.prototype.readDoubleBE=function(Qe,dt){return Qe=Qe>>>0,dt||pr(Qe,8,this.length),Fe.read(this,Qe,!1,52,8)};function rr(nr,Qe,dt,or,dr,br){if(!Je.isBuffer(nr))throw new TypeError('"buffer" argument must be a Buffer instance');if(Qe>dr||Qe<br)throw new RangeError('"value" argument is out of bounds');if(dt+or>nr.length)throw new RangeError("Index out of range")}Je.prototype.writeUintLE=Je.prototype.writeUIntLE=function(Qe,dt,or,dr){if(Qe=+Qe,dt=dt>>>0,or=or>>>0,!dr){const Dr=Math.pow(2,8*or)-1;rr(this,Qe,dt,or,Dr,0)}let br=1,Er=0;for(this[dt]=Qe&255;++Er<or&&(br*=256);)this[dt+Er]=Qe/br&255;return dt+or},Je.prototype.writeUintBE=Je.prototype.writeUIntBE=function(Qe,dt,or,dr){if(Qe=+Qe,dt=dt>>>0,or=or>>>0,!dr){const Dr=Math.pow(2,8*or)-1;rr(this,Qe,dt,or,Dr,0)}let br=or-1,Er=1;for(this[dt+br]=Qe&255;--br>=0&&(Er*=256);)this[dt+br]=Qe/Er&255;return dt+or},Je.prototype.writeUint8=Je.prototype.writeUInt8=function(Qe,dt,or){return Qe=+Qe,dt=dt>>>0,or||rr(this,Qe,dt,1,255,0),this[dt]=Qe&255,dt+1},Je.prototype.writeUint16LE=Je.prototype.writeUInt16LE=function(Qe,dt,or){return Qe=+Qe,dt=dt>>>0,or||rr(this,Qe,dt,2,65535,0),this[dt]=Qe&255,this[dt+1]=Qe>>>8,dt+2},Je.prototype.writeUint16BE=Je.prototype.writeUInt16BE=function(Qe,dt,or){return Qe=+Qe,dt=dt>>>0,or||rr(this,Qe,dt,2,65535,0),this[dt]=Qe>>>8,this[dt+1]=Qe&255,dt+2},Je.prototype.writeUint32LE=Je.prototype.writeUInt32LE=function(Qe,dt,or){return Qe=+Qe,dt=dt>>>0,or||rr(this,Qe,dt,4,4294967295,0),this[dt+3]=Qe>>>24,this[dt+2]=Qe>>>16,this[dt+1]=Qe>>>8,this[dt]=Qe&255,dt+4},Je.prototype.writeUint32BE=Je.prototype.writeUInt32BE=function(Qe,dt,or){return Qe=+Qe,dt=dt>>>0,or||rr(this,Qe,dt,4,4294967295,0),this[dt]=Qe>>>24,this[dt+1]=Qe>>>16,this[dt+2]=Qe>>>8,this[dt+3]=Qe&255,dt+4};function hr(nr,Qe,dt,or,dr){Gr(Qe,or,dr,nr,dt,7);let br=Number(Qe&BigInt(4294967295));nr[dt++]=br,br=br>>8,nr[dt++]=br,br=br>>8,nr[dt++]=br,br=br>>8,nr[dt++]=br;let Er=Number(Qe>>BigInt(32)&BigInt(4294967295));return nr[dt++]=Er,Er=Er>>8,nr[dt++]=Er,Er=Er>>8,nr[dt++]=Er,Er=Er>>8,nr[dt++]=Er,dt}function Cr(nr,Qe,dt,or,dr){Gr(Qe,or,dr,nr,dt,7);let br=Number(Qe&BigInt(4294967295));nr[dt+7]=br,br=br>>8,nr[dt+6]=br,br=br>>8,nr[dt+5]=br,br=br>>8,nr[dt+4]=br;let Er=Number(Qe>>BigInt(32)&BigInt(4294967295));return nr[dt+3]=Er,Er=Er>>8,nr[dt+2]=Er,Er=Er>>8,nr[dt+1]=Er,Er=Er>>8,nr[dt]=Er,dt+8}Je.prototype.writeBigUInt64LE=qn(function(Qe,dt=0){return hr(this,Qe,dt,BigInt(0),BigInt("0xffffffffffffffff"))}),Je.prototype.writeBigUInt64BE=qn(function(Qe,dt=0){return Cr(this,Qe,dt,BigInt(0),BigInt("0xffffffffffffffff"))}),Je.prototype.writeIntLE=function(Qe,dt,or,dr){if(Qe=+Qe,dt=dt>>>0,!dr){const Vr=Math.pow(2,8*or-1);rr(this,Qe,dt,or,Vr-1,-Vr)}let br=0,Er=1,Dr=0;for(this[dt]=Qe&255;++br<or&&(Er*=256);)Qe<0&&Dr===0&&this[dt+br-1]!==0&&(Dr=1),this[dt+br]=(Qe/Er>>0)-Dr&255;return dt+or},Je.prototype.writeIntBE=function(Qe,dt,or,dr){if(Qe=+Qe,dt=dt>>>0,!dr){const Vr=Math.pow(2,8*or-1);rr(this,Qe,dt,or,Vr-1,-Vr)}let br=or-1,Er=1,Dr=0;for(this[dt+br]=Qe&255;--br>=0&&(Er*=256);)Qe<0&&Dr===0&&this[dt+br+1]!==0&&(Dr=1),this[dt+br]=(Qe/Er>>0)-Dr&255;return dt+or},Je.prototype.writeInt8=function(Qe,dt,or){return Qe=+Qe,dt=dt>>>0,or||rr(this,Qe,dt,1,127,-128),Qe<0&&(Qe=255+Qe+1),this[dt]=Qe&255,dt+1},Je.prototype.writeInt16LE=function(Qe,dt,or){return Qe=+Qe,dt=dt>>>0,or||rr(this,Qe,dt,2,32767,-32768),this[dt]=Qe&255,this[dt+1]=Qe>>>8,dt+2},Je.prototype.writeInt16BE=function(Qe,dt,or){return Qe=+Qe,dt=dt>>>0,or||rr(this,Qe,dt,2,32767,-32768),this[dt]=Qe>>>8,this[dt+1]=Qe&255,dt+2},Je.prototype.writeInt32LE=function(Qe,dt,or){return Qe=+Qe,dt=dt>>>0,or||rr(this,Qe,dt,4,2147483647,-2147483648),this[dt]=Qe&255,this[dt+1]=Qe>>>8,this[dt+2]=Qe>>>16,this[dt+3]=Qe>>>24,dt+4},Je.prototype.writeInt32BE=function(Qe,dt,or){return Qe=+Qe,dt=dt>>>0,or||rr(this,Qe,dt,4,2147483647,-2147483648),Qe<0&&(Qe=4294967295+Qe+1),this[dt]=Qe>>>24,this[dt+1]=Qe>>>16,this[dt+2]=Qe>>>8,this[dt+3]=Qe&255,dt+4},Je.prototype.writeBigInt64LE=qn(function(Qe,dt=0){return hr(this,Qe,dt,-BigInt("0x8000000000000000"),BigInt("0x7fffffffffffffff"))}),Je.prototype.writeBigInt64BE=qn(function(Qe,dt=0){return Cr(this,Qe,dt,-BigInt("0x8000000000000000"),BigInt("0x7fffffffffffffff"))});function Or(nr,Qe,dt,or,dr,br){if(dt+or>nr.length)throw new RangeError("Index out of range");if(dt<0)throw new RangeError("Index out of range")}function Ur(nr,Qe,dt,or,dr){return Qe=+Qe,dt=dt>>>0,dr||Or(nr,Qe,dt,4),Fe.write(nr,Qe,dt,or,23,4),dt+4}Je.prototype.writeFloatLE=function(Qe,dt,or){return Ur(this,Qe,dt,!0,or)},Je.prototype.writeFloatBE=function(Qe,dt,or){return Ur(this,Qe,dt,!1,or)};function qr(nr,Qe,dt,or,dr){return Qe=+Qe,dt=dt>>>0,dr||Or(nr,Qe,dt,8),Fe.write(nr,Qe,dt,or,52,8),dt+8}Je.prototype.writeDoubleLE=function(Qe,dt,or){return qr(this,Qe,dt,!0,or)},Je.prototype.writeDoubleBE=function(Qe,dt,or){return qr(this,Qe,dt,!1,or)},Je.prototype.copy=function(Qe,dt,or,dr){if(!Je.isBuffer(Qe))throw new TypeError("argument should be a Buffer");if(or||(or=0),!dr&&dr!==0&&(dr=this.length),dt>=Qe.length&&(dt=Qe.length),dt||(dt=0),dr>0&&dr<or&&(dr=or),dr===or||Qe.length===0||this.length===0)return 0;if(dt<0)throw new RangeError("targetStart out of bounds");if(or<0||or>=this.length)throw new RangeError("Index out of range");if(dr<0)throw new RangeError("sourceEnd out of bounds");dr>this.length&&(dr=this.length),Qe.length-dt<dr-or&&(dr=Qe.length-dt+or);const br=dr-or;return this===Qe&&typeof Uint8Array.prototype.copyWithin=="function"?this.copyWithin(dt,or,dr):Uint8Array.prototype.set.call(Qe,this.subarray(or,dr),dt),br},Je.prototype.fill=function(Qe,dt,or,dr){if(typeof Qe=="string"){if(typeof dt=="string"?(dr=dt,dt=0,or=this.length):typeof or=="string"&&(dr=or,or=this.length),dr!==void 0&&typeof dr!="string")throw new TypeError("encoding must be a string");if(typeof dr=="string"&&!Je.isEncoding(dr))throw new TypeError("Unknown encoding: "+dr);if(Qe.length===1){const Er=Qe.charCodeAt(0);(dr==="utf8"&&Er<128||dr==="latin1")&&(Qe=Er)}}else typeof Qe=="number"?Qe=Qe&255:typeof Qe=="boolean"&&(Qe=Number(Qe));if(dt<0||this.length<dt||this.length<or)throw new RangeError("Out of range index");if(or<=dt)return this;dt=dt>>>0,or=or===void 0?this.length:or>>>0,Qe||(Qe=0);let br;if(typeof Qe=="number")for(br=dt;br<or;++br)this[br]=Qe;else{const Er=Je.isBuffer(Qe)?Qe:Je.from(Qe,dr),Dr=Er.length;if(Dr===0)throw new TypeError('The value "'+Qe+'" is invalid for argument "value"');for(br=0;br<or-dt;++br)this[br+dt]=Er[br%Dr]}return this};const Fr={};function zr(nr,Qe,dt){Fr[nr]=class extends dt{constructor(){super(),Object.defineProperty(this,"message",{value:Qe.apply(this,arguments),writable:!0,configurable:!0}),this.name=`${this.name} [${nr}]`,this.stack,delete this.name}get code(){return nr}set code(dr){Object.defineProperty(this,"code",{configurable:!0,enumerable:!0,value:dr,writable:!0})}toString(){return`${this.name} [${nr}]: ${this.message}`}}}zr("ERR_BUFFER_OUT_OF_BOUNDS",function(nr){return nr?`${nr} is outside of buffer bounds`:"Attempt to access memory outside buffer bounds"},RangeError),zr("ERR_INVALID_ARG_TYPE",function(nr,Qe){return`The "${nr}" argument must be of type number. Received type ${typeof Qe}`},TypeError),zr("ERR_OUT_OF_RANGE",function(nr,Qe,dt){let or=`The value of "${nr}" is out of range.`,dr=dt;return Number.isInteger(dt)&&Math.abs(dt)>2**32?dr=Yr(String(dt)):typeof dt=="bigint"&&(dr=String(dt),(dt>BigInt(2)**BigInt(32)||dt<-(BigInt(2)**BigInt(32)))&&(dr=Yr(dr)),dr+="n"),or+=` It must be ${Qe}. Received ${dr}`,or},RangeError);function Yr(nr){let Qe="",dt=nr.length;const or=nr[0]==="-"?1:0;for(;dt>=or+4;dt-=3)Qe=`_${nr.slice(dt-3,dt)}${Qe}`;return`${nr.slice(0,dt)}${Qe}`}function Wr(nr,Qe,dt){Hn(Qe,"offset"),(nr[Qe]===void 0||nr[Qe+dt]===void 0)&&Xr(Qe,nr.length-(dt+1))}function Gr(nr,Qe,dt,or,dr,br){if(nr>dt||nr<Qe){const Er=typeof Qe=="bigint"?"n":"";let Dr;throw br>3?Qe===0||Qe===BigInt(0)?Dr=`>= 0${Er} and < 2${Er} ** ${(br+1)*8}${Er}`:Dr=`>= -(2${Er} ** ${(br+1)*8-1}${Er}) and < 2 ** ${(br+1)*8-1}${Er}`:Dr=`>= ${Qe}${Er} and <= ${dt}${Er}`,new Fr.ERR_OUT_OF_RANGE("value",Dr,nr)}Wr(or,dr,br)}function Hn(nr,Qe){if(typeof nr!="number")throw new Fr.ERR_INVALID_ARG_TYPE(Qe,"number",nr)}function Xr(nr,Qe,dt){throw Math.floor(nr)!==nr?(Hn(nr,dt),new Fr.ERR_OUT_OF_RANGE(dt||"offset","an integer",nr)):Qe<0?new Fr.ERR_BUFFER_OUT_OF_BOUNDS:new Fr.ERR_OUT_OF_RANGE(dt||"offset",`>= ${dt?1:0} and <= ${Qe}`,nr)}const Zr=/[^+/0-9A-Za-z-_]/g;function Wn(nr){if(nr=nr.split("=")[0],nr=nr.trim().replace(Zr,""),nr.length<2)return"";for(;nr.length%4!==0;)nr=nr+"=";return nr}function Qr(nr,Qe){Qe=Qe||1/0;let dt;const or=nr.length;let dr=null;const br=[];for(let Er=0;Er<or;++Er){if(dt=nr.charCodeAt(Er),dt>55295&&dt<57344){if(!dr){if(dt>56319){(Qe-=3)>-1&&br.push(239,191,189);continue}else if(Er+1===or){(Qe-=3)>-1&&br.push(239,191,189);continue}dr=dt;continue}if(dt<56320){(Qe-=3)>-1&&br.push(239,191,189),dr=dt;continue}dt=(dr-55296<<10|dt-56320)+65536}else dr&&(Qe-=3)>-1&&br.push(239,191,189);if(dr=null,dt<128){if((Qe-=1)<0)break;br.push(dt)}else if(dt<2048){if((Qe-=2)<0)break;br.push(dt>>6|192,dt&63|128)}else if(dt<65536){if((Qe-=3)<0)break;br.push(dt>>12|224,dt>>6&63|128,dt&63|128)}else if(dt<1114112){if((Qe-=4)<0)break;br.push(dt>>18|240,dt>>12&63|128,dt>>6&63|128,dt&63|128)}else throw new Error("Invalid code point")}return br}function jn(nr){const Qe=[];for(let dt=0;dt<nr.length;++dt)Qe.push(nr.charCodeAt(dt)&255);return Qe}function fi(nr,Qe){let dt,or,dr;const br=[];for(let Er=0;Er<nr.length&&!((Qe-=2)<0);++Er)dt=nr.charCodeAt(Er),or=dt>>8,dr=dt%256,br.push(dr),br.push(or);return br}function $n(nr){return Re.toByteArray(Wn(nr))}function Jr(nr,Qe,dt,or){let dr;for(dr=0;dr<or&&!(dr+dt>=Qe.length||dr>=nr.length);++dr)Qe[dr+dt]=nr[dr];return dr}function Cn(nr,Qe){return nr instanceof Qe||nr!=null&&nr.constructor!=null&&nr.constructor.name!=null&&nr.constructor.name===Qe.name}function Fn(nr){return nr!==nr}const Kn=function(){const nr="0123456789abcdef",Qe=new Array(256);for(let dt=0;dt<16;++dt){const or=dt*16;for(let dr=0;dr<16;++dr)Qe[or+dr]=nr[dt]+nr[dr]}return Qe}();function qn(nr){return typeof BigInt>"u"?Un:nr}function Un(){throw new Error("BigInt not supported")}})(buffer);function number$1(Ke){if(!Number.isSafeInteger(Ke)||Ke<0)throw new Error(`Wrong positive integer: ${Ke}`)}function bool(Ke){if(typeof Ke!="boolean")throw new Error(`Expected boolean, not ${Ke}`)}function bytes(Ke,...Re){if(!(Ke instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(Re.length>0&&!Re.includes(Ke.length))throw new TypeError(`Expected Uint8Array of length ${Re}, not of length=${Ke.length}`)}function hash(Ke){if(typeof Ke!="function"||typeof Ke.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");number$1(Ke.outputLen),number$1(Ke.blockLen)}function exists(Ke,Re=!0){if(Ke.destroyed)throw new Error("Hash instance has been destroyed");if(Re&&Ke.finished)throw new Error("Hash#digest() has already been called")}function output(Ke,Re){bytes(Ke);const Fe=Re.outputLen;if(Ke.length<Fe)throw new Error(`digestInto() expects output buffer of length at least ${Fe}`)}const assert$2={number:number$1,bool,bytes,hash,exists,output};/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */const u32$1=Ke=>new Uint32Array(Ke.buffer,Ke.byteOffset,Math.floor(Ke.byteLength/4)),createView=Ke=>new DataView(Ke.buffer,Ke.byteOffset,Ke.byteLength),rotr=(Ke,Re)=>Ke<<32-Re|Ke>>>Re,isLE=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;if(!isLE)throw new Error("Non little-endian hardware is not supported");Array.from({length:256},(Ke,Re)=>Re.toString(16).padStart(2,"0"));function utf8ToBytes(Ke){if(typeof Ke!="string")throw new TypeError(`utf8ToBytes expected string, got ${typeof Ke}`);return new TextEncoder().encode(Ke)}function toBytes(Ke){if(typeof Ke=="string"&&(Ke=utf8ToBytes(Ke)),!(Ke instanceof Uint8Array))throw new TypeError(`Expected input type is Uint8Array (got ${typeof Ke})`);return Ke}class Hash{clone(){return this._cloneInto()}}function wrapConstructor(Ke){const Re=qe=>Ke().update(toBytes(qe)).digest(),Fe=Ke();return Re.outputLen=Fe.outputLen,Re.blockLen=Fe.blockLen,Re.create=()=>Ke(),Re}function wrapConstructorWithOpts(Ke){const Re=(qe,We)=>Ke(We).update(toBytes(qe)).digest(),Fe=Ke({});return Re.outputLen=Fe.outputLen,Re.blockLen=Fe.blockLen,Re.create=qe=>Ke(qe),Re}function setBigUint64(Ke,Re,Fe,qe){if(typeof Ke.setBigUint64=="function")return Ke.setBigUint64(Re,Fe,qe);const We=BigInt(32),Ze=BigInt(4294967295),Xe=Number(Fe>>We&Ze),Je=Number(Fe&Ze),tr=qe?4:0,er=qe?0:4;Ke.setUint32(Re+tr,Xe,qe),Ke.setUint32(Re+er,Je,qe)}class SHA2 extends Hash{constructor(Re,Fe,qe,We){super(),this.blockLen=Re,this.outputLen=Fe,this.padOffset=qe,this.isLE=We,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(Re),this.view=createView(this.buffer)}update(Re){assert$2.exists(this);const{view:Fe,buffer:qe,blockLen:We}=this;Re=toBytes(Re);const Ze=Re.length;for(let Xe=0;Xe<Ze;){const Je=Math.min(We-this.pos,Ze-Xe);if(Je===We){const tr=createView(Re);for(;We<=Ze-Xe;Xe+=We)this.process(tr,Xe);continue}qe.set(Re.subarray(Xe,Xe+Je),this.pos),this.pos+=Je,Xe+=Je,this.pos===We&&(this.process(Fe,0),this.pos=0)}return this.length+=Re.length,this.roundClean(),this}digestInto(Re){assert$2.exists(this),assert$2.output(Re,this),this.finished=!0;const{buffer:Fe,view:qe,blockLen:We,isLE:Ze}=this;let{pos:Xe}=this;Fe[Xe++]=128,this.buffer.subarray(Xe).fill(0),this.padOffset>We-Xe&&(this.process(qe,0),Xe=0);for(let tr=Xe;tr<We;tr++)Fe[tr]=0;setBigUint64(qe,We-8,BigInt(this.length*8),Ze),this.process(qe,0);const Je=createView(Re);this.get().forEach((tr,er)=>Je.setUint32(4*er,tr,Ze))}digest(){const{buffer:Re,outputLen:Fe}=this;this.digestInto(Re);const qe=Re.slice(0,Fe);return this.destroy(),qe}_cloneInto(Re){Re||(Re=new this.constructor),Re.set(...this.get());const{blockLen:Fe,buffer:qe,length:We,finished:Ze,destroyed:Xe,pos:Je}=this;return Re.length=We,Re.pos=Je,Re.finished=Ze,Re.destroyed=Xe,We%Fe&&Re.buffer.set(qe),Re}}const U32_MASK64=BigInt(2**32-1),_32n=BigInt(32);function fromBig(Ke,Re=!1){return Re?{h:Number(Ke&U32_MASK64),l:Number(Ke>>_32n&U32_MASK64)}:{h:Number(Ke>>_32n&U32_MASK64)|0,l:Number(Ke&U32_MASK64)|0}}function split(Ke,Re=!1){let Fe=new Uint32Array(Ke.length),qe=new Uint32Array(Ke.length);for(let We=0;We<Ke.length;We++){const{h:Ze,l:Xe}=fromBig(Ke[We],Re);[Fe[We],qe[We]]=[Ze,Xe]}return[Fe,qe]}const toBig=(Ke,Re)=>BigInt(Ke>>>0)<<_32n|BigInt(Re>>>0),shrSH=(Ke,Re,Fe)=>Ke>>>Fe,shrSL=(Ke,Re,Fe)=>Ke<<32-Fe|Re>>>Fe,rotrSH=(Ke,Re,Fe)=>Ke>>>Fe|Re<<32-Fe,rotrSL=(Ke,Re,Fe)=>Ke<<32-Fe|Re>>>Fe,rotrBH=(Ke,Re,Fe)=>Ke<<64-Fe|Re>>>Fe-32,rotrBL=(Ke,Re,Fe)=>Ke>>>Fe-32|Re<<64-Fe,rotr32H=(Ke,Re)=>Re,rotr32L=(Ke,Re)=>Ke,rotlSH=(Ke,Re,Fe)=>Ke<<Fe|Re>>>32-Fe,rotlSL=(Ke,Re,Fe)=>Re<<Fe|Ke>>>32-Fe,rotlBH=(Ke,Re,Fe)=>Re<<Fe-32|Ke>>>64-Fe,rotlBL=(Ke,Re,Fe)=>Ke<<Fe-32|Re>>>64-Fe;function add(Ke,Re,Fe,qe){const We=(Re>>>0)+(qe>>>0);return{h:Ke+Fe+(We/2**32|0)|0,l:We|0}}const add3L=(Ke,Re,Fe)=>(Ke>>>0)+(Re>>>0)+(Fe>>>0),add3H=(Ke,Re,Fe,qe)=>Re+Fe+qe+(Ke/2**32|0)|0,add4L=(Ke,Re,Fe,qe)=>(Ke>>>0)+(Re>>>0)+(Fe>>>0)+(qe>>>0),add4H=(Ke,Re,Fe,qe,We)=>Re+Fe+qe+We+(Ke/2**32|0)|0,add5L=(Ke,Re,Fe,qe,We)=>(Ke>>>0)+(Re>>>0)+(Fe>>>0)+(qe>>>0)+(We>>>0),add5H=(Ke,Re,Fe,qe,We,Ze)=>Re+Fe+qe+We+Ze+(Ke/2**32|0)|0,u64$1={fromBig,split,toBig,shrSH,shrSL,rotrSH,rotrSL,rotrBH,rotrBL,rotr32H,rotr32L,rotlSH,rotlSL,rotlBH,rotlBL,add,add3L,add3H,add4L,add4H,add5H,add5L},[SHA512_Kh,SHA512_Kl]=u64$1.split(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(Ke=>BigInt(Ke))),SHA512_W_H=new Uint32Array(80),SHA512_W_L=new Uint32Array(80);class SHA512 extends SHA2{constructor(){super(128,64,16,!1),this.Ah=1779033703,this.Al=-205731576,this.Bh=-1150833019,this.Bl=-2067093701,this.Ch=1013904242,this.Cl=-23791573,this.Dh=-1521486534,this.Dl=1595750129,this.Eh=1359893119,this.El=-1377402159,this.Fh=-1694144372,this.Fl=725511199,this.Gh=528734635,this.Gl=-79577749,this.Hh=1541459225,this.Hl=327033209}get(){const{Ah:Re,Al:Fe,Bh:qe,Bl:We,Ch:Ze,Cl:Xe,Dh:Je,Dl:tr,Eh:er,El:ir,Fh:ur,Fl:fr,Gh:ar,Gl:yr,Hh:mr,Hl:wr}=this;return[Re,Fe,qe,We,Ze,Xe,Je,tr,er,ir,ur,fr,ar,yr,mr,wr]}set(Re,Fe,qe,We,Ze,Xe,Je,tr,er,ir,ur,fr,ar,yr,mr,wr){this.Ah=Re|0,this.Al=Fe|0,this.Bh=qe|0,this.Bl=We|0,this.Ch=Ze|0,this.Cl=Xe|0,this.Dh=Je|0,this.Dl=tr|0,this.Eh=er|0,this.El=ir|0,this.Fh=ur|0,this.Fl=fr|0,this.Gh=ar|0,this.Gl=yr|0,this.Hh=mr|0,this.Hl=wr|0}process(Re,Fe){for(let vr=0;vr<16;vr++,Fe+=4)SHA512_W_H[vr]=Re.getUint32(Fe),SHA512_W_L[vr]=Re.getUint32(Fe+=4);for(let vr=16;vr<80;vr++){const Ir=SHA512_W_H[vr-15]|0,Tr=SHA512_W_L[vr-15]|0,Pr=u64$1.rotrSH(Ir,Tr,1)^u64$1.rotrSH(Ir,Tr,8)^u64$1.shrSH(Ir,Tr,7),Rr=u64$1.rotrSL(Ir,Tr,1)^u64$1.rotrSL(Ir,Tr,8)^u64$1.shrSL(Ir,Tr,7),Br=SHA512_W_H[vr-2]|0,Mr=SHA512_W_L[vr-2]|0,Lr=u64$1.rotrSH(Br,Mr,19)^u64$1.rotrBH(Br,Mr,61)^u64$1.shrSH(Br,Mr,6),$r=u64$1.rotrSL(Br,Mr,19)^u64$1.rotrBL(Br,Mr,61)^u64$1.shrSL(Br,Mr,6),Nr=u64$1.add4L(Rr,$r,SHA512_W_L[vr-7],SHA512_W_L[vr-16]),cr=u64$1.add4H(Nr,Pr,Lr,SHA512_W_H[vr-7],SHA512_W_H[vr-16]);SHA512_W_H[vr]=cr|0,SHA512_W_L[vr]=Nr|0}let{Ah:qe,Al:We,Bh:Ze,Bl:Xe,Ch:Je,Cl:tr,Dh:er,Dl:ir,Eh:ur,El:fr,Fh:ar,Fl:yr,Gh:mr,Gl:wr,Hh:Sr,Hl:Ar}=this;for(let vr=0;vr<80;vr++){const Ir=u64$1.rotrSH(ur,fr,14)^u64$1.rotrSH(ur,fr,18)^u64$1.rotrBH(ur,fr,41),Tr=u64$1.rotrSL(ur,fr,14)^u64$1.rotrSL(ur,fr,18)^u64$1.rotrBL(ur,fr,41),Pr=ur&ar^~ur&mr,Rr=fr&yr^~fr&wr,Br=u64$1.add5L(Ar,Tr,Rr,SHA512_Kl[vr],SHA512_W_L[vr]),Mr=u64$1.add5H(Br,Sr,Ir,Pr,SHA512_Kh[vr],SHA512_W_H[vr]),Lr=Br|0,$r=u64$1.rotrSH(qe,We,28)^u64$1.rotrBH(qe,We,34)^u64$1.rotrBH(qe,We,39),Nr=u64$1.rotrSL(qe,We,28)^u64$1.rotrBL(qe,We,34)^u64$1.rotrBL(qe,We,39),cr=qe&Ze^qe&Je^Ze&Je,Dt=We&Xe^We&tr^Xe&tr;Sr=mr|0,Ar=wr|0,mr=ar|0,wr=yr|0,ar=ur|0,yr=fr|0,{h:ur,l:fr}=u64$1.add(er|0,ir|0,Mr|0,Lr|0),er=Je|0,ir=tr|0,Je=Ze|0,tr=Xe|0,Ze=qe|0,Xe=We|0;const sr=u64$1.add3L(Lr,Nr,Dt);qe=u64$1.add3H(sr,Mr,$r,cr),We=sr|0}({h:qe,l:We}=u64$1.add(this.Ah|0,this.Al|0,qe|0,We|0)),{h:Ze,l:Xe}=u64$1.add(this.Bh|0,this.Bl|0,Ze|0,Xe|0),{h:Je,l:tr}=u64$1.add(this.Ch|0,this.Cl|0,Je|0,tr|0),{h:er,l:ir}=u64$1.add(this.Dh|0,this.Dl|0,er|0,ir|0),{h:ur,l:fr}=u64$1.add(this.Eh|0,this.El|0,ur|0,fr|0),{h:ar,l:yr}=u64$1.add(this.Fh|0,this.Fl|0,ar|0,yr|0),{h:mr,l:wr}=u64$1.add(this.Gh|0,this.Gl|0,mr|0,wr|0),{h:Sr,l:Ar}=u64$1.add(this.Hh|0,this.Hl|0,Sr|0,Ar|0),this.set(qe,We,Ze,Xe,Je,tr,er,ir,ur,fr,ar,yr,mr,wr,Sr,Ar)}roundClean(){SHA512_W_H.fill(0),SHA512_W_L.fill(0)}destroy(){this.buffer.fill(0),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}class SHA512_256 extends SHA512{constructor(){super(),this.Ah=573645204,this.Al=-64227540,this.Bh=-1621794909,this.Bl=-934517566,this.Ch=596883563,this.Cl=1867755857,this.Dh=-1774684391,this.Dl=1497426621,this.Eh=-1775747358,this.El=-1467023389,this.Fh=-1101128155,this.Fl=1401305490,this.Gh=721525244,this.Gl=746961066,this.Hh=246885852,this.Hl=-2117784414,this.outputLen=32}}class SHA384 extends SHA512{constructor(){super(),this.Ah=-876896931,this.Al=-1056596264,this.Bh=1654270250,this.Bl=914150663,this.Ch=-1856437926,this.Cl=812702999,this.Dh=355462360,this.Dl=-150054599,this.Eh=1731405415,this.El=-4191439,this.Fh=-1900787065,this.Fl=1750603025,this.Gh=-619958771,this.Gl=1694076839,this.Hh=1203062813,this.Hl=-1090891868,this.outputLen=48}}const sha512=wrapConstructor(()=>new SHA512);wrapConstructor(()=>new SHA512_256);wrapConstructor(()=>new SHA384);const __viteBrowserExternal={},nodeCrypto=Object.freeze(Object.defineProperty({__proto__:null,default:__viteBrowserExternal},Symbol.toStringTag,{value:"Module"}));/*! noble-ed25519 - MIT License (c) 2019 Paul Miller (paulmillr.com) */const _0n$2=BigInt(0),_1n$2=BigInt(1),_2n$2=BigInt(2),CU_O=BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),CURVE$1=Object.freeze({a:BigInt(-1),d:BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),P:BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949"),l:CU_O,n:CU_O,h:BigInt(8),Gx:BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),Gy:BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960")}),POW_2_256$1=BigInt("0x10000000000000000000000000000000000000000000000000000000000000000"),SQRT_M1=BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");BigInt("6853475219497561581579357271197624642482790079785650197046958215289687604742");const SQRT_AD_MINUS_ONE=BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235"),INVSQRT_A_MINUS_D=BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578"),ONE_MINUS_D_SQ=BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838"),D_MINUS_ONE_SQ=BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952");class ExtendedPoint{constructor(Re,Fe,qe,We){this.x=Re,this.y=Fe,this.z=qe,this.t=We}static fromAffine(Re){if(!(Re instanceof Point$1))throw new TypeError("ExtendedPoint#fromAffine: expected Point");return Re.equals(Point$1.ZERO)?ExtendedPoint.ZERO:new ExtendedPoint(Re.x,Re.y,_1n$2,mod$1(Re.x*Re.y))}static toAffineBatch(Re){const Fe=invertBatch$1(Re.map(qe=>qe.z));return Re.map((qe,We)=>qe.toAffine(Fe[We]))}static normalizeZ(Re){return this.toAffineBatch(Re).map(this.fromAffine)}equals(Re){assertExtPoint(Re);const{x:Fe,y:qe,z:We}=this,{x:Ze,y:Xe,z:Je}=Re,tr=mod$1(Fe*Je),er=mod$1(Ze*We),ir=mod$1(qe*Je),ur=mod$1(Xe*We);return tr===er&&ir===ur}negate(){return new ExtendedPoint(mod$1(-this.x),this.y,this.z,mod$1(-this.t))}double(){const{x:Re,y:Fe,z:qe}=this,{a:We}=CURVE$1,Ze=mod$1(Re*Re),Xe=mod$1(Fe*Fe),Je=mod$1(_2n$2*mod$1(qe*qe)),tr=mod$1(We*Ze),er=Re+Fe,ir=mod$1(mod$1(er*er)-Ze-Xe),ur=tr+Xe,fr=ur-Je,ar=tr-Xe,yr=mod$1(ir*fr),mr=mod$1(ur*ar),wr=mod$1(ir*ar),Sr=mod$1(fr*ur);return new ExtendedPoint(yr,mr,Sr,wr)}add(Re){assertExtPoint(Re);const{x:Fe,y:qe,z:We,t:Ze}=this,{x:Xe,y:Je,z:tr,t:er}=Re,ir=mod$1((qe-Fe)*(Je+Xe)),ur=mod$1((qe+Fe)*(Je-Xe)),fr=mod$1(ur-ir);if(fr===_0n$2)return this.double();const ar=mod$1(We*_2n$2*er),yr=mod$1(Ze*_2n$2*tr),mr=yr+ar,wr=ur+ir,Sr=yr-ar,Ar=mod$1(mr*fr),vr=mod$1(wr*Sr),Ir=mod$1(mr*Sr),Tr=mod$1(fr*wr);return new ExtendedPoint(Ar,vr,Tr,Ir)}subtract(Re){return this.add(Re.negate())}precomputeWindow(Re){const Fe=1+256/Re,qe=[];let We=this,Ze=We;for(let Xe=0;Xe<Fe;Xe++){Ze=We,qe.push(Ze);for(let Je=1;Je<2**(Re-1);Je++)Ze=Ze.add(We),qe.push(Ze);We=Ze.double()}return qe}wNAF(Re,Fe){!Fe&&this.equals(ExtendedPoint.BASE)&&(Fe=Point$1.BASE);const qe=Fe&&Fe._WINDOW_SIZE||1;if(256%qe)throw new Error("Point#wNAF: Invalid precomputation window, must be power of 2");let We=Fe&&pointPrecomputes$1.get(Fe);We||(We=this.precomputeWindow(qe),Fe&&qe!==1&&(We=ExtendedPoint.normalizeZ(We),pointPrecomputes$1.set(Fe,We)));let Ze=ExtendedPoint.ZERO,Xe=ExtendedPoint.ZERO;const Je=1+256/qe,tr=2**(qe-1),er=BigInt(2**qe-1),ir=2**qe,ur=BigInt(qe);for(let fr=0;fr<Je;fr++){const ar=fr*tr;let yr=Number(Re&er);if(Re>>=ur,yr>tr&&(yr-=ir,Re+=_1n$2),yr===0){let mr=We[ar];fr%2&&(mr=mr.negate()),Xe=Xe.add(mr)}else{let mr=We[ar+Math.abs(yr)-1];yr<0&&(mr=mr.negate()),Ze=Ze.add(mr)}}return ExtendedPoint.normalizeZ([Ze,Xe])[0]}multiply(Re,Fe){return this.wNAF(normalizeScalar$1(Re,CURVE$1.l),Fe)}multiplyUnsafe(Re){let Fe=normalizeScalar$1(Re,CURVE$1.l,!1);const qe=ExtendedPoint.BASE,We=ExtendedPoint.ZERO;if(Fe===_0n$2)return We;if(this.equals(We)||Fe===_1n$2)return this;if(this.equals(qe))return this.wNAF(Fe);let Ze=We,Xe=this;for(;Fe>_0n$2;)Fe&_1n$2&&(Ze=Ze.add(Xe)),Xe=Xe.double(),Fe>>=_1n$2;return Ze}isSmallOrder(){return this.multiplyUnsafe(CURVE$1.h).equals(ExtendedPoint.ZERO)}isTorsionFree(){return this.multiplyUnsafe(CURVE$1.l).equals(ExtendedPoint.ZERO)}toAffine(Re=invert$1(this.z)){const{x:Fe,y:qe,z:We}=this,Ze=mod$1(Fe*Re),Xe=mod$1(qe*Re);if(mod$1(We*Re)!==_1n$2)throw new Error("invZ was invalid");return new Point$1(Ze,Xe)}fromRistrettoBytes(){legacyRist()}toRistrettoBytes(){legacyRist()}fromRistrettoHash(){legacyRist()}}ExtendedPoint.BASE=new ExtendedPoint(CURVE$1.Gx,CURVE$1.Gy,_1n$2,mod$1(CURVE$1.Gx*CURVE$1.Gy));ExtendedPoint.ZERO=new ExtendedPoint(_0n$2,_1n$2,_1n$2,_0n$2);function assertExtPoint(Ke){if(!(Ke instanceof ExtendedPoint))throw new TypeError("ExtendedPoint expected")}function assertRstPoint(Ke){if(!(Ke instanceof RistrettoPoint))throw new TypeError("RistrettoPoint expected")}function legacyRist(){throw new Error("Legacy method: switch to RistrettoPoint")}class RistrettoPoint{constructor(Re){this.ep=Re}static calcElligatorRistrettoMap(Re){const{d:Fe}=CURVE$1,qe=mod$1(SQRT_M1*Re*Re),We=mod$1((qe+_1n$2)*ONE_MINUS_D_SQ);let Ze=BigInt(-1);const Xe=mod$1((Ze-Fe*qe)*mod$1(qe+Fe));let{isValid:Je,value:tr}=uvRatio(We,Xe),er=mod$1(tr*Re);edIsNegative(er)||(er=mod$1(-er)),Je||(tr=er),Je||(Ze=qe);const ir=mod$1(Ze*(qe-_1n$2)*D_MINUS_ONE_SQ-Xe),ur=tr*tr,fr=mod$1((tr+tr)*Xe),ar=mod$1(ir*SQRT_AD_MINUS_ONE),yr=mod$1(_1n$2-ur),mr=mod$1(_1n$2+ur);return new ExtendedPoint(mod$1(fr*mr),mod$1(yr*ar),mod$1(ar*mr),mod$1(fr*yr))}static hashToCurve(Re){Re=ensureBytes$1(Re,64);const Fe=bytes255ToNumberLE(Re.slice(0,32)),qe=this.calcElligatorRistrettoMap(Fe),We=bytes255ToNumberLE(Re.slice(32,64)),Ze=this.calcElligatorRistrettoMap(We);return new RistrettoPoint(qe.add(Ze))}static fromHex(Re){Re=ensureBytes$1(Re,32);const{a:Fe,d:qe}=CURVE$1,We="RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint",Ze=bytes255ToNumberLE(Re);if(!equalBytes(numberTo32BytesLE(Ze),Re)||edIsNegative(Ze))throw new Error(We);const Xe=mod$1(Ze*Ze),Je=mod$1(_1n$2+Fe*Xe),tr=mod$1(_1n$2-Fe*Xe),er=mod$1(Je*Je),ir=mod$1(tr*tr),ur=mod$1(Fe*qe*er-ir),{isValid:fr,value:ar}=invertSqrt(mod$1(ur*ir)),yr=mod$1(ar*tr),mr=mod$1(ar*yr*ur);let wr=mod$1((Ze+Ze)*yr);edIsNegative(wr)&&(wr=mod$1(-wr));const Sr=mod$1(Je*mr),Ar=mod$1(wr*Sr);if(!fr||edIsNegative(Ar)||Sr===_0n$2)throw new Error(We);return new RistrettoPoint(new ExtendedPoint(wr,Sr,_1n$2,Ar))}toRawBytes(){let{x:Re,y:Fe,z:qe,t:We}=this.ep;const Ze=mod$1(mod$1(qe+Fe)*mod$1(qe-Fe)),Xe=mod$1(Re*Fe),Je=mod$1(Xe*Xe),{value:tr}=invertSqrt(mod$1(Ze*Je)),er=mod$1(tr*Ze),ir=mod$1(tr*Xe),ur=mod$1(er*ir*We);let fr;if(edIsNegative(We*ur)){let yr=mod$1(Fe*SQRT_M1),mr=mod$1(Re*SQRT_M1);Re=yr,Fe=mr,fr=mod$1(er*INVSQRT_A_MINUS_D)}else fr=ir;edIsNegative(Re*ur)&&(Fe=mod$1(-Fe));let ar=mod$1((qe-Fe)*fr);return edIsNegative(ar)&&(ar=mod$1(-ar)),numberTo32BytesLE(ar)}toHex(){return bytesToHex$1(this.toRawBytes())}toString(){return this.toHex()}equals(Re){assertRstPoint(Re);const Fe=this.ep,qe=Re.ep,We=mod$1(Fe.x*qe.y)===mod$1(Fe.y*qe.x),Ze=mod$1(Fe.y*qe.y)===mod$1(Fe.x*qe.x);return We||Ze}add(Re){return assertRstPoint(Re),new RistrettoPoint(this.ep.add(Re.ep))}subtract(Re){return assertRstPoint(Re),new RistrettoPoint(this.ep.subtract(Re.ep))}multiply(Re){return new RistrettoPoint(this.ep.multiply(Re))}multiplyUnsafe(Re){return new RistrettoPoint(this.ep.multiplyUnsafe(Re))}}RistrettoPoint.BASE=new RistrettoPoint(ExtendedPoint.BASE);RistrettoPoint.ZERO=new RistrettoPoint(ExtendedPoint.ZERO);const pointPrecomputes$1=new WeakMap;class Point$1{constructor(Re,Fe){this.x=Re,this.y=Fe}_setWindowSize(Re){this._WINDOW_SIZE=Re,pointPrecomputes$1.delete(this)}static fromHex(Re,Fe=!0){const{d:qe,P:We}=CURVE$1;Re=ensureBytes$1(Re,32);const Ze=Re.slice();Ze[31]=Re[31]&-129;const Xe=bytesToNumberLE(Ze);if(Fe&&Xe>=We)throw new Error("Expected 0 < hex < P");if(!Fe&&Xe>=POW_2_256$1)throw new Error("Expected 0 < hex < 2**256");const Je=mod$1(Xe*Xe),tr=mod$1(Je-_1n$2),er=mod$1(qe*Je+_1n$2);let{isValid:ir,value:ur}=uvRatio(tr,er);if(!ir)throw new Error("Point.fromHex: invalid y coordinate");const fr=(ur&_1n$2)===_1n$2;return(Re[31]&128)!==0!==fr&&(ur=mod$1(-ur)),new Point$1(ur,Xe)}static async fromPrivateKey(Re){return(await getExtendedPublicKey(Re)).point}toRawBytes(){const Re=numberTo32BytesLE(this.y);return Re[31]|=this.x&_1n$2?128:0,Re}toHex(){return bytesToHex$1(this.toRawBytes())}toX25519(){const{y:Re}=this,Fe=mod$1((_1n$2+Re)*invert$1(_1n$2-Re));return numberTo32BytesLE(Fe)}isTorsionFree(){return ExtendedPoint.fromAffine(this).isTorsionFree()}equals(Re){return this.x===Re.x&&this.y===Re.y}negate(){return new Point$1(mod$1(-this.x),this.y)}add(Re){return ExtendedPoint.fromAffine(this).add(ExtendedPoint.fromAffine(Re)).toAffine()}subtract(Re){return this.add(Re.negate())}multiply(Re){return ExtendedPoint.fromAffine(this).multiply(Re,this).toAffine()}}Point$1.BASE=new Point$1(CURVE$1.Gx,CURVE$1.Gy);Point$1.ZERO=new Point$1(_0n$2,_1n$2);class Signature$1{constructor(Re,Fe){this.r=Re,this.s=Fe,this.assertValidity()}static fromHex(Re){const Fe=ensureBytes$1(Re,64),qe=Point$1.fromHex(Fe.slice(0,32),!1),We=bytesToNumberLE(Fe.slice(32,64));return new Signature$1(qe,We)}assertValidity(){const{r:Re,s:Fe}=this;if(!(Re instanceof Point$1))throw new Error("Expected Point instance");return normalizeScalar$1(Fe,CURVE$1.l,!1),this}toRawBytes(){const Re=new Uint8Array(64);return Re.set(this.r.toRawBytes()),Re.set(numberTo32BytesLE(this.s),32),Re}toHex(){return bytesToHex$1(this.toRawBytes())}}function concatBytes$1(...Ke){if(!Ke.every(qe=>qe instanceof Uint8Array))throw new Error("Expected Uint8Array list");if(Ke.length===1)return Ke[0];const Re=Ke.reduce((qe,We)=>qe+We.length,0),Fe=new Uint8Array(Re);for(let qe=0,We=0;qe<Ke.length;qe++){const Ze=Ke[qe];Fe.set(Ze,We),We+=Ze.length}return Fe}const hexes$1=Array.from({length:256},(Ke,Re)=>Re.toString(16).padStart(2,"0"));function bytesToHex$1(Ke){if(!(Ke instanceof Uint8Array))throw new Error("Uint8Array expected");let Re="";for(let Fe=0;Fe<Ke.length;Fe++)Re+=hexes$1[Ke[Fe]];return Re}function hexToBytes$1(Ke){if(typeof Ke!="string")throw new TypeError("hexToBytes: expected string, got "+typeof Ke);if(Ke.length%2)throw new Error("hexToBytes: received invalid unpadded hex");const Re=new Uint8Array(Ke.length/2);for(let Fe=0;Fe<Re.length;Fe++){const qe=Fe*2,We=Ke.slice(qe,qe+2),Ze=Number.parseInt(We,16);if(Number.isNaN(Ze)||Ze<0)throw new Error("Invalid byte sequence");Re[Fe]=Ze}return Re}function numberTo32BytesBE(Ke){const Fe=Ke.toString(16).padStart(64,"0");return hexToBytes$1(Fe)}function numberTo32BytesLE(Ke){return numberTo32BytesBE(Ke).reverse()}function edIsNegative(Ke){return(mod$1(Ke)&_1n$2)===_1n$2}function bytesToNumberLE(Ke){if(!(Ke instanceof Uint8Array))throw new Error("Expected Uint8Array");return BigInt("0x"+bytesToHex$1(Uint8Array.from(Ke).reverse()))}const MAX_255B=BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");function bytes255ToNumberLE(Ke){return mod$1(bytesToNumberLE(Ke)&MAX_255B)}function mod$1(Ke,Re=CURVE$1.P){const Fe=Ke%Re;return Fe>=_0n$2?Fe:Re+Fe}function invert$1(Ke,Re=CURVE$1.P){if(Ke===_0n$2||Re<=_0n$2)throw new Error(`invert: expected positive integers, got n=${Ke} mod=${Re}`);let Fe=mod$1(Ke,Re),qe=Re,We=_0n$2,Ze=_1n$2;for(;Fe!==_0n$2;){const Je=qe/Fe,tr=qe%Fe,er=We-Ze*Je;qe=Fe,Fe=tr,We=Ze,Ze=er}if(qe!==_1n$2)throw new Error("invert: does not exist");return mod$1(We,Re)}function invertBatch$1(Ke,Re=CURVE$1.P){const Fe=new Array(Ke.length),qe=Ke.reduce((Ze,Xe,Je)=>Xe===_0n$2?Ze:(Fe[Je]=Ze,mod$1(Ze*Xe,Re)),_1n$2),We=invert$1(qe,Re);return Ke.reduceRight((Ze,Xe,Je)=>Xe===_0n$2?Ze:(Fe[Je]=mod$1(Ze*Fe[Je],Re),mod$1(Ze*Xe,Re)),We),Fe}function pow2$1(Ke,Re){const{P:Fe}=CURVE$1;let qe=Ke;for(;Re-- >_0n$2;)qe*=qe,qe%=Fe;return qe}function pow_2_252_3(Ke){const{P:Re}=CURVE$1,Fe=BigInt(5),qe=BigInt(10),We=BigInt(20),Ze=BigInt(40),Xe=BigInt(80),tr=Ke*Ke%Re*Ke%Re,er=pow2$1(tr,_2n$2)*tr%Re,ir=pow2$1(er,_1n$2)*Ke%Re,ur=pow2$1(ir,Fe)*ir%Re,fr=pow2$1(ur,qe)*ur%Re,ar=pow2$1(fr,We)*fr%Re,yr=pow2$1(ar,Ze)*ar%Re,mr=pow2$1(yr,Xe)*yr%Re,wr=pow2$1(mr,Xe)*yr%Re,Sr=pow2$1(wr,qe)*ur%Re;return{pow_p_5_8:pow2$1(Sr,_2n$2)*Ke%Re,b2:tr}}function uvRatio(Ke,Re){const Fe=mod$1(Re*Re*Re),qe=mod$1(Fe*Fe*Re),We=pow_2_252_3(Ke*qe).pow_p_5_8;let Ze=mod$1(Ke*Fe*We);const Xe=mod$1(Re*Ze*Ze),Je=Ze,tr=mod$1(Ze*SQRT_M1),er=Xe===Ke,ir=Xe===mod$1(-Ke),ur=Xe===mod$1(-Ke*SQRT_M1);return er&&(Ze=Je),(ir||ur)&&(Ze=tr),edIsNegative(Ze)&&(Ze=mod$1(-Ze)),{isValid:er||ir,value:Ze}}function invertSqrt(Ke){return uvRatio(_1n$2,Ke)}function modlLE(Ke){return mod$1(bytesToNumberLE(Ke),CURVE$1.l)}function equalBytes(Ke,Re){if(Ke.length!==Re.length)return!1;for(let Fe=0;Fe<Ke.length;Fe++)if(Ke[Fe]!==Re[Fe])return!1;return!0}function ensureBytes$1(Ke,Re){const Fe=Ke instanceof Uint8Array?Uint8Array.from(Ke):hexToBytes$1(Ke);if(typeof Re=="number"&&Fe.length!==Re)throw new Error(`Expected ${Re} bytes`);return Fe}function normalizeScalar$1(Ke,Re,Fe=!0){if(!Re)throw new TypeError("Specify max value");if(typeof Ke=="number"&&Number.isSafeInteger(Ke)&&(Ke=BigInt(Ke)),typeof Ke=="bigint"&&Ke<Re){if(Fe){if(_0n$2<Ke)return Ke}else if(_0n$2<=Ke)return Ke}throw new TypeError("Expected valid scalar: 0 < scalar < max")}function adjustBytes25519(Ke){return Ke[0]&=248,Ke[31]&=127,Ke[31]|=64,Ke}function checkPrivateKey(Ke){if(Ke=typeof Ke=="bigint"||typeof Ke=="number"?numberTo32BytesBE(normalizeScalar$1(Ke,POW_2_256$1)):ensureBytes$1(Ke),Ke.length!==32)throw new Error("Expected 32 bytes");return Ke}function getKeyFromHash(Ke){const Re=adjustBytes25519(Ke.slice(0,32)),Fe=Ke.slice(32,64),qe=modlLE(Re),We=Point$1.BASE.multiply(qe),Ze=We.toRawBytes();return{head:Re,prefix:Fe,scalar:qe,point:We,pointBytes:Ze}}let _sha512Sync;function sha512s(...Ke){if(typeof _sha512Sync!="function")throw new Error("utils.sha512Sync must be set to use sync methods");return _sha512Sync(...Ke)}async function getExtendedPublicKey(Ke){return getKeyFromHash(await utils$1.sha512(checkPrivateKey(Ke)))}function getExtendedPublicKeySync(Ke){return getKeyFromHash(sha512s(checkPrivateKey(Ke)))}function getPublicKeySync(Ke){return getExtendedPublicKeySync(Ke).pointBytes}function signSync$1(Ke,Re){Ke=ensureBytes$1(Ke);const{prefix:Fe,scalar:qe,pointBytes:We}=getExtendedPublicKeySync(Re),Ze=modlLE(sha512s(Fe,Ke)),Xe=Point$1.BASE.multiply(Ze),Je=modlLE(sha512s(Xe.toRawBytes(),We,Ke)),tr=mod$1(Ze+Je*qe,CURVE$1.l);return new Signature$1(Xe,tr).toRawBytes()}function prepareVerification(Ke,Re,Fe){Re=ensureBytes$1(Re),Fe instanceof Point$1||(Fe=Point$1.fromHex(Fe,!1));const{r:qe,s:We}=Ke instanceof Signature$1?Ke.assertValidity():Signature$1.fromHex(Ke),Ze=ExtendedPoint.BASE.multiplyUnsafe(We);return{r:qe,s:We,SB:Ze,pub:Fe,msg:Re}}function finishVerification(Ke,Re,Fe,qe){const We=modlLE(qe),Ze=ExtendedPoint.fromAffine(Ke).multiplyUnsafe(We);return ExtendedPoint.fromAffine(Re).add(Ze).subtract(Fe).multiplyUnsafe(CURVE$1.h).equals(ExtendedPoint.ZERO)}function verifySync(Ke,Re,Fe){const{r:qe,SB:We,msg:Ze,pub:Xe}=prepareVerification(Ke,Re,Fe),Je=sha512s(qe.toRawBytes(),Xe.toRawBytes(),Ze);return finishVerification(Xe,qe,We,Je)}const sync={getExtendedPublicKey:getExtendedPublicKeySync,getPublicKey:getPublicKeySync,sign:signSync$1,verify:verifySync};Point$1.BASE._setWindowSize(8);const crypto$2={node:nodeCrypto,web:typeof self=="object"&&"crypto"in self?self.crypto:void 0},utils$1={bytesToHex:bytesToHex$1,hexToBytes:hexToBytes$1,concatBytes:concatBytes$1,getExtendedPublicKey,mod:mod$1,invert:invert$1,TORSION_SUBGROUP:["0100000000000000000000000000000000000000000000000000000000000000","c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a","0000000000000000000000000000000000000000000000000000000000000080","26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05","ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f","26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85","0000000000000000000000000000000000000000000000000000000000000000","c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa"],hashToPrivateScalar:Ke=>{if(Ke=ensureBytes$1(Ke),Ke.length<40||Ke.length>1024)throw new Error("Expected 40-1024 bytes of private key as per FIPS 186");return mod$1(bytesToNumberLE(Ke),CURVE$1.l-_1n$2)+_1n$2},randomBytes:(Ke=32)=>{if(crypto$2.web)return crypto$2.web.getRandomValues(new Uint8Array(Ke));if(crypto$2.node){const{randomBytes:Re}=crypto$2.node;return new Uint8Array(Re(Ke).buffer)}else throw new Error("The environment doesn't have randomBytes function")},randomPrivateKey:()=>utils$1.randomBytes(32),sha512:async(...Ke)=>{const Re=concatBytes$1(...Ke);if(crypto$2.web){const Fe=await crypto$2.web.subtle.digest("SHA-512",Re.buffer);return new Uint8Array(Fe)}else{if(crypto$2.node)return Uint8Array.from(crypto$2.node.createHash("sha512").update(Re).digest());throw new Error("The environment doesn't have sha512 function")}},precompute(Ke=8,Re=Point$1.BASE){const Fe=Re.equals(Point$1.BASE)?Re:new Point$1(Re.x,Re.y);return Fe._setWindowSize(Ke),Fe.multiply(_2n$2),Fe},sha512Sync:void 0};Object.defineProperties(utils$1,{sha512Sync:{configurable:!1,get(){return _sha512Sync},set(Ke){_sha512Sync||(_sha512Sync=Ke)}}});var bn$1={exports:{}};const require$$0$1=getAugmentedNamespace(nodeCrypto);(function(Ke){(function(Re,Fe){function qe(cr,Dt){if(!cr)throw new Error(Dt||"Assertion failed")}function We(cr,Dt){cr.super_=Dt;var sr=function(){};sr.prototype=Dt.prototype,cr.prototype=new sr,cr.prototype.constructor=cr}function Ze(cr,Dt,sr){if(Ze.isBN(cr))return cr;this.negative=0,this.words=null,this.length=0,this.red=null,cr!==null&&((Dt==="le"||Dt==="be")&&(sr=Dt,Dt=10),this._init(cr||0,Dt||10,sr||"be"))}typeof Re=="object"?Re.exports=Ze:Fe.BN=Ze,Ze.BN=Ze,Ze.wordSize=26;var Xe;try{typeof window<"u"&&typeof window.Buffer<"u"?Xe=window.Buffer:Xe=require$$0$1.Buffer}catch{}Ze.isBN=function(Dt){return Dt instanceof Ze?!0:Dt!==null&&typeof Dt=="object"&&Dt.constructor.wordSize===Ze.wordSize&&Array.isArray(Dt.words)},Ze.max=function(Dt,sr){return Dt.cmp(sr)>0?Dt:sr},Ze.min=function(Dt,sr){return Dt.cmp(sr)<0?Dt:sr},Ze.prototype._init=function(Dt,sr,lr){if(typeof Dt=="number")return this._initNumber(Dt,sr,lr);if(typeof Dt=="object")return this._initArray(Dt,sr,lr);sr==="hex"&&(sr=16),qe(sr===(sr|0)&&sr>=2&&sr<=36),Dt=Dt.toString().replace(/\s+/g,"");var gr=0;Dt[0]==="-"&&(gr++,this.negative=1),gr<Dt.length&&(sr===16?this._parseHex(Dt,gr,lr):(this._parseBase(Dt,sr,gr),lr==="le"&&this._initArray(this.toArray(),sr,lr)))},Ze.prototype._initNumber=function(Dt,sr,lr){Dt<0&&(this.negative=1,Dt=-Dt),Dt<67108864?(this.words=[Dt&67108863],this.length=1):Dt<4503599627370496?(this.words=[Dt&67108863,Dt/67108864&67108863],this.length=2):(qe(Dt<9007199254740992),this.words=[Dt&67108863,Dt/67108864&67108863,1],this.length=3),lr==="le"&&this._initArray(this.toArray(),sr,lr)},Ze.prototype._initArray=function(Dt,sr,lr){if(qe(typeof Dt.length=="number"),Dt.length<=0)return this.words=[0],this.length=1,this;this.length=Math.ceil(Dt.length/3),this.words=new Array(this.length);for(var gr=0;gr<this.length;gr++)this.words[gr]=0;var _r,xr,kr=0;if(lr==="be")for(gr=Dt.length-1,_r=0;gr>=0;gr-=3)xr=Dt[gr]|Dt[gr-1]<<8|Dt[gr-2]<<16,this.words[_r]|=xr<<kr&67108863,this.words[_r+1]=xr>>>26-kr&67108863,kr+=24,kr>=26&&(kr-=26,_r++);else if(lr==="le")for(gr=0,_r=0;gr<Dt.length;gr+=3)xr=Dt[gr]|Dt[gr+1]<<8|Dt[gr+2]<<16,this.words[_r]|=xr<<kr&67108863,this.words[_r+1]=xr>>>26-kr&67108863,kr+=24,kr>=26&&(kr-=26,_r++);return this._strip()};function Je(cr,Dt){var sr=cr.charCodeAt(Dt);if(sr>=48&&sr<=57)return sr-48;if(sr>=65&&sr<=70)return sr-55;if(sr>=97&&sr<=102)return sr-87;qe(!1,"Invalid character in "+cr)}function tr(cr,Dt,sr){var lr=Je(cr,sr);return sr-1>=Dt&&(lr|=Je(cr,sr-1)<<4),lr}Ze.prototype._parseHex=function(Dt,sr,lr){this.length=Math.ceil((Dt.length-sr)/6),this.words=new Array(this.length);for(var gr=0;gr<this.length;gr++)this.words[gr]=0;var _r=0,xr=0,kr;if(lr==="be")for(gr=Dt.length-1;gr>=sr;gr-=2)kr=tr(Dt,sr,gr)<<_r,this.words[xr]|=kr&67108863,_r>=18?(_r-=18,xr+=1,this.words[xr]|=kr>>>26):_r+=8;else{var pr=Dt.length-sr;for(gr=pr%2===0?sr+1:sr;gr<Dt.length;gr+=2)kr=tr(Dt,sr,gr)<<_r,this.words[xr]|=kr&67108863,_r>=18?(_r-=18,xr+=1,this.words[xr]|=kr>>>26):_r+=8}this._strip()};function er(cr,Dt,sr,lr){for(var gr=0,_r=0,xr=Math.min(cr.length,sr),kr=Dt;kr<xr;kr++){var pr=cr.charCodeAt(kr)-48;gr*=lr,pr>=49?_r=pr-49+10:pr>=17?_r=pr-17+10:_r=pr,qe(pr>=0&&_r<lr,"Invalid character"),gr+=_r}return gr}Ze.prototype._parseBase=function(Dt,sr,lr){this.words=[0],this.length=1;for(var gr=0,_r=1;_r<=67108863;_r*=sr)gr++;gr--,_r=_r/sr|0;for(var xr=Dt.length-lr,kr=xr%gr,pr=Math.min(xr,xr-kr)+lr,rr=0,hr=lr;hr<pr;hr+=gr)rr=er(Dt,hr,hr+gr,sr),this.imuln(_r),this.words[0]+rr<67108864?this.words[0]+=rr:this._iaddn(rr);if(kr!==0){var Cr=1;for(rr=er(Dt,hr,Dt.length,sr),hr=0;hr<kr;hr++)Cr*=sr;this.imuln(Cr),this.words[0]+rr<67108864?this.words[0]+=rr:this._iaddn(rr)}this._strip()},Ze.prototype.copy=function(Dt){Dt.words=new Array(this.length);for(var sr=0;sr<this.length;sr++)Dt.words[sr]=this.words[sr];Dt.length=this.length,Dt.negative=this.negative,Dt.red=this.red};function ir(cr,Dt){cr.words=Dt.words,cr.length=Dt.length,cr.negative=Dt.negative,cr.red=Dt.red}if(Ze.prototype._move=function(Dt){ir(Dt,this)},Ze.prototype.clone=function(){var Dt=new Ze(null);return this.copy(Dt),Dt},Ze.prototype._expand=function(Dt){for(;this.length<Dt;)this.words[this.length++]=0;return this},Ze.prototype._strip=function(){for(;this.length>1&&this.words[this.length-1]===0;)this.length--;return this._normSign()},Ze.prototype._normSign=function(){return this.length===1&&this.words[0]===0&&(this.negative=0),this},typeof Symbol<"u"&&typeof Symbol.for=="function")try{Ze.prototype[Symbol.for("nodejs.util.inspect.custom")]=ur}catch{Ze.prototype.inspect=ur}else Ze.prototype.inspect=ur;function ur(){return(this.red?"<BN-R: ":"<BN: ")+this.toString(16)+">"}var fr=["","0","00","000","0000","00000","000000","0000000","00000000","000000000","0000000000","00000000000","000000000000","0000000000000","00000000000000","000000000000000","0000000000000000","00000000000000000","000000000000000000","0000000000000000000","00000000000000000000","000000000000000000000","0000000000000000000000","00000000000000000000000","000000000000000000000000","0000000000000000000000000"],ar=[0,0,25,16,12,11,10,9,8,8,7,7,7,7,6,6,6,6,6,6,6,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5],yr=[0,0,33554432,43046721,16777216,48828125,60466176,40353607,16777216,43046721,1e7,19487171,35831808,62748517,7529536,11390625,16777216,24137569,34012224,47045881,64e6,4084101,5153632,6436343,7962624,9765625,11881376,14348907,17210368,20511149,243e5,28629151,33554432,39135393,45435424,52521875,60466176];Ze.prototype.toString=function(Dt,sr){Dt=Dt||10,sr=sr|0||1;var lr;if(Dt===16||Dt==="hex"){lr="";for(var gr=0,_r=0,xr=0;xr<this.length;xr++){var kr=this.words[xr],pr=((kr<<gr|_r)&16777215).toString(16);_r=kr>>>24-gr&16777215,gr+=2,gr>=26&&(gr-=26,xr--),_r!==0||xr!==this.length-1?lr=fr[6-pr.length]+pr+lr:lr=pr+lr}for(_r!==0&&(lr=_r.toString(16)+lr);lr.length%sr!==0;)lr="0"+lr;return this.negative!==0&&(lr="-"+lr),lr}if(Dt===(Dt|0)&&Dt>=2&&Dt<=36){var rr=ar[Dt],hr=yr[Dt];lr="";var Cr=this.clone();for(Cr.negative=0;!Cr.isZero();){var Or=Cr.modrn(hr).toString(Dt);Cr=Cr.idivn(hr),Cr.isZero()?lr=Or+lr:lr=fr[rr-Or.length]+Or+lr}for(this.isZero()&&(lr="0"+lr);lr.length%sr!==0;)lr="0"+lr;return this.negative!==0&&(lr="-"+lr),lr}qe(!1,"Base should be between 2 and 36")},Ze.prototype.toNumber=function(){var Dt=this.words[0];return this.length===2?Dt+=this.words[1]*67108864:this.length===3&&this.words[2]===1?Dt+=4503599627370496+this.words[1]*67108864:this.length>2&&qe(!1,"Number can only safely store up to 53 bits"),this.negative!==0?-Dt:Dt},Ze.prototype.toJSON=function(){return this.toString(16,2)},Xe&&(Ze.prototype.toBuffer=function(Dt,sr){return this.toArrayLike(Xe,Dt,sr)}),Ze.prototype.toArray=function(Dt,sr){return this.toArrayLike(Array,Dt,sr)};var mr=function(Dt,sr){return Dt.allocUnsafe?Dt.allocUnsafe(sr):new Dt(sr)};Ze.prototype.toArrayLike=function(Dt,sr,lr){this._strip();var gr=this.byteLength(),_r=lr||Math.max(1,gr);qe(gr<=_r,"byte array longer than desired length"),qe(_r>0,"Requested array length <= 0");var xr=mr(Dt,_r),kr=sr==="le"?"LE":"BE";return this["_toArrayLike"+kr](xr,gr),xr},Ze.prototype._toArrayLikeLE=function(Dt,sr){for(var lr=0,gr=0,_r=0,xr=0;_r<this.length;_r++){var kr=this.words[_r]<<xr|gr;Dt[lr++]=kr&255,lr<Dt.length&&(Dt[lr++]=kr>>8&255),lr<Dt.length&&(Dt[lr++]=kr>>16&255),xr===6?(lr<Dt.length&&(Dt[lr++]=kr>>24&255),gr=0,xr=0):(gr=kr>>>24,xr+=2)}if(lr<Dt.length)for(Dt[lr++]=gr;lr<Dt.length;)Dt[lr++]=0},Ze.prototype._toArrayLikeBE=function(Dt,sr){for(var lr=Dt.length-1,gr=0,_r=0,xr=0;_r<this.length;_r++){var kr=this.words[_r]<<xr|gr;Dt[lr--]=kr&255,lr>=0&&(Dt[lr--]=kr>>8&255),lr>=0&&(Dt[lr--]=kr>>16&255),xr===6?(lr>=0&&(Dt[lr--]=kr>>24&255),gr=0,xr=0):(gr=kr>>>24,xr+=2)}if(lr>=0)for(Dt[lr--]=gr;lr>=0;)Dt[lr--]=0},Math.clz32?Ze.prototype._countBits=function(Dt){return 32-Math.clz32(Dt)}:Ze.prototype._countBits=function(Dt){var sr=Dt,lr=0;return sr>=4096&&(lr+=13,sr>>>=13),sr>=64&&(lr+=7,sr>>>=7),sr>=8&&(lr+=4,sr>>>=4),sr>=2&&(lr+=2,sr>>>=2),lr+sr},Ze.prototype._zeroBits=function(Dt){if(Dt===0)return 26;var sr=Dt,lr=0;return(sr&8191)===0&&(lr+=13,sr>>>=13),(sr&127)===0&&(lr+=7,sr>>>=7),(sr&15)===0&&(lr+=4,sr>>>=4),(sr&3)===0&&(lr+=2,sr>>>=2),(sr&1)===0&&lr++,lr},Ze.prototype.bitLength=function(){var Dt=this.words[this.length-1],sr=this._countBits(Dt);return(this.length-1)*26+sr};function wr(cr){for(var Dt=new Array(cr.bitLength()),sr=0;sr<Dt.length;sr++){var lr=sr/26|0,gr=sr%26;Dt[sr]=cr.words[lr]>>>gr&1}return Dt}Ze.prototype.zeroBits=function(){if(this.isZero())return 0;for(var Dt=0,sr=0;sr<this.length;sr++){var lr=this._zeroBits(this.words[sr]);if(Dt+=lr,lr!==26)break}return Dt},Ze.prototype.byteLength=function(){return Math.ceil(this.bitLength()/8)},Ze.prototype.toTwos=function(Dt){return this.negative!==0?this.abs().inotn(Dt).iaddn(1):this.clone()},Ze.prototype.fromTwos=function(Dt){return this.testn(Dt-1)?this.notn(Dt).iaddn(1).ineg():this.clone()},Ze.prototype.isNeg=function(){return this.negative!==0},Ze.prototype.neg=function(){return this.clone().ineg()},Ze.prototype.ineg=function(){return this.isZero()||(this.negative^=1),this},Ze.prototype.iuor=function(Dt){for(;this.length<Dt.length;)this.words[this.length++]=0;for(var sr=0;sr<Dt.length;sr++)this.words[sr]=this.words[sr]|Dt.words[sr];return this._strip()},Ze.prototype.ior=function(Dt){return qe((this.negative|Dt.negative)===0),this.iuor(Dt)},Ze.prototype.or=function(Dt){return this.length>Dt.length?this.clone().ior(Dt):Dt.clone().ior(this)},Ze.prototype.uor=function(Dt){return this.length>Dt.length?this.clone().iuor(Dt):Dt.clone().iuor(this)},Ze.prototype.iuand=function(Dt){var sr;this.length>Dt.length?sr=Dt:sr=this;for(var lr=0;lr<sr.length;lr++)this.words[lr]=this.words[lr]&Dt.words[lr];return this.length=sr.length,this._strip()},Ze.prototype.iand=function(Dt){return qe((this.negative|Dt.negative)===0),this.iuand(Dt)},Ze.prototype.and=function(Dt){return this.length>Dt.length?this.clone().iand(Dt):Dt.clone().iand(this)},Ze.prototype.uand=function(Dt){return this.length>Dt.length?this.clone().iuand(Dt):Dt.clone().iuand(this)},Ze.prototype.iuxor=function(Dt){var sr,lr;this.length>Dt.length?(sr=this,lr=Dt):(sr=Dt,lr=this);for(var gr=0;gr<lr.length;gr++)this.words[gr]=sr.words[gr]^lr.words[gr];if(this!==sr)for(;gr<sr.length;gr++)this.words[gr]=sr.words[gr];return this.length=sr.length,this._strip()},Ze.prototype.ixor=function(Dt){return qe((this.negative|Dt.negative)===0),this.iuxor(Dt)},Ze.prototype.xor=function(Dt){return this.length>Dt.length?this.clone().ixor(Dt):Dt.clone().ixor(this)},Ze.prototype.uxor=function(Dt){return this.length>Dt.length?this.clone().iuxor(Dt):Dt.clone().iuxor(this)},Ze.prototype.inotn=function(Dt){qe(typeof Dt=="number"&&Dt>=0);var sr=Math.ceil(Dt/26)|0,lr=Dt%26;this._expand(sr),lr>0&&sr--;for(var gr=0;gr<sr;gr++)this.words[gr]=~this.words[gr]&67108863;return lr>0&&(this.words[gr]=~this.words[gr]&67108863>>26-lr),this._strip()},Ze.prototype.notn=function(Dt){return this.clone().inotn(Dt)},Ze.prototype.setn=function(Dt,sr){qe(typeof Dt=="number"&&Dt>=0);var lr=Dt/26|0,gr=Dt%26;return this._expand(lr+1),sr?this.words[lr]=this.words[lr]|1<<gr:this.words[lr]=this.words[lr]&~(1<<gr),this._strip()},Ze.prototype.iadd=function(Dt){var sr;if(this.negative!==0&&Dt.negative===0)return this.negative=0,sr=this.isub(Dt),this.negative^=1,this._normSign();if(this.negative===0&&Dt.negative!==0)return Dt.negative=0,sr=this.isub(Dt),Dt.negative=1,sr._normSign();var lr,gr;this.length>Dt.length?(lr=this,gr=Dt):(lr=Dt,gr=this);for(var _r=0,xr=0;xr<gr.length;xr++)sr=(lr.words[xr]|0)+(gr.words[xr]|0)+_r,this.words[xr]=sr&67108863,_r=sr>>>26;for(;_r!==0&&xr<lr.length;xr++)sr=(lr.words[xr]|0)+_r,this.words[xr]=sr&67108863,_r=sr>>>26;if(this.length=lr.length,_r!==0)this.words[this.length]=_r,this.length++;else if(lr!==this)for(;xr<lr.length;xr++)this.words[xr]=lr.words[xr];return this},Ze.prototype.add=function(Dt){var sr;return Dt.negative!==0&&this.negative===0?(Dt.negative=0,sr=this.sub(Dt),Dt.negative^=1,sr):Dt.negative===0&&this.negative!==0?(this.negative=0,sr=Dt.sub(this),this.negative=1,sr):this.length>Dt.length?this.clone().iadd(Dt):Dt.clone().iadd(this)},Ze.prototype.isub=function(Dt){if(Dt.negative!==0){Dt.negative=0;var sr=this.iadd(Dt);return Dt.negative=1,sr._normSign()}else if(this.negative!==0)return this.negative=0,this.iadd(Dt),this.negative=1,this._normSign();var lr=this.cmp(Dt);if(lr===0)return this.negative=0,this.length=1,this.words[0]=0,this;var gr,_r;lr>0?(gr=this,_r=Dt):(gr=Dt,_r=this);for(var xr=0,kr=0;kr<_r.length;kr++)sr=(gr.words[kr]|0)-(_r.words[kr]|0)+xr,xr=sr>>26,this.words[kr]=sr&67108863;for(;xr!==0&&kr<gr.length;kr++)sr=(gr.words[kr]|0)+xr,xr=sr>>26,this.words[kr]=sr&67108863;if(xr===0&&kr<gr.length&&gr!==this)for(;kr<gr.length;kr++)this.words[kr]=gr.words[kr];return this.length=Math.max(this.length,kr),gr!==this&&(this.negative=1),this._strip()},Ze.prototype.sub=function(Dt){return this.clone().isub(Dt)};function Sr(cr,Dt,sr){sr.negative=Dt.negative^cr.negative;var lr=cr.length+Dt.length|0;sr.length=lr,lr=lr-1|0;var gr=cr.words[0]|0,_r=Dt.words[0]|0,xr=gr*_r,kr=xr&67108863,pr=xr/67108864|0;sr.words[0]=kr;for(var rr=1;rr<lr;rr++){for(var hr=pr>>>26,Cr=pr&67108863,Or=Math.min(rr,Dt.length-1),Ur=Math.max(0,rr-cr.length+1);Ur<=Or;Ur++){var qr=rr-Ur|0;gr=cr.words[qr]|0,_r=Dt.words[Ur]|0,xr=gr*_r+Cr,hr+=xr/67108864|0,Cr=xr&67108863}sr.words[rr]=Cr|0,pr=hr|0}return pr!==0?sr.words[rr]=pr|0:sr.length--,sr._strip()}var Ar=function(Dt,sr,lr){var gr=Dt.words,_r=sr.words,xr=lr.words,kr=0,pr,rr,hr,Cr=gr[0]|0,Or=Cr&8191,Ur=Cr>>>13,qr=gr[1]|0,Fr=qr&8191,zr=qr>>>13,Yr=gr[2]|0,Wr=Yr&8191,Gr=Yr>>>13,Hn=gr[3]|0,Xr=Hn&8191,Zr=Hn>>>13,Wn=gr[4]|0,Qr=Wn&8191,jn=Wn>>>13,fi=gr[5]|0,$n=fi&8191,Jr=fi>>>13,Cn=gr[6]|0,Fn=Cn&8191,Kn=Cn>>>13,qn=gr[7]|0,Un=qn&8191,nr=qn>>>13,Qe=gr[8]|0,dt=Qe&8191,or=Qe>>>13,dr=gr[9]|0,br=dr&8191,Er=dr>>>13,Dr=_r[0]|0,Vr=Dr&8191,Kr=Dr>>>13,jr=_r[1]|0,Hr=jr&8191,Gn=jr>>>13,Bi=_r[2]|0,Yn=Bi&8191,Zn=Bi>>>13,Li=_r[3]|0,Xn=Li&8191,Jn=Li>>>13,Ci=_r[4]|0,Qn=Ci&8191,ei=Ci>>>13,Oi=_r[5]|0,ti=Oi&8191,ri=Oi>>>13,Pi=_r[6]|0,ni=Pi&8191,ii=Pi>>>13,Mi=_r[7]|0,oi=Mi&8191,si=Mi>>>13,Ni=_r[8]|0,ai=Ni&8191,ci=Ni>>>13,Ui=_r[9]|0,ui=Ui&8191,li=Ui>>>13;lr.negative=Dt.negative^sr.negative,lr.length=19,pr=Math.imul(Or,Vr),rr=Math.imul(Or,Kr),rr=rr+Math.imul(Ur,Vr)|0,hr=Math.imul(Ur,Kr);var di=(kr+pr|0)+((rr&8191)<<13)|0;kr=(hr+(rr>>>13)|0)+(di>>>26)|0,di&=67108863,pr=Math.imul(Fr,Vr),rr=Math.imul(Fr,Kr),rr=rr+Math.imul(zr,Vr)|0,hr=Math.imul(zr,Kr),pr=pr+Math.imul(Or,Hr)|0,rr=rr+Math.imul(Or,Gn)|0,rr=rr+Math.imul(Ur,Hr)|0,hr=hr+Math.imul(Ur,Gn)|0;var hi=(kr+pr|0)+((rr&8191)<<13)|0;kr=(hr+(rr>>>13)|0)+(hi>>>26)|0,hi&=67108863,pr=Math.imul(Wr,Vr),rr=Math.imul(Wr,Kr),rr=rr+Math.imul(Gr,Vr)|0,hr=Math.imul(Gr,Kr),pr=pr+Math.imul(Fr,Hr)|0,rr=rr+Math.imul(Fr,Gn)|0,rr=rr+Math.imul(zr,Hr)|0,hr=hr+Math.imul(zr,Gn)|0,pr=pr+Math.imul(Or,Yn)|0,rr=rr+Math.imul(Or,Zn)|0,rr=rr+Math.imul(Ur,Yn)|0,hr=hr+Math.imul(Ur,Zn)|0;var pi=(kr+pr|0)+((rr&8191)<<13)|0;kr=(hr+(rr>>>13)|0)+(pi>>>26)|0,pi&=67108863,pr=Math.imul(Xr,Vr),rr=Math.imul(Xr,Kr),rr=rr+Math.imul(Zr,Vr)|0,hr=Math.imul(Zr,Kr),pr=pr+Math.imul(Wr,Hr)|0,rr=rr+Math.imul(Wr,Gn)|0,rr=rr+Math.imul(Gr,Hr)|0,hr=hr+Math.imul(Gr,Gn)|0,pr=pr+Math.imul(Fr,Yn)|0,rr=rr+Math.imul(Fr,Zn)|0,rr=rr+Math.imul(zr,Yn)|0,hr=hr+Math.imul(zr,Zn)|0,pr=pr+Math.imul(Or,Xn)|0,rr=rr+Math.imul(Or,Jn)|0,rr=rr+Math.imul(Ur,Xn)|0,hr=hr+Math.imul(Ur,Jn)|0;var yi=(kr+pr|0)+((rr&8191)<<13)|0;kr=(hr+(rr>>>13)|0)+(yi>>>26)|0,yi&=67108863,pr=Math.imul(Qr,Vr),rr=Math.imul(Qr,Kr),rr=rr+Math.imul(jn,Vr)|0,hr=Math.imul(jn,Kr),pr=pr+Math.imul(Xr,Hr)|0,rr=rr+Math.imul(Xr,Gn)|0,rr=rr+Math.imul(Zr,Hr)|0,hr=hr+Math.imul(Zr,Gn)|0,pr=pr+Math.imul(Wr,Yn)|0,rr=rr+Math.imul(Wr,Zn)|0,rr=rr+Math.imul(Gr,Yn)|0,hr=hr+Math.imul(Gr,Zn)|0,pr=pr+Math.imul(Fr,Xn)|0,rr=rr+Math.imul(Fr,Jn)|0,rr=rr+Math.imul(zr,Xn)|0,hr=hr+Math.imul(zr,Jn)|0,pr=pr+Math.imul(Or,Qn)|0,rr=rr+Math.imul(Or,ei)|0,rr=rr+Math.imul(Ur,Qn)|0,hr=hr+Math.imul(Ur,ei)|0;var gi=(kr+pr|0)+((rr&8191)<<13)|0;kr=(hr+(rr>>>13)|0)+(gi>>>26)|0,gi&=67108863,pr=Math.imul($n,Vr),rr=Math.imul($n,Kr),rr=rr+Math.imul(Jr,Vr)|0,hr=Math.imul(Jr,Kr),pr=pr+Math.imul(Qr,Hr)|0,rr=rr+Math.imul(Qr,Gn)|0,rr=rr+Math.imul(jn,Hr)|0,hr=hr+Math.imul(jn,Gn)|0,pr=pr+Math.imul(Xr,Yn)|0,rr=rr+Math.imul(Xr,Zn)|0,rr=rr+Math.imul(Zr,Yn)|0,hr=hr+Math.imul(Zr,Zn)|0,pr=pr+Math.imul(Wr,Xn)|0,rr=rr+Math.imul(Wr,Jn)|0,rr=rr+Math.imul(Gr,Xn)|0,hr=hr+Math.imul(Gr,Jn)|0,pr=pr+Math.imul(Fr,Qn)|0,rr=rr+Math.imul(Fr,ei)|0,rr=rr+Math.imul(zr,Qn)|0,hr=hr+Math.imul(zr,ei)|0,pr=pr+Math.imul(Or,ti)|0,rr=rr+Math.imul(Or,ri)|0,rr=rr+Math.imul(Ur,ti)|0,hr=hr+Math.imul(Ur,ri)|0;var mi=(kr+pr|0)+((rr&8191)<<13)|0;kr=(hr+(rr>>>13)|0)+(mi>>>26)|0,mi&=67108863,pr=Math.imul(Fn,Vr),rr=Math.imul(Fn,Kr),rr=rr+Math.imul(Kn,Vr)|0,hr=Math.imul(Kn,Kr),pr=pr+Math.imul($n,Hr)|0,rr=rr+Math.imul($n,Gn)|0,rr=rr+Math.imul(Jr,Hr)|0,hr=hr+Math.imul(Jr,Gn)|0,pr=pr+Math.imul(Qr,Yn)|0,rr=rr+Math.imul(Qr,Zn)|0,rr=rr+Math.imul(jn,Yn)|0,hr=hr+Math.imul(jn,Zn)|0,pr=pr+Math.imul(Xr,Xn)|0,rr=rr+Math.imul(Xr,Jn)|0,rr=rr+Math.imul(Zr,Xn)|0,hr=hr+Math.imul(Zr,Jn)|0,pr=pr+Math.imul(Wr,Qn)|0,rr=rr+Math.imul(Wr,ei)|0,rr=rr+Math.imul(Gr,Qn)|0,hr=hr+Math.imul(Gr,ei)|0,pr=pr+Math.imul(Fr,ti)|0,rr=rr+Math.imul(Fr,ri)|0,rr=rr+Math.imul(zr,ti)|0,hr=hr+Math.imul(zr,ri)|0,pr=pr+Math.imul(Or,ni)|0,rr=rr+Math.imul(Or,ii)|0,rr=rr+Math.imul(Ur,ni)|0,hr=hr+Math.imul(Ur,ii)|0;var _i=(kr+pr|0)+((rr&8191)<<13)|0;kr=(hr+(rr>>>13)|0)+(_i>>>26)|0,_i&=67108863,pr=Math.imul(Un,Vr),rr=Math.imul(Un,Kr),rr=rr+Math.imul(nr,Vr)|0,hr=Math.imul(nr,Kr),pr=pr+Math.imul(Fn,Hr)|0,rr=rr+Math.imul(Fn,Gn)|0,rr=rr+Math.imul(Kn,Hr)|0,hr=hr+Math.imul(Kn,Gn)|0,pr=pr+Math.imul($n,Yn)|0,rr=rr+Math.imul($n,Zn)|0,rr=rr+Math.imul(Jr,Yn)|0,hr=hr+Math.imul(Jr,Zn)|0,pr=pr+Math.imul(Qr,Xn)|0,rr=rr+Math.imul(Qr,Jn)|0,rr=rr+Math.imul(jn,Xn)|0,hr=hr+Math.imul(jn,Jn)|0,pr=pr+Math.imul(Xr,Qn)|0,rr=rr+Math.imul(Xr,ei)|0,rr=rr+Math.imul(Zr,Qn)|0,hr=hr+Math.imul(Zr,ei)|0,pr=pr+Math.imul(Wr,ti)|0,rr=rr+Math.imul(Wr,ri)|0,rr=rr+Math.imul(Gr,ti)|0,hr=hr+Math.imul(Gr,ri)|0,pr=pr+Math.imul(Fr,ni)|0,rr=rr+Math.imul(Fr,ii)|0,rr=rr+Math.imul(zr,ni)|0,hr=hr+Math.imul(zr,ii)|0,pr=pr+Math.imul(Or,oi)|0,rr=rr+Math.imul(Or,si)|0,rr=rr+Math.imul(Ur,oi)|0,hr=hr+Math.imul(Ur,si)|0;var bi=(kr+pr|0)+((rr&8191)<<13)|0;kr=(hr+(rr>>>13)|0)+(bi>>>26)|0,bi&=67108863,pr=Math.imul(dt,Vr),rr=Math.imul(dt,Kr),rr=rr+Math.imul(or,Vr)|0,hr=Math.imul(or,Kr),pr=pr+Math.imul(Un,Hr)|0,rr=rr+Math.imul(Un,Gn)|0,rr=rr+Math.imul(nr,Hr)|0,hr=hr+Math.imul(nr,Gn)|0,pr=pr+Math.imul(Fn,Yn)|0,rr=rr+Math.imul(Fn,Zn)|0,rr=rr+Math.imul(Kn,Yn)|0,hr=hr+Math.imul(Kn,Zn)|0,pr=pr+Math.imul($n,Xn)|0,rr=rr+Math.imul($n,Jn)|0,rr=rr+Math.imul(Jr,Xn)|0,hr=hr+Math.imul(Jr,Jn)|0,pr=pr+Math.imul(Qr,Qn)|0,rr=rr+Math.imul(Qr,ei)|0,rr=rr+Math.imul(jn,Qn)|0,hr=hr+Math.imul(jn,ei)|0,pr=pr+Math.imul(Xr,ti)|0,rr=rr+Math.imul(Xr,ri)|0,rr=rr+Math.imul(Zr,ti)|0,hr=hr+Math.imul(Zr,ri)|0,pr=pr+Math.imul(Wr,ni)|0,rr=rr+Math.imul(Wr,ii)|0,rr=rr+Math.imul(Gr,ni)|0,hr=hr+Math.imul(Gr,ii)|0,pr=pr+Math.imul(Fr,oi)|0,rr=rr+Math.imul(Fr,si)|0,rr=rr+Math.imul(zr,oi)|0,hr=hr+Math.imul(zr,si)|0,pr=pr+Math.imul(Or,ai)|0,rr=rr+Math.imul(Or,ci)|0,rr=rr+Math.imul(Ur,ai)|0,hr=hr+Math.imul(Ur,ci)|0;var wi=(kr+pr|0)+((rr&8191)<<13)|0;kr=(hr+(rr>>>13)|0)+(wi>>>26)|0,wi&=67108863,pr=Math.imul(br,Vr),rr=Math.imul(br,Kr),rr=rr+Math.imul(Er,Vr)|0,hr=Math.imul(Er,Kr),pr=pr+Math.imul(dt,Hr)|0,rr=rr+Math.imul(dt,Gn)|0,rr=rr+Math.imul(or,Hr)|0,hr=hr+Math.imul(or,Gn)|0,pr=pr+Math.imul(Un,Yn)|0,rr=rr+Math.imul(Un,Zn)|0,rr=rr+Math.imul(nr,Yn)|0,hr=hr+Math.imul(nr,Zn)|0,pr=pr+Math.imul(Fn,Xn)|0,rr=rr+Math.imul(Fn,Jn)|0,rr=rr+Math.imul(Kn,Xn)|0,hr=hr+Math.imul(Kn,Jn)|0,pr=pr+Math.imul($n,Qn)|0,rr=rr+Math.imul($n,ei)|0,rr=rr+Math.imul(Jr,Qn)|0,hr=hr+Math.imul(Jr,ei)|0,pr=pr+Math.imul(Qr,ti)|0,rr=rr+Math.imul(Qr,ri)|0,rr=rr+Math.imul(jn,ti)|0,hr=hr+Math.imul(jn,ri)|0,pr=pr+Math.imul(Xr,ni)|0,rr=rr+Math.imul(Xr,ii)|0,rr=rr+Math.imul(Zr,ni)|0,hr=hr+Math.imul(Zr,ii)|0,pr=pr+Math.imul(Wr,oi)|0,rr=rr+Math.imul(Wr,si)|0,rr=rr+Math.imul(Gr,oi)|0,hr=hr+Math.imul(Gr,si)|0,pr=pr+Math.imul(Fr,ai)|0,rr=rr+Math.imul(Fr,ci)|0,rr=rr+Math.imul(zr,ai)|0,hr=hr+Math.imul(zr,ci)|0,pr=pr+Math.imul(Or,ui)|0,rr=rr+Math.imul(Or,li)|0,rr=rr+Math.imul(Ur,ui)|0,hr=hr+Math.imul(Ur,li)|0;var vi=(kr+pr|0)+((rr&8191)<<13)|0;kr=(hr+(rr>>>13)|0)+(vi>>>26)|0,vi&=67108863,pr=Math.imul(br,Hr),rr=Math.imul(br,Gn),rr=rr+Math.imul(Er,Hr)|0,hr=Math.imul(Er,Gn),pr=pr+Math.imul(dt,Yn)|0,rr=rr+Math.imul(dt,Zn)|0,rr=rr+Math.imul(or,Yn)|0,hr=hr+Math.imul(or,Zn)|0,pr=pr+Math.imul(Un,Xn)|0,rr=rr+Math.imul(Un,Jn)|0,rr=rr+Math.imul(nr,Xn)|0,hr=hr+Math.imul(nr,Jn)|0,pr=pr+Math.imul(Fn,Qn)|0,rr=rr+Math.imul(Fn,ei)|0,rr=rr+Math.imul(Kn,Qn)|0,hr=hr+Math.imul(Kn,ei)|0,pr=pr+Math.imul($n,ti)|0,rr=rr+Math.imul($n,ri)|0,rr=rr+Math.imul(Jr,ti)|0,hr=hr+Math.imul(Jr,ri)|0,pr=pr+Math.imul(Qr,ni)|0,rr=rr+Math.imul(Qr,ii)|0,rr=rr+Math.imul(jn,ni)|0,hr=hr+Math.imul(jn,ii)|0,pr=pr+Math.imul(Xr,oi)|0,rr=rr+Math.imul(Xr,si)|0,rr=rr+Math.imul(Zr,oi)|0,hr=hr+Math.imul(Zr,si)|0,pr=pr+Math.imul(Wr,ai)|0,rr=rr+Math.imul(Wr,ci)|0,rr=rr+Math.imul(Gr,ai)|0,hr=hr+Math.imul(Gr,ci)|0,pr=pr+Math.imul(Fr,ui)|0,rr=rr+Math.imul(Fr,li)|0,rr=rr+Math.imul(zr,ui)|0,hr=hr+Math.imul(zr,li)|0;var Si=(kr+pr|0)+((rr&8191)<<13)|0;kr=(hr+(rr>>>13)|0)+(Si>>>26)|0,Si&=67108863,pr=Math.imul(br,Yn),rr=Math.imul(br,Zn),rr=rr+Math.imul(Er,Yn)|0,hr=Math.imul(Er,Zn),pr=pr+Math.imul(dt,Xn)|0,rr=rr+Math.imul(dt,Jn)|0,rr=rr+Math.imul(or,Xn)|0,hr=hr+Math.imul(or,Jn)|0,pr=pr+Math.imul(Un,Qn)|0,rr=rr+Math.imul(Un,ei)|0,rr=rr+Math.imul(nr,Qn)|0,hr=hr+Math.imul(nr,ei)|0,pr=pr+Math.imul(Fn,ti)|0,rr=rr+Math.imul(Fn,ri)|0,rr=rr+Math.imul(Kn,ti)|0,hr=hr+Math.imul(Kn,ri)|0,pr=pr+Math.imul($n,ni)|0,rr=rr+Math.imul($n,ii)|0,rr=rr+Math.imul(Jr,ni)|0,hr=hr+Math.imul(Jr,ii)|0,pr=pr+Math.imul(Qr,oi)|0,rr=rr+Math.imul(Qr,si)|0,rr=rr+Math.imul(jn,oi)|0,hr=hr+Math.imul(jn,si)|0,pr=pr+Math.imul(Xr,ai)|0,rr=rr+Math.imul(Xr,ci)|0,rr=rr+Math.imul(Zr,ai)|0,hr=hr+Math.imul(Zr,ci)|0,pr=pr+Math.imul(Wr,ui)|0,rr=rr+Math.imul(Wr,li)|0,rr=rr+Math.imul(Gr,ui)|0,hr=hr+Math.imul(Gr,li)|0;var Ei=(kr+pr|0)+((rr&8191)<<13)|0;kr=(hr+(rr>>>13)|0)+(Ei>>>26)|0,Ei&=67108863,pr=Math.imul(br,Xn),rr=Math.imul(br,Jn),rr=rr+Math.imul(Er,Xn)|0,hr=Math.imul(Er,Jn),pr=pr+Math.imul(dt,Qn)|0,rr=rr+Math.imul(dt,ei)|0,rr=rr+Math.imul(or,Qn)|0,hr=hr+Math.imul(or,ei)|0,pr=pr+Math.imul(Un,ti)|0,rr=rr+Math.imul(Un,ri)|0,rr=rr+Math.imul(nr,ti)|0,hr=hr+Math.imul(nr,ri)|0,pr=pr+Math.imul(Fn,ni)|0,rr=rr+Math.imul(Fn,ii)|0,rr=rr+Math.imul(Kn,ni)|0,hr=hr+Math.imul(Kn,ii)|0,pr=pr+Math.imul($n,oi)|0,rr=rr+Math.imul($n,si)|0,rr=rr+Math.imul(Jr,oi)|0,hr=hr+Math.imul(Jr,si)|0,pr=pr+Math.imul(Qr,ai)|0,rr=rr+Math.imul(Qr,ci)|0,rr=rr+Math.imul(jn,ai)|0,hr=hr+Math.imul(jn,ci)|0,pr=pr+Math.imul(Xr,ui)|0,rr=rr+Math.imul(Xr,li)|0,rr=rr+Math.imul(Zr,ui)|0,hr=hr+Math.imul(Zr,li)|0;var xi=(kr+pr|0)+((rr&8191)<<13)|0;kr=(hr+(rr>>>13)|0)+(xi>>>26)|0,xi&=67108863,pr=Math.imul(br,Qn),rr=Math.imul(br,ei),rr=rr+Math.imul(Er,Qn)|0,hr=Math.imul(Er,ei),pr=pr+Math.imul(dt,ti)|0,rr=rr+Math.imul(dt,ri)|0,rr=rr+Math.imul(or,ti)|0,hr=hr+Math.imul(or,ri)|0,pr=pr+Math.imul(Un,ni)|0,rr=rr+Math.imul(Un,ii)|0,rr=rr+Math.imul(nr,ni)|0,hr=hr+Math.imul(nr,ii)|0,pr=pr+Math.imul(Fn,oi)|0,rr=rr+Math.imul(Fn,si)|0,rr=rr+Math.imul(Kn,oi)|0,hr=hr+Math.imul(Kn,si)|0,pr=pr+Math.imul($n,ai)|0,rr=rr+Math.imul($n,ci)|0,rr=rr+Math.imul(Jr,ai)|0,hr=hr+Math.imul(Jr,ci)|0,pr=pr+Math.imul(Qr,ui)|0,rr=rr+Math.imul(Qr,li)|0,rr=rr+Math.imul(jn,ui)|0,hr=hr+Math.imul(jn,li)|0;var Ai=(kr+pr|0)+((rr&8191)<<13)|0;kr=(hr+(rr>>>13)|0)+(Ai>>>26)|0,Ai&=67108863,pr=Math.imul(br,ti),rr=Math.imul(br,ri),rr=rr+Math.imul(Er,ti)|0,hr=Math.imul(Er,ri),pr=pr+Math.imul(dt,ni)|0,rr=rr+Math.imul(dt,ii)|0,rr=rr+Math.imul(or,ni)|0,hr=hr+Math.imul(or,ii)|0,pr=pr+Math.imul(Un,oi)|0,rr=rr+Math.imul(Un,si)|0,rr=rr+Math.imul(nr,oi)|0,hr=hr+Math.imul(nr,si)|0,pr=pr+Math.imul(Fn,ai)|0,rr=rr+Math.imul(Fn,ci)|0,rr=rr+Math.imul(Kn,ai)|0,hr=hr+Math.imul(Kn,ci)|0,pr=pr+Math.imul($n,ui)|0,rr=rr+Math.imul($n,li)|0,rr=rr+Math.imul(Jr,ui)|0,hr=hr+Math.imul(Jr,li)|0;var Ii=(kr+pr|0)+((rr&8191)<<13)|0;kr=(hr+(rr>>>13)|0)+(Ii>>>26)|0,Ii&=67108863,pr=Math.imul(br,ni),rr=Math.imul(br,ii),rr=rr+Math.imul(Er,ni)|0,hr=Math.imul(Er,ii),pr=pr+Math.imul(dt,oi)|0,rr=rr+Math.imul(dt,si)|0,rr=rr+Math.imul(or,oi)|0,hr=hr+Math.imul(or,si)|0,pr=pr+Math.imul(Un,ai)|0,rr=rr+Math.imul(Un,ci)|0,rr=rr+Math.imul(nr,ai)|0,hr=hr+Math.imul(nr,ci)|0,pr=pr+Math.imul(Fn,ui)|0,rr=rr+Math.imul(Fn,li)|0,rr=rr+Math.imul(Kn,ui)|0,hr=hr+Math.imul(Kn,li)|0;var ki=(kr+pr|0)+((rr&8191)<<13)|0;kr=(hr+(rr>>>13)|0)+(ki>>>26)|0,ki&=67108863,pr=Math.imul(br,oi),rr=Math.imul(br,si),rr=rr+Math.imul(Er,oi)|0,hr=Math.imul(Er,si),pr=pr+Math.imul(dt,ai)|0,rr=rr+Math.imul(dt,ci)|0,rr=rr+Math.imul(or,ai)|0,hr=hr+Math.imul(or,ci)|0,pr=pr+Math.imul(Un,ui)|0,rr=rr+Math.imul(Un,li)|0,rr=rr+Math.imul(nr,ui)|0,hr=hr+Math.imul(nr,li)|0;var Ri=(kr+pr|0)+((rr&8191)<<13)|0;kr=(hr+(rr>>>13)|0)+(Ri>>>26)|0,Ri&=67108863,pr=Math.imul(br,ai),rr=Math.imul(br,ci),rr=rr+Math.imul(Er,ai)|0,hr=Math.imul(Er,ci),pr=pr+Math.imul(dt,ui)|0,rr=rr+Math.imul(dt,li)|0,rr=rr+Math.imul(or,ui)|0,hr=hr+Math.imul(or,li)|0;var Ti=(kr+pr|0)+((rr&8191)<<13)|0;kr=(hr+(rr>>>13)|0)+(Ti>>>26)|0,Ti&=67108863,pr=Math.imul(br,ui),rr=Math.imul(br,li),rr=rr+Math.imul(Er,ui)|0,hr=Math.imul(Er,li);var $i=(kr+pr|0)+((rr&8191)<<13)|0;return kr=(hr+(rr>>>13)|0)+($i>>>26)|0,$i&=67108863,xr[0]=di,xr[1]=hi,xr[2]=pi,xr[3]=yi,xr[4]=gi,xr[5]=mi,xr[6]=_i,xr[7]=bi,xr[8]=wi,xr[9]=vi,xr[10]=Si,xr[11]=Ei,xr[12]=xi,xr[13]=Ai,xr[14]=Ii,xr[15]=ki,xr[16]=Ri,xr[17]=Ti,xr[18]=$i,kr!==0&&(xr[19]=kr,lr.length++),lr};Math.imul||(Ar=Sr);function vr(cr,Dt,sr){sr.negative=Dt.negative^cr.negative,sr.length=cr.length+Dt.length;for(var lr=0,gr=0,_r=0;_r<sr.length-1;_r++){var xr=gr;gr=0;for(var kr=lr&67108863,pr=Math.min(_r,Dt.length-1),rr=Math.max(0,_r-cr.length+1);rr<=pr;rr++){var hr=_r-rr,Cr=cr.words[hr]|0,Or=Dt.words[rr]|0,Ur=Cr*Or,qr=Ur&67108863;xr=xr+(Ur/67108864|0)|0,qr=qr+kr|0,kr=qr&67108863,xr=xr+(qr>>>26)|0,gr+=xr>>>26,xr&=67108863}sr.words[_r]=kr,lr=xr,xr=gr}return lr!==0?sr.words[_r]=lr:sr.length--,sr._strip()}function Ir(cr,Dt,sr){return vr(cr,Dt,sr)}Ze.prototype.mulTo=function(Dt,sr){var lr,gr=this.length+Dt.length;return this.length===10&&Dt.length===10?lr=Ar(this,Dt,sr):gr<63?lr=Sr(this,Dt,sr):gr<1024?lr=vr(this,Dt,sr):lr=Ir(this,Dt,sr),lr},Ze.prototype.mul=function(Dt){var sr=new Ze(null);return sr.words=new Array(this.length+Dt.length),this.mulTo(Dt,sr)},Ze.prototype.mulf=function(Dt){var sr=new Ze(null);return sr.words=new Array(this.length+Dt.length),Ir(this,Dt,sr)},Ze.prototype.imul=function(Dt){return this.clone().mulTo(Dt,this)},Ze.prototype.imuln=function(Dt){var sr=Dt<0;sr&&(Dt=-Dt),qe(typeof Dt=="number"),qe(Dt<67108864);for(var lr=0,gr=0;gr<this.length;gr++){var _r=(this.words[gr]|0)*Dt,xr=(_r&67108863)+(lr&67108863);lr>>=26,lr+=_r/67108864|0,lr+=xr>>>26,this.words[gr]=xr&67108863}return lr!==0&&(this.words[gr]=lr,this.length++),sr?this.ineg():this},Ze.prototype.muln=function(Dt){return this.clone().imuln(Dt)},Ze.prototype.sqr=function(){return this.mul(this)},Ze.prototype.isqr=function(){return this.imul(this.clone())},Ze.prototype.pow=function(Dt){var sr=wr(Dt);if(sr.length===0)return new Ze(1);for(var lr=this,gr=0;gr<sr.length&&sr[gr]===0;gr++,lr=lr.sqr());if(++gr<sr.length)for(var _r=lr.sqr();gr<sr.length;gr++,_r=_r.sqr())sr[gr]!==0&&(lr=lr.mul(_r));return lr},Ze.prototype.iushln=function(Dt){qe(typeof Dt=="number"&&Dt>=0);var sr=Dt%26,lr=(Dt-sr)/26,gr=67108863>>>26-sr<<26-sr,_r;if(sr!==0){var xr=0;for(_r=0;_r<this.length;_r++){var kr=this.words[_r]&gr,pr=(this.words[_r]|0)-kr<<sr;this.words[_r]=pr|xr,xr=kr>>>26-sr}xr&&(this.words[_r]=xr,this.length++)}if(lr!==0){for(_r=this.length-1;_r>=0;_r--)this.words[_r+lr]=this.words[_r];for(_r=0;_r<lr;_r++)this.words[_r]=0;this.length+=lr}return this._strip()},Ze.prototype.ishln=function(Dt){return qe(this.negative===0),this.iushln(Dt)},Ze.prototype.iushrn=function(Dt,sr,lr){qe(typeof Dt=="number"&&Dt>=0);var gr;sr?gr=(sr-sr%26)/26:gr=0;var _r=Dt%26,xr=Math.min((Dt-_r)/26,this.length),kr=67108863^67108863>>>_r<<_r,pr=lr;if(gr-=xr,gr=Math.max(0,gr),pr){for(var rr=0;rr<xr;rr++)pr.words[rr]=this.words[rr];pr.length=xr}if(xr!==0)if(this.length>xr)for(this.length-=xr,rr=0;rr<this.length;rr++)this.words[rr]=this.words[rr+xr];else this.words[0]=0,this.length=1;var hr=0;for(rr=this.length-1;rr>=0&&(hr!==0||rr>=gr);rr--){var Cr=this.words[rr]|0;this.words[rr]=hr<<26-_r|Cr>>>_r,hr=Cr&kr}return pr&&hr!==0&&(pr.words[pr.length++]=hr),this.length===0&&(this.words[0]=0,this.length=1),this._strip()},Ze.prototype.ishrn=function(Dt,sr,lr){return qe(this.negative===0),this.iushrn(Dt,sr,lr)},Ze.prototype.shln=function(Dt){return this.clone().ishln(Dt)},Ze.prototype.ushln=function(Dt){return this.clone().iushln(Dt)},Ze.prototype.shrn=function(Dt){return this.clone().ishrn(Dt)},Ze.prototype.ushrn=function(Dt){return this.clone().iushrn(Dt)},Ze.prototype.testn=function(Dt){qe(typeof Dt=="number"&&Dt>=0);var sr=Dt%26,lr=(Dt-sr)/26,gr=1<<sr;if(this.length<=lr)return!1;var _r=this.words[lr];return!!(_r&gr)},Ze.prototype.imaskn=function(Dt){qe(typeof Dt=="number"&&Dt>=0);var sr=Dt%26,lr=(Dt-sr)/26;if(qe(this.negative===0,"imaskn works only with positive numbers"),this.length<=lr)return this;if(sr!==0&&lr++,this.length=Math.min(lr,this.length),sr!==0){var gr=67108863^67108863>>>sr<<sr;this.words[this.length-1]&=gr}return this._strip()},Ze.prototype.maskn=function(Dt){return this.clone().imaskn(Dt)},Ze.prototype.iaddn=function(Dt){return qe(typeof Dt=="number"),qe(Dt<67108864),Dt<0?this.isubn(-Dt):this.negative!==0?this.length===1&&(this.words[0]|0)<=Dt?(this.words[0]=Dt-(this.words[0]|0),this.negative=0,this):(this.negative=0,this.isubn(Dt),this.negative=1,this):this._iaddn(Dt)},Ze.prototype._iaddn=function(Dt){this.words[0]+=Dt;for(var sr=0;sr<this.length&&this.words[sr]>=67108864;sr++)this.words[sr]-=67108864,sr===this.length-1?this.words[sr+1]=1:this.words[sr+1]++;return this.length=Math.max(this.length,sr+1),this},Ze.prototype.isubn=function(Dt){if(qe(typeof Dt=="number"),qe(Dt<67108864),Dt<0)return this.iaddn(-Dt);if(this.negative!==0)return this.negative=0,this.iaddn(Dt),this.negative=1,this;if(this.words[0]-=Dt,this.length===1&&this.words[0]<0)this.words[0]=-this.words[0],this.negative=1;else for(var sr=0;sr<this.length&&this.words[sr]<0;sr++)this.words[sr]+=67108864,this.words[sr+1]-=1;return this._strip()},Ze.prototype.addn=function(Dt){return this.clone().iaddn(Dt)},Ze.prototype.subn=function(Dt){return this.clone().isubn(Dt)},Ze.prototype.iabs=function(){return this.negative=0,this},Ze.prototype.abs=function(){return this.clone().iabs()},Ze.prototype._ishlnsubmul=function(Dt,sr,lr){var gr=Dt.length+lr,_r;this._expand(gr);var xr,kr=0;for(_r=0;_r<Dt.length;_r++){xr=(this.words[_r+lr]|0)+kr;var pr=(Dt.words[_r]|0)*sr;xr-=pr&67108863,kr=(xr>>26)-(pr/67108864|0),this.words[_r+lr]=xr&67108863}for(;_r<this.length-lr;_r++)xr=(this.words[_r+lr]|0)+kr,kr=xr>>26,this.words[_r+lr]=xr&67108863;if(kr===0)return this._strip();for(qe(kr===-1),kr=0,_r=0;_r<this.length;_r++)xr=-(this.words[_r]|0)+kr,kr=xr>>26,this.words[_r]=xr&67108863;return this.negative=1,this._strip()},Ze.prototype._wordDiv=function(Dt,sr){var lr=this.length-Dt.length,gr=this.clone(),_r=Dt,xr=_r.words[_r.length-1]|0,kr=this._countBits(xr);lr=26-kr,lr!==0&&(_r=_r.ushln(lr),gr.iushln(lr),xr=_r.words[_r.length-1]|0);var pr=gr.length-_r.length,rr;if(sr!=="mod"){rr=new Ze(null),rr.length=pr+1,rr.words=new Array(rr.length);for(var hr=0;hr<rr.length;hr++)rr.words[hr]=0}var Cr=gr.clone()._ishlnsubmul(_r,1,pr);Cr.negative===0&&(gr=Cr,rr&&(rr.words[pr]=1));for(var Or=pr-1;Or>=0;Or--){var Ur=(gr.words[_r.length+Or]|0)*67108864+(gr.words[_r.length+Or-1]|0);for(Ur=Math.min(Ur/xr|0,67108863),gr._ishlnsubmul(_r,Ur,Or);gr.negative!==0;)Ur--,gr.negative=0,gr._ishlnsubmul(_r,1,Or),gr.isZero()||(gr.negative^=1);rr&&(rr.words[Or]=Ur)}return rr&&rr._strip(),gr._strip(),sr!=="div"&&lr!==0&&gr.iushrn(lr),{div:rr||null,mod:gr}},Ze.prototype.divmod=function(Dt,sr,lr){if(qe(!Dt.isZero()),this.isZero())return{div:new Ze(0),mod:new Ze(0)};var gr,_r,xr;return this.negative!==0&&Dt.negative===0?(xr=this.neg().divmod(Dt,sr),sr!=="mod"&&(gr=xr.div.neg()),sr!=="div"&&(_r=xr.mod.neg(),lr&&_r.negative!==0&&_r.iadd(Dt)),{div:gr,mod:_r}):this.negative===0&&Dt.negative!==0?(xr=this.divmod(Dt.neg(),sr),sr!=="mod"&&(gr=xr.div.neg()),{div:gr,mod:xr.mod}):(this.negative&Dt.negative)!==0?(xr=this.neg().divmod(Dt.neg(),sr),sr!=="div"&&(_r=xr.mod.neg(),lr&&_r.negative!==0&&_r.isub(Dt)),{div:xr.div,mod:_r}):Dt.length>this.length||this.cmp(Dt)<0?{div:new Ze(0),mod:this}:Dt.length===1?sr==="div"?{div:this.divn(Dt.words[0]),mod:null}:sr==="mod"?{div:null,mod:new Ze(this.modrn(Dt.words[0]))}:{div:this.divn(Dt.words[0]),mod:new Ze(this.modrn(Dt.words[0]))}:this._wordDiv(Dt,sr)},Ze.prototype.div=function(Dt){return this.divmod(Dt,"div",!1).div},Ze.prototype.mod=function(Dt){return this.divmod(Dt,"mod",!1).mod},Ze.prototype.umod=function(Dt){return this.divmod(Dt,"mod",!0).mod},Ze.prototype.divRound=function(Dt){var sr=this.divmod(Dt);if(sr.mod.isZero())return sr.div;var lr=sr.div.negative!==0?sr.mod.isub(Dt):sr.mod,gr=Dt.ushrn(1),_r=Dt.andln(1),xr=lr.cmp(gr);return xr<0||_r===1&&xr===0?sr.div:sr.div.negative!==0?sr.div.isubn(1):sr.div.iaddn(1)},Ze.prototype.modrn=function(Dt){var sr=Dt<0;sr&&(Dt=-Dt),qe(Dt<=67108863);for(var lr=(1<<26)%Dt,gr=0,_r=this.length-1;_r>=0;_r--)gr=(lr*gr+(this.words[_r]|0))%Dt;return sr?-gr:gr},Ze.prototype.modn=function(Dt){return this.modrn(Dt)},Ze.prototype.idivn=function(Dt){var sr=Dt<0;sr&&(Dt=-Dt),qe(Dt<=67108863);for(var lr=0,gr=this.length-1;gr>=0;gr--){var _r=(this.words[gr]|0)+lr*67108864;this.words[gr]=_r/Dt|0,lr=_r%Dt}return this._strip(),sr?this.ineg():this},Ze.prototype.divn=function(Dt){return this.clone().idivn(Dt)},Ze.prototype.egcd=function(Dt){qe(Dt.negative===0),qe(!Dt.isZero());var sr=this,lr=Dt.clone();sr.negative!==0?sr=sr.umod(Dt):sr=sr.clone();for(var gr=new Ze(1),_r=new Ze(0),xr=new Ze(0),kr=new Ze(1),pr=0;sr.isEven()&&lr.isEven();)sr.iushrn(1),lr.iushrn(1),++pr;for(var rr=lr.clone(),hr=sr.clone();!sr.isZero();){for(var Cr=0,Or=1;(sr.words[0]&Or)===0&&Cr<26;++Cr,Or<<=1);if(Cr>0)for(sr.iushrn(Cr);Cr-- >0;)(gr.isOdd()||_r.isOdd())&&(gr.iadd(rr),_r.isub(hr)),gr.iushrn(1),_r.iushrn(1);for(var Ur=0,qr=1;(lr.words[0]&qr)===0&&Ur<26;++Ur,qr<<=1);if(Ur>0)for(lr.iushrn(Ur);Ur-- >0;)(xr.isOdd()||kr.isOdd())&&(xr.iadd(rr),kr.isub(hr)),xr.iushrn(1),kr.iushrn(1);sr.cmp(lr)>=0?(sr.isub(lr),gr.isub(xr),_r.isub(kr)):(lr.isub(sr),xr.isub(gr),kr.isub(_r))}return{a:xr,b:kr,gcd:lr.iushln(pr)}},Ze.prototype._invmp=function(Dt){qe(Dt.negative===0),qe(!Dt.isZero());var sr=this,lr=Dt.clone();sr.negative!==0?sr=sr.umod(Dt):sr=sr.clone();for(var gr=new Ze(1),_r=new Ze(0),xr=lr.clone();sr.cmpn(1)>0&&lr.cmpn(1)>0;){for(var kr=0,pr=1;(sr.words[0]&pr)===0&&kr<26;++kr,pr<<=1);if(kr>0)for(sr.iushrn(kr);kr-- >0;)gr.isOdd()&&gr.iadd(xr),gr.iushrn(1);for(var rr=0,hr=1;(lr.words[0]&hr)===0&&rr<26;++rr,hr<<=1);if(rr>0)for(lr.iushrn(rr);rr-- >0;)_r.isOdd()&&_r.iadd(xr),_r.iushrn(1);sr.cmp(lr)>=0?(sr.isub(lr),gr.isub(_r)):(lr.isub(sr),_r.isub(gr))}var Cr;return sr.cmpn(1)===0?Cr=gr:Cr=_r,Cr.cmpn(0)<0&&Cr.iadd(Dt),Cr},Ze.prototype.gcd=function(Dt){if(this.isZero())return Dt.abs();if(Dt.isZero())return this.abs();var sr=this.clone(),lr=Dt.clone();sr.negative=0,lr.negative=0;for(var gr=0;sr.isEven()&&lr.isEven();gr++)sr.iushrn(1),lr.iushrn(1);do{for(;sr.isEven();)sr.iushrn(1);for(;lr.isEven();)lr.iushrn(1);var _r=sr.cmp(lr);if(_r<0){var xr=sr;sr=lr,lr=xr}else if(_r===0||lr.cmpn(1)===0)break;sr.isub(lr)}while(!0);return lr.iushln(gr)},Ze.prototype.invm=function(Dt){return this.egcd(Dt).a.umod(Dt)},Ze.prototype.isEven=function(){return(this.words[0]&1)===0},Ze.prototype.isOdd=function(){return(this.words[0]&1)===1},Ze.prototype.andln=function(Dt){return this.words[0]&Dt},Ze.prototype.bincn=function(Dt){qe(typeof Dt=="number");var sr=Dt%26,lr=(Dt-sr)/26,gr=1<<sr;if(this.length<=lr)return this._expand(lr+1),this.words[lr]|=gr,this;for(var _r=gr,xr=lr;_r!==0&&xr<this.length;xr++){var kr=this.words[xr]|0;kr+=_r,_r=kr>>>26,kr&=67108863,this.words[xr]=kr}return _r!==0&&(this.words[xr]=_r,this.length++),this},Ze.prototype.isZero=function(){return this.length===1&&this.words[0]===0},Ze.prototype.cmpn=function(Dt){var sr=Dt<0;if(this.negative!==0&&!sr)return-1;if(this.negative===0&&sr)return 1;this._strip();var lr;if(this.length>1)lr=1;else{sr&&(Dt=-Dt),qe(Dt<=67108863,"Number is too big");var gr=this.words[0]|0;lr=gr===Dt?0:gr<Dt?-1:1}return this.negative!==0?-lr|0:lr},Ze.prototype.cmp=function(Dt){if(this.negative!==0&&Dt.negative===0)return-1;if(this.negative===0&&Dt.negative!==0)return 1;var sr=this.ucmp(Dt);return this.negative!==0?-sr|0:sr},Ze.prototype.ucmp=function(Dt){if(this.length>Dt.length)return 1;if(this.length<Dt.length)return-1;for(var sr=0,lr=this.length-1;lr>=0;lr--){var gr=this.words[lr]|0,_r=Dt.words[lr]|0;if(gr!==_r){gr<_r?sr=-1:gr>_r&&(sr=1);break}}return sr},Ze.prototype.gtn=function(Dt){return this.cmpn(Dt)===1},Ze.prototype.gt=function(Dt){return this.cmp(Dt)===1},Ze.prototype.gten=function(Dt){return this.cmpn(Dt)>=0},Ze.prototype.gte=function(Dt){return this.cmp(Dt)>=0},Ze.prototype.ltn=function(Dt){return this.cmpn(Dt)===-1},Ze.prototype.lt=function(Dt){return this.cmp(Dt)===-1},Ze.prototype.lten=function(Dt){return this.cmpn(Dt)<=0},Ze.prototype.lte=function(Dt){return this.cmp(Dt)<=0},Ze.prototype.eqn=function(Dt){return this.cmpn(Dt)===0},Ze.prototype.eq=function(Dt){return this.cmp(Dt)===0},Ze.red=function(Dt){return new $r(Dt)},Ze.prototype.toRed=function(Dt){return qe(!this.red,"Already a number in reduction context"),qe(this.negative===0,"red works only with positives"),Dt.convertTo(this)._forceRed(Dt)},Ze.prototype.fromRed=function(){return qe(this.red,"fromRed works only with numbers in reduction context"),this.red.convertFrom(this)},Ze.prototype._forceRed=function(Dt){return this.red=Dt,this},Ze.prototype.forceRed=function(Dt){return qe(!this.red,"Already a number in reduction context"),this._forceRed(Dt)},Ze.prototype.redAdd=function(Dt){return qe(this.red,"redAdd works only with red numbers"),this.red.add(this,Dt)},Ze.prototype.redIAdd=function(Dt){return qe(this.red,"redIAdd works only with red numbers"),this.red.iadd(this,Dt)},Ze.prototype.redSub=function(Dt){return qe(this.red,"redSub works only with red numbers"),this.red.sub(this,Dt)},Ze.prototype.redISub=function(Dt){return qe(this.red,"redISub works only with red numbers"),this.red.isub(this,Dt)},Ze.prototype.redShl=function(Dt){return qe(this.red,"redShl works only with red numbers"),this.red.shl(this,Dt)},Ze.prototype.redMul=function(Dt){return qe(this.red,"redMul works only with red numbers"),this.red._verify2(this,Dt),this.red.mul(this,Dt)},Ze.prototype.redIMul=function(Dt){return qe(this.red,"redMul works only with red numbers"),this.red._verify2(this,Dt),this.red.imul(this,Dt)},Ze.prototype.redSqr=function(){return qe(this.red,"redSqr works only with red numbers"),this.red._verify1(this),this.red.sqr(this)},Ze.prototype.redISqr=function(){return qe(this.red,"redISqr works only with red numbers"),this.red._verify1(this),this.red.isqr(this)},Ze.prototype.redSqrt=function(){return qe(this.red,"redSqrt works only with red numbers"),this.red._verify1(this),this.red.sqrt(this)},Ze.prototype.redInvm=function(){return qe(this.red,"redInvm works only with red numbers"),this.red._verify1(this),this.red.invm(this)},Ze.prototype.redNeg=function(){return qe(this.red,"redNeg works only with red numbers"),this.red._verify1(this),this.red.neg(this)},Ze.prototype.redPow=function(Dt){return qe(this.red&&!Dt.red,"redPow(normalNum)"),this.red._verify1(this),this.red.pow(this,Dt)};var Tr={k256:null,p224:null,p192:null,p25519:null};function Pr(cr,Dt){this.name=cr,this.p=new Ze(Dt,16),this.n=this.p.bitLength(),this.k=new Ze(1).iushln(this.n).isub(this.p),this.tmp=this._tmp()}Pr.prototype._tmp=function(){var Dt=new Ze(null);return Dt.words=new Array(Math.ceil(this.n/13)),Dt},Pr.prototype.ireduce=function(Dt){var sr=Dt,lr;do this.split(sr,this.tmp),sr=this.imulK(sr),sr=sr.iadd(this.tmp),lr=sr.bitLength();while(lr>this.n);var gr=lr<this.n?-1:sr.ucmp(this.p);return gr===0?(sr.words[0]=0,sr.length=1):gr>0?sr.isub(this.p):sr.strip!==void 0?sr.strip():sr._strip(),sr},Pr.prototype.split=function(Dt,sr){Dt.iushrn(this.n,0,sr)},Pr.prototype.imulK=function(Dt){return Dt.imul(this.k)};function Rr(){Pr.call(this,"k256","ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f")}We(Rr,Pr),Rr.prototype.split=function(Dt,sr){for(var lr=4194303,gr=Math.min(Dt.length,9),_r=0;_r<gr;_r++)sr.words[_r]=Dt.words[_r];if(sr.length=gr,Dt.length<=9){Dt.words[0]=0,Dt.length=1;return}var xr=Dt.words[9];for(sr.words[sr.length++]=xr&lr,_r=10;_r<Dt.length;_r++){var kr=Dt.words[_r]|0;Dt.words[_r-10]=(kr&lr)<<4|xr>>>22,xr=kr}xr>>>=22,Dt.words[_r-10]=xr,xr===0&&Dt.length>10?Dt.length-=10:Dt.length-=9},Rr.prototype.imulK=function(Dt){Dt.words[Dt.length]=0,Dt.words[Dt.length+1]=0,Dt.length+=2;for(var sr=0,lr=0;lr<Dt.length;lr++){var gr=Dt.words[lr]|0;sr+=gr*977,Dt.words[lr]=sr&67108863,sr=gr*64+(sr/67108864|0)}return Dt.words[Dt.length-1]===0&&(Dt.length--,Dt.words[Dt.length-1]===0&&Dt.length--),Dt};function Br(){Pr.call(this,"p224","ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001")}We(Br,Pr);function Mr(){Pr.call(this,"p192","ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff")}We(Mr,Pr);function Lr(){Pr.call(this,"25519","7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed")}We(Lr,Pr),Lr.prototype.imulK=function(Dt){for(var sr=0,lr=0;lr<Dt.length;lr++){var gr=(Dt.words[lr]|0)*19+sr,_r=gr&67108863;gr>>>=26,Dt.words[lr]=_r,sr=gr}return sr!==0&&(Dt.words[Dt.length++]=sr),Dt},Ze._prime=function(Dt){if(Tr[Dt])return Tr[Dt];var sr;if(Dt==="k256")sr=new Rr;else if(Dt==="p224")sr=new Br;else if(Dt==="p192")sr=new Mr;else if(Dt==="p25519")sr=new Lr;else throw new Error("Unknown prime "+Dt);return Tr[Dt]=sr,sr};function $r(cr){if(typeof cr=="string"){var Dt=Ze._prime(cr);this.m=Dt.p,this.prime=Dt}else qe(cr.gtn(1),"modulus must be greater than 1"),this.m=cr,this.prime=null}$r.prototype._verify1=function(Dt){qe(Dt.negative===0,"red works only with positives"),qe(Dt.red,"red works only with red numbers")},$r.prototype._verify2=function(Dt,sr){qe((Dt.negative|sr.negative)===0,"red works only with positives"),qe(Dt.red&&Dt.red===sr.red,"red works only with red numbers")},$r.prototype.imod=function(Dt){return this.prime?this.prime.ireduce(Dt)._forceRed(this):(ir(Dt,Dt.umod(this.m)._forceRed(this)),Dt)},$r.prototype.neg=function(Dt){return Dt.isZero()?Dt.clone():this.m.sub(Dt)._forceRed(this)},$r.prototype.add=function(Dt,sr){this._verify2(Dt,sr);var lr=Dt.add(sr);return lr.cmp(this.m)>=0&&lr.isub(this.m),lr._forceRed(this)},$r.prototype.iadd=function(Dt,sr){this._verify2(Dt,sr);var lr=Dt.iadd(sr);return lr.cmp(this.m)>=0&&lr.isub(this.m),lr},$r.prototype.sub=function(Dt,sr){this._verify2(Dt,sr);var lr=Dt.sub(sr);return lr.cmpn(0)<0&&lr.iadd(this.m),lr._forceRed(this)},$r.prototype.isub=function(Dt,sr){this._verify2(Dt,sr);var lr=Dt.isub(sr);return lr.cmpn(0)<0&&lr.iadd(this.m),lr},$r.prototype.shl=function(Dt,sr){return this._verify1(Dt),this.imod(Dt.ushln(sr))},$r.prototype.imul=function(Dt,sr){return this._verify2(Dt,sr),this.imod(Dt.imul(sr))},$r.prototype.mul=function(Dt,sr){return this._verify2(Dt,sr),this.imod(Dt.mul(sr))},$r.prototype.isqr=function(Dt){return this.imul(Dt,Dt.clone())},$r.prototype.sqr=function(Dt){return this.mul(Dt,Dt)},$r.prototype.sqrt=function(Dt){if(Dt.isZero())return Dt.clone();var sr=this.m.andln(3);if(qe(sr%2===1),sr===3){var lr=this.m.add(new Ze(1)).iushrn(2);return this.pow(Dt,lr)}for(var gr=this.m.subn(1),_r=0;!gr.isZero()&&gr.andln(1)===0;)_r++,gr.iushrn(1);qe(!gr.isZero());var xr=new Ze(1).toRed(this),kr=xr.redNeg(),pr=this.m.subn(1).iushrn(1),rr=this.m.bitLength();for(rr=new Ze(2*rr*rr).toRed(this);this.pow(rr,pr).cmp(kr)!==0;)rr.redIAdd(kr);for(var hr=this.pow(rr,gr),Cr=this.pow(Dt,gr.addn(1).iushrn(1)),Or=this.pow(Dt,gr),Ur=_r;Or.cmp(xr)!==0;){for(var qr=Or,Fr=0;qr.cmp(xr)!==0;Fr++)qr=qr.redSqr();qe(Fr<Ur);var zr=this.pow(hr,new Ze(1).iushln(Ur-Fr-1));Cr=Cr.redMul(zr),hr=zr.redSqr(),Or=Or.redMul(hr),Ur=Fr}return Cr},$r.prototype.invm=function(Dt){var sr=Dt._invmp(this.m);return sr.negative!==0?(sr.negative=0,this.imod(sr).redNeg()):this.imod(sr)},$r.prototype.pow=function(Dt,sr){if(sr.isZero())return new Ze(1).toRed(this);if(sr.cmpn(1)===0)return Dt.clone();var lr=4,gr=new Array(1<<lr);gr[0]=new Ze(1).toRed(this),gr[1]=Dt;for(var _r=2;_r<gr.length;_r++)gr[_r]=this.mul(gr[_r-1],Dt);var xr=gr[0],kr=0,pr=0,rr=sr.bitLength()%26;for(rr===0&&(rr=26),_r=sr.length-1;_r>=0;_r--){for(var hr=sr.words[_r],Cr=rr-1;Cr>=0;Cr--){var Or=hr>>Cr&1;if(xr!==gr[0]&&(xr=this.sqr(xr)),Or===0&&kr===0){pr=0;continue}kr<<=1,kr|=Or,pr++,!(pr!==lr&&(_r!==0||Cr!==0))&&(xr=this.mul(xr,gr[kr]),pr=0,kr=0)}rr=26}return xr},$r.prototype.convertTo=function(Dt){var sr=Dt.umod(this.m);return sr===Dt?sr.clone():sr},$r.prototype.convertFrom=function(Dt){var sr=Dt.clone();return sr.red=null,sr},Ze.mont=function(Dt){return new Nr(Dt)};function Nr(cr){$r.call(this,cr),this.shift=this.m.bitLength(),this.shift%26!==0&&(this.shift+=26-this.shift%26),this.r=new Ze(1).iushln(this.shift),this.r2=this.imod(this.r.sqr()),this.rinv=this.r._invmp(this.m),this.minv=this.rinv.mul(this.r).isubn(1).div(this.m),this.minv=this.minv.umod(this.r),this.minv=this.r.sub(this.minv)}We(Nr,$r),Nr.prototype.convertTo=function(Dt){return this.imod(Dt.ushln(this.shift))},Nr.prototype.convertFrom=function(Dt){var sr=this.imod(Dt.mul(this.rinv));return sr.red=null,sr},Nr.prototype.imul=function(Dt,sr){if(Dt.isZero()||sr.isZero())return Dt.words[0]=0,Dt.length=1,Dt;var lr=Dt.imul(sr),gr=lr.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),_r=lr.isub(gr).iushrn(this.shift),xr=_r;return _r.cmp(this.m)>=0?xr=_r.isub(this.m):_r.cmpn(0)<0&&(xr=_r.iadd(this.m)),xr._forceRed(this)},Nr.prototype.mul=function(Dt,sr){if(Dt.isZero()||sr.isZero())return new Ze(0)._forceRed(this);var lr=Dt.mul(sr),gr=lr.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),_r=lr.isub(gr).iushrn(this.shift),xr=_r;return _r.cmp(this.m)>=0?xr=_r.isub(this.m):_r.cmpn(0)<0&&(xr=_r.iadd(this.m)),xr._forceRed(this)},Nr.prototype.invm=function(Dt){var sr=this.imod(Dt._invmp(this.m).mul(this.r2));return sr._forceRed(this)}})(Ke,commonjsGlobal)})(bn$1);const u=bn$1.exports;var safeBuffer={exports:{}};/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */(function(Ke,Re){var Fe=buffer,qe=Fe.Buffer;function We(Xe,Je){for(var tr in Xe)Je[tr]=Xe[tr]}qe.from&&qe.alloc&&qe.allocUnsafe&&qe.allocUnsafeSlow?Ke.exports=Fe:(We(Fe,Re),Re.Buffer=Ze);function Ze(Xe,Je,tr){return qe(Xe,Je,tr)}Ze.prototype=Object.create(qe.prototype),We(qe,Ze),Ze.from=function(Xe,Je,tr){if(typeof Xe=="number")throw new TypeError("Argument must not be a number");return qe(Xe,Je,tr)},Ze.alloc=function(Xe,Je,tr){if(typeof Xe!="number")throw new TypeError("Argument must be a number");var er=qe(Xe);return Je!==void 0?typeof tr=="string"?er.fill(Je,tr):er.fill(Je):er.fill(0),er},Ze.allocUnsafe=function(Xe){if(typeof Xe!="number")throw new TypeError("Argument must be a number");return qe(Xe)},Ze.allocUnsafeSlow=function(Xe){if(typeof Xe!="number")throw new TypeError("Argument must be a number");return Fe.SlowBuffer(Xe)}})(safeBuffer,safeBuffer.exports);var _Buffer=safeBuffer.exports.Buffer;function base$1(Ke){if(Ke.length>=255)throw new TypeError("Alphabet too long");for(var Re=new Uint8Array(256),Fe=0;Fe<Re.length;Fe++)Re[Fe]=255;for(var qe=0;qe<Ke.length;qe++){var We=Ke.charAt(qe),Ze=We.charCodeAt(0);if(Re[Ze]!==255)throw new TypeError(We+" is ambiguous");Re[Ze]=qe}var Xe=Ke.length,Je=Ke.charAt(0),tr=Math.log(Xe)/Math.log(256),er=Math.log(256)/Math.log(Xe);function ir(ar){if((Array.isArray(ar)||ar instanceof Uint8Array)&&(ar=_Buffer.from(ar)),!_Buffer.isBuffer(ar))throw new TypeError("Expected Buffer");if(ar.length===0)return"";for(var yr=0,mr=0,wr=0,Sr=ar.length;wr!==Sr&&ar[wr]===0;)wr++,yr++;for(var Ar=(Sr-wr)*er+1>>>0,vr=new Uint8Array(Ar);wr!==Sr;){for(var Ir=ar[wr],Tr=0,Pr=Ar-1;(Ir!==0||Tr<mr)&&Pr!==-1;Pr--,Tr++)Ir+=256*vr[Pr]>>>0,vr[Pr]=Ir%Xe>>>0,Ir=Ir/Xe>>>0;if(Ir!==0)throw new Error("Non-zero carry");mr=Tr,wr++}for(var Rr=Ar-mr;Rr!==Ar&&vr[Rr]===0;)Rr++;for(var Br=Je.repeat(yr);Rr<Ar;++Rr)Br+=Ke.charAt(vr[Rr]);return Br}function ur(ar){if(typeof ar!="string")throw new TypeError("Expected String");if(ar.length===0)return _Buffer.alloc(0);for(var yr=0,mr=0,wr=0;ar[yr]===Je;)mr++,yr++;for(var Sr=(ar.length-yr)*tr+1>>>0,Ar=new Uint8Array(Sr);ar[yr];){var vr=Re[ar.charCodeAt(yr)];if(vr===255)return;for(var Ir=0,Tr=Sr-1;(vr!==0||Ir<wr)&&Tr!==-1;Tr--,Ir++)vr+=Xe*Ar[Tr]>>>0,Ar[Tr]=vr%256>>>0,vr=vr/256>>>0;if(vr!==0)throw new Error("Non-zero carry");wr=Ir,yr++}for(var Pr=Sr-wr;Pr!==Sr&&Ar[Pr]===0;)Pr++;var Rr=_Buffer.allocUnsafe(mr+(Sr-Pr));Rr.fill(0,0,mr);for(var Br=mr;Pr!==Sr;)Rr[Br++]=Ar[Pr++];return Rr}function fr(ar){var yr=ur(ar);if(yr)return yr;throw new Error("Non-base"+Xe+" character")}return{encode:ir,decodeUnsafe:ur,decode:fr}}var src=base$1,basex=src,ALPHABET="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz",bs58=basex(ALPHABET);const Chi=(Ke,Re,Fe)=>Ke&Re^~Ke&Fe,Maj=(Ke,Re,Fe)=>Ke&Re^Ke&Fe^Re&Fe,SHA256_K=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),IV=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),SHA256_W=new Uint32Array(64);class SHA256 extends SHA2{constructor(){super(64,32,8,!1),this.A=IV[0]|0,this.B=IV[1]|0,this.C=IV[2]|0,this.D=IV[3]|0,this.E=IV[4]|0,this.F=IV[5]|0,this.G=IV[6]|0,this.H=IV[7]|0}get(){const{A:Re,B:Fe,C:qe,D:We,E:Ze,F:Xe,G:Je,H:tr}=this;return[Re,Fe,qe,We,Ze,Xe,Je,tr]}set(Re,Fe,qe,We,Ze,Xe,Je,tr){this.A=Re|0,this.B=Fe|0,this.C=qe|0,this.D=We|0,this.E=Ze|0,this.F=Xe|0,this.G=Je|0,this.H=tr|0}process(Re,Fe){for(let ur=0;ur<16;ur++,Fe+=4)SHA256_W[ur]=Re.getUint32(Fe,!1);for(let ur=16;ur<64;ur++){const fr=SHA256_W[ur-15],ar=SHA256_W[ur-2],yr=rotr(fr,7)^rotr(fr,18)^fr>>>3,mr=rotr(ar,17)^rotr(ar,19)^ar>>>10;SHA256_W[ur]=mr+SHA256_W[ur-7]+yr+SHA256_W[ur-16]|0}let{A:qe,B:We,C:Ze,D:Xe,E:Je,F:tr,G:er,H:ir}=this;for(let ur=0;ur<64;ur++){const fr=rotr(Je,6)^rotr(Je,11)^rotr(Je,25),ar=ir+fr+Chi(Je,tr,er)+SHA256_K[ur]+SHA256_W[ur]|0,mr=(rotr(qe,2)^rotr(qe,13)^rotr(qe,22))+Maj(qe,We,Ze)|0;ir=er,er=tr,tr=Je,Je=Xe+ar|0,Xe=Ze,Ze=We,We=qe,qe=ar+mr|0}qe=qe+this.A|0,We=We+this.B|0,Ze=Ze+this.C|0,Xe=Xe+this.D|0,Je=Je+this.E|0,tr=tr+this.F|0,er=er+this.G|0,ir=ir+this.H|0,this.set(qe,We,Ze,Xe,Je,tr,er,ir)}roundClean(){SHA256_W.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}const sha256$1=wrapConstructor(()=>new SHA256);var lib$1={};function inRange(Ke,Re,Fe){return Re<=Ke&&Ke<=Fe}function ToDictionary(Ke){if(Ke===void 0)return{};if(Ke===Object(Ke))return Ke;throw TypeError("Could not convert argument to dictionary")}function stringToCodePoints(Ke){for(var Re=String(Ke),Fe=Re.length,qe=0,We=[];qe<Fe;){var Ze=Re.charCodeAt(qe);if(Ze<55296||Ze>57343)We.push(Ze);else if(56320<=Ze&&Ze<=57343)We.push(65533);else if(55296<=Ze&&Ze<=56319)if(qe===Fe-1)We.push(65533);else{var Xe=Ke.charCodeAt(qe+1);if(56320<=Xe&&Xe<=57343){var Je=Ze&1023,tr=Xe&1023;We.push(65536+(Je<<10)+tr),qe+=1}else We.push(65533)}qe+=1}return We}function codePointsToString(Ke){for(var Re="",Fe=0;Fe<Ke.length;++Fe){var qe=Ke[Fe];qe<=65535?Re+=String.fromCharCode(qe):(qe-=65536,Re+=String.fromCharCode((qe>>10)+55296,(qe&1023)+56320))}return Re}var end_of_stream=-1;function Stream(Ke){this.tokens=[].slice.call(Ke)}Stream.prototype={endOfStream:function(){return!this.tokens.length},read:function(){return this.tokens.length?this.tokens.shift():end_of_stream},prepend:function(Ke){if(Array.isArray(Ke))for(var Re=Ke;Re.length;)this.tokens.unshift(Re.pop());else this.tokens.unshift(Ke)},push:function(Ke){if(Array.isArray(Ke))for(var Re=Ke;Re.length;)this.tokens.push(Re.shift());else this.tokens.push(Ke)}};var finished=-1;function decoderError(Ke,Re){if(Ke)throw TypeError("Decoder error");return Re||65533}var DEFAULT_ENCODING="utf-8";function TextDecoder$1(Ke,Re){if(!(this instanceof TextDecoder$1))return new TextDecoder$1(Ke,Re);if(Ke=Ke!==void 0?String(Ke).toLowerCase():DEFAULT_ENCODING,Ke!==DEFAULT_ENCODING)throw new Error("Encoding not supported. Only utf-8 is supported");Re=ToDictionary(Re),this._streaming=!1,this._BOMseen=!1,this._decoder=null,this._fatal=Boolean(Re.fatal),this._ignoreBOM=Boolean(Re.ignoreBOM),Object.defineProperty(this,"encoding",{value:"utf-8"}),Object.defineProperty(this,"fatal",{value:this._fatal}),Object.defineProperty(this,"ignoreBOM",{value:this._ignoreBOM})}TextDecoder$1.prototype={decode:function(Re,Fe){var qe;typeof Re=="object"&&Re instanceof ArrayBuffer?qe=new Uint8Array(Re):typeof Re=="object"&&"buffer"in Re&&Re.buffer instanceof ArrayBuffer?qe=new Uint8Array(Re.buffer,Re.byteOffset,Re.byteLength):qe=new Uint8Array(0),Fe=ToDictionary(Fe),this._streaming||(this._decoder=new UTF8Decoder({fatal:this._fatal}),this._BOMseen=!1),this._streaming=Boolean(Fe.stream);for(var We=new Stream(qe),Ze=[],Xe;!We.endOfStream()&&(Xe=this._decoder.handler(We,We.read()),Xe!==finished);)Xe!==null&&(Array.isArray(Xe)?Ze.push.apply(Ze,Xe):Ze.push(Xe));if(!this._streaming){do{if(Xe=this._decoder.handler(We,We.read()),Xe===finished)break;Xe!==null&&(Array.isArray(Xe)?Ze.push.apply(Ze,Xe):Ze.push(Xe))}while(!We.endOfStream());this._decoder=null}return Ze.length&&["utf-8"].indexOf(this.encoding)!==-1&&!this._ignoreBOM&&!this._BOMseen&&(Ze[0]===65279?(this._BOMseen=!0,Ze.shift()):this._BOMseen=!0),codePointsToString(Ze)}};function TextEncoder$1(Ke,Re){if(!(this instanceof TextEncoder$1))return new TextEncoder$1(Ke,Re);if(Ke=Ke!==void 0?String(Ke).toLowerCase():DEFAULT_ENCODING,Ke!==DEFAULT_ENCODING)throw new Error("Encoding not supported. Only utf-8 is supported");Re=ToDictionary(Re),this._streaming=!1,this._encoder=null,this._options={fatal:Boolean(Re.fatal)},Object.defineProperty(this,"encoding",{value:"utf-8"})}TextEncoder$1.prototype={encode:function(Re,Fe){Re=Re?String(Re):"",Fe=ToDictionary(Fe),this._streaming||(this._encoder=new UTF8Encoder(this._options)),this._streaming=Boolean(Fe.stream);for(var qe=[],We=new Stream(stringToCodePoints(Re)),Ze;!We.endOfStream()&&(Ze=this._encoder.handler(We,We.read()),Ze!==finished);)Array.isArray(Ze)?qe.push.apply(qe,Ze):qe.push(Ze);if(!this._streaming){for(;Ze=this._encoder.handler(We,We.read()),Ze!==finished;)Array.isArray(Ze)?qe.push.apply(qe,Ze):qe.push(Ze);this._encoder=null}return new Uint8Array(qe)}};function UTF8Decoder(Ke){var Re=Ke.fatal,Fe=0,qe=0,We=0,Ze=128,Xe=191;this.handler=function(Je,tr){if(tr===end_of_stream&&We!==0)return We=0,decoderError(Re);if(tr===end_of_stream)return finished;if(We===0){if(inRange(tr,0,127))return tr;if(inRange(tr,194,223))We=1,Fe=tr-192;else if(inRange(tr,224,239))tr===224&&(Ze=160),tr===237&&(Xe=159),We=2,Fe=tr-224;else if(inRange(tr,240,244))tr===240&&(Ze=144),tr===244&&(Xe=143),We=3,Fe=tr-240;else return decoderError(Re);return Fe=Fe<<6*We,null}if(!inRange(tr,Ze,Xe))return Fe=We=qe=0,Ze=128,Xe=191,Je.prepend(tr),decoderError(Re);if(Ze=128,Xe=191,qe+=1,Fe+=tr-128<<6*(We-qe),qe!==We)return null;var er=Fe;return Fe=We=qe=0,er}}function UTF8Encoder(Ke){Ke.fatal,this.handler=function(Re,Fe){if(Fe===end_of_stream)return finished;if(inRange(Fe,0,127))return Fe;var qe,We;inRange(Fe,128,2047)?(qe=1,We=192):inRange(Fe,2048,65535)?(qe=2,We=224):inRange(Fe,65536,1114111)&&(qe=3,We=240);for(var Ze=[(Fe>>6*qe)+We];qe>0;){var Xe=Fe>>6*(qe-1);Ze.push(128|Xe&63),qe-=1}return Ze}}const encoding$1=Object.freeze(Object.defineProperty({__proto__:null,TextEncoder:TextEncoder$1,TextDecoder:TextDecoder$1},Symbol.toStringTag,{value:"Module"})),require$$2=getAugmentedNamespace(encoding$1);var __createBinding=commonjsGlobal&&commonjsGlobal.__createBinding||(Object.create?function(Ke,Re,Fe,qe){qe===void 0&&(qe=Fe),Object.defineProperty(Ke,qe,{enumerable:!0,get:function(){return Re[Fe]}})}:function(Ke,Re,Fe,qe){qe===void 0&&(qe=Fe),Ke[qe]=Re[Fe]}),__setModuleDefault=commonjsGlobal&&commonjsGlobal.__setModuleDefault||(Object.create?function(Ke,Re){Object.defineProperty(Ke,"default",{enumerable:!0,value:Re})}:function(Ke,Re){Ke.default=Re}),__decorate=commonjsGlobal&&commonjsGlobal.__decorate||function(Ke,Re,Fe,qe){var We=arguments.length,Ze=We<3?Re:qe===null?qe=Object.getOwnPropertyDescriptor(Re,Fe):qe,Xe;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")Ze=Reflect.decorate(Ke,Re,Fe,qe);else for(var Je=Ke.length-1;Je>=0;Je--)(Xe=Ke[Je])&&(Ze=(We<3?Xe(Ze):We>3?Xe(Re,Fe,Ze):Xe(Re,Fe))||Ze);return We>3&&Ze&&Object.defineProperty(Re,Fe,Ze),Ze},__importStar=commonjsGlobal&&commonjsGlobal.__importStar||function(Ke){if(Ke&&Ke.__esModule)return Ke;var Re={};if(Ke!=null)for(var Fe in Ke)Fe!=="default"&&Object.hasOwnProperty.call(Ke,Fe)&&__createBinding(Re,Ke,Fe);return __setModuleDefault(Re,Ke),Re},__importDefault=commonjsGlobal&&commonjsGlobal.__importDefault||function(Ke){return Ke&&Ke.__esModule?Ke:{default:Ke}};Object.defineProperty(lib$1,"__esModule",{value:!0});var deserializeUnchecked_1=lib$1.deserializeUnchecked=deserialize_1=lib$1.deserialize=serialize_1=lib$1.serialize=lib$1.BinaryReader=lib$1.BinaryWriter=lib$1.BorshError=lib$1.baseDecode=lib$1.baseEncode=void 0;const bn_js_1=__importDefault(bn$1.exports),bs58_1=__importDefault(bs58),encoding=__importStar(require$$2),ResolvedTextDecoder=typeof TextDecoder!="function"?encoding.TextDecoder:TextDecoder,textDecoder=new ResolvedTextDecoder("utf-8",{fatal:!0});function baseEncode(Ke){return typeof Ke=="string"&&(Ke=Buffer.from(Ke,"utf8")),bs58_1.default.encode(Buffer.from(Ke))}lib$1.baseEncode=baseEncode;function baseDecode(Ke){return Buffer.from(bs58_1.default.decode(Ke))}lib$1.baseDecode=baseDecode;const INITIAL_LENGTH=1024;class BorshError extends Error{constructor(Re){super(Re),this.fieldPath=[],this.originalMessage=Re}addToFieldPath(Re){this.fieldPath.splice(0,0,Re),this.message=this.originalMessage+": "+this.fieldPath.join(".")}}lib$1.BorshError=BorshError;class BinaryWriter{constructor(){this.buf=Buffer.alloc(INITIAL_LENGTH),this.length=0}maybeResize(){this.buf.length<16+this.length&&(this.buf=Buffer.concat([this.buf,Buffer.alloc(INITIAL_LENGTH)]))}writeU8(Re){this.maybeResize(),this.buf.writeUInt8(Re,this.length),this.length+=1}writeU16(Re){this.maybeResize(),this.buf.writeUInt16LE(Re,this.length),this.length+=2}writeU32(Re){this.maybeResize(),this.buf.writeUInt32LE(Re,this.length),this.length+=4}writeU64(Re){this.maybeResize(),this.writeBuffer(Buffer.from(new bn_js_1.default(Re).toArray("le",8)))}writeU128(Re){this.maybeResize(),this.writeBuffer(Buffer.from(new bn_js_1.default(Re).toArray("le",16)))}writeU256(Re){this.maybeResize(),this.writeBuffer(Buffer.from(new bn_js_1.default(Re).toArray("le",32)))}writeU512(Re){this.maybeResize(),this.writeBuffer(Buffer.from(new bn_js_1.default(Re).toArray("le",64)))}writeBuffer(Re){this.buf=Buffer.concat([Buffer.from(this.buf.subarray(0,this.length)),Re,Buffer.alloc(INITIAL_LENGTH)]),this.length+=Re.length}writeString(Re){this.maybeResize();const Fe=Buffer.from(Re,"utf8");this.writeU32(Fe.length),this.writeBuffer(Fe)}writeFixedArray(Re){this.writeBuffer(Buffer.from(Re))}writeArray(Re,Fe){this.maybeResize(),this.writeU32(Re.length);for(const qe of Re)this.maybeResize(),Fe(qe)}toArray(){return this.buf.subarray(0,this.length)}}lib$1.BinaryWriter=BinaryWriter;function handlingRangeError(Ke,Re,Fe){const qe=Fe.value;Fe.value=function(...We){try{return qe.apply(this,We)}catch(Ze){if(Ze instanceof RangeError){const Xe=Ze.code;if(["ERR_BUFFER_OUT_OF_BOUNDS","ERR_OUT_OF_RANGE"].indexOf(Xe)>=0)throw new BorshError("Reached the end of buffer when deserializing")}throw Ze}}}class BinaryReader{constructor(Re){this.buf=Re,this.offset=0}readU8(){const Re=this.buf.readUInt8(this.offset);return this.offset+=1,Re}readU16(){const Re=this.buf.readUInt16LE(this.offset);return this.offset+=2,Re}readU32(){const Re=this.buf.readUInt32LE(this.offset);return this.offset+=4,Re}readU64(){const Re=this.readBuffer(8);return new bn_js_1.default(Re,"le")}readU128(){const Re=this.readBuffer(16);return new bn_js_1.default(Re,"le")}readU256(){const Re=this.readBuffer(32);return new bn_js_1.default(Re,"le")}readU512(){const Re=this.readBuffer(64);return new bn_js_1.default(Re,"le")}readBuffer(Re){if(this.offset+Re>this.buf.length)throw new BorshError(`Expected buffer length ${Re} isn't within bounds`);const Fe=this.buf.slice(this.offset,this.offset+Re);return this.offset+=Re,Fe}readString(){const Re=this.readU32(),Fe=this.readBuffer(Re);try{return textDecoder.decode(Fe)}catch(qe){throw new BorshError(`Error decoding UTF-8 string: ${qe}`)}}readFixedArray(Re){return new Uint8Array(this.readBuffer(Re))}readArray(Re){const Fe=this.readU32(),qe=Array();for(let We=0;We<Fe;++We)qe.push(Re());return qe}}__decorate([handlingRangeError],BinaryReader.prototype,"readU8",null);__decorate([handlingRangeError],BinaryReader.prototype,"readU16",null);__decorate([handlingRangeError],BinaryReader.prototype,"readU32",null);__decorate([handlingRangeError],BinaryReader.prototype,"readU64",null);__decorate([handlingRangeError],BinaryReader.prototype,"readU128",null);__decorate([handlingRangeError],BinaryReader.prototype,"readU256",null);__decorate([handlingRangeError],BinaryReader.prototype,"readU512",null);__decorate([handlingRangeError],BinaryReader.prototype,"readString",null);__decorate([handlingRangeError],BinaryReader.prototype,"readFixedArray",null);__decorate([handlingRangeError],BinaryReader.prototype,"readArray",null);lib$1.BinaryReader=BinaryReader;function capitalizeFirstLetter(Ke){return Ke.charAt(0).toUpperCase()+Ke.slice(1)}function serializeField(Ke,Re,Fe,qe,We){try{if(typeof qe=="string")We[`write${capitalizeFirstLetter(qe)}`](Fe);else if(qe instanceof Array)if(typeof qe[0]=="number"){if(Fe.length!==qe[0])throw new BorshError(`Expecting byte array of length ${qe[0]}, but got ${Fe.length} bytes`);We.writeFixedArray(Fe)}else if(qe.length===2&&typeof qe[1]=="number"){if(Fe.length!==qe[1])throw new BorshError(`Expecting byte array of length ${qe[1]}, but got ${Fe.length} bytes`);for(let Ze=0;Ze<qe[1];Ze++)serializeField(Ke,null,Fe[Ze],qe[0],We)}else We.writeArray(Fe,Ze=>{serializeField(Ke,Re,Ze,qe[0],We)});else if(qe.kind!==void 0)switch(qe.kind){case"option":{Fe==null?We.writeU8(0):(We.writeU8(1),serializeField(Ke,Re,Fe,qe.type,We));break}case"map":{We.writeU32(Fe.size),Fe.forEach((Ze,Xe)=>{serializeField(Ke,Re,Xe,qe.key,We),serializeField(Ke,Re,Ze,qe.value,We)});break}default:throw new BorshError(`FieldType ${qe} unrecognized`)}else serializeStruct(Ke,Fe,We)}catch(Ze){throw Ze instanceof BorshError&&Ze.addToFieldPath(Re),Ze}}function serializeStruct(Ke,Re,Fe){if(typeof Re.borshSerialize=="function"){Re.borshSerialize(Fe);return}const qe=Ke.get(Re.constructor);if(!qe)throw new BorshError(`Class ${Re.constructor.name} is missing in schema`);if(qe.kind==="struct")qe.fields.map(([We,Ze])=>{serializeField(Ke,We,Re[We],Ze,Fe)});else if(qe.kind==="enum"){const We=Re[qe.field];for(let Ze=0;Ze<qe.values.length;++Ze){const[Xe,Je]=qe.values[Ze];if(Xe===We){Fe.writeU8(Ze),serializeField(Ke,Xe,Re[Xe],Je,Fe);break}}}else throw new BorshError(`Unexpected schema kind: ${qe.kind} for ${Re.constructor.name}`)}function serialize(Ke,Re,Fe=BinaryWriter){const qe=new Fe;return serializeStruct(Ke,Re,qe),qe.toArray()}var serialize_1=lib$1.serialize=serialize;function deserializeField(Ke,Re,Fe,qe){try{if(typeof Fe=="string")return qe[`read${capitalizeFirstLetter(Fe)}`]();if(Fe instanceof Array){if(typeof Fe[0]=="number")return qe.readFixedArray(Fe[0]);if(typeof Fe[1]=="number"){const We=[];for(let Ze=0;Ze<Fe[1];Ze++)We.push(deserializeField(Ke,null,Fe[0],qe));return We}else return qe.readArray(()=>deserializeField(Ke,Re,Fe[0],qe))}if(Fe.kind==="option")return qe.readU8()?deserializeField(Ke,Re,Fe.type,qe):void 0;if(Fe.kind==="map"){let We=new Map;const Ze=qe.readU32();for(let Xe=0;Xe<Ze;Xe++){const Je=deserializeField(Ke,Re,Fe.key,qe),tr=deserializeField(Ke,Re,Fe.value,qe);We.set(Je,tr)}return We}return deserializeStruct(Ke,Fe,qe)}catch(We){throw We instanceof BorshError&&We.addToFieldPath(Re),We}}function deserializeStruct(Ke,Re,Fe){if(typeof Re.borshDeserialize=="function")return Re.borshDeserialize(Fe);const qe=Ke.get(Re);if(!qe)throw new BorshError(`Class ${Re.name} is missing in schema`);if(qe.kind==="struct"){const We={};for(const[Ze,Xe]of Ke.get(Re).fields)We[Ze]=deserializeField(Ke,Ze,Xe,Fe);return new Re(We)}if(qe.kind==="enum"){const We=Fe.readU8();if(We>=qe.values.length)throw new BorshError(`Enum index: ${We} is out of range`);const[Ze,Xe]=qe.values[We],Je=deserializeField(Ke,Ze,Xe,Fe);return new Re({[Ze]:Je})}throw new BorshError(`Unexpected schema kind: ${qe.kind} for ${Re.constructor.name}`)}function deserialize(Ke,Re,Fe,qe=BinaryReader){const We=new qe(Fe),Ze=deserializeStruct(Ke,Re,We);if(We.offset<Fe.length)throw new BorshError(`Unexpected ${Fe.length-We.offset} bytes after deserialized data`);return Ze}var deserialize_1=lib$1.deserialize=deserialize;function deserializeUnchecked(Ke,Re,Fe,qe=BinaryReader){const We=new qe(Fe);return deserializeStruct(Ke,Re,We)}deserializeUnchecked_1=lib$1.deserializeUnchecked=deserializeUnchecked;var Layout$3={};Object.defineProperty(Layout$3,"__esModule",{value:!0});Layout$3.s16=Layout$3.s8=Layout$3.nu64be=Layout$3.u48be=Layout$3.u40be=Layout$3.u32be=Layout$3.u24be=Layout$3.u16be=nu64=Layout$3.nu64=Layout$3.u48=Layout$3.u40=u32=Layout$3.u32=Layout$3.u24=u16=Layout$3.u16=u8=Layout$3.u8=offset=Layout$3.offset=Layout$3.greedy=Layout$3.Constant=Layout$3.UTF8=Layout$3.CString=Layout$3.Blob=Layout$3.Boolean=Layout$3.BitField=Layout$3.BitStructure=Layout$3.VariantLayout=Layout$3.Union=Layout$3.UnionLayoutDiscriminator=Layout$3.UnionDiscriminator=Layout$3.Structure=Layout$3.Sequence=Layout$3.DoubleBE=Layout$3.Double=Layout$3.FloatBE=Layout$3.Float=Layout$3.NearInt64BE=Layout$3.NearInt64=Layout$3.NearUInt64BE=Layout$3.NearUInt64=Layout$3.IntBE=Layout$3.Int=Layout$3.UIntBE=Layout$3.UInt=Layout$3.OffsetLayout=Layout$3.GreedyCount=Layout$3.ExternalLayout=Layout$3.bindConstructorLayout=Layout$3.nameWithProperty=Layout$3.Layout=Layout$3.uint8ArrayToBuffer=Layout$3.checkUint8Array=void 0;Layout$3.constant=Layout$3.utf8=Layout$3.cstr=blob=Layout$3.blob=Layout$3.unionLayoutDiscriminator=Layout$3.union=seq=Layout$3.seq=Layout$3.bits=struct=Layout$3.struct=Layout$3.f64be=Layout$3.f64=Layout$3.f32be=Layout$3.f32=Layout$3.ns64be=Layout$3.s48be=Layout$3.s40be=Layout$3.s32be=Layout$3.s24be=Layout$3.s16be=ns64=Layout$3.ns64=Layout$3.s48=Layout$3.s40=Layout$3.s32=Layout$3.s24=void 0;const buffer_1=buffer$1;function checkUint8Array(Ke){if(!(Ke instanceof Uint8Array))throw new TypeError("b must be a Uint8Array")}Layout$3.checkUint8Array=checkUint8Array;function uint8ArrayToBuffer(Ke){return checkUint8Array(Ke),buffer_1.Buffer.from(Ke.buffer,Ke.byteOffset,Ke.length)}Layout$3.uint8ArrayToBuffer=uint8ArrayToBuffer;class Layout$2{constructor(Re,Fe){if(!Number.isInteger(Re))throw new TypeError("span must be an integer");this.span=Re,this.property=Fe}makeDestinationObject(){return{}}getSpan(Re,Fe){if(0>this.span)throw new RangeError("indeterminate span");return this.span}replicate(Re){const Fe=Object.create(this.constructor.prototype);return Object.assign(Fe,this),Fe.property=Re,Fe}fromArray(Re){}}Layout$3.Layout=Layout$2;function nameWithProperty$1(Ke,Re){return Re.property?Ke+"["+Re.property+"]":Ke}Layout$3.nameWithProperty=nameWithProperty$1;function bindConstructorLayout$1(Ke,Re){if(typeof Ke!="function")throw new TypeError("Class must be constructor");if(Object.prototype.hasOwnProperty.call(Ke,"layout_"))throw new Error("Class is already bound to a layout");if(!(Re&&Re instanceof Layout$2))throw new TypeError("layout must be a Layout");if(Object.prototype.hasOwnProperty.call(Re,"boundConstructor_"))throw new Error("layout is already bound to a constructor");Ke.layout_=Re,Re.boundConstructor_=Ke,Re.makeDestinationObject=()=>new Ke,Object.defineProperty(Ke.prototype,"encode",{value(Fe,qe){return Re.encode(this,Fe,qe)},writable:!0}),Object.defineProperty(Ke,"decode",{value(Fe,qe){return Re.decode(Fe,qe)},writable:!0})}Layout$3.bindConstructorLayout=bindConstructorLayout$1;class ExternalLayout$1 extends Layout$2{isCount(){throw new Error("ExternalLayout is abstract")}}Layout$3.ExternalLayout=ExternalLayout$1;class GreedyCount$1 extends ExternalLayout$1{constructor(Re=1,Fe){if(!Number.isInteger(Re)||0>=Re)throw new TypeError("elementSpan must be a (positive) integer");super(-1,Fe),this.elementSpan=Re}isCount(){return!0}decode(Re,Fe=0){checkUint8Array(Re);const qe=Re.length-Fe;return Math.floor(qe/this.elementSpan)}encode(Re,Fe,qe){return 0}}Layout$3.GreedyCount=GreedyCount$1;class OffsetLayout$1 extends ExternalLayout$1{constructor(Re,Fe=0,qe){if(!(Re instanceof Layout$2))throw new TypeError("layout must be a Layout");if(!Number.isInteger(Fe))throw new TypeError("offset must be integer or undefined");super(Re.span,qe||Re.property),this.layout=Re,this.offset=Fe}isCount(){return this.layout instanceof UInt$1||this.layout instanceof UIntBE$1}decode(Re,Fe=0){return this.layout.decode(Re,Fe+this.offset)}encode(Re,Fe,qe=0){return this.layout.encode(Re,Fe,qe+this.offset)}}Layout$3.OffsetLayout=OffsetLayout$1;class UInt$1 extends Layout$2{constructor(Re,Fe){if(super(Re,Fe),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(Re,Fe=0){return uint8ArrayToBuffer(Re).readUIntLE(Fe,this.span)}encode(Re,Fe,qe=0){return uint8ArrayToBuffer(Fe).writeUIntLE(Re,qe,this.span),this.span}}Layout$3.UInt=UInt$1;class UIntBE$1 extends Layout$2{constructor(Re,Fe){if(super(Re,Fe),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(Re,Fe=0){return uint8ArrayToBuffer(Re).readUIntBE(Fe,this.span)}encode(Re,Fe,qe=0){return uint8ArrayToBuffer(Fe).writeUIntBE(Re,qe,this.span),this.span}}Layout$3.UIntBE=UIntBE$1;class Int$1 extends Layout$2{constructor(Re,Fe){if(super(Re,Fe),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(Re,Fe=0){return uint8ArrayToBuffer(Re).readIntLE(Fe,this.span)}encode(Re,Fe,qe=0){return uint8ArrayToBuffer(Fe).writeIntLE(Re,qe,this.span),this.span}}Layout$3.Int=Int$1;class IntBE$1 extends Layout$2{constructor(Re,Fe){if(super(Re,Fe),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(Re,Fe=0){return uint8ArrayToBuffer(Re).readIntBE(Fe,this.span)}encode(Re,Fe,qe=0){return uint8ArrayToBuffer(Fe).writeIntBE(Re,qe,this.span),this.span}}Layout$3.IntBE=IntBE$1;const V2E32$1=Math.pow(2,32);function divmodInt64$1(Ke){const Re=Math.floor(Ke/V2E32$1),Fe=Ke-Re*V2E32$1;return{hi32:Re,lo32:Fe}}function roundedInt64$1(Ke,Re){return Ke*V2E32$1+Re}class NearUInt64$1 extends Layout$2{constructor(Re){super(8,Re)}decode(Re,Fe=0){const qe=uint8ArrayToBuffer(Re),We=qe.readUInt32LE(Fe),Ze=qe.readUInt32LE(Fe+4);return roundedInt64$1(Ze,We)}encode(Re,Fe,qe=0){const We=divmodInt64$1(Re),Ze=uint8ArrayToBuffer(Fe);return Ze.writeUInt32LE(We.lo32,qe),Ze.writeUInt32LE(We.hi32,qe+4),8}}Layout$3.NearUInt64=NearUInt64$1;class NearUInt64BE$1 extends Layout$2{constructor(Re){super(8,Re)}decode(Re,Fe=0){const qe=uint8ArrayToBuffer(Re),We=qe.readUInt32BE(Fe),Ze=qe.readUInt32BE(Fe+4);return roundedInt64$1(We,Ze)}encode(Re,Fe,qe=0){const We=divmodInt64$1(Re),Ze=uint8ArrayToBuffer(Fe);return Ze.writeUInt32BE(We.hi32,qe),Ze.writeUInt32BE(We.lo32,qe+4),8}}Layout$3.NearUInt64BE=NearUInt64BE$1;class NearInt64$1 extends Layout$2{constructor(Re){super(8,Re)}decode(Re,Fe=0){const qe=uint8ArrayToBuffer(Re),We=qe.readUInt32LE(Fe),Ze=qe.readInt32LE(Fe+4);return roundedInt64$1(Ze,We)}encode(Re,Fe,qe=0){const We=divmodInt64$1(Re),Ze=uint8ArrayToBuffer(Fe);return Ze.writeUInt32LE(We.lo32,qe),Ze.writeInt32LE(We.hi32,qe+4),8}}Layout$3.NearInt64=NearInt64$1;class NearInt64BE$1 extends Layout$2{constructor(Re){super(8,Re)}decode(Re,Fe=0){const qe=uint8ArrayToBuffer(Re),We=qe.readInt32BE(Fe),Ze=qe.readUInt32BE(Fe+4);return roundedInt64$1(We,Ze)}encode(Re,Fe,qe=0){const We=divmodInt64$1(Re),Ze=uint8ArrayToBuffer(Fe);return Ze.writeInt32BE(We.hi32,qe),Ze.writeUInt32BE(We.lo32,qe+4),8}}Layout$3.NearInt64BE=NearInt64BE$1;class Float$1 extends Layout$2{constructor(Re){super(4,Re)}decode(Re,Fe=0){return uint8ArrayToBuffer(Re).readFloatLE(Fe)}encode(Re,Fe,qe=0){return uint8ArrayToBuffer(Fe).writeFloatLE(Re,qe),4}}Layout$3.Float=Float$1;class FloatBE$1 extends Layout$2{constructor(Re){super(4,Re)}decode(Re,Fe=0){return uint8ArrayToBuffer(Re).readFloatBE(Fe)}encode(Re,Fe,qe=0){return uint8ArrayToBuffer(Fe).writeFloatBE(Re,qe),4}}Layout$3.FloatBE=FloatBE$1;class Double$1 extends Layout$2{constructor(Re){super(8,Re)}decode(Re,Fe=0){return uint8ArrayToBuffer(Re).readDoubleLE(Fe)}encode(Re,Fe,qe=0){return uint8ArrayToBuffer(Fe).writeDoubleLE(Re,qe),8}}Layout$3.Double=Double$1;class DoubleBE$1 extends Layout$2{constructor(Re){super(8,Re)}decode(Re,Fe=0){return uint8ArrayToBuffer(Re).readDoubleBE(Fe)}encode(Re,Fe,qe=0){return uint8ArrayToBuffer(Fe).writeDoubleBE(Re,qe),8}}Layout$3.DoubleBE=DoubleBE$1;class Sequence$1 extends Layout$2{constructor(Re,Fe,qe){if(!(Re instanceof Layout$2))throw new TypeError("elementLayout must be a Layout");if(!(Fe instanceof ExternalLayout$1&&Fe.isCount()||Number.isInteger(Fe)&&0<=Fe))throw new TypeError("count must be non-negative integer or an unsigned integer ExternalLayout");let We=-1;!(Fe instanceof ExternalLayout$1)&&0<Re.span&&(We=Fe*Re.span),super(We,qe),this.elementLayout=Re,this.count=Fe}getSpan(Re,Fe=0){if(0<=this.span)return this.span;let qe=0,We=this.count;if(We instanceof ExternalLayout$1&&(We=We.decode(Re,Fe)),0<this.elementLayout.span)qe=We*this.elementLayout.span;else{let Ze=0;for(;Ze<We;)qe+=this.elementLayout.getSpan(Re,Fe+qe),++Ze}return qe}decode(Re,Fe=0){const qe=[];let We=0,Ze=this.count;for(Ze instanceof ExternalLayout$1&&(Ze=Ze.decode(Re,Fe));We<Ze;)qe.push(this.elementLayout.decode(Re,Fe)),Fe+=this.elementLayout.getSpan(Re,Fe),We+=1;return qe}encode(Re,Fe,qe=0){const We=this.elementLayout,Ze=Re.reduce((Xe,Je)=>Xe+We.encode(Je,Fe,qe+Xe),0);return this.count instanceof ExternalLayout$1&&this.count.encode(Re.length,Fe,qe),Ze}}Layout$3.Sequence=Sequence$1;class Structure$1 extends Layout$2{constructor(Re,Fe,qe){if(!(Array.isArray(Re)&&Re.reduce((Ze,Xe)=>Ze&&Xe instanceof Layout$2,!0)))throw new TypeError("fields must be array of Layout instances");typeof Fe=="boolean"&&qe===void 0&&(qe=Fe,Fe=void 0);for(const Ze of Re)if(0>Ze.span&&Ze.property===void 0)throw new Error("fields cannot contain unnamed variable-length layout");let We=-1;try{We=Re.reduce((Ze,Xe)=>Ze+Xe.getSpan(),0)}catch{}super(We,Fe),this.fields=Re,this.decodePrefixes=!!qe}getSpan(Re,Fe=0){if(0<=this.span)return this.span;let qe=0;try{qe=this.fields.reduce((We,Ze)=>{const Xe=Ze.getSpan(Re,Fe);return Fe+=Xe,We+Xe},0)}catch{throw new RangeError("indeterminate span")}return qe}decode(Re,Fe=0){checkUint8Array(Re);const qe=this.makeDestinationObject();for(const We of this.fields)if(We.property!==void 0&&(qe[We.property]=We.decode(Re,Fe)),Fe+=We.getSpan(Re,Fe),this.decodePrefixes&&Re.length===Fe)break;return qe}encode(Re,Fe,qe=0){const We=qe;let Ze=0,Xe=0;for(const Je of this.fields){let tr=Je.span;if(Xe=0<tr?tr:0,Je.property!==void 0){const er=Re[Je.property];er!==void 0&&(Xe=Je.encode(er,Fe,qe),0>tr&&(tr=Je.getSpan(Fe,qe)))}Ze=qe,qe+=tr}return Ze+Xe-We}fromArray(Re){const Fe=this.makeDestinationObject();for(const qe of this.fields)qe.property!==void 0&&0<Re.length&&(Fe[qe.property]=Re.shift());return Fe}layoutFor(Re){if(typeof Re!="string")throw new TypeError("property must be string");for(const Fe of this.fields)if(Fe.property===Re)return Fe}offsetOf(Re){if(typeof Re!="string")throw new TypeError("property must be string");let Fe=0;for(const qe of this.fields){if(qe.property===Re)return Fe;0>qe.span?Fe=-1:0<=Fe&&(Fe+=qe.span)}}}Layout$3.Structure=Structure$1;class UnionDiscriminator$1{constructor(Re){this.property=Re}decode(Re,Fe){throw new Error("UnionDiscriminator is abstract")}encode(Re,Fe,qe){throw new Error("UnionDiscriminator is abstract")}}Layout$3.UnionDiscriminator=UnionDiscriminator$1;class UnionLayoutDiscriminator$1 extends UnionDiscriminator$1{constructor(Re,Fe){if(!(Re instanceof ExternalLayout$1&&Re.isCount()))throw new TypeError("layout must be an unsigned integer ExternalLayout");super(Fe||Re.property||"variant"),this.layout=Re}decode(Re,Fe){return this.layout.decode(Re,Fe)}encode(Re,Fe,qe){return this.layout.encode(Re,Fe,qe)}}Layout$3.UnionLayoutDiscriminator=UnionLayoutDiscriminator$1;class Union$1 extends Layout$2{constructor(Re,Fe,qe){let We;if(Re instanceof UInt$1||Re instanceof UIntBE$1)We=new UnionLayoutDiscriminator$1(new OffsetLayout$1(Re));else if(Re instanceof ExternalLayout$1&&Re.isCount())We=new UnionLayoutDiscriminator$1(Re);else if(Re instanceof UnionDiscriminator$1)We=Re;else throw new TypeError("discr must be a UnionDiscriminator or an unsigned integer layout");if(Fe===void 0&&(Fe=null),!(Fe===null||Fe instanceof Layout$2))throw new TypeError("defaultLayout must be null or a Layout");if(Fe!==null){if(0>Fe.span)throw new Error("defaultLayout must have constant span");Fe.property===void 0&&(Fe=Fe.replicate("content"))}let Ze=-1;Fe&&(Ze=Fe.span,0<=Ze&&(Re instanceof UInt$1||Re instanceof UIntBE$1)&&(Ze+=We.layout.span)),super(Ze,qe),this.discriminator=We,this.usesPrefixDiscriminator=Re instanceof UInt$1||Re instanceof UIntBE$1,this.defaultLayout=Fe,this.registry={};let Xe=this.defaultGetSourceVariant.bind(this);this.getSourceVariant=function(Je){return Xe(Je)},this.configGetSourceVariant=function(Je){Xe=Je.bind(this)}}getSpan(Re,Fe=0){if(0<=this.span)return this.span;const qe=this.getVariant(Re,Fe);if(!qe)throw new Error("unable to determine span for unrecognized variant");return qe.getSpan(Re,Fe)}defaultGetSourceVariant(Re){if(Object.prototype.hasOwnProperty.call(Re,this.discriminator.property)){if(this.defaultLayout&&this.defaultLayout.property&&Object.prototype.hasOwnProperty.call(Re,this.defaultLayout.property))return;const Fe=this.registry[Re[this.discriminator.property]];if(Fe&&(!Fe.layout||Fe.property&&Object.prototype.hasOwnProperty.call(Re,Fe.property)))return Fe}else for(const Fe in this.registry){const qe=this.registry[Fe];if(qe.property&&Object.prototype.hasOwnProperty.call(Re,qe.property))return qe}throw new Error("unable to infer src variant")}decode(Re,Fe=0){let qe;const We=this.discriminator,Ze=We.decode(Re,Fe),Xe=this.registry[Ze];if(Xe===void 0){const Je=this.defaultLayout;let tr=0;this.usesPrefixDiscriminator&&(tr=We.layout.span),qe=this.makeDestinationObject(),qe[We.property]=Ze,qe[Je.property]=Je.decode(Re,Fe+tr)}else qe=Xe.decode(Re,Fe);return qe}encode(Re,Fe,qe=0){const We=this.getSourceVariant(Re);if(We===void 0){const Ze=this.discriminator,Xe=this.defaultLayout;let Je=0;return this.usesPrefixDiscriminator&&(Je=Ze.layout.span),Ze.encode(Re[Ze.property],Fe,qe),Je+Xe.encode(Re[Xe.property],Fe,qe+Je)}return We.encode(Re,Fe,qe)}addVariant(Re,Fe,qe){const We=new VariantLayout$1(this,Re,Fe,qe);return this.registry[Re]=We,We}getVariant(Re,Fe=0){let qe;return Re instanceof Uint8Array?qe=this.discriminator.decode(Re,Fe):qe=Re,this.registry[qe]}}Layout$3.Union=Union$1;class VariantLayout$1 extends Layout$2{constructor(Re,Fe,qe,We){if(!(Re instanceof Union$1))throw new TypeError("union must be a Union");if(!Number.isInteger(Fe)||0>Fe)throw new TypeError("variant must be a (non-negative) integer");if(typeof qe=="string"&&We===void 0&&(We=qe,qe=null),qe){if(!(qe instanceof Layout$2))throw new TypeError("layout must be a Layout");if(Re.defaultLayout!==null&&0<=qe.span&&qe.span>Re.defaultLayout.span)throw new Error("variant span exceeds span of containing union");if(typeof We!="string")throw new TypeError("variant must have a String property")}let Ze=Re.span;0>Re.span&&(Ze=qe?qe.span:0,0<=Ze&&Re.usesPrefixDiscriminator&&(Ze+=Re.discriminator.layout.span)),super(Ze,We),this.union=Re,this.variant=Fe,this.layout=qe||null}getSpan(Re,Fe=0){if(0<=this.span)return this.span;let qe=0;this.union.usesPrefixDiscriminator&&(qe=this.union.discriminator.layout.span);let We=0;return this.layout&&(We=this.layout.getSpan(Re,Fe+qe)),qe+We}decode(Re,Fe=0){const qe=this.makeDestinationObject();if(this!==this.union.getVariant(Re,Fe))throw new Error("variant mismatch");let We=0;return this.union.usesPrefixDiscriminator&&(We=this.union.discriminator.layout.span),this.layout?qe[this.property]=this.layout.decode(Re,Fe+We):this.property?qe[this.property]=!0:this.union.usesPrefixDiscriminator&&(qe[this.union.discriminator.property]=this.variant),qe}encode(Re,Fe,qe=0){let We=0;if(this.union.usesPrefixDiscriminator&&(We=this.union.discriminator.layout.span),this.layout&&!Object.prototype.hasOwnProperty.call(Re,this.property))throw new TypeError("variant lacks property "+this.property);this.union.discriminator.encode(this.variant,Fe,qe);let Ze=We;if(this.layout&&(this.layout.encode(Re[this.property],Fe,qe+We),Ze+=this.layout.getSpan(Fe,qe+We),0<=this.union.span&&Ze>this.union.span))throw new Error("encoded variant overruns containing union");return Ze}fromArray(Re){if(this.layout)return this.layout.fromArray(Re)}}Layout$3.VariantLayout=VariantLayout$1;function fixBitwiseResult$1(Ke){return 0>Ke&&(Ke+=4294967296),Ke}class BitStructure$1 extends Layout$2{constructor(Re,Fe,qe){if(!(Re instanceof UInt$1||Re instanceof UIntBE$1))throw new TypeError("word must be a UInt or UIntBE layout");if(typeof Fe=="string"&&qe===void 0&&(qe=Fe,Fe=!1),4<Re.span)throw new RangeError("word cannot exceed 32 bits");super(Re.span,qe),this.word=Re,this.msb=!!Fe,this.fields=[];let We=0;this._packedSetValue=function(Ze){return We=fixBitwiseResult$1(Ze),this},this._packedGetValue=function(){return We}}decode(Re,Fe=0){const qe=this.makeDestinationObject(),We=this.word.decode(Re,Fe);this._packedSetValue(We);for(const Ze of this.fields)Ze.property!==void 0&&(qe[Ze.property]=Ze.decode(Re));return qe}encode(Re,Fe,qe=0){const We=this.word.decode(Fe,qe);this._packedSetValue(We);for(const Ze of this.fields)if(Ze.property!==void 0){const Xe=Re[Ze.property];Xe!==void 0&&Ze.encode(Xe)}return this.word.encode(this._packedGetValue(),Fe,qe)}addField(Re,Fe){const qe=new BitField$1(this,Re,Fe);return this.fields.push(qe),qe}addBoolean(Re){const Fe=new Boolean$2(this,Re);return this.fields.push(Fe),Fe}fieldFor(Re){if(typeof Re!="string")throw new TypeError("property must be string");for(const Fe of this.fields)if(Fe.property===Re)return Fe}}Layout$3.BitStructure=BitStructure$1;class BitField$1{constructor(Re,Fe,qe){if(!(Re instanceof BitStructure$1))throw new TypeError("container must be a BitStructure");if(!Number.isInteger(Fe)||0>=Fe)throw new TypeError("bits must be positive integer");const We=8*Re.span,Ze=Re.fields.reduce((Xe,Je)=>Xe+Je.bits,0);if(Fe+Ze>We)throw new Error("bits too long for span remainder ("+(We-Ze)+" of "+We+" remain)");this.container=Re,this.bits=Fe,this.valueMask=(1<<Fe)-1,Fe===32&&(this.valueMask=4294967295),this.start=Ze,this.container.msb&&(this.start=We-Ze-Fe),this.wordMask=fixBitwiseResult$1(this.valueMask<<this.start),this.property=qe}decode(Re,Fe){const qe=this.container._packedGetValue();return fixBitwiseResult$1(qe&this.wordMask)>>>this.start}encode(Re){if(typeof Re!="number"||!Number.isInteger(Re)||Re!==fixBitwiseResult$1(Re&this.valueMask))throw new TypeError(nameWithProperty$1("BitField.encode",this)+" value must be integer not exceeding "+this.valueMask);const Fe=this.container._packedGetValue(),qe=fixBitwiseResult$1(Re<<this.start);this.container._packedSetValue(fixBitwiseResult$1(Fe&~this.wordMask)|qe)}}Layout$3.BitField=BitField$1;class Boolean$2 extends BitField$1{constructor(Re,Fe){super(Re,1,Fe)}decode(Re,Fe){return!!super.decode(Re,Fe)}encode(Re){typeof Re=="boolean"&&(Re=+Re),super.encode(Re)}}Layout$3.Boolean=Boolean$2;class Blob$2 extends Layout$2{constructor(Re,Fe){if(!(Re instanceof ExternalLayout$1&&Re.isCount()||Number.isInteger(Re)&&0<=Re))throw new TypeError("length must be positive integer or an unsigned integer ExternalLayout");let qe=-1;Re instanceof ExternalLayout$1||(qe=Re),super(qe,Fe),this.length=Re}getSpan(Re,Fe){let qe=this.span;return 0>qe&&(qe=this.length.decode(Re,Fe)),qe}decode(Re,Fe=0){let qe=this.span;return 0>qe&&(qe=this.length.decode(Re,Fe)),uint8ArrayToBuffer(Re).slice(Fe,Fe+qe)}encode(Re,Fe,qe){let We=this.length;if(this.length instanceof ExternalLayout$1&&(We=Re.length),!(Re instanceof Uint8Array&&We===Re.length))throw new TypeError(nameWithProperty$1("Blob.encode",this)+" requires (length "+We+") Uint8Array as src");if(qe+We>Fe.length)throw new RangeError("encoding overruns Uint8Array");const Ze=uint8ArrayToBuffer(Re);return uint8ArrayToBuffer(Fe).write(Ze.toString("hex"),qe,We,"hex"),this.length instanceof ExternalLayout$1&&this.length.encode(We,Fe,qe),We}}Layout$3.Blob=Blob$2;class CString$1 extends Layout$2{constructor(Re){super(-1,Re)}getSpan(Re,Fe=0){checkUint8Array(Re);let qe=Fe;for(;qe<Re.length&&Re[qe]!==0;)qe+=1;return 1+qe-Fe}decode(Re,Fe=0){const qe=this.getSpan(Re,Fe);return uint8ArrayToBuffer(Re).slice(Fe,Fe+qe-1).toString("utf-8")}encode(Re,Fe,qe=0){typeof Re!="string"&&(Re=String(Re));const We=buffer_1.Buffer.from(Re,"utf8"),Ze=We.length;if(qe+Ze>Fe.length)throw new RangeError("encoding overruns Buffer");const Xe=uint8ArrayToBuffer(Fe);return We.copy(Xe,qe),Xe[qe+Ze]=0,Ze+1}}Layout$3.CString=CString$1;class UTF8$1 extends Layout$2{constructor(Re,Fe){if(typeof Re=="string"&&Fe===void 0&&(Fe=Re,Re=void 0),Re===void 0)Re=-1;else if(!Number.isInteger(Re))throw new TypeError("maxSpan must be an integer");super(-1,Fe),this.maxSpan=Re}getSpan(Re,Fe=0){return checkUint8Array(Re),Re.length-Fe}decode(Re,Fe=0){const qe=this.getSpan(Re,Fe);if(0<=this.maxSpan&&this.maxSpan<qe)throw new RangeError("text length exceeds maxSpan");return uint8ArrayToBuffer(Re).slice(Fe,Fe+qe).toString("utf-8")}encode(Re,Fe,qe=0){typeof Re!="string"&&(Re=String(Re));const We=buffer_1.Buffer.from(Re,"utf8"),Ze=We.length;if(0<=this.maxSpan&&this.maxSpan<Ze)throw new RangeError("text length exceeds maxSpan");if(qe+Ze>Fe.length)throw new RangeError("encoding overruns Buffer");return We.copy(uint8ArrayToBuffer(Fe),qe),Ze}}Layout$3.UTF8=UTF8$1;class Constant$1 extends Layout$2{constructor(Re,Fe){super(0,Fe),this.value=Re}decode(Re,Fe){return this.value}encode(Re,Fe,qe){return 0}}Layout$3.Constant=Constant$1;Layout$3.greedy=(Ke,Re)=>new GreedyCount$1(Ke,Re);var offset=Layout$3.offset=(Ke,Re,Fe)=>new OffsetLayout$1(Ke,Re,Fe),u8=Layout$3.u8=Ke=>new UInt$1(1,Ke),u16=Layout$3.u16=Ke=>new UInt$1(2,Ke);Layout$3.u24=Ke=>new UInt$1(3,Ke);var u32=Layout$3.u32=Ke=>new UInt$1(4,Ke);Layout$3.u40=Ke=>new UInt$1(5,Ke);Layout$3.u48=Ke=>new UInt$1(6,Ke);var nu64=Layout$3.nu64=Ke=>new NearUInt64$1(Ke);Layout$3.u16be=Ke=>new UIntBE$1(2,Ke);Layout$3.u24be=Ke=>new UIntBE$1(3,Ke);Layout$3.u32be=Ke=>new UIntBE$1(4,Ke);Layout$3.u40be=Ke=>new UIntBE$1(5,Ke);Layout$3.u48be=Ke=>new UIntBE$1(6,Ke);Layout$3.nu64be=Ke=>new NearUInt64BE$1(Ke);Layout$3.s8=Ke=>new Int$1(1,Ke);Layout$3.s16=Ke=>new Int$1(2,Ke);Layout$3.s24=Ke=>new Int$1(3,Ke);Layout$3.s32=Ke=>new Int$1(4,Ke);Layout$3.s40=Ke=>new Int$1(5,Ke);Layout$3.s48=Ke=>new Int$1(6,Ke);var ns64=Layout$3.ns64=Ke=>new NearInt64$1(Ke);Layout$3.s16be=Ke=>new IntBE$1(2,Ke);Layout$3.s24be=Ke=>new IntBE$1(3,Ke);Layout$3.s32be=Ke=>new IntBE$1(4,Ke);Layout$3.s40be=Ke=>new IntBE$1(5,Ke);Layout$3.s48be=Ke=>new IntBE$1(6,Ke);Layout$3.ns64be=Ke=>new NearInt64BE$1(Ke);Layout$3.f32=Ke=>new Float$1(Ke);Layout$3.f32be=Ke=>new FloatBE$1(Ke);Layout$3.f64=Ke=>new Double$1(Ke);Layout$3.f64be=Ke=>new DoubleBE$1(Ke);var struct=Layout$3.struct=(Ke,Re,Fe)=>new Structure$1(Ke,Re,Fe);Layout$3.bits=(Ke,Re,Fe)=>new BitStructure$1(Ke,Re,Fe);var seq=Layout$3.seq=(Ke,Re,Fe)=>new Sequence$1(Ke,Re,Fe);Layout$3.union=(Ke,Re,Fe)=>new Union$1(Ke,Re,Fe);Layout$3.unionLayoutDiscriminator=(Ke,Re)=>new UnionLayoutDiscriminator$1(Ke,Re);var blob=Layout$3.blob=(Ke,Re)=>new Blob$2(Ke,Re);Layout$3.cstr=Ke=>new CString$1(Ke);Layout$3.utf8=(Ke,Re)=>new UTF8$1(Ke,Re);Layout$3.constant=(Ke,Re)=>new Constant$1(Ke,Re);var browser$1={};Object.defineProperty(browser$1,"__esModule",{value:!0});function toBigIntLE(Ke){{const Re=Buffer.from(Ke);Re.reverse();const Fe=Re.toString("hex");return Fe.length===0?BigInt(0):BigInt(`0x${Fe}`)}}var toBigIntLE_1=browser$1.toBigIntLE=toBigIntLE;function toBigIntBE(Ke){{const Re=Ke.toString("hex");return Re.length===0?BigInt(0):BigInt(`0x${Re}`)}}browser$1.toBigIntBE=toBigIntBE;function toBufferLE(Ke,Re){{const Fe=Ke.toString(16),qe=Buffer.from(Fe.padStart(Re*2,"0").slice(0,Re*2),"hex");return qe.reverse(),qe}}var toBufferLE_1=browser$1.toBufferLE=toBufferLE;function toBufferBE(Ke,Re){{const Fe=Ke.toString(16);return Buffer.from(Fe.padStart(Re*2,"0").slice(0,Re*2),"hex")}}browser$1.toBufferBE=toBufferBE;class StructError extends TypeError{constructor(Re,Fe){let qe;const{message:We,...Ze}=Re,{path:Xe}=Re,Je=Xe.length===0?We:"At path: "+Xe.join(".")+" -- "+We;super(Je),Object.assign(this,Ze),this.name=this.constructor.name,this.failures=()=>{var tr;return(tr=qe)!=null?tr:qe=[Re,...Fe()]}}}function isIterable(Ke){return isObject(Ke)&&typeof Ke[Symbol.iterator]=="function"}function isObject(Ke){return typeof Ke=="object"&&Ke!=null}function print(Ke){return typeof Ke=="string"?JSON.stringify(Ke):""+Ke}function shiftIterator(Ke){const{done:Re,value:Fe}=Ke.next();return Re?void 0:Fe}function toFailure(Ke,Re,Fe,qe){if(Ke===!0)return;Ke===!1?Ke={}:typeof Ke=="string"&&(Ke={message:Ke});const{path:We,branch:Ze}=Re,{type:Xe}=Fe,{refinement:Je,message:tr="Expected a value of type `"+Xe+"`"+(Je?" with refinement `"+Je+"`":"")+", but received: `"+print(qe)+"`"}=Ke;return{value:qe,type:Xe,refinement:Je,key:We[We.length-1],path:We,branch:Ze,...Ke,message:tr}}function*toFailures(Ke,Re,Fe,qe){isIterable(Ke)||(Ke=[Ke]);for(const We of Ke){const Ze=toFailure(We,Re,Fe,qe);Ze&&(yield Ze)}}function*run(Ke,Re,Fe={}){const{path:qe=[],branch:We=[Ke],coerce:Ze=!1,mask:Xe=!1}=Fe,Je={path:qe,branch:We};if(Ze&&(Ke=Re.coercer(Ke,Je),Xe&&Re.type!=="type"&&isObject(Re.schema)&&isObject(Ke)&&!Array.isArray(Ke)))for(const er in Ke)Re.schema[er]===void 0&&delete Ke[er];let tr=!0;for(const er of Re.validator(Ke,Je))tr=!1,yield[er,void 0];for(let[er,ir,ur]of Re.entries(Ke,Je)){const fr=run(ir,ur,{path:er===void 0?qe:[...qe,er],branch:er===void 0?We:[...We,ir],coerce:Ze,mask:Xe});for(const ar of fr)ar[0]?(tr=!1,yield[ar[0],void 0]):Ze&&(ir=ar[1],er===void 0?Ke=ir:Ke instanceof Map?Ke.set(er,ir):Ke instanceof Set?Ke.add(ir):isObject(Ke)&&(Ke[er]=ir))}if(tr)for(const er of Re.refiner(Ke,Je))tr=!1,yield[er,void 0];tr&&(yield[void 0,Ke])}class Struct$1{constructor(Re){const{type:Fe,schema:qe,validator:We,refiner:Ze,coercer:Xe=tr=>tr,entries:Je=function*(){}}=Re;this.type=Fe,this.schema=qe,this.entries=Je,this.coercer=Xe,We?this.validator=(tr,er)=>{const ir=We(tr,er);return toFailures(ir,er,this,tr)}:this.validator=()=>[],Ze?this.refiner=(tr,er)=>{const ir=Ze(tr,er);return toFailures(ir,er,this,tr)}:this.refiner=()=>[]}assert(Re){return assert$1(Re,this)}create(Re){return create(Re,this)}is(Re){return is(Re,this)}mask(Re){return mask(Re,this)}validate(Re,Fe={}){return validate$1(Re,this,Fe)}}function assert$1(Ke,Re){const Fe=validate$1(Ke,Re);if(Fe[0])throw Fe[0]}function create(Ke,Re){const Fe=validate$1(Ke,Re,{coerce:!0});if(Fe[0])throw Fe[0];return Fe[1]}function mask(Ke,Re){const Fe=validate$1(Ke,Re,{coerce:!0,mask:!0});if(Fe[0])throw Fe[0];return Fe[1]}function is(Ke,Re){return!validate$1(Ke,Re)[0]}function validate$1(Ke,Re,Fe={}){const qe=run(Ke,Re,Fe),We=shiftIterator(qe);return We[0]?[new StructError(We[0],function*(){for(const Xe of qe)Xe[0]&&(yield Xe[0])}),void 0]:[void 0,We[1]]}function define(Ke,Re){return new Struct$1({type:Ke,schema:null,validator:Re})}function any(){return define("any",()=>!0)}function array(Ke){return new Struct$1({type:"array",schema:Ke,*entries(Re){if(Ke&&Array.isArray(Re))for(const[Fe,qe]of Re.entries())yield[Fe,qe,Ke]},coercer(Re){return Array.isArray(Re)?Re.slice():Re},validator(Re){return Array.isArray(Re)||"Expected an array value, but received: "+print(Re)}})}function boolean(){return define("boolean",Ke=>typeof Ke=="boolean")}function instance(Ke){return define("instance",Re=>Re instanceof Ke||"Expected a `"+Ke.name+"` instance, but received: "+print(Re))}function literal(Ke){const Re=print(Ke),Fe=typeof Ke;return new Struct$1({type:"literal",schema:Fe==="string"||Fe==="number"||Fe==="boolean"?Ke:null,validator(qe){return qe===Ke||"Expected the literal `"+Re+"`, but received: "+print(qe)}})}function never(){return define("never",()=>!1)}function nullable(Ke){return new Struct$1({...Ke,validator:(Re,Fe)=>Re===null||Ke.validator(Re,Fe),refiner:(Re,Fe)=>Re===null||Ke.refiner(Re,Fe)})}function number(){return define("number",Ke=>typeof Ke=="number"&&!isNaN(Ke)||"Expected a number, but received: "+print(Ke))}function optional(Ke){return new Struct$1({...Ke,validator:(Re,Fe)=>Re===void 0||Ke.validator(Re,Fe),refiner:(Re,Fe)=>Re===void 0||Ke.refiner(Re,Fe)})}function record(Ke,Re){return new Struct$1({type:"record",schema:null,*entries(Fe){if(isObject(Fe))for(const qe in Fe){const We=Fe[qe];yield[qe,qe,Ke],yield[qe,We,Re]}},validator(Fe){return isObject(Fe)||"Expected an object, but received: "+print(Fe)}})}function string(){return define("string",Ke=>typeof Ke=="string"||"Expected a string, but received: "+print(Ke))}function tuple(Ke){const Re=never();return new Struct$1({type:"tuple",schema:null,*entries(Fe){if(Array.isArray(Fe)){const qe=Math.max(Ke.length,Fe.length);for(let We=0;We<qe;We++)yield[We,Fe[We],Ke[We]||Re]}},validator(Fe){return Array.isArray(Fe)||"Expected an array, but received: "+print(Fe)}})}function type(Ke){const Re=Object.keys(Ke);return new Struct$1({type:"type",schema:Ke,*entries(Fe){if(isObject(Fe))for(const qe of Re)yield[qe,Fe[qe],Ke[qe]]},validator(Fe){return isObject(Fe)||"Expected an object, but received: "+print(Fe)}})}function union(Ke){const Re=Ke.map(Fe=>Fe.type).join(" | ");return new Struct$1({type:"union",schema:null,validator(Fe,qe){const We=[];for(const Ze of Ke){const[...Xe]=run(Fe,Ze,qe),[Je]=Xe;if(Je[0])for(const[tr]of Xe)tr&&We.push(tr);else return[]}return["Expected the value to satisfy a union of `"+Re+"`, but received: "+print(Fe),...We]}})}function unknown(){return define("unknown",()=>!0)}function coerce(Ke,Re,Fe){return new Struct$1({...Ke,coercer:(qe,We)=>is(qe,Re)?Ke.coercer(Fe(qe,We),We):Ke.coercer(qe,We)})}var index_browser={},interopRequireDefault={exports:{}};(function(Ke){function Re(Fe){return Fe&&Fe.__esModule?Fe:{default:Fe}}Ke.exports=Re,Ke.exports.__esModule=!0,Ke.exports.default=Ke.exports})(interopRequireDefault);var createClass={exports:{}},hasRequiredCreateClass;function requireCreateClass(){return hasRequiredCreateClass||(hasRequiredCreateClass=1,function(Ke){function Re(qe,We){for(var Ze=0;Ze<We.length;Ze++){var Xe=We[Ze];Xe.enumerable=Xe.enumerable||!1,Xe.configurable=!0,"value"in Xe&&(Xe.writable=!0),Object.defineProperty(qe,Xe.key,Xe)}}function Fe(qe,We,Ze){return We&&Re(qe.prototype,We),Ze&&Re(qe,Ze),Object.defineProperty(qe,"prototype",{writable:!1}),qe}Ke.exports=Fe,Ke.exports.__esModule=!0,Ke.exports.default=Ke.exports}(createClass)),createClass.exports}var classCallCheck={exports:{}},hasRequiredClassCallCheck;function requireClassCallCheck(){return hasRequiredClassCallCheck||(hasRequiredClassCallCheck=1,function(Ke){function Re(Fe,qe){if(!(Fe instanceof qe))throw new TypeError("Cannot call a class as a function")}Ke.exports=Re,Ke.exports.__esModule=!0,Ke.exports.default=Ke.exports}(classCallCheck)),classCallCheck.exports}var inherits={exports:{}},setPrototypeOf={exports:{}},hasRequiredSetPrototypeOf;function requireSetPrototypeOf(){return hasRequiredSetPrototypeOf||(hasRequiredSetPrototypeOf=1,function(Ke){function Re(Fe,qe){return Ke.exports=Re=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(Ze,Xe){return Ze.__proto__=Xe,Ze},Ke.exports.__esModule=!0,Ke.exports.default=Ke.exports,Re(Fe,qe)}Ke.exports=Re,Ke.exports.__esModule=!0,Ke.exports.default=Ke.exports}(setPrototypeOf)),setPrototypeOf.exports}var hasRequiredInherits;function requireInherits(){return hasRequiredInherits||(hasRequiredInherits=1,function(Ke){var Re=requireSetPrototypeOf();function Fe(qe,We){if(typeof We!="function"&&We!==null)throw new TypeError("Super expression must either be null or a function");qe.prototype=Object.create(We&&We.prototype,{constructor:{value:qe,writable:!0,configurable:!0}}),Object.defineProperty(qe,"prototype",{writable:!1}),We&&Re(qe,We)}Ke.exports=Fe,Ke.exports.__esModule=!0,Ke.exports.default=Ke.exports}(inherits)),inherits.exports}var possibleConstructorReturn={exports:{}},_typeof={exports:{}},hasRequired_typeof;function require_typeof(){return hasRequired_typeof||(hasRequired_typeof=1,function(Ke){function Re(Fe){return Ke.exports=Re=typeof Symbol=="function"&&typeof Symbol.iterator=="symbol"?function(qe){return typeof qe}:function(qe){return qe&&typeof Symbol=="function"&&qe.constructor===Symbol&&qe!==Symbol.prototype?"symbol":typeof qe},Ke.exports.__esModule=!0,Ke.exports.default=Ke.exports,Re(Fe)}Ke.exports=Re,Ke.exports.__esModule=!0,Ke.exports.default=Ke.exports}(_typeof)),_typeof.exports}var assertThisInitialized={exports:{}},hasRequiredAssertThisInitialized;function requireAssertThisInitialized(){return hasRequiredAssertThisInitialized||(hasRequiredAssertThisInitialized=1,function(Ke){function Re(Fe){if(Fe===void 0)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return Fe}Ke.exports=Re,Ke.exports.__esModule=!0,Ke.exports.default=Ke.exports}(assertThisInitialized)),assertThisInitialized.exports}var hasRequiredPossibleConstructorReturn;function requirePossibleConstructorReturn(){return hasRequiredPossibleConstructorReturn||(hasRequiredPossibleConstructorReturn=1,function(Ke){var Re=require_typeof().default,Fe=requireAssertThisInitialized();function qe(We,Ze){if(Ze&&(Re(Ze)==="object"||typeof Ze=="function"))return Ze;if(Ze!==void 0)throw new TypeError("Derived constructors may only return object or undefined");return Fe(We)}Ke.exports=qe,Ke.exports.__esModule=!0,Ke.exports.default=Ke.exports}(possibleConstructorReturn)),possibleConstructorReturn.exports}var getPrototypeOf={exports:{}},hasRequiredGetPrototypeOf;function requireGetPrototypeOf(){return hasRequiredGetPrototypeOf||(hasRequiredGetPrototypeOf=1,function(Ke){function Re(Fe){return Ke.exports=Re=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(We){return We.__proto__||Object.getPrototypeOf(We)},Ke.exports.__esModule=!0,Ke.exports.default=Ke.exports,Re(Fe)}Ke.exports=Re,Ke.exports.__esModule=!0,Ke.exports.default=Ke.exports}(getPrototypeOf)),getPrototypeOf.exports}var websocket_browser={},eventemitter3={exports:{}};(function(Ke){var Re=Object.prototype.hasOwnProperty,Fe="~";function qe(){}Object.create&&(qe.prototype=Object.create(null),new qe().__proto__||(Fe=!1));function We(tr,er,ir){this.fn=tr,this.context=er,this.once=ir||!1}function Ze(tr,er,ir,ur,fr){if(typeof ir!="function")throw new TypeError("The listener must be a function");var ar=new We(ir,ur||tr,fr),yr=Fe?Fe+er:er;return tr._events[yr]?tr._events[yr].fn?tr._events[yr]=[tr._events[yr],ar]:tr._events[yr].push(ar):(tr._events[yr]=ar,tr._eventsCount++),tr}function Xe(tr,er){--tr._eventsCount===0?tr._events=new qe:delete tr._events[er]}function Je(){this._events=new qe,this._eventsCount=0}Je.prototype.eventNames=function(){var er=[],ir,ur;if(this._eventsCount===0)return er;for(ur in ir=this._events)Re.call(ir,ur)&&er.push(Fe?ur.slice(1):ur);return Object.getOwnPropertySymbols?er.concat(Object.getOwnPropertySymbols(ir)):er},Je.prototype.listeners=function(er){var ir=Fe?Fe+er:er,ur=this._events[ir];if(!ur)return[];if(ur.fn)return[ur.fn];for(var fr=0,ar=ur.length,yr=new Array(ar);fr<ar;fr++)yr[fr]=ur[fr].fn;return yr},Je.prototype.listenerCount=function(er){var ir=Fe?Fe+er:er,ur=this._events[ir];return ur?ur.fn?1:ur.length:0},Je.prototype.emit=function(er,ir,ur,fr,ar,yr){var mr=Fe?Fe+er:er;if(!this._events[mr])return!1;var wr=this._events[mr],Sr=arguments.length,Ar,vr;if(wr.fn){switch(wr.once&&this.removeListener(er,wr.fn,void 0,!0),Sr){case 1:return wr.fn.call(wr.context),!0;case 2:return wr.fn.call(wr.context,ir),!0;case 3:return wr.fn.call(wr.context,ir,ur),!0;case 4:return wr.fn.call(wr.context,ir,ur,fr),!0;case 5:return wr.fn.call(wr.context,ir,ur,fr,ar),!0;case 6:return wr.fn.call(wr.context,ir,ur,fr,ar,yr),!0}for(vr=1,Ar=new Array(Sr-1);vr<Sr;vr++)Ar[vr-1]=arguments[vr];wr.fn.apply(wr.context,Ar)}else{var Ir=wr.length,Tr;for(vr=0;vr<Ir;vr++)switch(wr[vr].once&&this.removeListener(er,wr[vr].fn,void 0,!0),Sr){case 1:wr[vr].fn.call(wr[vr].context);break;case 2:wr[vr].fn.call(wr[vr].context,ir);break;case 3:wr[vr].fn.call(wr[vr].context,ir,ur);break;case 4:wr[vr].fn.call(wr[vr].context,ir,ur,fr);break;default:if(!Ar)for(Tr=1,Ar=new Array(Sr-1);Tr<Sr;Tr++)Ar[Tr-1]=arguments[Tr];wr[vr].fn.apply(wr[vr].context,Ar)}}return!0},Je.prototype.on=function(er,ir,ur){return Ze(this,er,ir,ur,!1)},Je.prototype.once=function(er,ir,ur){return Ze(this,er,ir,ur,!0)},Je.prototype.removeListener=function(er,ir,ur,fr){var ar=Fe?Fe+er:er;if(!this._events[ar])return this;if(!ir)return Xe(this,ar),this;var yr=this._events[ar];if(yr.fn)yr.fn===ir&&(!fr||yr.once)&&(!ur||yr.context===ur)&&Xe(this,ar);else{for(var mr=0,wr=[],Sr=yr.length;mr<Sr;mr++)(yr[mr].fn!==ir||fr&&!yr[mr].once||ur&&yr[mr].context!==ur)&&wr.push(yr[mr]);wr.length?this._events[ar]=wr.length===1?wr[0]:wr:Xe(this,ar)}return this},Je.prototype.removeAllListeners=function(er){var ir;return er?(ir=Fe?Fe+er:er,this._events[ir]&&Xe(this,ir)):(this._events=new qe,this._eventsCount=0),this},Je.prototype.off=Je.prototype.removeListener,Je.prototype.addListener=Je.prototype.on,Je.prefixed=Fe,Je.EventEmitter=Je,Ke.exports=Je})(eventemitter3);const y=eventemitter3.exports;var hasRequiredWebsocket_browser;function requireWebsocket_browser(){return hasRequiredWebsocket_browser||(hasRequiredWebsocket_browser=1,function(Ke){var Re=interopRequireDefault.exports;Object.defineProperty(Ke,"__esModule",{value:!0}),Ke.default=ur;var Fe=Re(requireClassCallCheck()),qe=Re(requireCreateClass()),We=Re(requireInherits()),Ze=Re(requirePossibleConstructorReturn()),Xe=Re(requireGetPrototypeOf()),Je=eventemitter3.exports;function tr(fr){var ar=er();return function(){var mr=(0,Xe.default)(fr),wr;if(ar){var Sr=(0,Xe.default)(this).constructor;wr=Reflect.construct(mr,arguments,Sr)}else wr=mr.apply(this,arguments);return(0,Ze.default)(this,wr)}}function er(){if(typeof Reflect>"u"||!Reflect.construct||Reflect.construct.sham)return!1;if(typeof Proxy=="function")return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],function(){})),!0}catch{return!1}}var ir=function(fr){(0,We.default)(yr,fr);var ar=tr(yr);function yr(mr,wr,Sr){var Ar;return(0,Fe.default)(this,yr),Ar=ar.call(this),Ar.socket=new window.WebSocket(mr,Sr),Ar.socket.onopen=function(){return Ar.emit("open")},Ar.socket.onmessage=function(vr){return Ar.emit("message",vr.data)},Ar.socket.onerror=function(vr){return Ar.emit("error",vr)},Ar.socket.onclose=function(vr){Ar.emit("close",vr.code,vr.reason)},Ar}return(0,qe.default)(yr,[{key:"send",value:function(wr,Sr,Ar){var vr=Ar||Sr;try{this.socket.send(wr),vr()}catch(Ir){vr(Ir)}}},{key:"close",value:function(wr,Sr){this.socket.close(wr,Sr)}},{key:"addEventListener",value:function(wr,Sr,Ar){this.socket.addEventListener(wr,Sr,Ar)}}]),yr}(Je.EventEmitter);function ur(fr,ar){return new ir(fr,ar)}}(websocket_browser)),websocket_browser}var client={},regeneratorRuntime$1={exports:{}},hasRequiredRegeneratorRuntime;function requireRegeneratorRuntime(){return hasRequiredRegeneratorRuntime||(hasRequiredRegeneratorRuntime=1,function(Ke){var Re=require_typeof().default;function Fe(){Ke.exports=Fe=function(){return qe},Ke.exports.__esModule=!0,Ke.exports.default=Ke.exports;var qe={},We=Object.prototype,Ze=We.hasOwnProperty,Xe=typeof Symbol=="function"?Symbol:{},Je=Xe.iterator||"@@iterator",tr=Xe.asyncIterator||"@@asyncIterator",er=Xe.toStringTag||"@@toStringTag";function ir(cr,Dt,sr){return Object.defineProperty(cr,Dt,{value:sr,enumerable:!0,configurable:!0,writable:!0}),cr[Dt]}try{ir({},"")}catch{ir=function(sr,lr,gr){return sr[lr]=gr}}function ur(cr,Dt,sr,lr){var gr=Dt&&Dt.prototype instanceof yr?Dt:yr,_r=Object.create(gr.prototype),xr=new Lr(lr||[]);return _r._invoke=function(kr,pr,rr){var hr="suspendedStart";return function(Cr,Or){if(hr==="executing")throw new Error("Generator is already running");if(hr==="completed"){if(Cr==="throw")throw Or;return Nr()}for(rr.method=Cr,rr.arg=Or;;){var Ur=rr.delegate;if(Ur){var qr=Rr(Ur,rr);if(qr){if(qr===ar)continue;return qr}}if(rr.method==="next")rr.sent=rr._sent=rr.arg;else if(rr.method==="throw"){if(hr==="suspendedStart")throw hr="completed",rr.arg;rr.dispatchException(rr.arg)}else rr.method==="return"&&rr.abrupt("return",rr.arg);hr="executing";var Fr=fr(kr,pr,rr);if(Fr.type==="normal"){if(hr=rr.done?"completed":"suspendedYield",Fr.arg===ar)continue;return{value:Fr.arg,done:rr.done}}Fr.type==="throw"&&(hr="completed",rr.method="throw",rr.arg=Fr.arg)}}}(cr,sr,xr),_r}function fr(cr,Dt,sr){try{return{type:"normal",arg:cr.call(Dt,sr)}}catch(lr){return{type:"throw",arg:lr}}}qe.wrap=ur;var ar={};function yr(){}function mr(){}function wr(){}var Sr={};ir(Sr,Je,function(){return this});var Ar=Object.getPrototypeOf,vr=Ar&&Ar(Ar($r([])));vr&&vr!==We&&Ze.call(vr,Je)&&(Sr=vr);var Ir=wr.prototype=yr.prototype=Object.create(Sr);function Tr(cr){["next","throw","return"].forEach(function(Dt){ir(cr,Dt,function(sr){return this._invoke(Dt,sr)})})}function Pr(cr,Dt){function sr(gr,_r,xr,kr){var pr=fr(cr[gr],cr,_r);if(pr.type!=="throw"){var rr=pr.arg,hr=rr.value;return hr&&Re(hr)=="object"&&Ze.call(hr,"__await")?Dt.resolve(hr.__await).then(function(Cr){sr("next",Cr,xr,kr)},function(Cr){sr("throw",Cr,xr,kr)}):Dt.resolve(hr).then(function(Cr){rr.value=Cr,xr(rr)},function(Cr){return sr("throw",Cr,xr,kr)})}kr(pr.arg)}var lr;this._invoke=function(gr,_r){function xr(){return new Dt(function(kr,pr){sr(gr,_r,kr,pr)})}return lr=lr?lr.then(xr,xr):xr()}}function Rr(cr,Dt){var sr=cr.iterator[Dt.method];if(sr===void 0){if(Dt.delegate=null,Dt.method==="throw"){if(cr.iterator.return&&(Dt.method="return",Dt.arg=void 0,Rr(cr,Dt),Dt.method==="throw"))return ar;Dt.method="throw",Dt.arg=new TypeError("The iterator does not provide a 'throw' method")}return ar}var lr=fr(sr,cr.iterator,Dt.arg);if(lr.type==="throw")return Dt.method="throw",Dt.arg=lr.arg,Dt.delegate=null,ar;var gr=lr.arg;return gr?gr.done?(Dt[cr.resultName]=gr.value,Dt.next=cr.nextLoc,Dt.method!=="return"&&(Dt.method="next",Dt.arg=void 0),Dt.delegate=null,ar):gr:(Dt.method="throw",Dt.arg=new TypeError("iterator result is not an object"),Dt.delegate=null,ar)}function Br(cr){var Dt={tryLoc:cr[0]};1 in cr&&(Dt.catchLoc=cr[1]),2 in cr&&(Dt.finallyLoc=cr[2],Dt.afterLoc=cr[3]),this.tryEntries.push(Dt)}function Mr(cr){var Dt=cr.completion||{};Dt.type="normal",delete Dt.arg,cr.completion=Dt}function Lr(cr){this.tryEntries=[{tryLoc:"root"}],cr.forEach(Br,this),this.reset(!0)}function $r(cr){if(cr){var Dt=cr[Je];if(Dt)return Dt.call(cr);if(typeof cr.next=="function")return cr;if(!isNaN(cr.length)){var sr=-1,lr=function gr(){for(;++sr<cr.length;)if(Ze.call(cr,sr))return gr.value=cr[sr],gr.done=!1,gr;return gr.value=void 0,gr.done=!0,gr};return lr.next=lr}}return{next:Nr}}function Nr(){return{value:void 0,done:!0}}return mr.prototype=wr,ir(Ir,"constructor",wr),ir(wr,"constructor",mr),mr.displayName=ir(wr,er,"GeneratorFunction"),qe.isGeneratorFunction=function(cr){var Dt=typeof cr=="function"&&cr.constructor;return!!Dt&&(Dt===mr||(Dt.displayName||Dt.name)==="GeneratorFunction")},qe.mark=function(cr){return Object.setPrototypeOf?Object.setPrototypeOf(cr,wr):(cr.__proto__=wr,ir(cr,er,"GeneratorFunction")),cr.prototype=Object.create(Ir),cr},qe.awrap=function(cr){return{__await:cr}},Tr(Pr.prototype),ir(Pr.prototype,tr,function(){return this}),qe.AsyncIterator=Pr,qe.async=function(cr,Dt,sr,lr,gr){gr===void 0&&(gr=Promise);var _r=new Pr(ur(cr,Dt,sr,lr),gr);return qe.isGeneratorFunction(Dt)?_r:_r.next().then(function(xr){return xr.done?xr.value:_r.next()})},Tr(Ir),ir(Ir,er,"Generator"),ir(Ir,Je,function(){return this}),ir(Ir,"toString",function(){return"[object Generator]"}),qe.keys=function(cr){var Dt=[];for(var sr in cr)Dt.push(sr);return Dt.reverse(),function lr(){for(;Dt.length;){var gr=Dt.pop();if(gr in cr)return lr.value=gr,lr.done=!1,lr}return lr.done=!0,lr}},qe.values=$r,Lr.prototype={constructor:Lr,reset:function(Dt){if(this.prev=0,this.next=0,this.sent=this._sent=void 0,this.done=!1,this.delegate=null,this.method="next",this.arg=void 0,this.tryEntries.forEach(Mr),!Dt)for(var sr in this)sr.charAt(0)==="t"&&Ze.call(this,sr)&&!isNaN(+sr.slice(1))&&(this[sr]=void 0)},stop:function(){this.done=!0;var Dt=this.tryEntries[0].completion;if(Dt.type==="throw")throw Dt.arg;return this.rval},dispatchException:function(Dt){if(this.done)throw Dt;var sr=this;function lr(rr,hr){return xr.type="throw",xr.arg=Dt,sr.next=rr,hr&&(sr.method="next",sr.arg=void 0),!!hr}for(var gr=this.tryEntries.length-1;gr>=0;--gr){var _r=this.tryEntries[gr],xr=_r.completion;if(_r.tryLoc==="root")return lr("end");if(_r.tryLoc<=this.prev){var kr=Ze.call(_r,"catchLoc"),pr=Ze.call(_r,"finallyLoc");if(kr&&pr){if(this.prev<_r.catchLoc)return lr(_r.catchLoc,!0);if(this.prev<_r.finallyLoc)return lr(_r.finallyLoc)}else if(kr){if(this.prev<_r.catchLoc)return lr(_r.catchLoc,!0)}else{if(!pr)throw new Error("try statement without catch or finally");if(this.prev<_r.finallyLoc)return lr(_r.finallyLoc)}}}},abrupt:function(Dt,sr){for(var lr=this.tryEntries.length-1;lr>=0;--lr){var gr=this.tryEntries[lr];if(gr.tryLoc<=this.prev&&Ze.call(gr,"finallyLoc")&&this.prev<gr.finallyLoc){var _r=gr;break}}_r&&(Dt==="break"||Dt==="continue")&&_r.tryLoc<=sr&&sr<=_r.finallyLoc&&(_r=null);var xr=_r?_r.completion:{};return xr.type=Dt,xr.arg=sr,_r?(this.method="next",this.next=_r.finallyLoc,ar):this.complete(xr)},complete:function(Dt,sr){if(Dt.type==="throw")throw Dt.arg;return Dt.type==="break"||Dt.type==="continue"?this.next=Dt.arg:Dt.type==="return"?(this.rval=this.arg=Dt.arg,this.method="return",this.next="end"):Dt.type==="normal"&&sr&&(this.next=sr),ar},finish:function(Dt){for(var sr=this.tryEntries.length-1;sr>=0;--sr){var lr=this.tryEntries[sr];if(lr.finallyLoc===Dt)return this.complete(lr.completion,lr.afterLoc),Mr(lr),ar}},catch:function(Dt){for(var sr=this.tryEntries.length-1;sr>=0;--sr){var lr=this.tryEntries[sr];if(lr.tryLoc===Dt){var gr=lr.completion;if(gr.type==="throw"){var _r=gr.arg;Mr(lr)}return _r}}throw new Error("illegal catch attempt")},delegateYield:function(Dt,sr,lr){return this.delegate={iterator:$r(Dt),resultName:sr,nextLoc:lr},this.method==="next"&&(this.arg=void 0),ar}},qe}Ke.exports=Fe,Ke.exports.__esModule=!0,Ke.exports.default=Ke.exports}(regeneratorRuntime$1)),regeneratorRuntime$1.exports}var regenerator,hasRequiredRegenerator;function requireRegenerator(){if(hasRequiredRegenerator)return regenerator;hasRequiredRegenerator=1;var Ke=requireRegeneratorRuntime()();regenerator=Ke;try{regeneratorRuntime=Ke}catch{typeof globalThis=="object"?globalThis.regeneratorRuntime=Ke:Function("r","regeneratorRuntime = r")(Ke)}return regenerator}var asyncToGenerator={exports:{}},hasRequiredAsyncToGenerator;function requireAsyncToGenerator(){return hasRequiredAsyncToGenerator||(hasRequiredAsyncToGenerator=1,function(Ke){function Re(qe,We,Ze,Xe,Je,tr,er){try{var ir=qe[tr](er),ur=ir.value}catch(fr){Ze(fr);return}ir.done?We(ur):Promise.resolve(ur).then(Xe,Je)}function Fe(qe){return function(){var We=this,Ze=arguments;return new Promise(function(Xe,Je){var tr=qe.apply(We,Ze);function er(ur){Re(tr,Xe,Je,er,ir,"next",ur)}function ir(ur){Re(tr,Xe,Je,er,ir,"throw",ur)}er(void 0)})}}Ke.exports=Fe,Ke.exports.__esModule=!0,Ke.exports.default=Ke.exports}(asyncToGenerator)),asyncToGenerator.exports}var hasRequiredClient;function requireClient(){return hasRequiredClient||(hasRequiredClient=1,function(Ke){var Re=interopRequireDefault.exports;Object.defineProperty(Ke,"__esModule",{value:!0}),Ke.default=void 0;var Fe=Re(requireRegenerator()),qe=Re(requireAsyncToGenerator()),We=Re(require_typeof()),Ze=Re(requireClassCallCheck()),Xe=Re(requireCreateClass()),Je=Re(requireInherits()),tr=Re(requirePossibleConstructorReturn()),er=Re(requireGetPrototypeOf()),ir=eventemitter3.exports;function ur(mr){var wr=fr();return function(){var Ar=(0,er.default)(mr),vr;if(wr){var Ir=(0,er.default)(this).constructor;vr=Reflect.construct(Ar,arguments,Ir)}else vr=Ar.apply(this,arguments);return(0,tr.default)(this,vr)}}function fr(){if(typeof Reflect>"u"||!Reflect.construct||Reflect.construct.sham)return!1;if(typeof Proxy=="function")return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],function(){})),!0}catch{return!1}}var ar=function(mr,wr){var Sr={};for(var Ar in mr)Object.prototype.hasOwnProperty.call(mr,Ar)&&wr.indexOf(Ar)<0&&(Sr[Ar]=mr[Ar]);if(mr!=null&&typeof Object.getOwnPropertySymbols=="function")for(var vr=0,Ar=Object.getOwnPropertySymbols(mr);vr<Ar.length;vr++)wr.indexOf(Ar[vr])<0&&Object.prototype.propertyIsEnumerable.call(mr,Ar[vr])&&(Sr[Ar[vr]]=mr[Ar[vr]]);return Sr},yr=function(mr){(0,Je.default)(Sr,mr);var wr=ur(Sr);function Sr(Ar){var vr,Ir=arguments.length>1&&arguments[1]!==void 0?arguments[1]:"ws://localhost:8080",Tr=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{},Pr=arguments.length>3?arguments[3]:void 0;(0,Ze.default)(this,Sr);var Rr=Tr.autoconnect,Br=Rr===void 0?!0:Rr,Mr=Tr.reconnect,Lr=Mr===void 0?!0:Mr,$r=Tr.reconnect_interval,Nr=$r===void 0?1e3:$r,cr=Tr.max_reconnects,Dt=cr===void 0?5:cr,sr=ar(Tr,["autoconnect","reconnect","reconnect_interval","max_reconnects"]);return vr=wr.call(this),vr.webSocketFactory=Ar,vr.queue={},vr.rpc_id=0,vr.address=Ir,vr.autoconnect=Br,vr.ready=!1,vr.reconnect=Lr,vr.reconnect_interval=Nr,vr.max_reconnects=Dt,vr.rest_options=sr,vr.current_reconnects=0,vr.generate_request_id=Pr||function(){return++vr.rpc_id},vr.autoconnect&&vr._connect(vr.address,Object.assign({autoconnect:vr.autoconnect,reconnect:vr.reconnect,reconnect_interval:vr.reconnect_interval,max_reconnects:vr.max_reconnects},vr.rest_options)),vr}return(0,Xe.default)(Sr,[{key:"connect",value:function(){this.socket||this._connect(this.address,Object.assign({autoconnect:this.autoconnect,reconnect:this.reconnect,reconnect_interval:this.reconnect_interval,max_reconnects:this.max_reconnects},this.rest_options))}},{key:"call",value:function(vr,Ir,Tr,Pr){var Rr=this;return!Pr&&(0,We.default)(Tr)==="object"&&(Pr=Tr,Tr=null),new Promise(function(Br,Mr){if(!Rr.ready)return Mr(new Error("socket not ready"));var Lr=Rr.generate_request_id(vr,Ir),$r={jsonrpc:"2.0",method:vr,params:Ir||null,id:Lr};Rr.socket.send(JSON.stringify($r),Pr,function(Nr){if(Nr)return Mr(Nr);Rr.queue[Lr]={promise:[Br,Mr]},Tr&&(Rr.queue[Lr].timeout=setTimeout(function(){delete Rr.queue[Lr],Mr(new Error("reply timeout"))},Tr))})})}},{key:"login",value:function(){var Ar=(0,qe.default)(Fe.default.mark(function Ir(Tr){var Pr;return Fe.default.wrap(function(Br){for(;;)switch(Br.prev=Br.next){case 0:return Br.next=2,this.call("rpc.login",Tr);case 2:if(Pr=Br.sent,Pr){Br.next=5;break}throw new Error("authentication failed");case 5:return Br.abrupt("return",Pr);case 6:case"end":return Br.stop()}},Ir,this)}));function vr(Ir){return Ar.apply(this,arguments)}return vr}()},{key:"listMethods",value:function(){var Ar=(0,qe.default)(Fe.default.mark(function Ir(){return Fe.default.wrap(function(Pr){for(;;)switch(Pr.prev=Pr.next){case 0:return Pr.next=2,this.call("__listMethods");case 2:return Pr.abrupt("return",Pr.sent);case 3:case"end":return Pr.stop()}},Ir,this)}));function vr(){return Ar.apply(this,arguments)}return vr}()},{key:"notify",value:function(vr,Ir){var Tr=this;return new Promise(function(Pr,Rr){if(!Tr.ready)return Rr(new Error("socket not ready"));var Br={jsonrpc:"2.0",method:vr,params:Ir||null};Tr.socket.send(JSON.stringify(Br),function(Mr){if(Mr)return Rr(Mr);Pr()})})}},{key:"subscribe",value:function(){var Ar=(0,qe.default)(Fe.default.mark(function Ir(Tr){var Pr;return Fe.default.wrap(function(Br){for(;;)switch(Br.prev=Br.next){case 0:return typeof Tr=="string"&&(Tr=[Tr]),Br.next=3,this.call("rpc.on",Tr);case 3:if(Pr=Br.sent,!(typeof Tr=="string"&&Pr[Tr]!=="ok")){Br.next=6;break}throw new Error("Failed subscribing to an event '"+Tr+"' with: "+Pr[Tr]);case 6:return Br.abrupt("return",Pr);case 7:case"end":return Br.stop()}},Ir,this)}));function vr(Ir){return Ar.apply(this,arguments)}return vr}()},{key:"unsubscribe",value:function(){var Ar=(0,qe.default)(Fe.default.mark(function Ir(Tr){var Pr;return Fe.default.wrap(function(Br){for(;;)switch(Br.prev=Br.next){case 0:return typeof Tr=="string"&&(Tr=[Tr]),Br.next=3,this.call("rpc.off",Tr);case 3:if(Pr=Br.sent,!(typeof Tr=="string"&&Pr[Tr]!=="ok")){Br.next=6;break}throw new Error("Failed unsubscribing from an event with: "+Pr);case 6:return Br.abrupt("return",Pr);case 7:case"end":return Br.stop()}},Ir,this)}));function vr(Ir){return Ar.apply(this,arguments)}return vr}()},{key:"close",value:function(vr,Ir){this.socket.close(vr||1e3,Ir)}},{key:"_connect",value:function(vr,Ir){var Tr=this;this.socket=this.webSocketFactory(vr,Ir),this.socket.addEventListener("open",function(){Tr.ready=!0,Tr.emit("open"),Tr.current_reconnects=0}),this.socket.addEventListener("message",function(Pr){var Rr=Pr.data;Rr instanceof ArrayBuffer&&(Rr=Buffer.from(Rr).toString());try{Rr=JSON.parse(Rr)}catch{return}if(Rr.notification&&Tr.listeners(Rr.notification).length){if(!Object.keys(Rr.params).length)return Tr.emit(Rr.notification);var Br=[Rr.notification];if(Rr.params.constructor===Object)Br.push(Rr.params);else for(var Mr=0;Mr<Rr.params.length;Mr++)Br.push(Rr.params[Mr]);return Promise.resolve().then(function(){Tr.emit.apply(Tr,Br)})}if(!Tr.queue[Rr.id])return Rr.method&&Rr.params?Promise.resolve().then(function(){Tr.emit(Rr.method,Rr.params)}):void 0;"error"in Rr=="result"in Rr&&Tr.queue[Rr.id].promise[1](new Error('Server response malformed. Response must include either "result" or "error", but not both.')),Tr.queue[Rr.id].timeout&&clearTimeout(Tr.queue[Rr.id].timeout),Rr.error?Tr.queue[Rr.id].promise[1](Rr.error):Tr.queue[Rr.id].promise[0](Rr.result),delete Tr.queue[Rr.id]}),this.socket.addEventListener("error",function(Pr){return Tr.emit("error",Pr)}),this.socket.addEventListener("close",function(Pr){var Rr=Pr.code,Br=Pr.reason;Tr.ready&&setTimeout(function(){return Tr.emit("close",Rr,Br)},0),Tr.ready=!1,Tr.socket=void 0,Rr!==1e3&&(Tr.current_reconnects++,Tr.reconnect&&(Tr.max_reconnects>Tr.current_reconnects||Tr.max_reconnects===0)&&setTimeout(function(){return Tr._connect(vr,Ir)},Tr.reconnect_interval))})}}]),Sr}(ir.EventEmitter);Ke.default=yr}(client)),client}var _interopRequireDefault=interopRequireDefault.exports;Object.defineProperty(index_browser,"__esModule",{value:!0});var Client_1=index_browser.Client=void 0,_createClass2=_interopRequireDefault(requireCreateClass()),_classCallCheck2=_interopRequireDefault(requireClassCallCheck()),_inherits2=_interopRequireDefault(requireInherits()),_possibleConstructorReturn2=_interopRequireDefault(requirePossibleConstructorReturn()),_getPrototypeOf2=_interopRequireDefault(requireGetPrototypeOf()),_websocket=_interopRequireDefault(requireWebsocket_browser()),_client=_interopRequireDefault(requireClient());function _createSuper(Ke){var Re=_isNativeReflectConstruct();return function(){var qe=(0,_getPrototypeOf2.default)(Ke),We;if(Re){var Ze=(0,_getPrototypeOf2.default)(this).constructor;We=Reflect.construct(qe,arguments,Ze)}else We=qe.apply(this,arguments);return(0,_possibleConstructorReturn2.default)(this,We)}}function _isNativeReflectConstruct(){if(typeof Reflect>"u"||!Reflect.construct||Reflect.construct.sham)return!1;if(typeof Proxy=="function")return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],function(){})),!0}catch{return!1}}var Client=function(Ke){(0,_inherits2.default)(Fe,Ke);var Re=_createSuper(Fe);function Fe(){var qe=arguments.length>0&&arguments[0]!==void 0?arguments[0]:"ws://localhost:8080",We=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{},Ze=We.autoconnect,Xe=Ze===void 0?!0:Ze,Je=We.reconnect,tr=Je===void 0?!0:Je,er=We.reconnect_interval,ir=er===void 0?1e3:er,ur=We.max_reconnects,fr=ur===void 0?5:ur,ar=arguments.length>2?arguments[2]:void 0;return(0,_classCallCheck2.default)(this,Fe),Re.call(this,_websocket.default,qe,{autoconnect:Xe,reconnect:tr,reconnect_interval:ir,max_reconnects:fr},ar)}return(0,_createClass2.default)(Fe)}(_client.default);Client_1=index_browser.Client=Client;var getRandomValues,rnds8=new Uint8Array(16);function rng(){if(!getRandomValues&&(getRandomValues=typeof crypto<"u"&&crypto.getRandomValues&&crypto.getRandomValues.bind(crypto)||typeof msCrypto<"u"&&typeof msCrypto.getRandomValues=="function"&&msCrypto.getRandomValues.bind(msCrypto),!getRandomValues))throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");return getRandomValues(rnds8)}const REGEX=/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;function validate(Ke){return typeof Ke=="string"&&REGEX.test(Ke)}var byteToHex=[];for(var i=0;i<256;++i)byteToHex.push((i+256).toString(16).substr(1));function stringify$1(Ke){var Re=arguments.length>1&&arguments[1]!==void 0?arguments[1]:0,Fe=(byteToHex[Ke[Re+0]]+byteToHex[Ke[Re+1]]+byteToHex[Ke[Re+2]]+byteToHex[Ke[Re+3]]+"-"+byteToHex[Ke[Re+4]]+byteToHex[Ke[Re+5]]+"-"+byteToHex[Ke[Re+6]]+byteToHex[Ke[Re+7]]+"-"+byteToHex[Ke[Re+8]]+byteToHex[Ke[Re+9]]+"-"+byteToHex[Ke[Re+10]]+byteToHex[Ke[Re+11]]+byteToHex[Ke[Re+12]]+byteToHex[Ke[Re+13]]+byteToHex[Ke[Re+14]]+byteToHex[Ke[Re+15]]).toLowerCase();if(!validate(Fe))throw TypeError("Stringified UUID is invalid");return Fe}var _nodeId,_clockseq,_lastMSecs=0,_lastNSecs=0;function v1(Ke,Re,Fe){var qe=Re&&Fe||0,We=Re||new Array(16);Ke=Ke||{};var Ze=Ke.node||_nodeId,Xe=Ke.clockseq!==void 0?Ke.clockseq:_clockseq;if(Ze==null||Xe==null){var Je=Ke.random||(Ke.rng||rng)();Ze==null&&(Ze=_nodeId=[Je[0]|1,Je[1],Je[2],Je[3],Je[4],Je[5]]),Xe==null&&(Xe=_clockseq=(Je[6]<<8|Je[7])&16383)}var tr=Ke.msecs!==void 0?Ke.msecs:Date.now(),er=Ke.nsecs!==void 0?Ke.nsecs:_lastNSecs+1,ir=tr-_lastMSecs+(er-_lastNSecs)/1e4;if(ir<0&&Ke.clockseq===void 0&&(Xe=Xe+1&16383),(ir<0||tr>_lastMSecs)&&Ke.nsecs===void 0&&(er=0),er>=1e4)throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");_lastMSecs=tr,_lastNSecs=er,_clockseq=Xe,tr+=122192928e5;var ur=((tr&268435455)*1e4+er)%4294967296;We[qe++]=ur>>>24&255,We[qe++]=ur>>>16&255,We[qe++]=ur>>>8&255,We[qe++]=ur&255;var fr=tr/4294967296*1e4&268435455;We[qe++]=fr>>>8&255,We[qe++]=fr&255,We[qe++]=fr>>>24&15|16,We[qe++]=fr>>>16&255,We[qe++]=Xe>>>8|128,We[qe++]=Xe&255;for(var ar=0;ar<6;++ar)We[qe+ar]=Ze[ar];return Re||stringify$1(We)}function parse(Ke){if(!validate(Ke))throw TypeError("Invalid UUID");var Re,Fe=new Uint8Array(16);return Fe[0]=(Re=parseInt(Ke.slice(0,8),16))>>>24,Fe[1]=Re>>>16&255,Fe[2]=Re>>>8&255,Fe[3]=Re&255,Fe[4]=(Re=parseInt(Ke.slice(9,13),16))>>>8,Fe[5]=Re&255,Fe[6]=(Re=parseInt(Ke.slice(14,18),16))>>>8,Fe[7]=Re&255,Fe[8]=(Re=parseInt(Ke.slice(19,23),16))>>>8,Fe[9]=Re&255,Fe[10]=(Re=parseInt(Ke.slice(24,36),16))/1099511627776&255,Fe[11]=Re/4294967296&255,Fe[12]=Re>>>24&255,Fe[13]=Re>>>16&255,Fe[14]=Re>>>8&255,Fe[15]=Re&255,Fe}function stringToBytes(Ke){Ke=unescape(encodeURIComponent(Ke));for(var Re=[],Fe=0;Fe<Ke.length;++Fe)Re.push(Ke.charCodeAt(Fe));return Re}var DNS="6ba7b810-9dad-11d1-80b4-00c04fd430c8",URL="6ba7b811-9dad-11d1-80b4-00c04fd430c8";function v35(Ke,Re,Fe){function qe(We,Ze,Xe,Je){if(typeof We=="string"&&(We=stringToBytes(We)),typeof Ze=="string"&&(Ze=parse(Ze)),Ze.length!==16)throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");var tr=new Uint8Array(16+We.length);if(tr.set(Ze),tr.set(We,Ze.length),tr=Fe(tr),tr[6]=tr[6]&15|Re,tr[8]=tr[8]&63|128,Xe){Je=Je||0;for(var er=0;er<16;++er)Xe[Je+er]=tr[er];return Xe}return stringify$1(tr)}try{qe.name=Ke}catch{}return qe.DNS=DNS,qe.URL=URL,qe}function md5(Ke){if(typeof Ke=="string"){var Re=unescape(encodeURIComponent(Ke));Ke=new Uint8Array(Re.length);for(var Fe=0;Fe<Re.length;++Fe)Ke[Fe]=Re.charCodeAt(Fe)}return md5ToHexEncodedArray(wordsToMd5(bytesToWords(Ke),Ke.length*8))}function md5ToHexEncodedArray(Ke){for(var Re=[],Fe=Ke.length*32,qe="0123456789abcdef",We=0;We<Fe;We+=8){var Ze=Ke[We>>5]>>>We%32&255,Xe=parseInt(qe.charAt(Ze>>>4&15)+qe.charAt(Ze&15),16);Re.push(Xe)}return Re}function getOutputLength(Ke){return(Ke+64>>>9<<4)+14+1}function wordsToMd5(Ke,Re){Ke[Re>>5]|=128<<Re%32,Ke[getOutputLength(Re)-1]=Re;for(var Fe=1732584193,qe=-271733879,We=-1732584194,Ze=271733878,Xe=0;Xe<Ke.length;Xe+=16){var Je=Fe,tr=qe,er=We,ir=Ze;Fe=md5ff(Fe,qe,We,Ze,Ke[Xe],7,-680876936),Ze=md5ff(Ze,Fe,qe,We,Ke[Xe+1],12,-389564586),We=md5ff(We,Ze,Fe,qe,Ke[Xe+2],17,606105819),qe=md5ff(qe,We,Ze,Fe,Ke[Xe+3],22,-1044525330),Fe=md5ff(Fe,qe,We,Ze,Ke[Xe+4],7,-176418897),Ze=md5ff(Ze,Fe,qe,We,Ke[Xe+5],12,1200080426),We=md5ff(We,Ze,Fe,qe,Ke[Xe+6],17,-1473231341),qe=md5ff(qe,We,Ze,Fe,Ke[Xe+7],22,-45705983),Fe=md5ff(Fe,qe,We,Ze,Ke[Xe+8],7,1770035416),Ze=md5ff(Ze,Fe,qe,We,Ke[Xe+9],12,-1958414417),We=md5ff(We,Ze,Fe,qe,Ke[Xe+10],17,-42063),qe=md5ff(qe,We,Ze,Fe,Ke[Xe+11],22,-1990404162),Fe=md5ff(Fe,qe,We,Ze,Ke[Xe+12],7,1804603682),Ze=md5ff(Ze,Fe,qe,We,Ke[Xe+13],12,-40341101),We=md5ff(We,Ze,Fe,qe,Ke[Xe+14],17,-1502002290),qe=md5ff(qe,We,Ze,Fe,Ke[Xe+15],22,1236535329),Fe=md5gg(Fe,qe,We,Ze,Ke[Xe+1],5,-165796510),Ze=md5gg(Ze,Fe,qe,We,Ke[Xe+6],9,-1069501632),We=md5gg(We,Ze,Fe,qe,Ke[Xe+11],14,643717713),qe=md5gg(qe,We,Ze,Fe,Ke[Xe],20,-373897302),Fe=md5gg(Fe,qe,We,Ze,Ke[Xe+5],5,-701558691),Ze=md5gg(Ze,Fe,qe,We,Ke[Xe+10],9,38016083),We=md5gg(We,Ze,Fe,qe,Ke[Xe+15],14,-660478335),qe=md5gg(qe,We,Ze,Fe,Ke[Xe+4],20,-405537848),Fe=md5gg(Fe,qe,We,Ze,Ke[Xe+9],5,568446438),Ze=md5gg(Ze,Fe,qe,We,Ke[Xe+14],9,-1019803690),We=md5gg(We,Ze,Fe,qe,Ke[Xe+3],14,-187363961),qe=md5gg(qe,We,Ze,Fe,Ke[Xe+8],20,1163531501),Fe=md5gg(Fe,qe,We,Ze,Ke[Xe+13],5,-1444681467),Ze=md5gg(Ze,Fe,qe,We,Ke[Xe+2],9,-51403784),We=md5gg(We,Ze,Fe,qe,Ke[Xe+7],14,1735328473),qe=md5gg(qe,We,Ze,Fe,Ke[Xe+12],20,-1926607734),Fe=md5hh(Fe,qe,We,Ze,Ke[Xe+5],4,-378558),Ze=md5hh(Ze,Fe,qe,We,Ke[Xe+8],11,-2022574463),We=md5hh(We,Ze,Fe,qe,Ke[Xe+11],16,1839030562),qe=md5hh(qe,We,Ze,Fe,Ke[Xe+14],23,-35309556),Fe=md5hh(Fe,qe,We,Ze,Ke[Xe+1],4,-1530992060),Ze=md5hh(Ze,Fe,qe,We,Ke[Xe+4],11,1272893353),We=md5hh(We,Ze,Fe,qe,Ke[Xe+7],16,-155497632),qe=md5hh(qe,We,Ze,Fe,Ke[Xe+10],23,-1094730640),Fe=md5hh(Fe,qe,We,Ze,Ke[Xe+13],4,681279174),Ze=md5hh(Ze,Fe,qe,We,Ke[Xe],11,-358537222),We=md5hh(We,Ze,Fe,qe,Ke[Xe+3],16,-722521979),qe=md5hh(qe,We,Ze,Fe,Ke[Xe+6],23,76029189),Fe=md5hh(Fe,qe,We,Ze,Ke[Xe+9],4,-640364487),Ze=md5hh(Ze,Fe,qe,We,Ke[Xe+12],11,-421815835),We=md5hh(We,Ze,Fe,qe,Ke[Xe+15],16,530742520),qe=md5hh(qe,We,Ze,Fe,Ke[Xe+2],23,-995338651),Fe=md5ii(Fe,qe,We,Ze,Ke[Xe],6,-198630844),Ze=md5ii(Ze,Fe,qe,We,Ke[Xe+7],10,1126891415),We=md5ii(We,Ze,Fe,qe,Ke[Xe+14],15,-1416354905),qe=md5ii(qe,We,Ze,Fe,Ke[Xe+5],21,-57434055),Fe=md5ii(Fe,qe,We,Ze,Ke[Xe+12],6,1700485571),Ze=md5ii(Ze,Fe,qe,We,Ke[Xe+3],10,-1894986606),We=md5ii(We,Ze,Fe,qe,Ke[Xe+10],15,-1051523),qe=md5ii(qe,We,Ze,Fe,Ke[Xe+1],21,-2054922799),Fe=md5ii(Fe,qe,We,Ze,Ke[Xe+8],6,1873313359),Ze=md5ii(Ze,Fe,qe,We,Ke[Xe+15],10,-30611744),We=md5ii(We,Ze,Fe,qe,Ke[Xe+6],15,-1560198380),qe=md5ii(qe,We,Ze,Fe,Ke[Xe+13],21,1309151649),Fe=md5ii(Fe,qe,We,Ze,Ke[Xe+4],6,-145523070),Ze=md5ii(Ze,Fe,qe,We,Ke[Xe+11],10,-1120210379),We=md5ii(We,Ze,Fe,qe,Ke[Xe+2],15,718787259),qe=md5ii(qe,We,Ze,Fe,Ke[Xe+9],21,-343485551),Fe=safeAdd(Fe,Je),qe=safeAdd(qe,tr),We=safeAdd(We,er),Ze=safeAdd(Ze,ir)}return[Fe,qe,We,Ze]}function bytesToWords(Ke){if(Ke.length===0)return[];for(var Re=Ke.length*8,Fe=new Uint32Array(getOutputLength(Re)),qe=0;qe<Re;qe+=8)Fe[qe>>5]|=(Ke[qe/8]&255)<<qe%32;return Fe}function safeAdd(Ke,Re){var Fe=(Ke&65535)+(Re&65535),qe=(Ke>>16)+(Re>>16)+(Fe>>16);return qe<<16|Fe&65535}function bitRotateLeft(Ke,Re){return Ke<<Re|Ke>>>32-Re}function md5cmn(Ke,Re,Fe,qe,We,Ze){return safeAdd(bitRotateLeft(safeAdd(safeAdd(Re,Ke),safeAdd(qe,Ze)),We),Fe)}function md5ff(Ke,Re,Fe,qe,We,Ze,Xe){return md5cmn(Re&Fe|~Re&qe,Ke,Re,We,Ze,Xe)}function md5gg(Ke,Re,Fe,qe,We,Ze,Xe){return md5cmn(Re&qe|Fe&~qe,Ke,Re,We,Ze,Xe)}function md5hh(Ke,Re,Fe,qe,We,Ze,Xe){return md5cmn(Re^Fe^qe,Ke,Re,We,Ze,Xe)}function md5ii(Ke,Re,Fe,qe,We,Ze,Xe){return md5cmn(Fe^(Re|~qe),Ke,Re,We,Ze,Xe)}var v3=v35("v3",48,md5);const v3$1=v3;function v4(Ke,Re,Fe){Ke=Ke||{};var qe=Ke.random||(Ke.rng||rng)();if(qe[6]=qe[6]&15|64,qe[8]=qe[8]&63|128,Re){Fe=Fe||0;for(var We=0;We<16;++We)Re[Fe+We]=qe[We];return Re}return stringify$1(qe)}function f(Ke,Re,Fe,qe){switch(Ke){case 0:return Re&Fe^~Re&qe;case 1:return Re^Fe^qe;case 2:return Re&Fe^Re&qe^Fe&qe;case 3:return Re^Fe^qe}}function ROTL(Ke,Re){return Ke<<Re|Ke>>>32-Re}function sha1(Ke){var Re=[1518500249,1859775393,2400959708,3395469782],Fe=[1732584193,4023233417,2562383102,271733878,3285377520];if(typeof Ke=="string"){var qe=unescape(encodeURIComponent(Ke));Ke=[];for(var We=0;We<qe.length;++We)Ke.push(qe.charCodeAt(We))}else Array.isArray(Ke)||(Ke=Array.prototype.slice.call(Ke));Ke.push(128);for(var Ze=Ke.length/4+2,Xe=Math.ceil(Ze/16),Je=new Array(Xe),tr=0;tr<Xe;++tr){for(var er=new Uint32Array(16),ir=0;ir<16;++ir)er[ir]=Ke[tr*64+ir*4]<<24|Ke[tr*64+ir*4+1]<<16|Ke[tr*64+ir*4+2]<<8|Ke[tr*64+ir*4+3];Je[tr]=er}Je[Xe-1][14]=(Ke.length-1)*8/Math.pow(2,32),Je[Xe-1][14]=Math.floor(Je[Xe-1][14]),Je[Xe-1][15]=(Ke.length-1)*8&4294967295;for(var ur=0;ur<Xe;++ur){for(var fr=new Uint32Array(80),ar=0;ar<16;++ar)fr[ar]=Je[ur][ar];for(var yr=16;yr<80;++yr)fr[yr]=ROTL(fr[yr-3]^fr[yr-8]^fr[yr-14]^fr[yr-16],1);for(var mr=Fe[0],wr=Fe[1],Sr=Fe[2],Ar=Fe[3],vr=Fe[4],Ir=0;Ir<80;++Ir){var Tr=Math.floor(Ir/20),Pr=ROTL(mr,5)+f(Tr,wr,Sr,Ar)+vr+Re[Tr]+fr[Ir]>>>0;vr=Ar,Ar=Sr,Sr=ROTL(wr,30)>>>0,wr=mr,mr=Pr}Fe[0]=Fe[0]+mr>>>0,Fe[1]=Fe[1]+wr>>>0,Fe[2]=Fe[2]+Sr>>>0,Fe[3]=Fe[3]+Ar>>>0,Fe[4]=Fe[4]+vr>>>0}return[Fe[0]>>24&255,Fe[0]>>16&255,Fe[0]>>8&255,Fe[0]&255,Fe[1]>>24&255,Fe[1]>>16&255,Fe[1]>>8&255,Fe[1]&255,Fe[2]>>24&255,Fe[2]>>16&255,Fe[2]>>8&255,Fe[2]&255,Fe[3]>>24&255,Fe[3]>>16&255,Fe[3]>>8&255,Fe[3]&255,Fe[4]>>24&255,Fe[4]>>16&255,Fe[4]>>8&255,Fe[4]&255]}var v5=v35("v5",80,sha1);const v5$1=v5,nil="00000000-0000-0000-0000-000000000000";function version(Ke){if(!validate(Ke))throw TypeError("Invalid UUID");return parseInt(Ke.substr(14,1),16)}const esmBrowser=Object.freeze(Object.defineProperty({__proto__:null,v1,v3:v3$1,v4,v5:v5$1,NIL:nil,version,validate,stringify:stringify$1,parse},Symbol.toStringTag,{value:"Module"})),require$$0=getAugmentedNamespace(esmBrowser),uuid$1=require$$0.v4,generateRequest$1=function(Ke,Re,Fe,qe){if(typeof Ke!="string")throw new TypeError(Ke+" must be a string");qe=qe||{};const We=typeof qe.version=="number"?qe.version:2;if(We!==1&&We!==2)throw new TypeError(We+" must be 1 or 2");const Ze={method:Ke};if(We===2&&(Ze.jsonrpc="2.0"),Re){if(typeof Re!="object"&&!Array.isArray(Re))throw new TypeError(Re+" must be an object, array or omitted");Ze.params=Re}if(typeof Fe>"u"){const Xe=typeof qe.generator=="function"?qe.generator:function(){return uuid$1()};Ze.id=Xe(Ze,qe)}else We===2&&Fe===null?qe.notificationIdNull&&(Ze.id=null):Ze.id=Fe;return Ze};var generateRequest_1=generateRequest$1;const uuid=require$$0.v4,generateRequest=generateRequest_1,ClientBrowser=function(Ke,Re){if(!(this instanceof ClientBrowser))return new ClientBrowser(Ke,Re);Re||(Re={}),this.options={reviver:typeof Re.reviver<"u"?Re.reviver:null,replacer:typeof Re.replacer<"u"?Re.replacer:null,generator:typeof Re.generator<"u"?Re.generator:function(){return uuid()},version:typeof Re.version<"u"?Re.version:2,notificationIdNull:typeof Re.notificationIdNull=="boolean"?Re.notificationIdNull:!1},this.callServer=Ke};var browser=ClientBrowser;ClientBrowser.prototype.request=function(Ke,Re,Fe,qe){const We=this;let Ze=null;const Xe=Array.isArray(Ke)&&typeof Re=="function";if(this.options.version===1&&Xe)throw new TypeError("JSON-RPC 1.0 does not support batching");if(Xe||!Xe&&Ke&&typeof Ke=="object"&&typeof Re=="function")qe=Re,Ze=Ke;else{typeof Fe=="function"&&(qe=Fe,Fe=void 0);const er=typeof qe=="function";try{Ze=generateRequest(Ke,Re,Fe,{generator:this.options.generator,version:this.options.version,notificationIdNull:this.options.notificationIdNull})}catch(ir){if(er)return qe(ir);throw ir}if(!er)return Ze}let tr;try{tr=JSON.stringify(Ze,this.options.replacer)}catch(er){return qe(er)}return this.callServer(tr,function(er,ir){We._parseResponse(er,ir,qe)}),Ze};ClientBrowser.prototype._parseResponse=function(Ke,Re,Fe){if(Ke){Fe(Ke);return}if(!Re)return Fe();let qe;try{qe=JSON.parse(Re,this.options.reviver)}catch(We){return Fe(We)}if(Fe.length===3)if(Array.isArray(qe)){const We=function(Xe){return typeof Xe.error<"u"},Ze=function(Xe){return!We(Xe)};return Fe(null,qe.filter(We),qe.filter(Ze))}else return Fe(null,qe.error,qe.result);Fe(null,qe)};const[SHA3_PI,SHA3_ROTL,_SHA3_IOTA]=[[],[],[]],_0n$1=BigInt(0),_1n$1=BigInt(1),_2n$1=BigInt(2),_7n=BigInt(7),_256n=BigInt(256),_0x71n=BigInt(113);for(let Ke=0,Re=_1n$1,Fe=1,qe=0;Ke<24;Ke++){[Fe,qe]=[qe,(2*Fe+3*qe)%5],SHA3_PI.push(2*(5*qe+Fe)),SHA3_ROTL.push((Ke+1)*(Ke+2)/2%64);let We=_0n$1;for(let Ze=0;Ze<7;Ze++)Re=(Re<<_1n$1^(Re>>_7n)*_0x71n)%_256n,Re&_2n$1&&(We^=_1n$1<<(_1n$1<<BigInt(Ze))-_1n$1);_SHA3_IOTA.push(We)}const[SHA3_IOTA_H,SHA3_IOTA_L]=u64$1.split(_SHA3_IOTA,!0),rotlH=(Ke,Re,Fe)=>Fe>32?u64$1.rotlBH(Ke,Re,Fe):u64$1.rotlSH(Ke,Re,Fe),rotlL=(Ke,Re,Fe)=>Fe>32?u64$1.rotlBL(Ke,Re,Fe):u64$1.rotlSL(Ke,Re,Fe);function keccakP(Ke,Re=24){const Fe=new Uint32Array(10);for(let qe=24-Re;qe<24;qe++){for(let Xe=0;Xe<10;Xe++)Fe[Xe]=Ke[Xe]^Ke[Xe+10]^Ke[Xe+20]^Ke[Xe+30]^Ke[Xe+40];for(let Xe=0;Xe<10;Xe+=2){const Je=(Xe+8)%10,tr=(Xe+2)%10,er=Fe[tr],ir=Fe[tr+1],ur=rotlH(er,ir,1)^Fe[Je],fr=rotlL(er,ir,1)^Fe[Je+1];for(let ar=0;ar<50;ar+=10)Ke[Xe+ar]^=ur,Ke[Xe+ar+1]^=fr}let We=Ke[2],Ze=Ke[3];for(let Xe=0;Xe<24;Xe++){const Je=SHA3_ROTL[Xe],tr=rotlH(We,Ze,Je),er=rotlL(We,Ze,Je),ir=SHA3_PI[Xe];We=Ke[ir],Ze=Ke[ir+1],Ke[ir]=tr,Ke[ir+1]=er}for(let Xe=0;Xe<50;Xe+=10){for(let Je=0;Je<10;Je++)Fe[Je]=Ke[Xe+Je];for(let Je=0;Je<10;Je++)Ke[Xe+Je]^=~Fe[(Je+2)%10]&Fe[(Je+4)%10]}Ke[0]^=SHA3_IOTA_H[qe],Ke[1]^=SHA3_IOTA_L[qe]}Fe.fill(0)}class Keccak extends Hash{constructor(Re,Fe,qe,We=!1,Ze=24){if(super(),this.blockLen=Re,this.suffix=Fe,this.outputLen=qe,this.enableXOF=We,this.rounds=Ze,this.pos=0,this.posOut=0,this.finished=!1,this.destroyed=!1,assert$2.number(qe),0>=this.blockLen||this.blockLen>=200)throw new Error("Sha3 supports only keccak-f1600 function");this.state=new Uint8Array(200),this.state32=u32$1(this.state)}keccak(){keccakP(this.state32,this.rounds),this.posOut=0,this.pos=0}update(Re){assert$2.exists(this);const{blockLen:Fe,state:qe}=this;Re=toBytes(Re);const We=Re.length;for(let Ze=0;Ze<We;){const Xe=Math.min(Fe-this.pos,We-Ze);for(let Je=0;Je<Xe;Je++)qe[this.pos++]^=Re[Ze++];this.pos===Fe&&this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;const{state:Re,suffix:Fe,pos:qe,blockLen:We}=this;Re[qe]^=Fe,(Fe&128)!==0&&qe===We-1&&this.keccak(),Re[We-1]^=128,this.keccak()}writeInto(Re){assert$2.exists(this,!1),assert$2.bytes(Re),this.finish();const Fe=this.state,{blockLen:qe}=this;for(let We=0,Ze=Re.length;We<Ze;){this.posOut>=qe&&this.keccak();const Xe=Math.min(qe-this.posOut,Ze-We);Re.set(Fe.subarray(this.posOut,this.posOut+Xe),We),this.posOut+=Xe,We+=Xe}return Re}xofInto(Re){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto(Re)}xof(Re){return assert$2.number(Re),this.xofInto(new Uint8Array(Re))}digestInto(Re){if(assert$2.output(Re,this),this.finished)throw new Error("digest() was already called");return this.writeInto(Re),this.destroy(),Re}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,this.state.fill(0)}_cloneInto(Re){const{blockLen:Fe,suffix:qe,outputLen:We,rounds:Ze,enableXOF:Xe}=this;return Re||(Re=new Keccak(Fe,qe,We,Xe,Ze)),Re.state32.set(this.state32),Re.pos=this.pos,Re.posOut=this.posOut,Re.finished=this.finished,Re.rounds=Ze,Re.suffix=qe,Re.outputLen=We,Re.enableXOF=Xe,Re.destroyed=this.destroyed,Re}}const gen=(Ke,Re,Fe)=>wrapConstructor(()=>new Keccak(Re,Ke,Fe));gen(6,144,224/8);gen(6,136,256/8);gen(6,104,384/8);gen(6,72,512/8);gen(1,144,224/8);const keccak_256=gen(1,136,256/8);gen(1,104,384/8);gen(1,72,512/8);const genShake=(Ke,Re,Fe)=>wrapConstructorWithOpts((qe={})=>new Keccak(Re,Ke,qe.dkLen===void 0?Fe:qe.dkLen,!0));genShake(31,168,128/8);genShake(31,136,256/8);class HMAC extends Hash{constructor(Re,Fe){super(),this.finished=!1,this.destroyed=!1,assert$2.hash(Re);const qe=toBytes(Fe);if(this.iHash=Re.create(),typeof this.iHash.update!="function")throw new TypeError("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const We=this.blockLen,Ze=new Uint8Array(We);Ze.set(qe.length>We?Re.create().update(qe).digest():qe);for(let Xe=0;Xe<Ze.length;Xe++)Ze[Xe]^=54;this.iHash.update(Ze),this.oHash=Re.create();for(let Xe=0;Xe<Ze.length;Xe++)Ze[Xe]^=106;this.oHash.update(Ze),Ze.fill(0)}update(Re){return assert$2.exists(this),this.iHash.update(Re),this}digestInto(Re){assert$2.exists(this),assert$2.bytes(Re,this.outputLen),this.finished=!0,this.iHash.digestInto(Re),this.oHash.update(Re),this.oHash.digestInto(Re),this.destroy()}digest(){const Re=new Uint8Array(this.oHash.outputLen);return this.digestInto(Re),Re}_cloneInto(Re){Re||(Re=Object.create(Object.getPrototypeOf(this),{}));const{oHash:Fe,iHash:qe,finished:We,destroyed:Ze,blockLen:Xe,outputLen:Je}=this;return Re=Re,Re.finished=We,Re.destroyed=Ze,Re.blockLen=Xe,Re.outputLen=Je,Re.oHash=Fe._cloneInto(Re.oHash),Re.iHash=qe._cloneInto(Re.iHash),Re}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const hmac=(Ke,Re,Fe)=>new HMAC(Ke,Re).update(Fe).digest();hmac.create=(Ke,Re)=>new HMAC(Ke,Re);/*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */const _0n=BigInt(0),_1n=BigInt(1),_2n=BigInt(2),_3n=BigInt(3),_8n=BigInt(8),CURVE=Object.freeze({a:_0n,b:BigInt(7),P:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),n:BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),h:_1n,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee")});function weistrass(Ke){const{a:Re,b:Fe}=CURVE,qe=mod(Ke*Ke),We=mod(qe*Ke);return mod(We+Re*Ke+Fe)}const USE_ENDOMORPHISM=CURVE.a===_0n;class ShaError extends Error{constructor(Re){super(Re)}}class JacobianPoint{constructor(Re,Fe,qe){this.x=Re,this.y=Fe,this.z=qe}static fromAffine(Re){if(!(Re instanceof Point))throw new TypeError("JacobianPoint#fromAffine: expected Point");return new JacobianPoint(Re.x,Re.y,_1n)}static toAffineBatch(Re){const Fe=invertBatch(Re.map(qe=>qe.z));return Re.map((qe,We)=>qe.toAffine(Fe[We]))}static normalizeZ(Re){return JacobianPoint.toAffineBatch(Re).map(JacobianPoint.fromAffine)}equals(Re){if(!(Re instanceof JacobianPoint))throw new TypeError("JacobianPoint expected");const{x:Fe,y:qe,z:We}=this,{x:Ze,y:Xe,z:Je}=Re,tr=mod(We*We),er=mod(Je*Je),ir=mod(Fe*er),ur=mod(Ze*tr),fr=mod(mod(qe*Je)*er),ar=mod(mod(Xe*We)*tr);return ir===ur&&fr===ar}negate(){return new JacobianPoint(this.x,mod(-this.y),this.z)}double(){const{x:Re,y:Fe,z:qe}=this,We=mod(Re*Re),Ze=mod(Fe*Fe),Xe=mod(Ze*Ze),Je=Re+Ze,tr=mod(_2n*(mod(Je*Je)-We-Xe)),er=mod(_3n*We),ir=mod(er*er),ur=mod(ir-_2n*tr),fr=mod(er*(tr-ur)-_8n*Xe),ar=mod(_2n*Fe*qe);return new JacobianPoint(ur,fr,ar)}add(Re){if(!(Re instanceof JacobianPoint))throw new TypeError("JacobianPoint expected");const{x:Fe,y:qe,z:We}=this,{x:Ze,y:Xe,z:Je}=Re;if(Ze===_0n||Xe===_0n)return this;if(Fe===_0n||qe===_0n)return Re;const tr=mod(We*We),er=mod(Je*Je),ir=mod(Fe*er),ur=mod(Ze*tr),fr=mod(mod(qe*Je)*er),ar=mod(mod(Xe*We)*tr),yr=mod(ur-ir),mr=mod(ar-fr);if(yr===_0n)return mr===_0n?this.double():JacobianPoint.ZERO;const wr=mod(yr*yr),Sr=mod(yr*wr),Ar=mod(ir*wr),vr=mod(mr*mr-Sr-_2n*Ar),Ir=mod(mr*(Ar-vr)-fr*Sr),Tr=mod(We*Je*yr);return new JacobianPoint(vr,Ir,Tr)}subtract(Re){return this.add(Re.negate())}multiplyUnsafe(Re){const Fe=JacobianPoint.ZERO;if(typeof Re=="bigint"&&Re===_0n)return Fe;let qe=normalizeScalar(Re);if(qe===_1n)return this;if(!USE_ENDOMORPHISM){let ur=Fe,fr=this;for(;qe>_0n;)qe&_1n&&(ur=ur.add(fr)),fr=fr.double(),qe>>=_1n;return ur}let{k1neg:We,k1:Ze,k2neg:Xe,k2:Je}=splitScalarEndo(qe),tr=Fe,er=Fe,ir=this;for(;Ze>_0n||Je>_0n;)Ze&_1n&&(tr=tr.add(ir)),Je&_1n&&(er=er.add(ir)),ir=ir.double(),Ze>>=_1n,Je>>=_1n;return We&&(tr=tr.negate()),Xe&&(er=er.negate()),er=new JacobianPoint(mod(er.x*CURVE.beta),er.y,er.z),tr.add(er)}precomputeWindow(Re){const Fe=USE_ENDOMORPHISM?128/Re+1:256/Re+1,qe=[];let We=this,Ze=We;for(let Xe=0;Xe<Fe;Xe++){Ze=We,qe.push(Ze);for(let Je=1;Je<2**(Re-1);Je++)Ze=Ze.add(We),qe.push(Ze);We=Ze.double()}return qe}wNAF(Re,Fe){!Fe&&this.equals(JacobianPoint.BASE)&&(Fe=Point.BASE);const qe=Fe&&Fe._WINDOW_SIZE||1;if(256%qe)throw new Error("Point#wNAF: Invalid precomputation window, must be power of 2");let We=Fe&&pointPrecomputes.get(Fe);We||(We=this.precomputeWindow(qe),Fe&&qe!==1&&(We=JacobianPoint.normalizeZ(We),pointPrecomputes.set(Fe,We)));let Ze=JacobianPoint.ZERO,Xe=JacobianPoint.ZERO;const Je=1+(USE_ENDOMORPHISM?128/qe:256/qe),tr=2**(qe-1),er=BigInt(2**qe-1),ir=2**qe,ur=BigInt(qe);for(let fr=0;fr<Je;fr++){const ar=fr*tr;let yr=Number(Re&er);if(Re>>=ur,yr>tr&&(yr-=ir,Re+=_1n),yr===0){let mr=We[ar];fr%2&&(mr=mr.negate()),Xe=Xe.add(mr)}else{let mr=We[ar+Math.abs(yr)-1];yr<0&&(mr=mr.negate()),Ze=Ze.add(mr)}}return{p:Ze,f:Xe}}multiply(Re,Fe){let qe=normalizeScalar(Re),We,Ze;if(USE_ENDOMORPHISM){const{k1neg:Xe,k1:Je,k2neg:tr,k2:er}=splitScalarEndo(qe);let{p:ir,f:ur}=this.wNAF(Je,Fe),{p:fr,f:ar}=this.wNAF(er,Fe);Xe&&(ir=ir.negate()),tr&&(fr=fr.negate()),fr=new JacobianPoint(mod(fr.x*CURVE.beta),fr.y,fr.z),We=ir.add(fr),Ze=ur.add(ar)}else{const{p:Xe,f:Je}=this.wNAF(qe,Fe);We=Xe,Ze=Je}return JacobianPoint.normalizeZ([We,Ze])[0]}toAffine(Re=invert(this.z)){const{x:Fe,y:qe,z:We}=this,Ze=Re,Xe=mod(Ze*Ze),Je=mod(Xe*Ze),tr=mod(Fe*Xe),er=mod(qe*Je);if(mod(We*Ze)!==_1n)throw new Error("invZ was invalid");return new Point(tr,er)}}JacobianPoint.BASE=new JacobianPoint(CURVE.Gx,CURVE.Gy,_1n);JacobianPoint.ZERO=new JacobianPoint(_0n,_1n,_0n);const pointPrecomputes=new WeakMap;class Point{constructor(Re,Fe){this.x=Re,this.y=Fe}_setWindowSize(Re){this._WINDOW_SIZE=Re,pointPrecomputes.delete(this)}hasEvenY(){return this.y%_2n===_0n}static fromCompressedHex(Re){const Fe=Re.length===32,qe=bytesToNumber(Fe?Re:Re.subarray(1));if(!isValidFieldElement(qe))throw new Error("Point is not on curve");const We=weistrass(qe);let Ze=sqrtMod(We);const Xe=(Ze&_1n)===_1n;Fe?Xe&&(Ze=mod(-Ze)):(Re[0]&1)===1!==Xe&&(Ze=mod(-Ze));const Je=new Point(qe,Ze);return Je.assertValidity(),Je}static fromUncompressedHex(Re){const Fe=bytesToNumber(Re.subarray(1,33)),qe=bytesToNumber(Re.subarray(33,65)),We=new Point(Fe,qe);return We.assertValidity(),We}static fromHex(Re){const Fe=ensureBytes(Re),qe=Fe.length,We=Fe[0];if(qe===32||qe===33&&(We===2||We===3))return this.fromCompressedHex(Fe);if(qe===65&&We===4)return this.fromUncompressedHex(Fe);throw new Error(`Point.fromHex: received invalid point. Expected 32-33 compressed bytes or 65 uncompressed bytes, not ${qe}`)}static fromPrivateKey(Re){return Point.BASE.multiply(normalizePrivateKey(Re))}static fromSignature(Re,Fe,qe){Re=ensureBytes(Re);const We=truncateHash(Re),{r:Ze,s:Xe}=normalizeSignature(Fe);if(qe!==0&&qe!==1)throw new Error("Cannot recover signature: invalid recovery bit");const Je=qe&1?"03":"02",tr=Point.fromHex(Je+numTo32bStr(Ze)),{n:er}=CURVE,ir=invert(Ze,er),ur=mod(-We*ir,er),fr=mod(Xe*ir,er),ar=Point.BASE.multiplyAndAddUnsafe(tr,ur,fr);if(!ar)throw new Error("Cannot recover signature: point at infinify");return ar.assertValidity(),ar}toRawBytes(Re=!1){return hexToBytes(this.toHex(Re))}toHex(Re=!1){const Fe=numTo32bStr(this.x);return Re?`${this.hasEvenY()?"02":"03"}${Fe}`:`04${Fe}${numTo32bStr(this.y)}`}toHexX(){return this.toHex(!0).slice(2)}toRawX(){return this.toRawBytes(!0).slice(1)}assertValidity(){const Re="Point is not on elliptic curve",{x:Fe,y:qe}=this;if(!isValidFieldElement(Fe)||!isValidFieldElement(qe))throw new Error(Re);const We=mod(qe*qe),Ze=weistrass(Fe);if(mod(We-Ze)!==_0n)throw new Error(Re)}equals(Re){return this.x===Re.x&&this.y===Re.y}negate(){return new Point(this.x,mod(-this.y))}double(){return JacobianPoint.fromAffine(this).double().toAffine()}add(Re){return JacobianPoint.fromAffine(this).add(JacobianPoint.fromAffine(Re)).toAffine()}subtract(Re){return this.add(Re.negate())}multiply(Re){return JacobianPoint.fromAffine(this).multiply(Re,this).toAffine()}multiplyAndAddUnsafe(Re,Fe,qe){const We=JacobianPoint.fromAffine(this),Ze=Fe===_0n||Fe===_1n||this!==Point.BASE?We.multiplyUnsafe(Fe):We.multiply(Fe),Xe=JacobianPoint.fromAffine(Re).multiplyUnsafe(qe),Je=Ze.add(Xe);return Je.equals(JacobianPoint.ZERO)?void 0:Je.toAffine()}}Point.BASE=new Point(CURVE.Gx,CURVE.Gy);Point.ZERO=new Point(_0n,_0n);function sliceDER(Ke){return Number.parseInt(Ke[0],16)>=8?"00"+Ke:Ke}function parseDERInt(Ke){if(Ke.length<2||Ke[0]!==2)throw new Error(`Invalid signature integer tag: ${bytesToHex(Ke)}`);const Re=Ke[1],Fe=Ke.subarray(2,Re+2);if(!Re||Fe.length!==Re)throw new Error("Invalid signature integer: wrong length");if(Fe[0]===0&&Fe[1]<=127)throw new Error("Invalid signature integer: trailing length");return{data:bytesToNumber(Fe),left:Ke.subarray(Re+2)}}function parseDERSignature(Ke){if(Ke.length<2||Ke[0]!=48)throw new Error(`Invalid signature tag: ${bytesToHex(Ke)}`);if(Ke[1]!==Ke.length-2)throw new Error("Invalid signature: incorrect length");const{data:Re,left:Fe}=parseDERInt(Ke.subarray(2)),{data:qe,left:We}=parseDERInt(Fe);if(We.length)throw new Error(`Invalid signature: left bytes after parsing: ${bytesToHex(We)}`);return{r:Re,s:qe}}class Signature{constructor(Re,Fe){this.r=Re,this.s=Fe,this.assertValidity()}static fromCompact(Re){const Fe=Re instanceof Uint8Array,qe="Signature.fromCompact";if(typeof Re!="string"&&!Fe)throw new TypeError(`${qe}: Expected string or Uint8Array`);const We=Fe?bytesToHex(Re):Re;if(We.length!==128)throw new Error(`${qe}: Expected 64-byte hex`);return new Signature(hexToNumber(We.slice(0,64)),hexToNumber(We.slice(64,128)))}static fromDER(Re){const Fe=Re instanceof Uint8Array;if(typeof Re!="string"&&!Fe)throw new TypeError("Signature.fromDER: Expected string or Uint8Array");const{r:qe,s:We}=parseDERSignature(Fe?Re:hexToBytes(Re));return new Signature(qe,We)}static fromHex(Re){return this.fromDER(Re)}assertValidity(){const{r:Re,s:Fe}=this;if(!isWithinCurveOrder(Re))throw new Error("Invalid Signature: r must be 0 < r < n");if(!isWithinCurveOrder(Fe))throw new Error("Invalid Signature: s must be 0 < s < n")}hasHighS(){const Re=CURVE.n>>_1n;return this.s>Re}normalizeS(){return this.hasHighS()?new Signature(this.r,CURVE.n-this.s):this}toDERRawBytes(Re=!1){return hexToBytes(this.toDERHex(Re))}toDERHex(Re=!1){const Fe=sliceDER(numberToHexUnpadded(this.s));if(Re)return Fe;const qe=sliceDER(numberToHexUnpadded(this.r)),We=numberToHexUnpadded(qe.length/2),Ze=numberToHexUnpadded(Fe.length/2);return`30${numberToHexUnpadded(qe.length/2+Fe.length/2+4)}02${We}${qe}02${Ze}${Fe}`}toRawBytes(){return this.toDERRawBytes()}toHex(){return this.toDERHex()}toCompactRawBytes(){return hexToBytes(this.toCompactHex())}toCompactHex(){return numTo32bStr(this.r)+numTo32bStr(this.s)}}function concatBytes(...Ke){if(!Ke.every(qe=>qe instanceof Uint8Array))throw new Error("Uint8Array list expected");if(Ke.length===1)return Ke[0];const Re=Ke.reduce((qe,We)=>qe+We.length,0),Fe=new Uint8Array(Re);for(let qe=0,We=0;qe<Ke.length;qe++){const Ze=Ke[qe];Fe.set(Ze,We),We+=Ze.length}return Fe}const hexes=Array.from({length:256},(Ke,Re)=>Re.toString(16).padStart(2,"0"));function bytesToHex(Ke){if(!(Ke instanceof Uint8Array))throw new Error("Expected Uint8Array");let Re="";for(let Fe=0;Fe<Ke.length;Fe++)Re+=hexes[Ke[Fe]];return Re}const POW_2_256=BigInt("0x10000000000000000000000000000000000000000000000000000000000000000");function numTo32bStr(Ke){if(typeof Ke!="bigint")throw new Error("Expected bigint");if(!(_0n<=Ke&&Ke<POW_2_256))throw new Error("Expected number < 2^256");return Ke.toString(16).padStart(64,"0")}function numTo32b(Ke){const Re=hexToBytes(numTo32bStr(Ke));if(Re.length!==32)throw new Error("Error: expected 32 bytes");return Re}function numberToHexUnpadded(Ke){const Re=Ke.toString(16);return Re.length&1?`0${Re}`:Re}function hexToNumber(Ke){if(typeof Ke!="string")throw new TypeError("hexToNumber: expected string, got "+typeof Ke);return BigInt(`0x${Ke}`)}function hexToBytes(Ke){if(typeof Ke!="string")throw new TypeError("hexToBytes: expected string, got "+typeof Ke);if(Ke.length%2)throw new Error("hexToBytes: received invalid unpadded hex"+Ke.length);const Re=new Uint8Array(Ke.length/2);for(let Fe=0;Fe<Re.length;Fe++){const qe=Fe*2,We=Ke.slice(qe,qe+2),Ze=Number.parseInt(We,16);if(Number.isNaN(Ze)||Ze<0)throw new Error("Invalid byte sequence");Re[Fe]=Ze}return Re}function bytesToNumber(Ke){return hexToNumber(bytesToHex(Ke))}function ensureBytes(Ke){return Ke instanceof Uint8Array?Uint8Array.from(Ke):hexToBytes(Ke)}function normalizeScalar(Ke){if(typeof Ke=="number"&&Number.isSafeInteger(Ke)&&Ke>0)return BigInt(Ke);if(typeof Ke=="bigint"&&isWithinCurveOrder(Ke))return Ke;throw new TypeError("Expected valid private scalar: 0 < scalar < curve.n")}function mod(Ke,Re=CURVE.P){const Fe=Ke%Re;return Fe>=_0n?Fe:Re+Fe}function pow2(Ke,Re){const{P:Fe}=CURVE;let qe=Ke;for(;Re-- >_0n;)qe*=qe,qe%=Fe;return qe}function sqrtMod(Ke){const{P:Re}=CURVE,Fe=BigInt(6),qe=BigInt(11),We=BigInt(22),Ze=BigInt(23),Xe=BigInt(44),Je=BigInt(88),tr=Ke*Ke*Ke%Re,er=tr*tr*Ke%Re,ir=pow2(er,_3n)*er%Re,ur=pow2(ir,_3n)*er%Re,fr=pow2(ur,_2n)*tr%Re,ar=pow2(fr,qe)*fr%Re,yr=pow2(ar,We)*ar%Re,mr=pow2(yr,Xe)*yr%Re,wr=pow2(mr,Je)*mr%Re,Sr=pow2(wr,Xe)*yr%Re,Ar=pow2(Sr,_3n)*er%Re,vr=pow2(Ar,Ze)*ar%Re,Ir=pow2(vr,Fe)*tr%Re;return pow2(Ir,_2n)}function invert(Ke,Re=CURVE.P){if(Ke===_0n||Re<=_0n)throw new Error(`invert: expected positive integers, got n=${Ke} mod=${Re}`);let Fe=mod(Ke,Re),qe=Re,We=_0n,Ze=_1n;for(;Fe!==_0n;){const Je=qe/Fe,tr=qe%Fe,er=We-Ze*Je;qe=Fe,Fe=tr,We=Ze,Ze=er}if(qe!==_1n)throw new Error("invert: does not exist");return mod(We,Re)}function invertBatch(Ke,Re=CURVE.P){const Fe=new Array(Ke.length),qe=Ke.reduce((Ze,Xe,Je)=>Xe===_0n?Ze:(Fe[Je]=Ze,mod(Ze*Xe,Re)),_1n),We=invert(qe,Re);return Ke.reduceRight((Ze,Xe,Je)=>Xe===_0n?Ze:(Fe[Je]=mod(Ze*Fe[Je],Re),mod(Ze*Xe,Re)),We),Fe}const divNearest=(Ke,Re)=>(Ke+Re/_2n)/Re,ENDO={a1:BigInt("0x3086d221a7d46bcde86c90e49284eb15"),b1:-_1n*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),a2:BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),b2:BigInt("0x3086d221a7d46bcde86c90e49284eb15"),POW_2_128:BigInt("0x100000000000000000000000000000000")};function splitScalarEndo(Ke){const{n:Re}=CURVE,{a1:Fe,b1:qe,a2:We,b2:Ze,POW_2_128:Xe}=ENDO,Je=divNearest(Ze*Ke,Re),tr=divNearest(-qe*Ke,Re);let er=mod(Ke-Je*Fe-tr*We,Re),ir=mod(-Je*qe-tr*Ze,Re);const ur=er>Xe,fr=ir>Xe;if(ur&&(er=Re-er),fr&&(ir=Re-ir),er>Xe||ir>Xe)throw new Error("splitScalarEndo: Endomorphism failed, k="+Ke);return{k1neg:ur,k1:er,k2neg:fr,k2:ir}}function truncateHash(Ke){const{n:Re}=CURVE,qe=Ke.length*8-256;let We=bytesToNumber(Ke);return qe>0&&(We=We>>BigInt(qe)),We>=Re&&(We-=Re),We}let _sha256Sync,_hmacSha256Sync;class HmacDrbg{constructor(){this.v=new Uint8Array(32).fill(1),this.k=new Uint8Array(32).fill(0),this.counter=0}hmac(...Re){return utils.hmacSha256(this.k,...Re)}hmacSync(...Re){return _hmacSha256Sync(this.k,...Re)}checkSync(){if(typeof _hmacSha256Sync!="function")throw new ShaError("hmacSha256Sync needs to be set")}incr(){if(this.counter>=1e3)throw new Error("Tried 1,000 k values for sign(), all were invalid");this.counter+=1}async reseed(Re=new Uint8Array){this.k=await this.hmac(this.v,Uint8Array.from([0]),Re),this.v=await this.hmac(this.v),Re.length!==0&&(this.k=await this.hmac(this.v,Uint8Array.from([1]),Re),this.v=await this.hmac(this.v))}reseedSync(Re=new Uint8Array){this.checkSync(),this.k=this.hmacSync(this.v,Uint8Array.from([0]),Re),this.v=this.hmacSync(this.v),Re.length!==0&&(this.k=this.hmacSync(this.v,Uint8Array.from([1]),Re),this.v=this.hmacSync(this.v))}async generate(){return this.incr(),this.v=await this.hmac(this.v),this.v}generateSync(){return this.checkSync(),this.incr(),this.v=this.hmacSync(this.v),this.v}}function isWithinCurveOrder(Ke){return _0n<Ke&&Ke<CURVE.n}function isValidFieldElement(Ke){return _0n<Ke&&Ke<CURVE.P}function kmdToSig(Ke,Re,Fe){const qe=bytesToNumber(Ke);if(!isWithinCurveOrder(qe))return;const{n:We}=CURVE,Ze=Point.BASE.multiply(qe),Xe=mod(Ze.x,We);if(Xe===_0n)return;const Je=mod(invert(qe,We)*mod(Re+Fe*Xe,We),We);if(Je===_0n)return;const tr=new Signature(Xe,Je),er=(Ze.x===tr.r?0:2)|Number(Ze.y&_1n);return{sig:tr,recovery:er}}function normalizePrivateKey(Ke){let Re;if(typeof Ke=="bigint")Re=Ke;else if(typeof Ke=="number"&&Number.isSafeInteger(Ke)&&Ke>0)Re=BigInt(Ke);else if(typeof Ke=="string"){if(Ke.length!==64)throw new Error("Expected 32 bytes of private key");Re=hexToNumber(Ke)}else if(Ke instanceof Uint8Array){if(Ke.length!==32)throw new Error("Expected 32 bytes of private key");Re=bytesToNumber(Ke)}else throw new TypeError("Expected valid private key");if(!isWithinCurveOrder(Re))throw new Error("Expected private key: 0 < key < n");return Re}function normalizeSignature(Ke){if(Ke instanceof Signature)return Ke.assertValidity(),Ke;try{return Signature.fromDER(Ke)}catch{return Signature.fromCompact(Ke)}}function getPublicKey$1(Ke,Re=!1){return Point.fromPrivateKey(Ke).toRawBytes(Re)}function bits2int(Ke){const Re=Ke.length>32?Ke.slice(0,32):Ke;return bytesToNumber(Re)}function bits2octets(Ke){const Re=bits2int(Ke),Fe=mod(Re,CURVE.n);return int2octets(Fe<_0n?Re:Fe)}function int2octets(Ke){return numTo32b(Ke)}function initSigArgs(Ke,Re,Fe){if(Ke==null)throw new Error(`sign: expected valid message hash, not "${Ke}"`);const qe=ensureBytes(Ke),We=normalizePrivateKey(Re),Ze=[int2octets(We),bits2octets(qe)];if(Fe!=null){Fe===!0&&(Fe=utils.randomBytes(32));const tr=ensureBytes(Fe);if(tr.length!==32)throw new Error("sign: Expected 32 bytes of extra data");Ze.push(tr)}const Xe=concatBytes(...Ze),Je=bits2int(qe);return{seed:Xe,m:Je,d:We}}function finalizeSig(Ke,Re){let{sig:Fe,recovery:qe}=Ke;const{canonical:We,der:Ze,recovered:Xe}=Object.assign({canonical:!0,der:!0},Re);We&&Fe.hasHighS()&&(Fe=Fe.normalizeS(),qe^=1);const Je=Ze?Fe.toDERRawBytes():Fe.toCompactRawBytes();return Xe?[Je,qe]:Je}function signSync(Ke,Re,Fe={}){const{seed:qe,m:We,d:Ze}=initSigArgs(Ke,Re,Fe.extraEntropy);let Xe;const Je=new HmacDrbg;for(Je.reseedSync(qe);!(Xe=kmdToSig(Je.generateSync(),We,Ze));)Je.reseedSync();return finalizeSig(Xe,Fe)}Point.BASE._setWindowSize(8);const crypto$1={node:nodeCrypto,web:typeof self=="object"&&"crypto"in self?self.crypto:void 0},TAGGED_HASH_PREFIXES={},utils={bytesToHex,hexToBytes,concatBytes,mod,invert,isValidPrivateKey(Ke){try{return normalizePrivateKey(Ke),!0}catch{return!1}},_bigintTo32Bytes:numTo32b,_normalizePrivateKey:normalizePrivateKey,hashToPrivateKey:Ke=>{if(Ke=ensureBytes(Ke),Ke.length<40||Ke.length>1024)throw new Error("Expected 40-1024 bytes of private key as per FIPS 186");const Re=mod(bytesToNumber(Ke),CURVE.n-_1n)+_1n;return numTo32b(Re)},randomBytes:(Ke=32)=>{if(crypto$1.web)return crypto$1.web.getRandomValues(new Uint8Array(Ke));if(crypto$1.node){const{randomBytes:Re}=crypto$1.node;return Uint8Array.from(Re(Ke))}else throw new Error("The environment doesn't have randomBytes function")},randomPrivateKey:()=>utils.hashToPrivateKey(utils.randomBytes(40)),sha256:async(...Ke)=>{if(crypto$1.web){const Re=await crypto$1.web.subtle.digest("SHA-256",concatBytes(...Ke));return new Uint8Array(Re)}else if(crypto$1.node){const{createHash:Re}=crypto$1.node,Fe=Re("sha256");return Ke.forEach(qe=>Fe.update(qe)),Uint8Array.from(Fe.digest())}else throw new Error("The environment doesn't have sha256 function")},hmacSha256:async(Ke,...Re)=>{if(crypto$1.web){const Fe=await crypto$1.web.subtle.importKey("raw",Ke,{name:"HMAC",hash:{name:"SHA-256"}},!1,["sign"]),qe=concatBytes(...Re),We=await crypto$1.web.subtle.sign("HMAC",Fe,qe);return new Uint8Array(We)}else if(crypto$1.node){const{createHmac:Fe}=crypto$1.node,qe=Fe("sha256",Ke);return Re.forEach(We=>qe.update(We)),Uint8Array.from(qe.digest())}else throw new Error("The environment doesn't have hmac-sha256 function")},sha256Sync:void 0,hmacSha256Sync:void 0,taggedHash:async(Ke,...Re)=>{let Fe=TAGGED_HASH_PREFIXES[Ke];if(Fe===void 0){const qe=await utils.sha256(Uint8Array.from(Ke,We=>We.charCodeAt(0)));Fe=concatBytes(qe,qe),TAGGED_HASH_PREFIXES[Ke]=Fe}return utils.sha256(Fe,...Re)},taggedHashSync:(Ke,...Re)=>{if(typeof _sha256Sync!="function")throw new ShaError("sha256Sync is undefined, you need to set it");let Fe=TAGGED_HASH_PREFIXES[Ke];if(Fe===void 0){const qe=_sha256Sync(Uint8Array.from(Ke,We=>We.charCodeAt(0)));Fe=concatBytes(qe,qe),TAGGED_HASH_PREFIXES[Ke]=Fe}return _sha256Sync(Fe,...Re)},precompute(Ke=8,Re=Point.BASE){const Fe=Re===Point.BASE?Re:new Point(Re.x,Re.y);return Fe._setWindowSize(Ke),Fe.multiply(_3n),Fe}};Object.defineProperties(utils,{sha256Sync:{configurable:!1,get(){return _sha256Sync},set(Ke){_sha256Sync||(_sha256Sync=Ke)}},hmacSha256Sync:{configurable:!1,get(){return _hmacSha256Sync},set(Ke){_hmacSha256Sync||(_hmacSha256Sync=Ke)}}});utils$1.sha512Sync=(...Ke)=>sha512(utils$1.concatBytes(...Ke));const generatePrivateKey=utils$1.randomPrivateKey,generateKeypair=()=>{const Ke=utils$1.randomPrivateKey(),Re=getPublicKey(Ke),Fe=new Uint8Array(64);return Fe.set(Ke),Fe.set(Re,32),{publicKey:Re,secretKey:Fe}},getPublicKey=sync.getPublicKey;function isOnCurve(Ke){try{return Point$1.fromHex(Ke,!0),!0}catch{return!1}}const sign=(Ke,Re)=>sync.sign(Ke,Re.slice(0,32)),verify=sync.verify,toBuffer=Ke=>buffer.Buffer.isBuffer(Ke)?Ke:Ke instanceof Uint8Array?buffer.Buffer.from(Ke.buffer,Ke.byteOffset,Ke.byteLength):buffer.Buffer.from(Ke);class Struct{constructor(Re){Object.assign(this,Re)}encode(){return buffer.Buffer.from(serialize_1(SOLANA_SCHEMA,this))}static decode(Re){return deserialize_1(SOLANA_SCHEMA,this,Re)}static decodeUnchecked(Re){return deserializeUnchecked_1(SOLANA_SCHEMA,this,Re)}}class Enum extends Struct{constructor(Re){if(super(Re),this.enum="",Object.keys(Re).length!==1)throw new Error("Enum can only take single value");Object.keys(Re).map(Fe=>{this.enum=Fe})}}const SOLANA_SCHEMA=new Map,MAX_SEED_LENGTH=32,PUBLIC_KEY_LENGTH=32;function isPublicKeyData(Ke){return Ke._bn!==void 0}let uniquePublicKeyCounter=1;class PublicKey extends Struct{constructor(Re){if(super({}),this._bn=void 0,isPublicKeyData(Re))this._bn=Re._bn;else{if(typeof Re=="string"){const Fe=bs58.decode(Re);if(Fe.length!=PUBLIC_KEY_LENGTH)throw new Error("Invalid public key input");this._bn=new u(Fe)}else this._bn=new u(Re);if(this._bn.byteLength()>32)throw new Error("Invalid public key input")}}static unique(){const Re=new PublicKey(uniquePublicKeyCounter);return uniquePublicKeyCounter+=1,new PublicKey(Re.toBuffer())}equals(Re){return this._bn.eq(Re._bn)}toBase58(){return bs58.encode(this.toBytes())}toJSON(){return this.toBase58()}toBytes(){return this.toBuffer()}toBuffer(){const Re=this._bn.toArrayLike(buffer.Buffer);if(Re.length===PUBLIC_KEY_LENGTH)return Re;const Fe=buffer.Buffer.alloc(32);return Re.copy(Fe,32-Re.length),Fe}toString(){return this.toBase58()}static async createWithSeed(Re,Fe,qe){const We=buffer.Buffer.concat([Re.toBuffer(),buffer.Buffer.from(Fe),qe.toBuffer()]),Ze=sha256$1(We);return new PublicKey(Ze)}static createProgramAddressSync(Re,Fe){let qe=buffer.Buffer.alloc(0);Re.forEach(function(Ze){if(Ze.length>MAX_SEED_LENGTH)throw new TypeError("Max seed length exceeded");qe=buffer.Buffer.concat([qe,toBuffer(Ze)])}),qe=buffer.Buffer.concat([qe,Fe.toBuffer(),buffer.Buffer.from("ProgramDerivedAddress")]);const We=sha256$1(qe);if(isOnCurve(We))throw new Error("Invalid seeds, address must fall off the curve");return new PublicKey(We)}static async createProgramAddress(Re,Fe){return this.createProgramAddressSync(Re,Fe)}static findProgramAddressSync(Re,Fe){let qe=255,We;for(;qe!=0;){try{const Ze=Re.concat(buffer.Buffer.from([qe]));We=this.createProgramAddressSync(Ze,Fe)}catch(Ze){if(Ze instanceof TypeError)throw Ze;qe--;continue}return[We,qe]}throw new Error("Unable to find a viable program address nonce")}static async findProgramAddress(Re,Fe){return this.findProgramAddressSync(Re,Fe)}static isOnCurve(Re){const Fe=new PublicKey(Re);return isOnCurve(Fe.toBytes())}}PublicKey.default=new PublicKey("11111111111111111111111111111111");SOLANA_SCHEMA.set(PublicKey,{kind:"struct",fields:[["_bn","u256"]]});class Account{constructor(Re){if(this._publicKey=void 0,this._secretKey=void 0,Re){const Fe=toBuffer(Re);if(Re.length!==64)throw new Error("bad secret key size");this._publicKey=Fe.slice(32,64),this._secretKey=Fe.slice(0,32)}else this._secretKey=toBuffer(generatePrivateKey()),this._publicKey=toBuffer(getPublicKey(this._secretKey))}get publicKey(){return new PublicKey(this._publicKey)}get secretKey(){return buffer.Buffer.concat([this._secretKey,this._publicKey],64)}}const BPF_LOADER_DEPRECATED_PROGRAM_ID=new PublicKey("BPFLoader1111111111111111111111111111111111"),PACKET_DATA_SIZE=1280-40-8,VERSION_PREFIX_MASK=127,SIGNATURE_LENGTH_IN_BYTES=64;class TransactionExpiredBlockheightExceededError extends Error{constructor(Re){super(`Signature ${Re} has expired: block height exceeded.`),this.signature=void 0,this.signature=Re}}Object.defineProperty(TransactionExpiredBlockheightExceededError.prototype,"name",{value:"TransactionExpiredBlockheightExceededError"});class TransactionExpiredTimeoutError extends Error{constructor(Re,Fe){super(`Transaction was not confirmed in ${Fe.toFixed(2)} seconds. It is unknown if it succeeded or failed. Check signature ${Re} using the Solana Explorer or CLI tools.`),this.signature=void 0,this.signature=Re}}Object.defineProperty(TransactionExpiredTimeoutError.prototype,"name",{value:"TransactionExpiredTimeoutError"});class MessageAccountKeys{constructor(Re,Fe){this.staticAccountKeys=void 0,this.accountKeysFromLookups=void 0,this.staticAccountKeys=Re,this.accountKeysFromLookups=Fe}keySegments(){const Re=[this.staticAccountKeys];return this.accountKeysFromLookups&&(Re.push(this.accountKeysFromLookups.writable),Re.push(this.accountKeysFromLookups.readonly)),Re}get(Re){for(const Fe of this.keySegments()){if(Re<Fe.length)return Fe[Re];Re-=Fe.length}}get length(){return this.keySegments().flat().length}compileInstructions(Re){if(this.length>255+1)throw new Error("Account index overflow encountered during compilation");const qe=new Map;this.keySegments().flat().forEach((Ze,Xe)=>{qe.set(Ze.toBase58(),Xe)});const We=Ze=>{const Xe=qe.get(Ze.toBase58());if(Xe===void 0)throw new Error("Encountered an unknown instruction account key during compilation");return Xe};return Re.map(Ze=>({programIdIndex:We(Ze.programId),accountKeyIndexes:Ze.keys.map(Xe=>We(Xe.pubkey)),data:Ze.data}))}}const publicKey=(Ke="publicKey")=>blob(32,Ke),signature=(Ke="signature")=>blob(64,Ke),rustString=(Ke="string")=>{const Re=struct([u32("length"),u32("lengthPadding"),blob(offset(u32(),-8),"chars")],Ke),Fe=Re.decode.bind(Re),qe=Re.encode.bind(Re),We=Re;return We.decode=(Ze,Xe)=>Fe(Ze,Xe).chars.toString(),We.encode=(Ze,Xe,Je)=>{const tr={chars:buffer.Buffer.from(Ze,"utf8")};return qe(tr,Xe,Je)},We.alloc=Ze=>u32().span+u32().span+buffer.Buffer.from(Ze,"utf8").length,We},authorized=(Ke="authorized")=>struct([publicKey("staker"),publicKey("withdrawer")],Ke),lockup=(Ke="lockup")=>struct([ns64("unixTimestamp"),ns64("epoch"),publicKey("custodian")],Ke),voteInit=(Ke="voteInit")=>struct([publicKey("nodePubkey"),publicKey("authorizedVoter"),publicKey("authorizedWithdrawer"),u8("commission")],Ke),voteAuthorizeWithSeedArgs=(Ke="voteAuthorizeWithSeedArgs")=>struct([u32("voteAuthorizationType"),publicKey("currentAuthorityDerivedKeyOwnerPubkey"),rustString("currentAuthorityDerivedKeySeed"),publicKey("newAuthorized")],Ke);function getAlloc(Ke,Re){const Fe=We=>{if(We.span>=0)return We.span;if(typeof We.alloc=="function")return We.alloc(Re[We.property]);if("count"in We&&"elementLayout"in We){const Ze=Re[We.property];if(Array.isArray(Ze))return Ze.length*Fe(We.elementLayout)}else if("fields"in We)return getAlloc({layout:We},Re[We.property]);return 0};let qe=0;return Ke.layout.fields.forEach(We=>{qe+=Fe(We)}),qe}function decodeLength(Ke){let Re=0,Fe=0;for(;;){let qe=Ke.shift();if(Re|=(qe&127)<<Fe*7,Fe+=1,(qe&128)===0)break}return Re}function encodeLength(Ke,Re){let Fe=Re;for(;;){let qe=Fe&127;if(Fe>>=7,Fe==0){Ke.push(qe);break}else qe|=128,Ke.push(qe)}}function assert(Ke,Re){if(!Ke)throw new Error(Re||"Assertion failed")}class CompiledKeys{constructor(Re,Fe){this.payer=void 0,this.keyMetaMap=void 0,this.payer=Re,this.keyMetaMap=Fe}static compile(Re,Fe){const qe=new Map,We=Xe=>{const Je=Xe.toBase58();let tr=qe.get(Je);return tr===void 0&&(tr={isSigner:!1,isWritable:!1,isInvoked:!1},qe.set(Je,tr)),tr},Ze=We(Fe);Ze.isSigner=!0,Ze.isWritable=!0;for(const Xe of Re){We(Xe.programId).isInvoked=!0;for(const Je of Xe.keys){const tr=We(Je.pubkey);tr.isSigner||(tr.isSigner=Je.isSigner),tr.isWritable||(tr.isWritable=Je.isWritable)}}return new CompiledKeys(Fe,qe)}getMessageComponents(){const Re=[...this.keyMetaMap.entries()];assert(Re.length<=256,"Max static account keys length exceeded");const Fe=Re.filter(([,tr])=>tr.isSigner&&tr.isWritable),qe=Re.filter(([,tr])=>tr.isSigner&&!tr.isWritable),We=Re.filter(([,tr])=>!tr.isSigner&&tr.isWritable),Ze=Re.filter(([,tr])=>!tr.isSigner&&!tr.isWritable),Xe={numRequiredSignatures:Fe.length+qe.length,numReadonlySignedAccounts:qe.length,numReadonlyUnsignedAccounts:Ze.length};{assert(Fe.length>0,"Expected at least one writable signer key");const[tr]=Fe[0];assert(tr===this.payer.toBase58(),"Expected first writable signer key to be the fee payer")}const Je=[...Fe.map(([tr])=>new PublicKey(tr)),...qe.map(([tr])=>new PublicKey(tr)),...We.map(([tr])=>new PublicKey(tr)),...Ze.map(([tr])=>new PublicKey(tr))];return[Xe,Je]}extractTableLookup(Re){const[Fe,qe]=this.drainKeysFoundInLookupTable(Re.state.addresses,Xe=>!Xe.isSigner&&!Xe.isInvoked&&Xe.isWritable),[We,Ze]=this.drainKeysFoundInLookupTable(Re.state.addresses,Xe=>!Xe.isSigner&&!Xe.isInvoked&&!Xe.isWritable);if(!(Fe.length===0&&We.length===0))return[{accountKey:Re.key,writableIndexes:Fe,readonlyIndexes:We},{writable:qe,readonly:Ze}]}drainKeysFoundInLookupTable(Re,Fe){const qe=new Array,We=new Array;for(const[Ze,Xe]of this.keyMetaMap.entries())if(Fe(Xe)){const Je=new PublicKey(Ze),tr=Re.findIndex(er=>er.equals(Je));tr>=0&&(assert(tr<256,"Max lookup table index exceeded"),qe.push(tr),We.push(Je),this.keyMetaMap.delete(Ze))}return[qe,We]}}class Message{constructor(Re){this.header=void 0,this.accountKeys=void 0,this.recentBlockhash=void 0,this.instructions=void 0,this.indexToProgramIds=new Map,this.header=Re.header,this.accountKeys=Re.accountKeys.map(Fe=>new PublicKey(Fe)),this.recentBlockhash=Re.recentBlockhash,this.instructions=Re.instructions,this.instructions.forEach(Fe=>this.indexToProgramIds.set(Fe.programIdIndex,this.accountKeys[Fe.programIdIndex]))}get version(){return"legacy"}get staticAccountKeys(){return this.accountKeys}get compiledInstructions(){return this.instructions.map(Re=>({programIdIndex:Re.programIdIndex,accountKeyIndexes:Re.accounts,data:bs58.decode(Re.data)}))}get addressTableLookups(){return[]}getAccountKeys(){return new MessageAccountKeys(this.staticAccountKeys)}static compile(Re){const Fe=CompiledKeys.compile(Re.instructions,Re.payerKey),[qe,We]=Fe.getMessageComponents(),Xe=new MessageAccountKeys(We).compileInstructions(Re.instructions).map(Je=>({programIdIndex:Je.programIdIndex,accounts:Je.accountKeyIndexes,data:bs58.encode(Je.data)}));return new Message({header:qe,accountKeys:We,recentBlockhash:Re.recentBlockhash,instructions:Xe})}isAccountSigner(Re){return Re<this.header.numRequiredSignatures}isAccountWritable(Re){const Fe=this.header.numRequiredSignatures;if(Re>=this.header.numRequiredSignatures){const qe=Re-Fe,Ze=this.accountKeys.length-Fe-this.header.numReadonlyUnsignedAccounts;return qe<Ze}else{const qe=Fe-this.header.numReadonlySignedAccounts;return Re<qe}}isProgramId(Re){return this.indexToProgramIds.has(Re)}programIds(){return[...this.indexToProgramIds.values()]}nonProgramIds(){return this.accountKeys.filter((Re,Fe)=>!this.isProgramId(Fe))}serialize(){const Re=this.accountKeys.length;let Fe=[];encodeLength(Fe,Re);const qe=this.instructions.map(ur=>{const{accounts:fr,programIdIndex:ar}=ur,yr=Array.from(bs58.decode(ur.data));let mr=[];encodeLength(mr,fr.length);let wr=[];return encodeLength(wr,yr.length),{programIdIndex:ar,keyIndicesCount:buffer.Buffer.from(mr),keyIndices:fr,dataLength:buffer.Buffer.from(wr),data:yr}});let We=[];encodeLength(We,qe.length);let Ze=buffer.Buffer.alloc(PACKET_DATA_SIZE);buffer.Buffer.from(We).copy(Ze);let Xe=We.length;qe.forEach(ur=>{const ar=struct([u8("programIdIndex"),blob(ur.keyIndicesCount.length,"keyIndicesCount"),seq(u8("keyIndex"),ur.keyIndices.length,"keyIndices"),blob(ur.dataLength.length,"dataLength"),seq(u8("userdatum"),ur.data.length,"data")]).encode(ur,Ze,Xe);Xe+=ar}),Ze=Ze.slice(0,Xe);const Je=struct([blob(1,"numRequiredSignatures"),blob(1,"numReadonlySignedAccounts"),blob(1,"numReadonlyUnsignedAccounts"),blob(Fe.length,"keyCount"),seq(publicKey("key"),Re,"keys"),publicKey("recentBlockhash")]),tr={numRequiredSignatures:buffer.Buffer.from([this.header.numRequiredSignatures]),numReadonlySignedAccounts:buffer.Buffer.from([this.header.numReadonlySignedAccounts]),numReadonlyUnsignedAccounts:buffer.Buffer.from([this.header.numReadonlyUnsignedAccounts]),keyCount:buffer.Buffer.from(Fe),keys:this.accountKeys.map(ur=>toBuffer(ur.toBytes())),recentBlockhash:bs58.decode(this.recentBlockhash)};let er=buffer.Buffer.alloc(2048);const ir=Je.encode(tr,er);return Ze.copy(er,ir),er.slice(0,ir+Ze.length)}static from(Re){let Fe=[...Re];const qe=Fe.shift();if(qe!==(qe&VERSION_PREFIX_MASK))throw new Error("Versioned messages must be deserialized with VersionedMessage.deserialize()");const We=Fe.shift(),Ze=Fe.shift(),Xe=decodeLength(Fe);let Je=[];for(let fr=0;fr<Xe;fr++){const ar=Fe.slice(0,PUBLIC_KEY_LENGTH);Fe=Fe.slice(PUBLIC_KEY_LENGTH),Je.push(new PublicKey(buffer.Buffer.from(ar)))}const tr=Fe.slice(0,PUBLIC_KEY_LENGTH);Fe=Fe.slice(PUBLIC_KEY_LENGTH);const er=decodeLength(Fe);let ir=[];for(let fr=0;fr<er;fr++){const ar=Fe.shift(),yr=decodeLength(Fe),mr=Fe.slice(0,yr);Fe=Fe.slice(yr);const wr=decodeLength(Fe),Sr=Fe.slice(0,wr),Ar=bs58.encode(buffer.Buffer.from(Sr));Fe=Fe.slice(wr),ir.push({programIdIndex:ar,accounts:mr,data:Ar})}const ur={header:{numRequiredSignatures:qe,numReadonlySignedAccounts:We,numReadonlyUnsignedAccounts:Ze},recentBlockhash:bs58.encode(buffer.Buffer.from(tr)),accountKeys:Je,instructions:ir};return new Message(ur)}}class MessageV0{constructor(Re){this.header=void 0,this.staticAccountKeys=void 0,this.recentBlockhash=void 0,this.compiledInstructions=void 0,this.addressTableLookups=void 0,this.header=Re.header,this.staticAccountKeys=Re.staticAccountKeys,this.recentBlockhash=Re.recentBlockhash,this.compiledInstructions=Re.compiledInstructions,this.addressTableLookups=Re.addressTableLookups}get version(){return 0}get numAccountKeysFromLookups(){let Re=0;for(const Fe of this.addressTableLookups)Re+=Fe.readonlyIndexes.length+Fe.writableIndexes.length;return Re}getAccountKeys(Re){let Fe;if(Re&&"accountKeysFromLookups"in Re&&Re.accountKeysFromLookups){if(this.numAccountKeysFromLookups!=Re.accountKeysFromLookups.writable.length+Re.accountKeysFromLookups.readonly.length)throw new Error("Failed to get account keys because of a mismatch in the number of account keys from lookups");Fe=Re.accountKeysFromLookups}else if(Re&&"addressLookupTableAccounts"in Re&&Re.addressLookupTableAccounts)Fe=this.resolveAddressTableLookups(Re.addressLookupTableAccounts);else if(this.addressTableLookups.length>0)throw new Error("Failed to get account keys because address table lookups were not resolved");return new MessageAccountKeys(this.staticAccountKeys,Fe)}isAccountSigner(Re){return Re<this.header.numRequiredSignatures}isAccountWritable(Re){const Fe=this.header.numRequiredSignatures,qe=this.staticAccountKeys.length;if(Re>=qe){const We=Re-qe,Ze=this.addressTableLookups.reduce((Xe,Je)=>Xe+Je.writableIndexes.length,0);return We<Ze}else if(Re>=this.header.numRequiredSignatures){const We=Re-Fe,Xe=qe-Fe-this.header.numReadonlyUnsignedAccounts;return We<Xe}else{const We=Fe-this.header.numReadonlySignedAccounts;return Re<We}}resolveAddressTableLookups(Re){const Fe={writable:[],readonly:[]};for(const qe of this.addressTableLookups){const We=Re.find(Ze=>Ze.key.equals(qe.accountKey));if(!We)throw new Error(`Failed to find address lookup table account for table key ${qe.accountKey.toBase58()}`);for(const Ze of qe.writableIndexes)if(Ze<We.state.addresses.length)Fe.writable.push(We.state.addresses[Ze]);else throw new Error(`Failed to find address for index ${Ze} in address lookup table ${qe.accountKey.toBase58()}`);for(const Ze of qe.readonlyIndexes)if(Ze<We.state.addresses.length)Fe.readonly.push(We.state.addresses[Ze]);else throw new Error(`Failed to find address for index ${Ze} in address lookup table ${qe.accountKey.toBase58()}`)}return Fe}static compile(Re){const Fe=CompiledKeys.compile(Re.instructions,Re.payerKey),qe=new Array,We={writable:new Array,readonly:new Array},Ze=Re.addressLookupTableAccounts||[];for(const ir of Ze){const ur=Fe.extractTableLookup(ir);if(ur!==void 0){const[fr,{writable:ar,readonly:yr}]=ur;qe.push(fr),We.writable.push(...ar),We.readonly.push(...yr)}}const[Xe,Je]=Fe.getMessageComponents(),er=new MessageAccountKeys(Je,We).compileInstructions(Re.instructions);return new MessageV0({header:Xe,staticAccountKeys:Je,recentBlockhash:Re.recentBlockhash,compiledInstructions:er,addressTableLookups:qe})}serialize(){const Re=Array();encodeLength(Re,this.staticAccountKeys.length);const Fe=this.serializeInstructions(),qe=Array();encodeLength(qe,this.compiledInstructions.length);const We=this.serializeAddressTableLookups(),Ze=Array();encodeLength(Ze,this.addressTableLookups.length);const Xe=struct([u8("prefix"),struct([u8("numRequiredSignatures"),u8("numReadonlySignedAccounts"),u8("numReadonlyUnsignedAccounts")],"header"),blob(Re.length,"staticAccountKeysLength"),seq(publicKey(),this.staticAccountKeys.length,"staticAccountKeys"),publicKey("recentBlockhash"),blob(qe.length,"instructionsLength"),blob(Fe.length,"serializedInstructions"),blob(Ze.length,"addressTableLookupsLength"),blob(We.length,"serializedAddressTableLookups")]),Je=new Uint8Array(PACKET_DATA_SIZE),tr=1<<7,er=Xe.encode({prefix:tr,header:this.header,staticAccountKeysLength:new Uint8Array(Re),staticAccountKeys:this.staticAccountKeys.map(ir=>ir.toBytes()),recentBlockhash:bs58.decode(this.recentBlockhash),instructionsLength:new Uint8Array(qe),serializedInstructions:Fe,addressTableLookupsLength:new Uint8Array(Ze),serializedAddressTableLookups:We},Je);return Je.slice(0,er)}serializeInstructions(){let Re=0;const Fe=new Uint8Array(PACKET_DATA_SIZE);for(const qe of this.compiledInstructions){const We=Array();encodeLength(We,qe.accountKeyIndexes.length);const Ze=Array();encodeLength(Ze,qe.data.length);const Xe=struct([u8("programIdIndex"),blob(We.length,"encodedAccountKeyIndexesLength"),seq(u8(),qe.accountKeyIndexes.length,"accountKeyIndexes"),blob(Ze.length,"encodedDataLength"),blob(qe.data.length,"data")]);Re+=Xe.encode({programIdIndex:qe.programIdIndex,encodedAccountKeyIndexesLength:new Uint8Array(We),accountKeyIndexes:qe.accountKeyIndexes,encodedDataLength:new Uint8Array(Ze),data:qe.data},Fe,Re)}return Fe.slice(0,Re)}serializeAddressTableLookups(){let Re=0;const Fe=new Uint8Array(PACKET_DATA_SIZE);for(const qe of this.addressTableLookups){const We=Array();encodeLength(We,qe.writableIndexes.length);const Ze=Array();encodeLength(Ze,qe.readonlyIndexes.length);const Xe=struct([publicKey("accountKey"),blob(We.length,"encodedWritableIndexesLength"),seq(u8(),qe.writableIndexes.length,"writableIndexes"),blob(Ze.length,"encodedReadonlyIndexesLength"),seq(u8(),qe.readonlyIndexes.length,"readonlyIndexes")]);Re+=Xe.encode({accountKey:qe.accountKey.toBytes(),encodedWritableIndexesLength:new Uint8Array(We),writableIndexes:qe.writableIndexes,encodedReadonlyIndexesLength:new Uint8Array(Ze),readonlyIndexes:qe.readonlyIndexes},Fe,Re)}return Fe.slice(0,Re)}static deserialize(Re){let Fe=[...Re];const qe=Fe.shift(),We=qe&VERSION_PREFIX_MASK;assert(qe!==We,"Expected versioned message but received legacy message");const Ze=We;assert(Ze===0,`Expected versioned message with version 0 but found version ${Ze}`);const Xe={numRequiredSignatures:Fe.shift(),numReadonlySignedAccounts:Fe.shift(),numReadonlyUnsignedAccounts:Fe.shift()},Je=[],tr=decodeLength(Fe);for(let yr=0;yr<tr;yr++)Je.push(new PublicKey(Fe.splice(0,PUBLIC_KEY_LENGTH)));const er=bs58.encode(Fe.splice(0,PUBLIC_KEY_LENGTH)),ir=decodeLength(Fe),ur=[];for(let yr=0;yr<ir;yr++){const mr=Fe.shift(),wr=decodeLength(Fe),Sr=Fe.splice(0,wr),Ar=decodeLength(Fe),vr=new Uint8Array(Fe.splice(0,Ar));ur.push({programIdIndex:mr,accountKeyIndexes:Sr,data:vr})}const fr=decodeLength(Fe),ar=[];for(let yr=0;yr<fr;yr++){const mr=new PublicKey(Fe.splice(0,PUBLIC_KEY_LENGTH)),wr=decodeLength(Fe),Sr=Fe.splice(0,wr),Ar=decodeLength(Fe),vr=Fe.splice(0,Ar);ar.push({accountKey:mr,writableIndexes:Sr,readonlyIndexes:vr})}return new MessageV0({header:Xe,staticAccountKeys:Je,recentBlockhash:er,compiledInstructions:ur,addressTableLookups:ar})}}const VersionedMessage={deserializeMessageVersion(Ke){const Re=Ke[0],Fe=Re&VERSION_PREFIX_MASK;return Fe===Re?"legacy":Fe},deserialize:Ke=>{const Re=VersionedMessage.deserializeMessageVersion(Ke);if(Re==="legacy")return Message.from(Ke);if(Re===0)return MessageV0.deserialize(Ke);throw new Error(`Transaction message version ${Re} deserialization is not supported`)}};let TransactionStatus;(function(Ke){Ke[Ke.BLOCKHEIGHT_EXCEEDED=0]="BLOCKHEIGHT_EXCEEDED",Ke[Ke.PROCESSED=1]="PROCESSED",Ke[Ke.TIMED_OUT=2]="TIMED_OUT"})(TransactionStatus||(TransactionStatus={}));const DEFAULT_SIGNATURE=buffer.Buffer.alloc(SIGNATURE_LENGTH_IN_BYTES).fill(0);class TransactionInstruction{constructor(Re){this.keys=void 0,this.programId=void 0,this.data=buffer.Buffer.alloc(0),this.programId=Re.programId,this.keys=Re.keys,Re.data&&(this.data=Re.data)}toJSON(){return{keys:this.keys.map(({pubkey:Re,isSigner:Fe,isWritable:qe})=>({pubkey:Re.toJSON(),isSigner:Fe,isWritable:qe})),programId:this.programId.toJSON(),data:[...this.data]}}}class Transaction{get signature(){return this.signatures.length>0?this.signatures[0].signature:null}constructor(Re){if(this.signatures=[],this.feePayer=void 0,this.instructions=[],this.recentBlockhash=void 0,this.lastValidBlockHeight=void 0,this.nonceInfo=void 0,this._message=void 0,this._json=void 0,!!Re)if(Re.feePayer&&(this.feePayer=Re.feePayer),Re.signatures&&(this.signatures=Re.signatures),Object.prototype.hasOwnProperty.call(Re,"lastValidBlockHeight")){const{blockhash:Fe,lastValidBlockHeight:qe}=Re;this.recentBlockhash=Fe,this.lastValidBlockHeight=qe}else{const{recentBlockhash:Fe,nonceInfo:qe}=Re;qe&&(this.nonceInfo=qe),this.recentBlockhash=Fe}}toJSON(){return{recentBlockhash:this.recentBlockhash||null,feePayer:this.feePayer?this.feePayer.toJSON():null,nonceInfo:this.nonceInfo?{nonce:this.nonceInfo.nonce,nonceInstruction:this.nonceInfo.nonceInstruction.toJSON()}:null,instructions:this.instructions.map(Re=>Re.toJSON()),signers:this.signatures.map(({publicKey:Re})=>Re.toJSON())}}add(...Re){if(Re.length===0)throw new Error("No instructions");return Re.forEach(Fe=>{"instructions"in Fe?this.instructions=this.instructions.concat(Fe.instructions):"data"in Fe&&"programId"in Fe&&"keys"in Fe?this.instructions.push(Fe):this.instructions.push(new TransactionInstruction(Fe))}),this}compileMessage(){if(this._message&&JSON.stringify(this.toJSON())===JSON.stringify(this._json))return this._message;let Re,Fe;if(this.nonceInfo?(Re=this.nonceInfo.nonce,this.instructions[0]!=this.nonceInfo.nonceInstruction?Fe=[this.nonceInfo.nonceInstruction,...this.instructions]:Fe=this.instructions):(Re=this.recentBlockhash,Fe=this.instructions),!Re)throw new Error("Transaction recentBlockhash required");Fe.length<1&&console.warn("No instructions provided");let qe;if(this.feePayer)qe=this.feePayer;else if(this.signatures.length>0&&this.signatures[0].publicKey)qe=this.signatures[0].publicKey;else throw new Error("Transaction fee payer required");for(let mr=0;mr<Fe.length;mr++)if(Fe[mr].programId===void 0)throw new Error(`Transaction instruction index ${mr} has undefined program id`);const We=[],Ze=[];Fe.forEach(mr=>{mr.keys.forEach(Sr=>{Ze.push({...Sr})});const wr=mr.programId.toString();We.includes(wr)||We.push(wr)}),We.forEach(mr=>{Ze.push({pubkey:new PublicKey(mr),isSigner:!1,isWritable:!1})});const Xe=[];Ze.forEach(mr=>{const wr=mr.pubkey.toString(),Sr=Xe.findIndex(Ar=>Ar.pubkey.toString()===wr);Sr>-1?(Xe[Sr].isWritable=Xe[Sr].isWritable||mr.isWritable,Xe[Sr].isSigner=Xe[Sr].isSigner||mr.isSigner):Xe.push(mr)}),Xe.sort(function(mr,wr){return mr.isSigner!==wr.isSigner?mr.isSigner?-1:1:mr.isWritable!==wr.isWritable?mr.isWritable?-1:1:mr.pubkey.toBase58().localeCompare(wr.pubkey.toBase58())});const Je=Xe.findIndex(mr=>mr.pubkey.equals(qe));if(Je>-1){const[mr]=Xe.splice(Je,1);mr.isSigner=!0,mr.isWritable=!0,Xe.unshift(mr)}else Xe.unshift({pubkey:qe,isSigner:!0,isWritable:!0});for(const mr of this.signatures){const wr=Xe.findIndex(Sr=>Sr.pubkey.equals(mr.publicKey));if(wr>-1)Xe[wr].isSigner||(Xe[wr].isSigner=!0,console.warn("Transaction references a signature that is unnecessary, only the fee payer and instruction signer accounts should sign a transaction. This behavior is deprecated and will throw an error in the next major version release."));else throw new Error(`unknown signer: ${mr.publicKey.toString()}`)}let tr=0,er=0,ir=0;const ur=[],fr=[];Xe.forEach(({pubkey:mr,isSigner:wr,isWritable:Sr})=>{wr?(ur.push(mr.toString()),tr+=1,Sr||(er+=1)):(fr.push(mr.toString()),Sr||(ir+=1))});const ar=ur.concat(fr),yr=Fe.map(mr=>{const{data:wr,programId:Sr}=mr;return{programIdIndex:ar.indexOf(Sr.toString()),accounts:mr.keys.map(Ar=>ar.indexOf(Ar.pubkey.toString())),data:bs58.encode(wr)}});return yr.forEach(mr=>{assert(mr.programIdIndex>=0),mr.accounts.forEach(wr=>assert(wr>=0))}),new Message({header:{numRequiredSignatures:tr,numReadonlySignedAccounts:er,numReadonlyUnsignedAccounts:ir},accountKeys:ar,recentBlockhash:Re,instructions:yr})}_compile(){const Re=this.compileMessage(),Fe=Re.accountKeys.slice(0,Re.header.numRequiredSignatures);return this.signatures.length===Fe.length&&this.signatures.every((We,Ze)=>Fe[Ze].equals(We.publicKey))||(this.signatures=Fe.map(qe=>({signature:null,publicKey:qe}))),Re}serializeMessage(){return this._compile().serialize()}async getEstimatedFee(Re){return(await Re.getFeeForMessage(this.compileMessage())).value}setSigners(...Re){if(Re.length===0)throw new Error("No signers");const Fe=new Set;this.signatures=Re.filter(qe=>{const We=qe.toString();return Fe.has(We)?!1:(Fe.add(We),!0)}).map(qe=>({signature:null,publicKey:qe}))}sign(...Re){if(Re.length===0)throw new Error("No signers");const Fe=new Set,qe=[];for(const Ze of Re){const Xe=Ze.publicKey.toString();Fe.has(Xe)||(Fe.add(Xe),qe.push(Ze))}this.signatures=qe.map(Ze=>({signature:null,publicKey:Ze.publicKey}));const We=this._compile();this._partialSign(We,...qe)}partialSign(...Re){if(Re.length===0)throw new Error("No signers");const Fe=new Set,qe=[];for(const Ze of Re){const Xe=Ze.publicKey.toString();Fe.has(Xe)||(Fe.add(Xe),qe.push(Ze))}const We=this._compile();this._partialSign(We,...qe)}_partialSign(Re,...Fe){const qe=Re.serialize();Fe.forEach(We=>{const Ze=sign(qe,We.secretKey);this._addSignature(We.publicKey,toBuffer(Ze))})}addSignature(Re,Fe){this._compile(),this._addSignature(Re,Fe)}_addSignature(Re,Fe){assert(Fe.length===64);const qe=this.signatures.findIndex(We=>Re.equals(We.publicKey));if(qe<0)throw new Error(`unknown signer: ${Re.toString()}`);this.signatures[qe].signature=buffer.Buffer.from(Fe)}verifySignatures(){return this._verifySignatures(this.serializeMessage(),!0)}_verifySignatures(Re,Fe){for(const{signature:qe,publicKey:We}of this.signatures)if(qe===null){if(Fe)return!1}else if(!verify(qe,Re,We.toBuffer()))return!1;return!0}serialize(Re){const{requireAllSignatures:Fe,verifySignatures:qe}=Object.assign({requireAllSignatures:!0,verifySignatures:!0},Re),We=this.serializeMessage();if(qe&&!this._verifySignatures(We,Fe))throw new Error("Signature verification failed");return this._serialize(We)}_serialize(Re){const{signatures:Fe}=this,qe=[];encodeLength(qe,Fe.length);const We=qe.length+Fe.length*64+Re.length,Ze=buffer.Buffer.alloc(We);return assert(Fe.length<256),buffer.Buffer.from(qe).copy(Ze,0),Fe.forEach(({signature:Xe},Je)=>{Xe!==null&&(assert(Xe.length===64,"signature has invalid length"),buffer.Buffer.from(Xe).copy(Ze,qe.length+Je*64))}),Re.copy(Ze,qe.length+Fe.length*64),assert(Ze.length<=PACKET_DATA_SIZE,`Transaction too large: ${Ze.length} > ${PACKET_DATA_SIZE}`),Ze}get keys(){return assert(this.instructions.length===1),this.instructions[0].keys.map(Re=>Re.pubkey)}get programId(){return assert(this.instructions.length===1),this.instructions[0].programId}get data(){return assert(this.instructions.length===1),this.instructions[0].data}static from(Re){let Fe=[...Re];const qe=decodeLength(Fe);let We=[];for(let Ze=0;Ze<qe;Ze++){const Xe=Fe.slice(0,SIGNATURE_LENGTH_IN_BYTES);Fe=Fe.slice(SIGNATURE_LENGTH_IN_BYTES),We.push(bs58.encode(buffer.Buffer.from(Xe)))}return Transaction.populate(Message.from(Fe),We)}static populate(Re,Fe=[]){const qe=new Transaction;return qe.recentBlockhash=Re.recentBlockhash,Re.header.numRequiredSignatures>0&&(qe.feePayer=Re.accountKeys[0]),Fe.forEach((We,Ze)=>{const Xe={signature:We==bs58.encode(DEFAULT_SIGNATURE)?null:bs58.decode(We),publicKey:Re.accountKeys[Ze]};qe.signatures.push(Xe)}),Re.instructions.forEach(We=>{const Ze=We.accounts.map(Xe=>{const Je=Re.accountKeys[Xe];return{pubkey:Je,isSigner:qe.signatures.some(tr=>tr.publicKey.toString()===Je.toString())||Re.isAccountSigner(Xe),isWritable:Re.isAccountWritable(Xe)}});qe.instructions.push(new TransactionInstruction({keys:Ze,programId:Re.accountKeys[We.programIdIndex],data:bs58.decode(We.data)}))}),qe._message=Re,qe._json=qe.toJSON(),qe}}class TransactionMessage{constructor(Re){this.payerKey=void 0,this.instructions=void 0,this.recentBlockhash=void 0,this.payerKey=Re.payerKey,this.instructions=Re.instructions,this.recentBlockhash=Re.recentBlockhash}static decompile(Re,Fe){const{header:qe,compiledInstructions:We,recentBlockhash:Ze}=Re,{numRequiredSignatures:Xe,numReadonlySignedAccounts:Je,numReadonlyUnsignedAccounts:tr}=qe,er=Xe-Je;assert(er>0,"Message header is invalid");const ir=Re.staticAccountKeys.length-tr;assert(ir>=0,"Message header is invalid");const ur=Re.getAccountKeys(Fe),fr=ur.get(0);if(fr===void 0)throw new Error("Failed to decompile message because no account keys were found");const ar=[];for(const yr of We){const mr=[];for(const Sr of yr.accountKeyIndexes){const Ar=ur.get(Sr);if(Ar===void 0)throw new Error(`Failed to find key for account key index ${Sr}`);const vr=Sr<Xe;let Ir;vr?Ir=Sr<er:Sr<ur.staticAccountKeys.length?Ir=Sr-Xe<ir:Ir=Sr-ur.staticAccountKeys.length<ur.accountKeysFromLookups.writable.length,mr.push({pubkey:Ar,isSigner:Sr<qe.numRequiredSignatures,isWritable:Ir})}const wr=ur.get(yr.programIdIndex);if(wr===void 0)throw new Error(`Failed to find program id for program id index ${yr.programIdIndex}`);ar.push(new TransactionInstruction({programId:wr,data:toBuffer(yr.data),keys:mr}))}return new TransactionMessage({payerKey:fr,instructions:ar,recentBlockhash:Ze})}compileToLegacyMessage(){return Message.compile({payerKey:this.payerKey,recentBlockhash:this.recentBlockhash,instructions:this.instructions})}compileToV0Message(Re){return MessageV0.compile({payerKey:this.payerKey,recentBlockhash:this.recentBlockhash,instructions:this.instructions,addressLookupTableAccounts:Re})}}class VersionedTransaction{get version(){return this.message.version}constructor(Re,Fe){if(this.signatures=void 0,this.message=void 0,Fe!==void 0)assert(Fe.length===Re.header.numRequiredSignatures,"Expected signatures length to be equal to the number of required signatures"),this.signatures=Fe;else{const qe=[];for(let We=0;We<Re.header.numRequiredSignatures;We++)qe.push(new Uint8Array(SIGNATURE_LENGTH_IN_BYTES));this.signatures=qe}this.message=Re}serialize(){const Re=this.message.serialize(),Fe=Array();encodeLength(Fe,this.signatures.length);const qe=struct([blob(Fe.length,"encodedSignaturesLength"),seq(signature(),this.signatures.length,"signatures"),blob(Re.length,"serializedMessage")]),We=new Uint8Array(2048),Ze=qe.encode({encodedSignaturesLength:new Uint8Array(Fe),signatures:this.signatures,serializedMessage:Re},We);return We.slice(0,Ze)}static deserialize(Re){let Fe=[...Re];const qe=[],We=decodeLength(Fe);for(let Xe=0;Xe<We;Xe++)qe.push(new Uint8Array(Fe.splice(0,SIGNATURE_LENGTH_IN_BYTES)));const Ze=VersionedMessage.deserialize(new Uint8Array(Fe));return new VersionedTransaction(Ze,qe)}sign(Re){const Fe=this.message.serialize(),qe=this.message.staticAccountKeys.slice(0,this.message.header.numRequiredSignatures);for(const We of Re){const Ze=qe.findIndex(Xe=>Xe.equals(We.publicKey));assert(Ze>=0,`Cannot sign with non signer key ${We.publicKey.toBase58()}`),this.signatures[Ze]=sign(Fe,We.secretKey)}}addSignature(Re,Fe){assert(Fe.byteLength===64,"Signature must be 64 bytes long");const We=this.message.staticAccountKeys.slice(0,this.message.header.numRequiredSignatures).findIndex(Ze=>Ze.equals(Re));assert(We>=0,`Can not add signature; \`${Re.toBase58()}\` is not required to sign this transaction`),this.signatures[We]=Fe}}const SYSVAR_CLOCK_PUBKEY=new PublicKey("SysvarC1ock11111111111111111111111111111111"),SYSVAR_EPOCH_SCHEDULE_PUBKEY=new PublicKey("SysvarEpochSchedu1e111111111111111111111111"),SYSVAR_INSTRUCTIONS_PUBKEY=new PublicKey("Sysvar1nstructions1111111111111111111111111"),SYSVAR_RECENT_BLOCKHASHES_PUBKEY=new PublicKey("SysvarRecentB1ockHashes11111111111111111111"),SYSVAR_RENT_PUBKEY=new PublicKey("SysvarRent111111111111111111111111111111111"),SYSVAR_REWARDS_PUBKEY=new PublicKey("SysvarRewards111111111111111111111111111111"),SYSVAR_SLOT_HASHES_PUBKEY=new PublicKey("SysvarS1otHashes111111111111111111111111111"),SYSVAR_SLOT_HISTORY_PUBKEY=new PublicKey("SysvarS1otHistory11111111111111111111111111"),SYSVAR_STAKE_HISTORY_PUBKEY=new PublicKey("SysvarStakeHistory1111111111111111111111111");async function sendAndConfirmTransaction(Ke,Re,Fe,qe){const We=qe&&{skipPreflight:qe.skipPreflight,preflightCommitment:qe.preflightCommitment||qe.commitment,maxRetries:qe.maxRetries,minContextSlot:qe.minContextSlot},Ze=await Ke.sendTransaction(Re,Fe,We),Xe=Re.recentBlockhash!=null&&Re.lastValidBlockHeight!=null?(await Ke.confirmTransaction({signature:Ze,blockhash:Re.recentBlockhash,lastValidBlockHeight:Re.lastValidBlockHeight},qe&&qe.commitment)).value:(await Ke.confirmTransaction(Ze,qe&&qe.commitment)).value;if(Xe.err)throw new Error(`Transaction ${Ze} failed (${JSON.stringify(Xe)})`);return Ze}function sleep(Ke){return new Promise(Re=>setTimeout(Re,Ke))}function encodeData(Ke,Re){const Fe=Ke.layout.span>=0?Ke.layout.span:getAlloc(Ke,Re),qe=buffer.Buffer.alloc(Fe),We=Object.assign({instruction:Ke.index},Re);return Ke.layout.encode(We,qe),qe}function decodeData$1(Ke,Re){let Fe;try{Fe=Ke.layout.decode(Re)}catch(qe){throw new Error("invalid instruction; "+qe)}if(Fe.instruction!==Ke.index)throw new Error(`invalid instruction; instruction index mismatch ${Fe.instruction} != ${Ke.index}`);return Fe}const FeeCalculatorLayout=nu64("lamportsPerSignature"),NonceAccountLayout=struct([u32("version"),u32("state"),publicKey("authorizedPubkey"),publicKey("nonce"),struct([FeeCalculatorLayout],"feeCalculator")]),NONCE_ACCOUNT_LENGTH=NonceAccountLayout.span;class NonceAccount{constructor(Re){this.authorizedPubkey=void 0,this.nonce=void 0,this.feeCalculator=void 0,this.authorizedPubkey=Re.authorizedPubkey,this.nonce=Re.nonce,this.feeCalculator=Re.feeCalculator}static fromAccountData(Re){const Fe=NonceAccountLayout.decode(toBuffer(Re),0);return new NonceAccount({authorizedPubkey:new PublicKey(Fe.authorizedPubkey),nonce:new PublicKey(Fe.nonce).toString(),feeCalculator:Fe.feeCalculator})}}const encodeDecode=Ke=>{const Re=Ke.decode.bind(Ke),Fe=Ke.encode.bind(Ke);return{decode:Re,encode:Fe}},bigInt=Ke=>Re=>{const Fe=blob(Ke,Re),{encode:qe,decode:We}=encodeDecode(Fe),Ze=Fe;return Ze.decode=(Xe,Je)=>{const tr=We(Xe,Je);return toBigIntLE_1(buffer.Buffer.from(tr))},Ze.encode=(Xe,Je,tr)=>{const er=toBufferLE_1(Xe,Ke);return qe(er,Je,tr)},Ze},u64=bigInt(8);class SystemInstruction{constructor(){}static decodeInstructionType(Re){this.checkProgramId(Re.programId);const qe=u32("instruction").decode(Re.data);let We;for(const[Ze,Xe]of Object.entries(SYSTEM_INSTRUCTION_LAYOUTS))if(Xe.index==qe){We=Ze;break}if(!We)throw new Error("Instruction type incorrect; not a SystemInstruction");return We}static decodeCreateAccount(Re){this.checkProgramId(Re.programId),this.checkKeyLength(Re.keys,2);const{lamports:Fe,space:qe,programId:We}=decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Create,Re.data);return{fromPubkey:Re.keys[0].pubkey,newAccountPubkey:Re.keys[1].pubkey,lamports:Fe,space:qe,programId:new PublicKey(We)}}static decodeTransfer(Re){this.checkProgramId(Re.programId),this.checkKeyLength(Re.keys,2);const{lamports:Fe}=decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Transfer,Re.data);return{fromPubkey:Re.keys[0].pubkey,toPubkey:Re.keys[1].pubkey,lamports:Fe}}static decodeTransferWithSeed(Re){this.checkProgramId(Re.programId),this.checkKeyLength(Re.keys,3);const{lamports:Fe,seed:qe,programId:We}=decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.TransferWithSeed,Re.data);return{fromPubkey:Re.keys[0].pubkey,basePubkey:Re.keys[1].pubkey,toPubkey:Re.keys[2].pubkey,lamports:Fe,seed:qe,programId:new PublicKey(We)}}static decodeAllocate(Re){this.checkProgramId(Re.programId),this.checkKeyLength(Re.keys,1);const{space:Fe}=decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Allocate,Re.data);return{accountPubkey:Re.keys[0].pubkey,space:Fe}}static decodeAllocateWithSeed(Re){this.checkProgramId(Re.programId),this.checkKeyLength(Re.keys,1);const{base:Fe,seed:qe,space:We,programId:Ze}=decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AllocateWithSeed,Re.data);return{accountPubkey:Re.keys[0].pubkey,basePubkey:new PublicKey(Fe),seed:qe,space:We,programId:new PublicKey(Ze)}}static decodeAssign(Re){this.checkProgramId(Re.programId),this.checkKeyLength(Re.keys,1);const{programId:Fe}=decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Assign,Re.data);return{accountPubkey:Re.keys[0].pubkey,programId:new PublicKey(Fe)}}static decodeAssignWithSeed(Re){this.checkProgramId(Re.programId),this.checkKeyLength(Re.keys,1);const{base:Fe,seed:qe,programId:We}=decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AssignWithSeed,Re.data);return{accountPubkey:Re.keys[0].pubkey,basePubkey:new PublicKey(Fe),seed:qe,programId:new PublicKey(We)}}static decodeCreateWithSeed(Re){this.checkProgramId(Re.programId),this.checkKeyLength(Re.keys,2);const{base:Fe,seed:qe,lamports:We,space:Ze,programId:Xe}=decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.CreateWithSeed,Re.data);return{fromPubkey:Re.keys[0].pubkey,newAccountPubkey:Re.keys[1].pubkey,basePubkey:new PublicKey(Fe),seed:qe,lamports:We,space:Ze,programId:new PublicKey(Xe)}}static decodeNonceInitialize(Re){this.checkProgramId(Re.programId),this.checkKeyLength(Re.keys,3);const{authorized:Fe}=decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.InitializeNonceAccount,Re.data);return{noncePubkey:Re.keys[0].pubkey,authorizedPubkey:new PublicKey(Fe)}}static decodeNonceAdvance(Re){return this.checkProgramId(Re.programId),this.checkKeyLength(Re.keys,3),decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AdvanceNonceAccount,Re.data),{noncePubkey:Re.keys[0].pubkey,authorizedPubkey:Re.keys[2].pubkey}}static decodeNonceWithdraw(Re){this.checkProgramId(Re.programId),this.checkKeyLength(Re.keys,5);const{lamports:Fe}=decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.WithdrawNonceAccount,Re.data);return{noncePubkey:Re.keys[0].pubkey,toPubkey:Re.keys[1].pubkey,authorizedPubkey:Re.keys[4].pubkey,lamports:Fe}}static decodeNonceAuthorize(Re){this.checkProgramId(Re.programId),this.checkKeyLength(Re.keys,2);const{authorized:Fe}=decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AuthorizeNonceAccount,Re.data);return{noncePubkey:Re.keys[0].pubkey,authorizedPubkey:Re.keys[1].pubkey,newAuthorizedPubkey:new PublicKey(Fe)}}static checkProgramId(Re){if(!Re.equals(SystemProgram.programId))throw new Error("invalid instruction; programId is not SystemProgram")}static checkKeyLength(Re,Fe){if(Re.length<Fe)throw new Error(`invalid instruction; found ${Re.length} keys, expected at least ${Fe}`)}}const SYSTEM_INSTRUCTION_LAYOUTS=Object.freeze({Create:{index:0,layout:struct([u32("instruction"),ns64("lamports"),ns64("space"),publicKey("programId")])},Assign:{index:1,layout:struct([u32("instruction"),publicKey("programId")])},Transfer:{index:2,layout:struct([u32("instruction"),u64("lamports")])},CreateWithSeed:{index:3,layout:struct([u32("instruction"),publicKey("base"),rustString("seed"),ns64("lamports"),ns64("space"),publicKey("programId")])},AdvanceNonceAccount:{index:4,layout:struct([u32("instruction")])},WithdrawNonceAccount:{index:5,layout:struct([u32("instruction"),ns64("lamports")])},InitializeNonceAccount:{index:6,layout:struct([u32("instruction"),publicKey("authorized")])},AuthorizeNonceAccount:{index:7,layout:struct([u32("instruction"),publicKey("authorized")])},Allocate:{index:8,layout:struct([u32("instruction"),ns64("space")])},AllocateWithSeed:{index:9,layout:struct([u32("instruction"),publicKey("base"),rustString("seed"),ns64("space"),publicKey("programId")])},AssignWithSeed:{index:10,layout:struct([u32("instruction"),publicKey("base"),rustString("seed"),publicKey("programId")])},TransferWithSeed:{index:11,layout:struct([u32("instruction"),u64("lamports"),rustString("seed"),publicKey("programId")])},UpgradeNonceAccount:{index:12,layout:struct([u32("instruction")])}});class SystemProgram{constructor(){}static createAccount(Re){const Fe=SYSTEM_INSTRUCTION_LAYOUTS.Create,qe=encodeData(Fe,{lamports:Re.lamports,space:Re.space,programId:toBuffer(Re.programId.toBuffer())});return new TransactionInstruction({keys:[{pubkey:Re.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:Re.newAccountPubkey,isSigner:!0,isWritable:!0}],programId:this.programId,data:qe})}static transfer(Re){let Fe,qe;if("basePubkey"in Re){const We=SYSTEM_INSTRUCTION_LAYOUTS.TransferWithSeed;Fe=encodeData(We,{lamports:BigInt(Re.lamports),seed:Re.seed,programId:toBuffer(Re.programId.toBuffer())}),qe=[{pubkey:Re.fromPubkey,isSigner:!1,isWritable:!0},{pubkey:Re.basePubkey,isSigner:!0,isWritable:!1},{pubkey:Re.toPubkey,isSigner:!1,isWritable:!0}]}else{const We=SYSTEM_INSTRUCTION_LAYOUTS.Transfer;Fe=encodeData(We,{lamports:BigInt(Re.lamports)}),qe=[{pubkey:Re.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:Re.toPubkey,isSigner:!1,isWritable:!0}]}return new TransactionInstruction({keys:qe,programId:this.programId,data:Fe})}static assign(Re){let Fe,qe;if("basePubkey"in Re){const We=SYSTEM_INSTRUCTION_LAYOUTS.AssignWithSeed;Fe=encodeData(We,{base:toBuffer(Re.basePubkey.toBuffer()),seed:Re.seed,programId:toBuffer(Re.programId.toBuffer())}),qe=[{pubkey:Re.accountPubkey,isSigner:!1,isWritable:!0},{pubkey:Re.basePubkey,isSigner:!0,isWritable:!1}]}else{const We=SYSTEM_INSTRUCTION_LAYOUTS.Assign;Fe=encodeData(We,{programId:toBuffer(Re.programId.toBuffer())}),qe=[{pubkey:Re.accountPubkey,isSigner:!0,isWritable:!0}]}return new TransactionInstruction({keys:qe,programId:this.programId,data:Fe})}static createAccountWithSeed(Re){const Fe=SYSTEM_INSTRUCTION_LAYOUTS.CreateWithSeed,qe=encodeData(Fe,{base:toBuffer(Re.basePubkey.toBuffer()),seed:Re.seed,lamports:Re.lamports,space:Re.space,programId:toBuffer(Re.programId.toBuffer())});let We=[{pubkey:Re.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:Re.newAccountPubkey,isSigner:!1,isWritable:!0}];return Re.basePubkey!=Re.fromPubkey&&We.push({pubkey:Re.basePubkey,isSigner:!0,isWritable:!1}),new TransactionInstruction({keys:We,programId:this.programId,data:qe})}static createNonceAccount(Re){const Fe=new Transaction;"basePubkey"in Re&&"seed"in Re?Fe.add(SystemProgram.createAccountWithSeed({fromPubkey:Re.fromPubkey,newAccountPubkey:Re.noncePubkey,basePubkey:Re.basePubkey,seed:Re.seed,lamports:Re.lamports,space:NONCE_ACCOUNT_LENGTH,programId:this.programId})):Fe.add(SystemProgram.createAccount({fromPubkey:Re.fromPubkey,newAccountPubkey:Re.noncePubkey,lamports:Re.lamports,space:NONCE_ACCOUNT_LENGTH,programId:this.programId}));const qe={noncePubkey:Re.noncePubkey,authorizedPubkey:Re.authorizedPubkey};return Fe.add(this.nonceInitialize(qe)),Fe}static nonceInitialize(Re){const Fe=SYSTEM_INSTRUCTION_LAYOUTS.InitializeNonceAccount,qe=encodeData(Fe,{authorized:toBuffer(Re.authorizedPubkey.toBuffer())}),We={keys:[{pubkey:Re.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:SYSVAR_RECENT_BLOCKHASHES_PUBKEY,isSigner:!1,isWritable:!1},{pubkey:SYSVAR_RENT_PUBKEY,isSigner:!1,isWritable:!1}],programId:this.programId,data:qe};return new TransactionInstruction(We)}static nonceAdvance(Re){const Fe=SYSTEM_INSTRUCTION_LAYOUTS.AdvanceNonceAccount,qe=encodeData(Fe),We={keys:[{pubkey:Re.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:SYSVAR_RECENT_BLOCKHASHES_PUBKEY,isSigner:!1,isWritable:!1},{pubkey:Re.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:qe};return new TransactionInstruction(We)}static nonceWithdraw(Re){const Fe=SYSTEM_INSTRUCTION_LAYOUTS.WithdrawNonceAccount,qe=encodeData(Fe,{lamports:Re.lamports});return new TransactionInstruction({keys:[{pubkey:Re.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:Re.toPubkey,isSigner:!1,isWritable:!0},{pubkey:SYSVAR_RECENT_BLOCKHASHES_PUBKEY,isSigner:!1,isWritable:!1},{pubkey:SYSVAR_RENT_PUBKEY,isSigner:!1,isWritable:!1},{pubkey:Re.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:qe})}static nonceAuthorize(Re){const Fe=SYSTEM_INSTRUCTION_LAYOUTS.AuthorizeNonceAccount,qe=encodeData(Fe,{authorized:toBuffer(Re.newAuthorizedPubkey.toBuffer())});return new TransactionInstruction({keys:[{pubkey:Re.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:Re.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:qe})}static allocate(Re){let Fe,qe;if("basePubkey"in Re){const We=SYSTEM_INSTRUCTION_LAYOUTS.AllocateWithSeed;Fe=encodeData(We,{base:toBuffer(Re.basePubkey.toBuffer()),seed:Re.seed,space:Re.space,programId:toBuffer(Re.programId.toBuffer())}),qe=[{pubkey:Re.accountPubkey,isSigner:!1,isWritable:!0},{pubkey:Re.basePubkey,isSigner:!0,isWritable:!1}]}else{const We=SYSTEM_INSTRUCTION_LAYOUTS.Allocate;Fe=encodeData(We,{space:Re.space}),qe=[{pubkey:Re.accountPubkey,isSigner:!0,isWritable:!0}]}return new TransactionInstruction({keys:qe,programId:this.programId,data:Fe})}}SystemProgram.programId=new PublicKey("11111111111111111111111111111111");const CHUNK_SIZE=PACKET_DATA_SIZE-300;class Loader{constructor(){}static getMinNumSignatures(Re){return 2*(Math.ceil(Re/Loader.chunkSize)+1+1)}static async load(Re,Fe,qe,We,Ze){{const ur=await Re.getMinimumBalanceForRentExemption(Ze.length),fr=await Re.getAccountInfo(qe.publicKey,"confirmed");let ar=null;if(fr!==null){if(fr.executable)return console.error("Program load failed, account is already executable"),!1;fr.data.length!==Ze.length&&(ar=ar||new Transaction,ar.add(SystemProgram.allocate({accountPubkey:qe.publicKey,space:Ze.length}))),fr.owner.equals(We)||(ar=ar||new Transaction,ar.add(SystemProgram.assign({accountPubkey:qe.publicKey,programId:We}))),fr.lamports<ur&&(ar=ar||new Transaction,ar.add(SystemProgram.transfer({fromPubkey:Fe.publicKey,toPubkey:qe.publicKey,lamports:ur-fr.lamports})))}else ar=new Transaction().add(SystemProgram.createAccount({fromPubkey:Fe.publicKey,newAccountPubkey:qe.publicKey,lamports:ur>0?ur:1,space:Ze.length,programId:We}));ar!==null&&await sendAndConfirmTransaction(Re,ar,[Fe,qe],{commitment:"confirmed"})}const Xe=struct([u32("instruction"),u32("offset"),u32("bytesLength"),u32("bytesLengthPadding"),seq(u8("byte"),offset(u32(),-8),"bytes")]),Je=Loader.chunkSize;let tr=0,er=Ze,ir=[];for(;er.length>0;){const ur=er.slice(0,Je),fr=buffer.Buffer.alloc(Je+16);Xe.encode({instruction:0,offset:tr,bytes:ur,bytesLength:0,bytesLengthPadding:0},fr);const ar=new Transaction().add({keys:[{pubkey:qe.publicKey,isSigner:!0,isWritable:!0}],programId:We,data:fr});ir.push(sendAndConfirmTransaction(Re,ar,[Fe,qe],{commitment:"confirmed"})),Re._rpcEndpoint.includes("solana.com")&&await sleep(1e3/4),tr+=Je,er=er.slice(Je)}await Promise.all(ir);{const ur=struct([u32("instruction")]),fr=buffer.Buffer.alloc(ur.span);ur.encode({instruction:1},fr);const ar=new Transaction().add({keys:[{pubkey:qe.publicKey,isSigner:!0,isWritable:!0},{pubkey:SYSVAR_RENT_PUBKEY,isSigner:!1,isWritable:!1}],programId:We,data:fr});await sendAndConfirmTransaction(Re,ar,[Fe,qe],{commitment:"confirmed"})}return!0}}Loader.chunkSize=CHUNK_SIZE;const BPF_LOADER_PROGRAM_ID=new PublicKey("BPFLoader2111111111111111111111111111111111");class BpfLoader{static getMinNumSignatures(Re){return Loader.getMinNumSignatures(Re)}static load(Re,Fe,qe,We,Ze){return Loader.load(Re,Fe,qe,Ze,We)}}var objToString=Object.prototype.toString,objKeys=Object.keys||function(Ke){var Re=[];for(var Fe in Ke)Re.push(Fe);return Re};function stringify(Ke,Re){var Fe,qe,We,Ze,Xe,Je,tr;if(Ke===!0)return"true";if(Ke===!1)return"false";switch(typeof Ke){case"object":if(Ke===null)return null;if(Ke.toJSON&&typeof Ke.toJSON=="function")return stringify(Ke.toJSON(),Re);if(tr=objToString.call(Ke),tr==="[object Array]"){for(We="[",qe=Ke.length-1,Fe=0;Fe<qe;Fe++)We+=stringify(Ke[Fe],!0)+",";return qe>-1&&(We+=stringify(Ke[Fe],!0)),We+"]"}else if(tr==="[object Object]"){for(Ze=objKeys(Ke).sort(),qe=Ze.length,We="",Fe=0;Fe<qe;)Xe=Ze[Fe],Je=stringify(Ke[Xe],!1),Je!==void 0&&(We&&(We+=","),We+=JSON.stringify(Xe)+":"+Je),Fe++;return"{"+We+"}"}else return JSON.stringify(Ke);case"function":case"undefined":return Re?null:void 0;case"string":return JSON.stringify(Ke);default:return isFinite(Ke)?Ke:null}}var fastStableStringify=function(Ke){var Re=stringify(Ke,!1);if(Re!==void 0)return""+Re},fastStableStringify$1=fastStableStringify;const MINIMUM_SLOT_PER_EPOCH=32;function trailingZeros(Ke){let Re=0;for(;Ke>1;)Ke/=2,Re++;return Re}function nextPowerOfTwo(Ke){return Ke===0?1:(Ke--,Ke|=Ke>>1,Ke|=Ke>>2,Ke|=Ke>>4,Ke|=Ke>>8,Ke|=Ke>>16,Ke|=Ke>>32,Ke+1)}class EpochSchedule{constructor(Re,Fe,qe,We,Ze){this.slotsPerEpoch=void 0,this.leaderScheduleSlotOffset=void 0,this.warmup=void 0,this.firstNormalEpoch=void 0,this.firstNormalSlot=void 0,this.slotsPerEpoch=Re,this.leaderScheduleSlotOffset=Fe,this.warmup=qe,this.firstNormalEpoch=We,this.firstNormalSlot=Ze}getEpoch(Re){return this.getEpochAndSlotIndex(Re)[0]}getEpochAndSlotIndex(Re){if(Re<this.firstNormalSlot){const Fe=trailingZeros(nextPowerOfTwo(Re+MINIMUM_SLOT_PER_EPOCH+1))-trailingZeros(MINIMUM_SLOT_PER_EPOCH)-1,qe=this.getSlotsInEpoch(Fe),We=Re-(qe-MINIMUM_SLOT_PER_EPOCH);return[Fe,We]}else{const Fe=Re-this.firstNormalSlot,qe=Math.floor(Fe/this.slotsPerEpoch),We=this.firstNormalEpoch+qe,Ze=Fe%this.slotsPerEpoch;return[We,Ze]}}getFirstSlotInEpoch(Re){return Re<=this.firstNormalEpoch?(Math.pow(2,Re)-1)*MINIMUM_SLOT_PER_EPOCH:(Re-this.firstNormalEpoch)*this.slotsPerEpoch+this.firstNormalSlot}getLastSlotInEpoch(Re){return this.getFirstSlotInEpoch(Re)+this.getSlotsInEpoch(Re)-1}getSlotsInEpoch(Re){return Re<this.firstNormalEpoch?Math.pow(2,Re+trailingZeros(MINIMUM_SLOT_PER_EPOCH)):this.slotsPerEpoch}}class SendTransactionError extends Error{constructor(Re,Fe){super(Re),this.logs=void 0,this.logs=Fe}}const SolanaJSONRPCErrorCode={JSON_RPC_SERVER_ERROR_BLOCK_CLEANED_UP:-32001,JSON_RPC_SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE:-32002,JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE:-32003,JSON_RPC_SERVER_ERROR_BLOCK_NOT_AVAILABLE:-32004,JSON_RPC_SERVER_ERROR_NODE_UNHEALTHY:-32005,JSON_RPC_SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE:-32006,JSON_RPC_SERVER_ERROR_SLOT_SKIPPED:-32007,JSON_RPC_SERVER_ERROR_NO_SNAPSHOT:-32008,JSON_RPC_SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED:-32009,JSON_RPC_SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX:-32010,JSON_RPC_SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE:-32011,JSON_RPC_SCAN_ERROR:-32012,JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH:-32013,JSON_RPC_SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET:-32014,JSON_RPC_SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION:-32015,JSON_RPC_SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED:-32016};class SolanaJSONRPCError extends Error{constructor({code:Re,message:Fe,data:qe},We){super(We!=null?`${We}: ${Fe}`:Fe),this.code=void 0,this.data=void 0,this.code=Re,this.data=qe,this.name="SolanaJSONRPCError"}}var fetchImpl=globalThis.fetch;const NUM_TICKS_PER_SECOND=160,DEFAULT_TICKS_PER_SLOT=64,NUM_SLOTS_PER_SECOND=NUM_TICKS_PER_SECOND/DEFAULT_TICKS_PER_SLOT,MS_PER_SLOT=1e3/NUM_SLOTS_PER_SECOND;function decodeData(Ke,Re){let Fe;try{Fe=Ke.layout.decode(Re)}catch(qe){throw new Error("invalid instruction; "+qe)}if(Fe.typeIndex!==Ke.index)throw new Error(`invalid account data; account type mismatch ${Fe.typeIndex} != ${Ke.index}`);return Fe}const LOOKUP_TABLE_META_SIZE=56;class AddressLookupTableAccount{constructor(Re){this.key=void 0,this.state=void 0,this.key=Re.key,this.state=Re.state}isActive(){const Re=BigInt("0xffffffffffffffff");return this.state.deactivationSlot===Re}static deserialize(Re){const Fe=decodeData(LookupTableMetaLayout,Re),qe=Re.length-LOOKUP_TABLE_META_SIZE;assert(qe>=0,"lookup table is invalid"),assert(qe%32===0,"lookup table is invalid");const We=qe/32,{addresses:Ze}=struct([seq(publicKey(),We,"addresses")]).decode(Re.slice(LOOKUP_TABLE_META_SIZE));return{deactivationSlot:Fe.deactivationSlot,lastExtendedSlot:Fe.lastExtendedSlot,lastExtendedSlotStartIndex:Fe.lastExtendedStartIndex,authority:Fe.authority.length!==0?new PublicKey(Fe.authority[0]):void 0,addresses:Ze.map(Xe=>new PublicKey(Xe))}}}const LookupTableMetaLayout={index:1,layout:struct([u32("typeIndex"),u64("deactivationSlot"),nu64("lastExtendedSlot"),u8("lastExtendedStartIndex"),u8(),seq(publicKey(),offset(u8(),-1),"authority")])},URL_RE=/^[^:]+:\/\/([^:[]+|\[[^\]]+\])(:\d+)?(.*)/i;function makeWebsocketUrl(Ke){const Re=Ke.match(URL_RE);if(Re==null)throw TypeError(`Failed to validate endpoint URL \`${Ke}\``);const[Fe,qe,We,Ze]=Re,Xe=Ke.startsWith("https:")?"wss:":"ws:",Je=We==null?null:parseInt(We.slice(1),10),tr=Je==null?"":`:${Je+1}`;return`${Xe}//${qe}${tr}${Ze}`}var _process$env$npm_pack;const PublicKeyFromString=coerce(instance(PublicKey),string(),Ke=>new PublicKey(Ke)),RawAccountDataResult=tuple([string(),literal("base64")]),BufferFromRawAccountData=coerce(instance(buffer.Buffer),RawAccountDataResult,Ke=>buffer.Buffer.from(Ke[0],"base64")),BLOCKHASH_CACHE_TIMEOUT_MS=30*1e3;function assertEndpointUrl(Ke){if(/^https?:/.test(Ke)===!1)throw new TypeError("Endpoint URL must start with `http:` or `https:`.");return Ke}function extractCommitmentFromConfig(Ke){let Re,Fe;if(typeof Ke=="string")Re=Ke;else if(Ke){const{commitment:qe,...We}=Ke;Re=qe,Fe=We}return{commitment:Re,config:Fe}}function createRpcResult(Ke){return union([type({jsonrpc:literal("2.0"),id:string(),result:Ke}),type({jsonrpc:literal("2.0"),id:string(),error:type({code:unknown(),message:string(),data:optional(any())})})])}const UnknownRpcResult=createRpcResult(unknown());function jsonRpcResult(Ke){return coerce(createRpcResult(Ke),UnknownRpcResult,Re=>"error"in Re?Re:{...Re,result:create(Re.result,Ke)})}function jsonRpcResultAndContext(Ke){return jsonRpcResult(type({context:type({slot:number()}),value:Ke}))}function notificationResultAndContext(Ke){return type({context:type({slot:number()}),value:Ke})}function versionedMessageFromResponse(Ke,Re){return Ke===0?new MessageV0({header:Re.header,staticAccountKeys:Re.accountKeys.map(Fe=>new PublicKey(Fe)),recentBlockhash:Re.recentBlockhash,compiledInstructions:Re.instructions.map(Fe=>({programIdIndex:Fe.programIdIndex,accountKeyIndexes:Fe.accounts,data:bs58.decode(Fe.data)})),addressTableLookups:Re.addressTableLookups}):new Message(Re)}const GetInflationGovernorResult=type({foundation:number(),foundationTerm:number(),initial:number(),taper:number(),terminal:number()}),GetInflationRewardResult=jsonRpcResult(array(nullable(type({epoch:number(),effectiveSlot:number(),amount:number(),postBalance:number()})))),GetEpochInfoResult=type({epoch:number(),slotIndex:number(),slotsInEpoch:number(),absoluteSlot:number(),blockHeight:optional(number()),transactionCount:optional(number())}),GetEpochScheduleResult=type({slotsPerEpoch:number(),leaderScheduleSlotOffset:number(),warmup:boolean(),firstNormalEpoch:number(),firstNormalSlot:number()}),GetLeaderScheduleResult=record(string(),array(number())),TransactionErrorResult=nullable(union([type({}),string()])),SignatureStatusResult=type({err:TransactionErrorResult}),SignatureReceivedResult=literal("receivedSignature"),VersionResult=type({"solana-core":string(),"feature-set":optional(number())}),SimulatedTransactionResponseStruct=jsonRpcResultAndContext(type({err:nullable(union([type({}),string()])),logs:nullable(array(string())),accounts:optional(nullable(array(nullable(type({executable:boolean(),owner:string(),lamports:number(),data:array(string()),rentEpoch:optional(number())}))))),unitsConsumed:optional(number()),returnData:optional(nullable(type({programId:string(),data:tuple([string(),literal("base64")])})))})),BlockProductionResponseStruct=jsonRpcResultAndContext(type({byIdentity:record(string(),array(number())),range:type({firstSlot:number(),lastSlot:number()})}));function createRpcClient(Ke,Re,Fe,qe,We){const Ze=Fe||fetchImpl;let Xe;return qe&&(Xe=async(tr,er)=>{const ir=await new Promise((ur,fr)=>{try{qe(tr,er,(ar,yr)=>ur([ar,yr]))}catch(ar){fr(ar)}});return await Ze(...ir)}),new browser(async(tr,er)=>{const ur={method:"POST",body:tr,agent:void 0,headers:Object.assign({"Content-Type":"application/json"},Re||{},COMMON_HTTP_HEADERS)};try{let fr=5,ar,yr=500;for(;Xe?ar=await Xe(Ke,ur):ar=await Ze(Ke,ur),!(ar.status!==429||We===!0||(fr-=1,fr===0));)console.log(`Server responded with ${ar.status} ${ar.statusText}.  Retrying after ${yr}ms delay...`),await sleep(yr),yr*=2;const mr=await ar.text();ar.ok?er(null,mr):er(new Error(`${ar.status} ${ar.statusText}: ${mr}`))}catch(fr){fr instanceof Error&&er(fr)}finally{}},{})}function createRpcRequest(Ke){return(Re,Fe)=>new Promise((qe,We)=>{Ke.request(Re,Fe,(Ze,Xe)=>{if(Ze){We(Ze);return}qe(Xe)})})}function createRpcBatchRequest(Ke){return Re=>new Promise((Fe,qe)=>{Re.length===0&&Fe([]);const We=Re.map(Ze=>Ke.request(Ze.methodName,Ze.args));Ke.request(We,(Ze,Xe)=>{if(Ze){qe(Ze);return}Fe(Xe)})})}const GetInflationGovernorRpcResult=jsonRpcResult(GetInflationGovernorResult),GetEpochInfoRpcResult=jsonRpcResult(GetEpochInfoResult),GetEpochScheduleRpcResult=jsonRpcResult(GetEpochScheduleResult),GetLeaderScheduleRpcResult=jsonRpcResult(GetLeaderScheduleResult),SlotRpcResult=jsonRpcResult(number()),GetSupplyRpcResult=jsonRpcResultAndContext(type({total:number(),circulating:number(),nonCirculating:number(),nonCirculatingAccounts:array(PublicKeyFromString)})),TokenAmountResult=type({amount:string(),uiAmount:nullable(number()),decimals:number(),uiAmountString:optional(string())}),GetTokenLargestAccountsResult=jsonRpcResultAndContext(array(type({address:PublicKeyFromString,amount:string(),uiAmount:nullable(number()),decimals:number(),uiAmountString:optional(string())}))),GetTokenAccountsByOwner=jsonRpcResultAndContext(array(type({pubkey:PublicKeyFromString,account:type({executable:boolean(),owner:PublicKeyFromString,lamports:number(),data:BufferFromRawAccountData,rentEpoch:number()})}))),ParsedAccountDataResult=type({program:string(),parsed:unknown(),space:number()}),GetParsedTokenAccountsByOwner=jsonRpcResultAndContext(array(type({pubkey:PublicKeyFromString,account:type({executable:boolean(),owner:PublicKeyFromString,lamports:number(),data:ParsedAccountDataResult,rentEpoch:number()})}))),GetLargestAccountsRpcResult=jsonRpcResultAndContext(array(type({lamports:number(),address:PublicKeyFromString}))),AccountInfoResult=type({executable:boolean(),owner:PublicKeyFromString,lamports:number(),data:BufferFromRawAccountData,rentEpoch:number()}),KeyedAccountInfoResult=type({pubkey:PublicKeyFromString,account:AccountInfoResult}),ParsedOrRawAccountData=coerce(union([instance(buffer.Buffer),ParsedAccountDataResult]),union([RawAccountDataResult,ParsedAccountDataResult]),Ke=>Array.isArray(Ke)?create(Ke,BufferFromRawAccountData):Ke),ParsedAccountInfoResult=type({executable:boolean(),owner:PublicKeyFromString,lamports:number(),data:ParsedOrRawAccountData,rentEpoch:number()}),KeyedParsedAccountInfoResult=type({pubkey:PublicKeyFromString,account:ParsedAccountInfoResult}),StakeActivationResult=type({state:union([literal("active"),literal("inactive"),literal("activating"),literal("deactivating")]),active:number(),inactive:number()}),GetConfirmedSignaturesForAddress2RpcResult=jsonRpcResult(array(type({signature:string(),slot:number(),err:TransactionErrorResult,memo:nullable(string()),blockTime:optional(nullable(number()))}))),GetSignaturesForAddressRpcResult=jsonRpcResult(array(type({signature:string(),slot:number(),err:TransactionErrorResult,memo:nullable(string()),blockTime:optional(nullable(number()))}))),AccountNotificationResult=type({subscription:number(),result:notificationResultAndContext(AccountInfoResult)}),ProgramAccountInfoResult=type({pubkey:PublicKeyFromString,account:AccountInfoResult}),ProgramAccountNotificationResult=type({subscription:number(),result:notificationResultAndContext(ProgramAccountInfoResult)}),SlotInfoResult=type({parent:number(),slot:number(),root:number()}),SlotNotificationResult=type({subscription:number(),result:SlotInfoResult}),SlotUpdateResult=union([type({type:union([literal("firstShredReceived"),literal("completed"),literal("optimisticConfirmation"),literal("root")]),slot:number(),timestamp:number()}),type({type:literal("createdBank"),parent:number(),slot:number(),timestamp:number()}),type({type:literal("frozen"),slot:number(),timestamp:number(),stats:type({numTransactionEntries:number(),numSuccessfulTransactions:number(),numFailedTransactions:number(),maxTransactionsPerEntry:number()})}),type({type:literal("dead"),slot:number(),timestamp:number(),err:string()})]),SlotUpdateNotificationResult=type({subscription:number(),result:SlotUpdateResult}),SignatureNotificationResult=type({subscription:number(),result:notificationResultAndContext(union([SignatureStatusResult,SignatureReceivedResult]))}),RootNotificationResult=type({subscription:number(),result:number()}),ContactInfoResult=type({pubkey:string(),gossip:nullable(string()),tpu:nullable(string()),rpc:nullable(string()),version:nullable(string())}),VoteAccountInfoResult=type({votePubkey:string(),nodePubkey:string(),activatedStake:number(),epochVoteAccount:boolean(),epochCredits:array(tuple([number(),number(),number()])),commission:number(),lastVote:number(),rootSlot:nullable(number())}),GetVoteAccounts=jsonRpcResult(type({current:array(VoteAccountInfoResult),delinquent:array(VoteAccountInfoResult)})),ConfirmationStatus=union([literal("processed"),literal("confirmed"),literal("finalized")]),SignatureStatusResponse=type({slot:number(),confirmations:nullable(number()),err:TransactionErrorResult,confirmationStatus:optional(ConfirmationStatus)}),GetSignatureStatusesRpcResult=jsonRpcResultAndContext(array(nullable(SignatureStatusResponse))),GetMinimumBalanceForRentExemptionRpcResult=jsonRpcResult(number()),AddressTableLookupStruct=type({accountKey:PublicKeyFromString,writableIndexes:array(number()),readonlyIndexes:array(number())}),ConfirmedTransactionResult=type({signatures:array(string()),message:type({accountKeys:array(string()),header:type({numRequiredSignatures:number(),numReadonlySignedAccounts:number(),numReadonlyUnsignedAccounts:number()}),instructions:array(type({accounts:array(number()),data:string(),programIdIndex:number()})),recentBlockhash:string(),addressTableLookups:optional(array(AddressTableLookupStruct))})}),ParsedInstructionResult=type({parsed:unknown(),program:string(),programId:PublicKeyFromString}),RawInstructionResult=type({accounts:array(PublicKeyFromString),data:string(),programId:PublicKeyFromString}),InstructionResult=union([RawInstructionResult,ParsedInstructionResult]),UnknownInstructionResult=union([type({parsed:unknown(),program:string(),programId:string()}),type({accounts:array(string()),data:string(),programId:string()})]),ParsedOrRawInstruction=coerce(InstructionResult,UnknownInstructionResult,Ke=>"accounts"in Ke?create(Ke,RawInstructionResult):create(Ke,ParsedInstructionResult)),ParsedConfirmedTransactionResult=type({signatures:array(string()),message:type({accountKeys:array(type({pubkey:PublicKeyFromString,signer:boolean(),writable:boolean(),source:optional(union([literal("transaction"),literal("lookupTable")]))})),instructions:array(ParsedOrRawInstruction),recentBlockhash:string(),addressTableLookups:optional(nullable(array(AddressTableLookupStruct)))})}),TokenBalanceResult=type({accountIndex:number(),mint:string(),owner:optional(string()),uiTokenAmount:TokenAmountResult}),LoadedAddressesResult=type({writable:array(PublicKeyFromString),readonly:array(PublicKeyFromString)}),ConfirmedTransactionMetaResult=type({err:TransactionErrorResult,fee:number(),innerInstructions:optional(nullable(array(type({index:number(),instructions:array(type({accounts:array(number()),data:string(),programIdIndex:number()}))})))),preBalances:array(number()),postBalances:array(number()),logMessages:optional(nullable(array(string()))),preTokenBalances:optional(nullable(array(TokenBalanceResult))),postTokenBalances:optional(nullable(array(TokenBalanceResult))),loadedAddresses:optional(LoadedAddressesResult),computeUnitsConsumed:optional(number())}),ParsedConfirmedTransactionMetaResult=type({err:TransactionErrorResult,fee:number(),innerInstructions:optional(nullable(array(type({index:number(),instructions:array(ParsedOrRawInstruction)})))),preBalances:array(number()),postBalances:array(number()),logMessages:optional(nullable(array(string()))),preTokenBalances:optional(nullable(array(TokenBalanceResult))),postTokenBalances:optional(nullable(array(TokenBalanceResult))),loadedAddresses:optional(LoadedAddressesResult),computeUnitsConsumed:optional(number())}),TransactionVersionStruct=union([literal(0),literal("legacy")]),GetBlockRpcResult=jsonRpcResult(nullable(type({blockhash:string(),previousBlockhash:string(),parentSlot:number(),transactions:array(type({transaction:ConfirmedTransactionResult,meta:nullable(ConfirmedTransactionMetaResult),version:optional(TransactionVersionStruct)})),rewards:optional(array(type({pubkey:string(),lamports:number(),postBalance:nullable(number()),rewardType:nullable(string())}))),blockTime:nullable(number()),blockHeight:nullable(number())}))),GetParsedBlockRpcResult=jsonRpcResult(nullable(type({blockhash:string(),previousBlockhash:string(),parentSlot:number(),transactions:array(type({transaction:ParsedConfirmedTransactionResult,meta:nullable(ParsedConfirmedTransactionMetaResult),version:optional(TransactionVersionStruct)})),rewards:optional(array(type({pubkey:string(),lamports:number(),postBalance:nullable(number()),rewardType:nullable(string())}))),blockTime:nullable(number()),blockHeight:nullable(number())}))),GetConfirmedBlockRpcResult=jsonRpcResult(nullable(type({blockhash:string(),previousBlockhash:string(),parentSlot:number(),transactions:array(type({transaction:ConfirmedTransactionResult,meta:nullable(ConfirmedTransactionMetaResult)})),rewards:optional(array(type({pubkey:string(),lamports:number(),postBalance:nullable(number()),rewardType:nullable(string())}))),blockTime:nullable(number())}))),GetBlockSignaturesRpcResult=jsonRpcResult(nullable(type({blockhash:string(),previousBlockhash:string(),parentSlot:number(),signatures:array(string()),blockTime:nullable(number())}))),GetTransactionRpcResult=jsonRpcResult(nullable(type({slot:number(),meta:ConfirmedTransactionMetaResult,blockTime:optional(nullable(number())),transaction:ConfirmedTransactionResult,version:optional(TransactionVersionStruct)}))),GetParsedTransactionRpcResult=jsonRpcResult(nullable(type({slot:number(),transaction:ParsedConfirmedTransactionResult,meta:nullable(ParsedConfirmedTransactionMetaResult),blockTime:optional(nullable(number())),version:optional(TransactionVersionStruct)}))),GetRecentBlockhashAndContextRpcResult=jsonRpcResultAndContext(type({blockhash:string(),feeCalculator:type({lamportsPerSignature:number()})})),GetLatestBlockhashRpcResult=jsonRpcResultAndContext(type({blockhash:string(),lastValidBlockHeight:number()})),PerfSampleResult=type({slot:number(),numTransactions:number(),numSlots:number(),samplePeriodSecs:number()}),GetRecentPerformanceSamplesRpcResult=jsonRpcResult(array(PerfSampleResult)),GetFeeCalculatorRpcResult=jsonRpcResultAndContext(nullable(type({feeCalculator:type({lamportsPerSignature:number()})}))),RequestAirdropRpcResult=jsonRpcResult(string()),SendTransactionRpcResult=jsonRpcResult(string()),LogsResult=type({err:TransactionErrorResult,logs:array(string()),signature:string()}),LogsNotificationResult=type({result:notificationResultAndContext(LogsResult),subscription:number()}),COMMON_HTTP_HEADERS={"solana-client":`js/${(_process$env$npm_pack="0.0.0-development")!==null&&_process$env$npm_pack!==void 0?_process$env$npm_pack:"UNKNOWN"}`};class Connection{constructor(Re,Fe){this._commitment=void 0,this._confirmTransactionInitialTimeout=void 0,this._rpcEndpoint=void 0,this._rpcWsEndpoint=void 0,this._rpcClient=void 0,this._rpcRequest=void 0,this._rpcBatchRequest=void 0,this._rpcWebSocket=void 0,this._rpcWebSocketConnected=!1,this._rpcWebSocketHeartbeat=null,this._rpcWebSocketIdleTimeout=null,this._rpcWebSocketGeneration=0,this._disableBlockhashCaching=!1,this._pollingBlockhash=!1,this._blockhashInfo={latestBlockhash:null,lastFetch:0,transactionSignatures:[],simulatedSignatures:[]},this._nextClientSubscriptionId=0,this._subscriptionDisposeFunctionsByClientSubscriptionId={},this._subscriptionCallbacksByServerSubscriptionId={},this._subscriptionsByHash={},this._subscriptionsAutoDisposedByRpc=new Set;let qe,We,Ze,Xe,Je;Fe&&typeof Fe=="string"?this._commitment=Fe:Fe&&(this._commitment=Fe.commitment,this._confirmTransactionInitialTimeout=Fe.confirmTransactionInitialTimeout,qe=Fe.wsEndpoint,We=Fe.httpHeaders,Ze=Fe.fetch,Xe=Fe.fetchMiddleware,Je=Fe.disableRetryOnRateLimit),this._rpcEndpoint=assertEndpointUrl(Re),this._rpcWsEndpoint=qe||makeWebsocketUrl(Re),this._rpcClient=createRpcClient(Re,We,Ze,Xe,Je),this._rpcRequest=createRpcRequest(this._rpcClient),this._rpcBatchRequest=createRpcBatchRequest(this._rpcClient),this._rpcWebSocket=new Client_1(this._rpcWsEndpoint,{autoconnect:!1,max_reconnects:1/0}),this._rpcWebSocket.on("open",this._wsOnOpen.bind(this)),this._rpcWebSocket.on("error",this._wsOnError.bind(this)),this._rpcWebSocket.on("close",this._wsOnClose.bind(this)),this._rpcWebSocket.on("accountNotification",this._wsOnAccountNotification.bind(this)),this._rpcWebSocket.on("programNotification",this._wsOnProgramAccountNotification.bind(this)),this._rpcWebSocket.on("slotNotification",this._wsOnSlotNotification.bind(this)),this._rpcWebSocket.on("slotsUpdatesNotification",this._wsOnSlotUpdatesNotification.bind(this)),this._rpcWebSocket.on("signatureNotification",this._wsOnSignatureNotification.bind(this)),this._rpcWebSocket.on("rootNotification",this._wsOnRootNotification.bind(this)),this._rpcWebSocket.on("logsNotification",this._wsOnLogsNotification.bind(this))}get commitment(){return this._commitment}get rpcEndpoint(){return this._rpcEndpoint}async getBalanceAndContext(Re,Fe){const{commitment:qe,config:We}=extractCommitmentFromConfig(Fe),Ze=this._buildArgs([Re.toBase58()],qe,void 0,We),Xe=await this._rpcRequest("getBalance",Ze),Je=create(Xe,jsonRpcResultAndContext(number()));if("error"in Je)throw new SolanaJSONRPCError(Je.error,`failed to get balance for ${Re.toBase58()}`);return Je.result}async getBalance(Re,Fe){return await this.getBalanceAndContext(Re,Fe).then(qe=>qe.value).catch(qe=>{throw new Error("failed to get balance of account "+Re.toBase58()+": "+qe)})}async getBlockTime(Re){const Fe=await this._rpcRequest("getBlockTime",[Re]),qe=create(Fe,jsonRpcResult(nullable(number())));if("error"in qe)throw new SolanaJSONRPCError(qe.error,`failed to get block time for slot ${Re}`);return qe.result}async getMinimumLedgerSlot(){const Re=await this._rpcRequest("minimumLedgerSlot",[]),Fe=create(Re,jsonRpcResult(number()));if("error"in Fe)throw new SolanaJSONRPCError(Fe.error,"failed to get minimum ledger slot");return Fe.result}async getFirstAvailableBlock(){const Re=await this._rpcRequest("getFirstAvailableBlock",[]),Fe=create(Re,SlotRpcResult);if("error"in Fe)throw new SolanaJSONRPCError(Fe.error,"failed to get first available block");return Fe.result}async getSupply(Re){let Fe={};typeof Re=="string"?Fe={commitment:Re}:Re?Fe={...Re,commitment:Re&&Re.commitment||this.commitment}:Fe={commitment:this.commitment};const qe=await this._rpcRequest("getSupply",[Fe]),We=create(qe,GetSupplyRpcResult);if("error"in We)throw new SolanaJSONRPCError(We.error,"failed to get supply");return We.result}async getTokenSupply(Re,Fe){const qe=this._buildArgs([Re.toBase58()],Fe),We=await this._rpcRequest("getTokenSupply",qe),Ze=create(We,jsonRpcResultAndContext(TokenAmountResult));if("error"in Ze)throw new SolanaJSONRPCError(Ze.error,"failed to get token supply");return Ze.result}async getTokenAccountBalance(Re,Fe){const qe=this._buildArgs([Re.toBase58()],Fe),We=await this._rpcRequest("getTokenAccountBalance",qe),Ze=create(We,jsonRpcResultAndContext(TokenAmountResult));if("error"in Ze)throw new SolanaJSONRPCError(Ze.error,"failed to get token account balance");return Ze.result}async getTokenAccountsByOwner(Re,Fe,qe){const{commitment:We,config:Ze}=extractCommitmentFromConfig(qe);let Xe=[Re.toBase58()];"mint"in Fe?Xe.push({mint:Fe.mint.toBase58()}):Xe.push({programId:Fe.programId.toBase58()});const Je=this._buildArgs(Xe,We,"base64",Ze),tr=await this._rpcRequest("getTokenAccountsByOwner",Je),er=create(tr,GetTokenAccountsByOwner);if("error"in er)throw new SolanaJSONRPCError(er.error,`failed to get token accounts owned by account ${Re.toBase58()}`);return er.result}async getParsedTokenAccountsByOwner(Re,Fe,qe){let We=[Re.toBase58()];"mint"in Fe?We.push({mint:Fe.mint.toBase58()}):We.push({programId:Fe.programId.toBase58()});const Ze=this._buildArgs(We,qe,"jsonParsed"),Xe=await this._rpcRequest("getTokenAccountsByOwner",Ze),Je=create(Xe,GetParsedTokenAccountsByOwner);if("error"in Je)throw new SolanaJSONRPCError(Je.error,`failed to get token accounts owned by account ${Re.toBase58()}`);return Je.result}async getLargestAccounts(Re){const Fe={...Re,commitment:Re&&Re.commitment||this.commitment},qe=Fe.filter||Fe.commitment?[Fe]:[],We=await this._rpcRequest("getLargestAccounts",qe),Ze=create(We,GetLargestAccountsRpcResult);if("error"in Ze)throw new SolanaJSONRPCError(Ze.error,"failed to get largest accounts");return Ze.result}async getTokenLargestAccounts(Re,Fe){const qe=this._buildArgs([Re.toBase58()],Fe),We=await this._rpcRequest("getTokenLargestAccounts",qe),Ze=create(We,GetTokenLargestAccountsResult);if("error"in Ze)throw new SolanaJSONRPCError(Ze.error,"failed to get token largest accounts");return Ze.result}async getAccountInfoAndContext(Re,Fe){const{commitment:qe,config:We}=extractCommitmentFromConfig(Fe),Ze=this._buildArgs([Re.toBase58()],qe,"base64",We),Xe=await this._rpcRequest("getAccountInfo",Ze),Je=create(Xe,jsonRpcResultAndContext(nullable(AccountInfoResult)));if("error"in Je)throw new SolanaJSONRPCError(Je.error,`failed to get info about account ${Re.toBase58()}`);return Je.result}async getParsedAccountInfo(Re,Fe){const{commitment:qe,config:We}=extractCommitmentFromConfig(Fe),Ze=this._buildArgs([Re.toBase58()],qe,"jsonParsed",We),Xe=await this._rpcRequest("getAccountInfo",Ze),Je=create(Xe,jsonRpcResultAndContext(nullable(ParsedAccountInfoResult)));if("error"in Je)throw new SolanaJSONRPCError(Je.error,`failed to get info about account ${Re.toBase58()}`);return Je.result}async getAccountInfo(Re,Fe){try{return(await this.getAccountInfoAndContext(Re,Fe)).value}catch(qe){throw new Error("failed to get info about account "+Re.toBase58()+": "+qe)}}async getMultipleParsedAccounts(Re,Fe){const{commitment:qe,config:We}=extractCommitmentFromConfig(Fe),Ze=Re.map(er=>er.toBase58()),Xe=this._buildArgs([Ze],qe,"jsonParsed",We),Je=await this._rpcRequest("getMultipleAccounts",Xe),tr=create(Je,jsonRpcResultAndContext(array(nullable(ParsedAccountInfoResult))));if("error"in tr)throw new SolanaJSONRPCError(tr.error,`failed to get info for accounts ${Ze}`);return tr.result}async getMultipleAccountsInfoAndContext(Re,Fe){const{commitment:qe,config:We}=extractCommitmentFromConfig(Fe),Ze=Re.map(er=>er.toBase58()),Xe=this._buildArgs([Ze],qe,"base64",We),Je=await this._rpcRequest("getMultipleAccounts",Xe),tr=create(Je,jsonRpcResultAndContext(array(nullable(AccountInfoResult))));if("error"in tr)throw new SolanaJSONRPCError(tr.error,`failed to get info for accounts ${Ze}`);return tr.result}async getMultipleAccountsInfo(Re,Fe){return(await this.getMultipleAccountsInfoAndContext(Re,Fe)).value}async getStakeActivation(Re,Fe,qe){const{commitment:We,config:Ze}=extractCommitmentFromConfig(Fe),Xe=this._buildArgs([Re.toBase58()],We,void 0,{...Ze,epoch:qe!=null?qe:Ze==null?void 0:Ze.epoch}),Je=await this._rpcRequest("getStakeActivation",Xe),tr=create(Je,jsonRpcResult(StakeActivationResult));if("error"in tr)throw new SolanaJSONRPCError(tr.error,`failed to get Stake Activation ${Re.toBase58()}`);return tr.result}async getProgramAccounts(Re,Fe){const{commitment:qe,config:We}=extractCommitmentFromConfig(Fe),{encoding:Ze,...Xe}=We||{},Je=this._buildArgs([Re.toBase58()],qe,Ze||"base64",Xe),tr=await this._rpcRequest("getProgramAccounts",Je),er=create(tr,jsonRpcResult(array(KeyedAccountInfoResult)));if("error"in er)throw new SolanaJSONRPCError(er.error,`failed to get accounts owned by program ${Re.toBase58()}`);return er.result}async getParsedProgramAccounts(Re,Fe){const{commitment:qe,config:We}=extractCommitmentFromConfig(Fe),Ze=this._buildArgs([Re.toBase58()],qe,"jsonParsed",We),Xe=await this._rpcRequest("getProgramAccounts",Ze),Je=create(Xe,jsonRpcResult(array(KeyedParsedAccountInfoResult)));if("error"in Je)throw new SolanaJSONRPCError(Je.error,`failed to get accounts owned by program ${Re.toBase58()}`);return Je.result}async confirmTransaction(Re,Fe){let qe;typeof Re=="string"?qe=Re:qe=Re.signature;let We;try{We=bs58.decode(qe)}catch{throw new Error("signature must be base58 encoded: "+qe)}assert(We.length===64,"signature has invalid length");const Ze=Fe||this.commitment;let Xe,Je,tr=!1;const er=new Promise((fr,ar)=>{try{Je=this.onSignature(qe,(yr,mr)=>{Je=void 0;const wr={context:mr,value:yr};tr=!0,fr({__type:TransactionStatus.PROCESSED,response:wr})},Ze)}catch(yr){ar(yr)}}),ir=new Promise(fr=>{if(typeof Re=="string"){let ar=this._confirmTransactionInitialTimeout||6e4;switch(Ze){case"processed":case"recent":case"single":case"confirmed":case"singleGossip":{ar=this._confirmTransactionInitialTimeout||30*1e3;break}}Xe=setTimeout(()=>fr({__type:TransactionStatus.TIMED_OUT,timeoutMs:ar}),ar)}else{let ar=Re;const yr=async()=>{try{return await this.getBlockHeight(Fe)}catch{return-1}};(async()=>{let mr=await yr();if(!tr){for(;mr<=ar.lastValidBlockHeight;)if(await sleep(1e3),tr||(mr=await yr(),tr))return;fr({__type:TransactionStatus.BLOCKHEIGHT_EXCEEDED})}})()}});let ur;try{const fr=await Promise.race([er,ir]);switch(fr.__type){case TransactionStatus.BLOCKHEIGHT_EXCEEDED:throw new TransactionExpiredBlockheightExceededError(qe);case TransactionStatus.PROCESSED:ur=fr.response;break;case TransactionStatus.TIMED_OUT:throw new TransactionExpiredTimeoutError(qe,fr.timeoutMs/1e3)}}finally{clearTimeout(Xe),Je&&this.removeSignatureListener(Je)}return ur}async getClusterNodes(){const Re=await this._rpcRequest("getClusterNodes",[]),Fe=create(Re,jsonRpcResult(array(ContactInfoResult)));if("error"in Fe)throw new SolanaJSONRPCError(Fe.error,"failed to get cluster nodes");return Fe.result}async getVoteAccounts(Re){const Fe=this._buildArgs([],Re),qe=await this._rpcRequest("getVoteAccounts",Fe),We=create(qe,GetVoteAccounts);if("error"in We)throw new SolanaJSONRPCError(We.error,"failed to get vote accounts");return We.result}async getSlot(Re){const{commitment:Fe,config:qe}=extractCommitmentFromConfig(Re),We=this._buildArgs([],Fe,void 0,qe),Ze=await this._rpcRequest("getSlot",We),Xe=create(Ze,jsonRpcResult(number()));if("error"in Xe)throw new SolanaJSONRPCError(Xe.error,"failed to get slot");return Xe.result}async getSlotLeader(Re){const{commitment:Fe,config:qe}=extractCommitmentFromConfig(Re),We=this._buildArgs([],Fe,void 0,qe),Ze=await this._rpcRequest("getSlotLeader",We),Xe=create(Ze,jsonRpcResult(string()));if("error"in Xe)throw new SolanaJSONRPCError(Xe.error,"failed to get slot leader");return Xe.result}async getSlotLeaders(Re,Fe){const qe=[Re,Fe],We=await this._rpcRequest("getSlotLeaders",qe),Ze=create(We,jsonRpcResult(array(PublicKeyFromString)));if("error"in Ze)throw new SolanaJSONRPCError(Ze.error,"failed to get slot leaders");return Ze.result}async getSignatureStatus(Re,Fe){const{context:qe,value:We}=await this.getSignatureStatuses([Re],Fe);assert(We.length===1);const Ze=We[0];return{context:qe,value:Ze}}async getSignatureStatuses(Re,Fe){const qe=[Re];Fe&&qe.push(Fe);const We=await this._rpcRequest("getSignatureStatuses",qe),Ze=create(We,GetSignatureStatusesRpcResult);if("error"in Ze)throw new SolanaJSONRPCError(Ze.error,"failed to get signature status");return Ze.result}async getTransactionCount(Re){const{commitment:Fe,config:qe}=extractCommitmentFromConfig(Re),We=this._buildArgs([],Fe,void 0,qe),Ze=await this._rpcRequest("getTransactionCount",We),Xe=create(Ze,jsonRpcResult(number()));if("error"in Xe)throw new SolanaJSONRPCError(Xe.error,"failed to get transaction count");return Xe.result}async getTotalSupply(Re){return(await this.getSupply({commitment:Re,excludeNonCirculatingAccountsList:!0})).value.total}async getInflationGovernor(Re){const Fe=this._buildArgs([],Re),qe=await this._rpcRequest("getInflationGovernor",Fe),We=create(qe,GetInflationGovernorRpcResult);if("error"in We)throw new SolanaJSONRPCError(We.error,"failed to get inflation");return We.result}async getInflationReward(Re,Fe,qe){const{commitment:We,config:Ze}=extractCommitmentFromConfig(qe),Xe=this._buildArgs([Re.map(er=>er.toBase58())],We,void 0,{...Ze,epoch:Fe!=null?Fe:Ze==null?void 0:Ze.epoch}),Je=await this._rpcRequest("getInflationReward",Xe),tr=create(Je,GetInflationRewardResult);if("error"in tr)throw new SolanaJSONRPCError(tr.error,"failed to get inflation reward");return tr.result}async getEpochInfo(Re){const{commitment:Fe,config:qe}=extractCommitmentFromConfig(Re),We=this._buildArgs([],Fe,void 0,qe),Ze=await this._rpcRequest("getEpochInfo",We),Xe=create(Ze,GetEpochInfoRpcResult);if("error"in Xe)throw new SolanaJSONRPCError(Xe.error,"failed to get epoch info");return Xe.result}async getEpochSchedule(){const Re=await this._rpcRequest("getEpochSchedule",[]),Fe=create(Re,GetEpochScheduleRpcResult);if("error"in Fe)throw new SolanaJSONRPCError(Fe.error,"failed to get epoch schedule");const qe=Fe.result;return new EpochSchedule(qe.slotsPerEpoch,qe.leaderScheduleSlotOffset,qe.warmup,qe.firstNormalEpoch,qe.firstNormalSlot)}async getLeaderSchedule(){const Re=await this._rpcRequest("getLeaderSchedule",[]),Fe=create(Re,GetLeaderScheduleRpcResult);if("error"in Fe)throw new SolanaJSONRPCError(Fe.error,"failed to get leader schedule");return Fe.result}async getMinimumBalanceForRentExemption(Re,Fe){const qe=this._buildArgs([Re],Fe),We=await this._rpcRequest("getMinimumBalanceForRentExemption",qe),Ze=create(We,GetMinimumBalanceForRentExemptionRpcResult);return"error"in Ze?(console.warn("Unable to fetch minimum balance for rent exemption"),0):Ze.result}async getRecentBlockhashAndContext(Re){const Fe=this._buildArgs([],Re),qe=await this._rpcRequest("getRecentBlockhash",Fe),We=create(qe,GetRecentBlockhashAndContextRpcResult);if("error"in We)throw new SolanaJSONRPCError(We.error,"failed to get recent blockhash");return We.result}async getRecentPerformanceSamples(Re){const Fe=await this._rpcRequest("getRecentPerformanceSamples",Re?[Re]:[]),qe=create(Fe,GetRecentPerformanceSamplesRpcResult);if("error"in qe)throw new SolanaJSONRPCError(qe.error,"failed to get recent performance samples");return qe.result}async getFeeCalculatorForBlockhash(Re,Fe){const qe=this._buildArgs([Re],Fe),We=await this._rpcRequest("getFeeCalculatorForBlockhash",qe),Ze=create(We,GetFeeCalculatorRpcResult);if("error"in Ze)throw new SolanaJSONRPCError(Ze.error,"failed to get fee calculator");const{context:Xe,value:Je}=Ze.result;return{context:Xe,value:Je!==null?Je.feeCalculator:null}}async getFeeForMessage(Re,Fe){const qe=Re.serialize().toString("base64"),We=this._buildArgs([qe],Fe),Ze=await this._rpcRequest("getFeeForMessage",We),Xe=create(Ze,jsonRpcResultAndContext(nullable(number())));if("error"in Xe)throw new SolanaJSONRPCError(Xe.error,"failed to get fee for message");if(Xe.result===null)throw new Error("invalid blockhash");return Xe.result}async getRecentBlockhash(Re){try{return(await this.getRecentBlockhashAndContext(Re)).value}catch(Fe){throw new Error("failed to get recent blockhash: "+Fe)}}async getLatestBlockhash(Re){try{return(await this.getLatestBlockhashAndContext(Re)).value}catch(Fe){throw new Error("failed to get recent blockhash: "+Fe)}}async getLatestBlockhashAndContext(Re){const{commitment:Fe,config:qe}=extractCommitmentFromConfig(Re),We=this._buildArgs([],Fe,void 0,qe),Ze=await this._rpcRequest("getLatestBlockhash",We),Xe=create(Ze,GetLatestBlockhashRpcResult);if("error"in Xe)throw new SolanaJSONRPCError(Xe.error,"failed to get latest blockhash");return Xe.result}async getVersion(){const Re=await this._rpcRequest("getVersion",[]),Fe=create(Re,jsonRpcResult(VersionResult));if("error"in Fe)throw new SolanaJSONRPCError(Fe.error,"failed to get version");return Fe.result}async getGenesisHash(){const Re=await this._rpcRequest("getGenesisHash",[]),Fe=create(Re,jsonRpcResult(string()));if("error"in Fe)throw new SolanaJSONRPCError(Fe.error,"failed to get genesis hash");return Fe.result}async getBlock(Re,Fe){const{commitment:qe,config:We}=extractCommitmentFromConfig(Fe),Ze=this._buildArgsAtLeastConfirmed([Re],qe,void 0,We),Xe=await this._rpcRequest("getBlock",Ze),Je=create(Xe,GetBlockRpcResult);if("error"in Je)throw new SolanaJSONRPCError(Je.error,"failed to get confirmed block");const tr=Je.result;return tr&&{...tr,transactions:tr.transactions.map(({transaction:er,meta:ir,version:ur})=>({meta:ir,transaction:{...er,message:versionedMessageFromResponse(ur,er.message)},version:ur}))}}async getParsedBlock(Re,Fe){const{commitment:qe,config:We}=extractCommitmentFromConfig(Fe),Ze=this._buildArgsAtLeastConfirmed([Re],qe,"jsonParsed",We),Xe=await this._rpcRequest("getBlock",Ze),Je=create(Xe,GetParsedBlockRpcResult);if("error"in Je)throw new SolanaJSONRPCError(Je.error,"failed to get block");return Je.result}async getBlockHeight(Re){const{commitment:Fe,config:qe}=extractCommitmentFromConfig(Re),We=this._buildArgs([],Fe,void 0,qe),Ze=await this._rpcRequest("getBlockHeight",We),Xe=create(Ze,jsonRpcResult(number()));if("error"in Xe)throw new SolanaJSONRPCError(Xe.error,"failed to get block height information");return Xe.result}async getBlockProduction(Re){let Fe,qe;if(typeof Re=="string")qe=Re;else if(Re){const{commitment:Je,...tr}=Re;qe=Je,Fe=tr}const We=this._buildArgs([],qe,"base64",Fe),Ze=await this._rpcRequest("getBlockProduction",We),Xe=create(Ze,BlockProductionResponseStruct);if("error"in Xe)throw new SolanaJSONRPCError(Xe.error,"failed to get block production information");return Xe.result}async getTransaction(Re,Fe){const{commitment:qe,config:We}=extractCommitmentFromConfig(Fe),Ze=this._buildArgsAtLeastConfirmed([Re],qe,void 0,We),Xe=await this._rpcRequest("getTransaction",Ze),Je=create(Xe,GetTransactionRpcResult);if("error"in Je)throw new SolanaJSONRPCError(Je.error,"failed to get transaction");const tr=Je.result;return tr&&{...tr,transaction:{...tr.transaction,message:versionedMessageFromResponse(tr.version,tr.transaction.message)}}}async getParsedTransaction(Re,Fe){const{commitment:qe,config:We}=extractCommitmentFromConfig(Fe),Ze=this._buildArgsAtLeastConfirmed([Re],qe,"jsonParsed",We),Xe=await this._rpcRequest("getTransaction",Ze),Je=create(Xe,GetParsedTransactionRpcResult);if("error"in Je)throw new SolanaJSONRPCError(Je.error,"failed to get transaction");return Je.result}async getParsedTransactions(Re,Fe){const{commitment:qe,config:We}=extractCommitmentFromConfig(Fe),Ze=Re.map(tr=>({methodName:"getTransaction",args:this._buildArgsAtLeastConfirmed([tr],qe,"jsonParsed",We)}));return(await this._rpcBatchRequest(Ze)).map(tr=>{const er=create(tr,GetParsedTransactionRpcResult);if("error"in er)throw new SolanaJSONRPCError(er.error,"failed to get transactions");return er.result})}async getTransactions(Re,Fe){const{commitment:qe,config:We}=extractCommitmentFromConfig(Fe),Ze=Re.map(tr=>({methodName:"getTransaction",args:this._buildArgsAtLeastConfirmed([tr],qe,void 0,We)}));return(await this._rpcBatchRequest(Ze)).map(tr=>{const er=create(tr,GetTransactionRpcResult);if("error"in er)throw new SolanaJSONRPCError(er.error,"failed to get transactions");const ir=er.result;return ir&&{...ir,transaction:{...ir.transaction,message:versionedMessageFromResponse(ir.version,ir.transaction.message)}}})}async getConfirmedBlock(Re,Fe){const qe=this._buildArgsAtLeastConfirmed([Re],Fe),We=await this._rpcRequest("getConfirmedBlock",qe),Ze=create(We,GetConfirmedBlockRpcResult);if("error"in Ze)throw new SolanaJSONRPCError(Ze.error,"failed to get confirmed block");const Xe=Ze.result;if(!Xe)throw new Error("Confirmed block "+Re+" not found");const Je={...Xe,transactions:Xe.transactions.map(({transaction:tr,meta:er})=>{const ir=new Message(tr.message);return{meta:er,transaction:{...tr,message:ir}}})};return{...Je,transactions:Je.transactions.map(({transaction:tr,meta:er})=>({meta:er,transaction:Transaction.populate(tr.message,tr.signatures)}))}}async getBlocks(Re,Fe,qe){const We=this._buildArgsAtLeastConfirmed(Fe!==void 0?[Re,Fe]:[Re],qe),Ze=await this._rpcRequest("getBlocks",We),Xe=create(Ze,jsonRpcResult(array(number())));if("error"in Xe)throw new SolanaJSONRPCError(Xe.error,"failed to get blocks");return Xe.result}async getBlockSignatures(Re,Fe){const qe=this._buildArgsAtLeastConfirmed([Re],Fe,void 0,{transactionDetails:"signatures",rewards:!1}),We=await this._rpcRequest("getBlock",qe),Ze=create(We,GetBlockSignaturesRpcResult);if("error"in Ze)throw new SolanaJSONRPCError(Ze.error,"failed to get block");const Xe=Ze.result;if(!Xe)throw new Error("Block "+Re+" not found");return Xe}async getConfirmedBlockSignatures(Re,Fe){const qe=this._buildArgsAtLeastConfirmed([Re],Fe,void 0,{transactionDetails:"signatures",rewards:!1}),We=await this._rpcRequest("getConfirmedBlock",qe),Ze=create(We,GetBlockSignaturesRpcResult);if("error"in Ze)throw new SolanaJSONRPCError(Ze.error,"failed to get confirmed block");const Xe=Ze.result;if(!Xe)throw new Error("Confirmed block "+Re+" not found");return Xe}async getConfirmedTransaction(Re,Fe){const qe=this._buildArgsAtLeastConfirmed([Re],Fe),We=await this._rpcRequest("getConfirmedTransaction",qe),Ze=create(We,GetTransactionRpcResult);if("error"in Ze)throw new SolanaJSONRPCError(Ze.error,"failed to get transaction");const Xe=Ze.result;if(!Xe)return Xe;const Je=new Message(Xe.transaction.message),tr=Xe.transaction.signatures;return{...Xe,transaction:Transaction.populate(Je,tr)}}async getParsedConfirmedTransaction(Re,Fe){const qe=this._buildArgsAtLeastConfirmed([Re],Fe,"jsonParsed"),We=await this._rpcRequest("getConfirmedTransaction",qe),Ze=create(We,GetParsedTransactionRpcResult);if("error"in Ze)throw new SolanaJSONRPCError(Ze.error,"failed to get confirmed transaction");return Ze.result}async getParsedConfirmedTransactions(Re,Fe){const qe=Re.map(Xe=>({methodName:"getConfirmedTransaction",args:this._buildArgsAtLeastConfirmed([Xe],Fe,"jsonParsed")}));return(await this._rpcBatchRequest(qe)).map(Xe=>{const Je=create(Xe,GetParsedTransactionRpcResult);if("error"in Je)throw new SolanaJSONRPCError(Je.error,"failed to get confirmed transactions");return Je.result})}async getConfirmedSignaturesForAddress(Re,Fe,qe){let We={},Ze=await this.getFirstAvailableBlock();for(;!("until"in We)&&(Fe--,!(Fe<=0||Fe<Ze));)try{const tr=await this.getConfirmedBlockSignatures(Fe,"finalized");tr.signatures.length>0&&(We.until=tr.signatures[tr.signatures.length-1].toString())}catch(tr){if(tr instanceof Error&&tr.message.includes("skipped"))continue;throw tr}let Xe=await this.getSlot("finalized");for(;!("before"in We)&&(qe++,!(qe>Xe));)try{const tr=await this.getConfirmedBlockSignatures(qe);tr.signatures.length>0&&(We.before=tr.signatures[tr.signatures.length-1].toString())}catch(tr){if(tr instanceof Error&&tr.message.includes("skipped"))continue;throw tr}return(await this.getConfirmedSignaturesForAddress2(Re,We)).map(tr=>tr.signature)}async getConfirmedSignaturesForAddress2(Re,Fe,qe){const We=this._buildArgsAtLeastConfirmed([Re.toBase58()],qe,void 0,Fe),Ze=await this._rpcRequest("getConfirmedSignaturesForAddress2",We),Xe=create(Ze,GetConfirmedSignaturesForAddress2RpcResult);if("error"in Xe)throw new SolanaJSONRPCError(Xe.error,"failed to get confirmed signatures for address");return Xe.result}async getSignaturesForAddress(Re,Fe,qe){const We=this._buildArgsAtLeastConfirmed([Re.toBase58()],qe,void 0,Fe),Ze=await this._rpcRequest("getSignaturesForAddress",We),Xe=create(Ze,GetSignaturesForAddressRpcResult);if("error"in Xe)throw new SolanaJSONRPCError(Xe.error,"failed to get signatures for address");return Xe.result}async getAddressLookupTable(Re,Fe){const{context:qe,value:We}=await this.getAccountInfoAndContext(Re,Fe);let Ze=null;return We!==null&&(Ze=new AddressLookupTableAccount({key:Re,state:AddressLookupTableAccount.deserialize(We.data)})),{context:qe,value:Ze}}async getNonceAndContext(Re,Fe){const{context:qe,value:We}=await this.getAccountInfoAndContext(Re,Fe);let Ze=null;return We!==null&&(Ze=NonceAccount.fromAccountData(We.data)),{context:qe,value:Ze}}async getNonce(Re,Fe){return await this.getNonceAndContext(Re,Fe).then(qe=>qe.value).catch(qe=>{throw new Error("failed to get nonce for account "+Re.toBase58()+": "+qe)})}async requestAirdrop(Re,Fe){const qe=await this._rpcRequest("requestAirdrop",[Re.toBase58(),Fe]),We=create(qe,RequestAirdropRpcResult);if("error"in We)throw new SolanaJSONRPCError(We.error,`airdrop to ${Re.toBase58()} failed`);return We.result}async _blockhashWithExpiryBlockHeight(Re){if(!Re){for(;this._pollingBlockhash;)await sleep(100);const qe=Date.now()-this._blockhashInfo.lastFetch>=BLOCKHASH_CACHE_TIMEOUT_MS;if(this._blockhashInfo.latestBlockhash!==null&&!qe)return this._blockhashInfo.latestBlockhash}return await this._pollNewBlockhash()}async _pollNewBlockhash(){this._pollingBlockhash=!0;try{const Re=Date.now(),Fe=this._blockhashInfo.latestBlockhash,qe=Fe?Fe.blockhash:null;for(let We=0;We<50;We++){const Ze=await this.getLatestBlockhash("finalized");if(qe!==Ze.blockhash)return this._blockhashInfo={latestBlockhash:Ze,lastFetch:Date.now(),transactionSignatures:[],simulatedSignatures:[]},Ze;await sleep(MS_PER_SLOT/2)}throw new Error(`Unable to obtain a new blockhash after ${Date.now()-Re}ms`)}finally{this._pollingBlockhash=!1}}async getStakeMinimumDelegation(Re){const{commitment:Fe,config:qe}=extractCommitmentFromConfig(Re),We=this._buildArgs([],Fe,"base64",qe),Ze=await this._rpcRequest("getStakeMinimumDelegation",We),Xe=create(Ze,jsonRpcResultAndContext(number()));if("error"in Xe)throw new SolanaJSONRPCError(Xe.error,"failed to get stake minimum delegation");return Xe.result}async simulateTransaction(Re,Fe,qe){if("message"in Re){const mr=Re.serialize(),wr=buffer.Buffer.from(mr).toString("base64");if(Array.isArray(Fe)||qe!==void 0)throw new Error("Invalid arguments");const Sr=Fe||{};Sr.encoding="base64","commitment"in Sr||(Sr.commitment=this.commitment);const Ar=[wr,Sr],vr=await this._rpcRequest("simulateTransaction",Ar),Ir=create(vr,SimulatedTransactionResponseStruct);if("error"in Ir)throw new Error("failed to simulate transaction: "+Ir.error.message);return Ir.result}let We;if(Re instanceof Transaction){let yr=Re;We=new Transaction,We.feePayer=yr.feePayer,We.instructions=Re.instructions,We.nonceInfo=yr.nonceInfo,We.signatures=yr.signatures}else We=Transaction.populate(Re),We._message=We._json=void 0;if(Fe!==void 0&&!Array.isArray(Fe))throw new Error("Invalid arguments");const Ze=Fe;if(We.nonceInfo&&Ze)We.sign(...Ze);else{let yr=this._disableBlockhashCaching;for(;;){const mr=await this._blockhashWithExpiryBlockHeight(yr);if(We.lastValidBlockHeight=mr.lastValidBlockHeight,We.recentBlockhash=mr.blockhash,!Ze)break;if(We.sign(...Ze),!We.signature)throw new Error("!signature");const wr=We.signature.toString("base64");if(!this._blockhashInfo.simulatedSignatures.includes(wr)&&!this._blockhashInfo.transactionSignatures.includes(wr)){this._blockhashInfo.simulatedSignatures.push(wr);break}else yr=!0}}const Xe=We._compile(),Je=Xe.serialize(),er=We._serialize(Je).toString("base64"),ir={encoding:"base64",commitment:this.commitment};if(qe){const yr=(Array.isArray(qe)?qe:Xe.nonProgramIds()).map(mr=>mr.toBase58());ir.accounts={encoding:"base64",addresses:yr}}Ze&&(ir.sigVerify=!0);const ur=[er,ir],fr=await this._rpcRequest("simulateTransaction",ur),ar=create(fr,SimulatedTransactionResponseStruct);if("error"in ar){let yr;if("data"in ar.error&&(yr=ar.error.data.logs,yr&&Array.isArray(yr))){const mr=`
    `,wr=mr+yr.join(mr);console.error(ar.error.message,wr)}throw new SendTransactionError("failed to simulate transaction: "+ar.error.message,yr)}return ar.result}async sendTransaction(Re,Fe,qe){if("version"in Re){if(Fe&&Array.isArray(Fe))throw new Error("Invalid arguments");const Xe=Re.serialize();return await this.sendRawTransaction(Xe,qe)}if(Fe===void 0||!Array.isArray(Fe))throw new Error("Invalid arguments");const We=Fe;if(Re.nonceInfo)Re.sign(...We);else{let Xe=this._disableBlockhashCaching;for(;;){const Je=await this._blockhashWithExpiryBlockHeight(Xe);if(Re.lastValidBlockHeight=Je.lastValidBlockHeight,Re.recentBlockhash=Je.blockhash,Re.sign(...We),!Re.signature)throw new Error("!signature");const tr=Re.signature.toString("base64");if(this._blockhashInfo.transactionSignatures.includes(tr))Xe=!0;else{this._blockhashInfo.transactionSignatures.push(tr);break}}}const Ze=Re.serialize();return await this.sendRawTransaction(Ze,qe)}async sendRawTransaction(Re,Fe){const qe=toBuffer(Re).toString("base64");return await this.sendEncodedTransaction(qe,Fe)}async sendEncodedTransaction(Re,Fe){const qe={encoding:"base64"},We=Fe&&Fe.skipPreflight,Ze=Fe&&Fe.preflightCommitment||this.commitment;Fe&&Fe.maxRetries!=null&&(qe.maxRetries=Fe.maxRetries),Fe&&Fe.minContextSlot!=null&&(qe.minContextSlot=Fe.minContextSlot),We&&(qe.skipPreflight=We),Ze&&(qe.preflightCommitment=Ze);const Xe=[Re,qe],Je=await this._rpcRequest("sendTransaction",Xe),tr=create(Je,SendTransactionRpcResult);if("error"in tr){let er;throw"data"in tr.error&&(er=tr.error.data.logs),new SendTransactionError("failed to send transaction: "+tr.error.message,er)}return tr.result}_wsOnOpen(){this._rpcWebSocketConnected=!0,this._rpcWebSocketHeartbeat=setInterval(()=>{this._rpcWebSocket.notify("ping").catch(()=>{})},5e3),this._updateSubscriptions()}_wsOnError(Re){this._rpcWebSocketConnected=!1,console.error("ws error:",Re.message)}_wsOnClose(Re){if(this._rpcWebSocketConnected=!1,this._rpcWebSocketGeneration=(this._rpcWebSocketGeneration+1)%Number.MAX_SAFE_INTEGER,this._rpcWebSocketIdleTimeout&&(clearTimeout(this._rpcWebSocketIdleTimeout),this._rpcWebSocketIdleTimeout=null),this._rpcWebSocketHeartbeat&&(clearInterval(this._rpcWebSocketHeartbeat),this._rpcWebSocketHeartbeat=null),Re===1e3){this._updateSubscriptions();return}this._subscriptionCallbacksByServerSubscriptionId={},Object.entries(this._subscriptionsByHash).forEach(([Fe,qe])=>{this._subscriptionsByHash[Fe]={...qe,state:"pending"}})}async _updateSubscriptions(){if(Object.keys(this._subscriptionsByHash).length===0){this._rpcWebSocketConnected&&(this._rpcWebSocketConnected=!1,this._rpcWebSocketIdleTimeout=setTimeout(()=>{this._rpcWebSocketIdleTimeout=null;try{this._rpcWebSocket.close()}catch(qe){qe instanceof Error&&console.log(`Error when closing socket connection: ${qe.message}`)}},500));return}if(this._rpcWebSocketIdleTimeout!==null&&(clearTimeout(this._rpcWebSocketIdleTimeout),this._rpcWebSocketIdleTimeout=null,this._rpcWebSocketConnected=!0),!this._rpcWebSocketConnected){this._rpcWebSocket.connect();return}const Re=this._rpcWebSocketGeneration,Fe=()=>Re===this._rpcWebSocketGeneration;await Promise.all(Object.keys(this._subscriptionsByHash).map(async qe=>{const We=this._subscriptionsByHash[qe];if(We!==void 0)switch(We.state){case"pending":case"unsubscribed":if(We.callbacks.size===0){delete this._subscriptionsByHash[qe],We.state==="unsubscribed"&&delete this._subscriptionCallbacksByServerSubscriptionId[We.serverSubscriptionId],await this._updateSubscriptions();return}await(async()=>{const{args:Ze,method:Xe}=We;try{this._subscriptionsByHash[qe]={...We,state:"subscribing"};const Je=await this._rpcWebSocket.call(Xe,Ze);this._subscriptionsByHash[qe]={...We,serverSubscriptionId:Je,state:"subscribed"},this._subscriptionCallbacksByServerSubscriptionId[Je]=We.callbacks,await this._updateSubscriptions()}catch(Je){if(Je instanceof Error&&console.error(`${Xe} error for argument`,Ze,Je.message),!Fe())return;this._subscriptionsByHash[qe]={...We,state:"pending"},await this._updateSubscriptions()}})();break;case"subscribed":We.callbacks.size===0&&await(async()=>{const{serverSubscriptionId:Ze,unsubscribeMethod:Xe}=We;if(this._subscriptionsAutoDisposedByRpc.has(Ze))this._subscriptionsAutoDisposedByRpc.delete(Ze);else{this._subscriptionsByHash[qe]={...We,state:"unsubscribing"};try{await this._rpcWebSocket.call(Xe,[Ze])}catch(Je){if(Je instanceof Error&&console.error(`${Xe} error:`,Je.message),!Fe())return;this._subscriptionsByHash[qe]={...We,state:"subscribed"},await this._updateSubscriptions();return}}this._subscriptionsByHash[qe]={...We,state:"unsubscribed"},await this._updateSubscriptions()})();break}}))}_handleServerNotification(Re,Fe){const qe=this._subscriptionCallbacksByServerSubscriptionId[Re];qe!==void 0&&qe.forEach(We=>{try{We(...Fe)}catch(Ze){console.error(Ze)}})}_wsOnAccountNotification(Re){const{result:Fe,subscription:qe}=create(Re,AccountNotificationResult);this._handleServerNotification(qe,[Fe.value,Fe.context])}_makeSubscription(Re,Fe){const qe=this._nextClientSubscriptionId++,We=fastStableStringify$1([Re.method,Fe]),Ze=this._subscriptionsByHash[We];return Ze===void 0?this._subscriptionsByHash[We]={...Re,args:Fe,callbacks:new Set([Re.callback]),state:"pending"}:Ze.callbacks.add(Re.callback),this._subscriptionDisposeFunctionsByClientSubscriptionId[qe]=async()=>{delete this._subscriptionDisposeFunctionsByClientSubscriptionId[qe];const Xe=this._subscriptionsByHash[We];assert(Xe!==void 0,`Could not find a \`Subscription\` when tearing down client subscription #${qe}`),Xe.callbacks.delete(Re.callback),await this._updateSubscriptions()},this._updateSubscriptions(),qe}onAccountChange(Re,Fe,qe){const We=this._buildArgs([Re.toBase58()],qe||this._commitment||"finalized","base64");return this._makeSubscription({callback:Fe,method:"accountSubscribe",unsubscribeMethod:"accountUnsubscribe"},We)}async removeAccountChangeListener(Re){await this._unsubscribeClientSubscription(Re,"account change")}_wsOnProgramAccountNotification(Re){const{result:Fe,subscription:qe}=create(Re,ProgramAccountNotificationResult);this._handleServerNotification(qe,[{accountId:Fe.value.pubkey,accountInfo:Fe.value.account},Fe.context])}onProgramAccountChange(Re,Fe,qe,We){const Ze=this._buildArgs([Re.toBase58()],qe||this._commitment||"finalized","base64",We?{filters:We}:void 0);return this._makeSubscription({callback:Fe,method:"programSubscribe",unsubscribeMethod:"programUnsubscribe"},Ze)}async removeProgramAccountChangeListener(Re){await this._unsubscribeClientSubscription(Re,"program account change")}onLogs(Re,Fe,qe){const We=this._buildArgs([typeof Re=="object"?{mentions:[Re.toString()]}:Re],qe||this._commitment||"finalized");return this._makeSubscription({callback:Fe,method:"logsSubscribe",unsubscribeMethod:"logsUnsubscribe"},We)}async removeOnLogsListener(Re){await this._unsubscribeClientSubscription(Re,"logs")}_wsOnLogsNotification(Re){const{result:Fe,subscription:qe}=create(Re,LogsNotificationResult);this._handleServerNotification(qe,[Fe.value,Fe.context])}_wsOnSlotNotification(Re){const{result:Fe,subscription:qe}=create(Re,SlotNotificationResult);this._handleServerNotification(qe,[Fe])}onSlotChange(Re){return this._makeSubscription({callback:Re,method:"slotSubscribe",unsubscribeMethod:"slotUnsubscribe"},[])}async removeSlotChangeListener(Re){await this._unsubscribeClientSubscription(Re,"slot change")}_wsOnSlotUpdatesNotification(Re){const{result:Fe,subscription:qe}=create(Re,SlotUpdateNotificationResult);this._handleServerNotification(qe,[Fe])}onSlotUpdate(Re){return this._makeSubscription({callback:Re,method:"slotsUpdatesSubscribe",unsubscribeMethod:"slotsUpdatesUnsubscribe"},[])}async removeSlotUpdateListener(Re){await this._unsubscribeClientSubscription(Re,"slot update")}async _unsubscribeClientSubscription(Re,Fe){const qe=this._subscriptionDisposeFunctionsByClientSubscriptionId[Re];qe?await qe():console.warn(`Ignored unsubscribe request because an active subscription with id \`${Re}\` for '${Fe}' events could not be found.`)}_buildArgs(Re,Fe,qe,We){const Ze=Fe||this._commitment;if(Ze||qe||We){let Xe={};qe&&(Xe.encoding=qe),Ze&&(Xe.commitment=Ze),We&&(Xe=Object.assign(Xe,We)),Re.push(Xe)}return Re}_buildArgsAtLeastConfirmed(Re,Fe,qe,We){const Ze=Fe||this._commitment;if(Ze&&!["confirmed","finalized"].includes(Ze))throw new Error("Using Connection with default commitment: `"+this._commitment+"`, but method requires at least `confirmed`");return this._buildArgs(Re,Fe,qe,We)}_wsOnSignatureNotification(Re){const{result:Fe,subscription:qe}=create(Re,SignatureNotificationResult);Fe.value!=="receivedSignature"&&this._subscriptionsAutoDisposedByRpc.add(qe),this._handleServerNotification(qe,Fe.value==="receivedSignature"?[{type:"received"},Fe.context]:[{type:"status",result:Fe.value},Fe.context])}onSignature(Re,Fe,qe){const We=this._buildArgs([Re],qe||this._commitment||"finalized"),Ze=this._makeSubscription({callback:(Xe,Je)=>{if(Xe.type==="status"){Fe(Xe.result,Je);try{this.removeSignatureListener(Ze)}catch{}}},method:"signatureSubscribe",unsubscribeMethod:"signatureUnsubscribe"},We);return Ze}onSignatureWithOptions(Re,Fe,qe){const{commitment:We,...Ze}={...qe,commitment:qe&&qe.commitment||this._commitment||"finalized"},Xe=this._buildArgs([Re],We,void 0,Ze),Je=this._makeSubscription({callback:(tr,er)=>{Fe(tr,er);try{this.removeSignatureListener(Je)}catch{}},method:"signatureSubscribe",unsubscribeMethod:"signatureUnsubscribe"},Xe);return Je}async removeSignatureListener(Re){await this._unsubscribeClientSubscription(Re,"signature result")}_wsOnRootNotification(Re){const{result:Fe,subscription:qe}=create(Re,RootNotificationResult);this._handleServerNotification(qe,[Fe])}onRootChange(Re){return this._makeSubscription({callback:Re,method:"rootSubscribe",unsubscribeMethod:"rootUnsubscribe"},[])}async removeRootChangeListener(Re){await this._unsubscribeClientSubscription(Re,"root change")}}class Keypair{constructor(Re){this._keypair=void 0,this._keypair=Re!=null?Re:generateKeypair()}static generate(){return new Keypair(generateKeypair())}static fromSecretKey(Re,Fe){if(Re.byteLength!==64)throw new Error("bad secret key size");const qe=Re.slice(32,64);if(!Fe||!Fe.skipValidation){const We=Re.slice(0,32),Ze=getPublicKey(We);for(let Xe=0;Xe<32;Xe++)if(qe[Xe]!==Ze[Xe])throw new Error("provided secretKey is invalid")}return new Keypair({publicKey:qe,secretKey:Re})}static fromSeed(Re){const Fe=getPublicKey(Re),qe=new Uint8Array(64);return qe.set(Re),qe.set(Fe,32),new Keypair({publicKey:Fe,secretKey:qe})}get publicKey(){return new PublicKey(this._keypair.publicKey)}get secretKey(){return new Uint8Array(this._keypair.secretKey)}}const LOOKUP_TABLE_INSTRUCTION_LAYOUTS=Object.freeze({CreateLookupTable:{index:0,layout:struct([u32("instruction"),u64("recentSlot"),u8("bumpSeed")])},FreezeLookupTable:{index:1,layout:struct([u32("instruction")])},ExtendLookupTable:{index:2,layout:struct([u32("instruction"),u64(),seq(publicKey(),offset(u32(),-8),"addresses")])},DeactivateLookupTable:{index:3,layout:struct([u32("instruction")])},CloseLookupTable:{index:4,layout:struct([u32("instruction")])}});class AddressLookupTableInstruction{constructor(){}static decodeInstructionType(Re){this.checkProgramId(Re.programId);const qe=u32("instruction").decode(Re.data);let We;for(const[Ze,Xe]of Object.entries(LOOKUP_TABLE_INSTRUCTION_LAYOUTS))if(Xe.index==qe){We=Ze;break}if(!We)throw new Error("Invalid Instruction. Should be a LookupTable Instruction");return We}static decodeCreateLookupTable(Re){this.checkProgramId(Re.programId),this.checkKeysLength(Re.keys,4);const{recentSlot:Fe}=decodeData$1(LOOKUP_TABLE_INSTRUCTION_LAYOUTS.CreateLookupTable,Re.data);return{authority:Re.keys[1].pubkey,payer:Re.keys[2].pubkey,recentSlot:Number(Fe)}}static decodeExtendLookupTable(Re){if(this.checkProgramId(Re.programId),Re.keys.length<2)throw new Error(`invalid instruction; found ${Re.keys.length} keys, expected at least 2`);const{addresses:Fe}=decodeData$1(LOOKUP_TABLE_INSTRUCTION_LAYOUTS.ExtendLookupTable,Re.data);return{lookupTable:Re.keys[0].pubkey,authority:Re.keys[1].pubkey,payer:Re.keys.length>2?Re.keys[2].pubkey:void 0,addresses:Fe.map(qe=>new PublicKey(qe))}}static decodeCloseLookupTable(Re){return this.checkProgramId(Re.programId),this.checkKeysLength(Re.keys,3),{lookupTable:Re.keys[0].pubkey,authority:Re.keys[1].pubkey,recipient:Re.keys[2].pubkey}}static decodeFreezeLookupTable(Re){return this.checkProgramId(Re.programId),this.checkKeysLength(Re.keys,2),{lookupTable:Re.keys[0].pubkey,authority:Re.keys[1].pubkey}}static decodeDeactivateLookupTable(Re){return this.checkProgramId(Re.programId),this.checkKeysLength(Re.keys,2),{lookupTable:Re.keys[0].pubkey,authority:Re.keys[1].pubkey}}static checkProgramId(Re){if(!Re.equals(AddressLookupTableProgram.programId))throw new Error("invalid instruction; programId is not AddressLookupTable Program")}static checkKeysLength(Re,Fe){if(Re.length<Fe)throw new Error(`invalid instruction; found ${Re.length} keys, expected at least ${Fe}`)}}class AddressLookupTableProgram{constructor(){}static createLookupTable(Re){const[Fe,qe]=PublicKey.findProgramAddressSync([Re.authority.toBuffer(),toBufferLE_1(BigInt(Re.recentSlot),8)],this.programId),We=LOOKUP_TABLE_INSTRUCTION_LAYOUTS.CreateLookupTable,Ze=encodeData(We,{recentSlot:BigInt(Re.recentSlot),bumpSeed:qe}),Xe=[{pubkey:Fe,isSigner:!1,isWritable:!0},{pubkey:Re.authority,isSigner:!0,isWritable:!1},{pubkey:Re.payer,isSigner:!0,isWritable:!0},{pubkey:SystemProgram.programId,isSigner:!1,isWritable:!1}];return[new TransactionInstruction({programId:this.programId,keys:Xe,data:Ze}),Fe]}static freezeLookupTable(Re){const Fe=LOOKUP_TABLE_INSTRUCTION_LAYOUTS.FreezeLookupTable,qe=encodeData(Fe),We=[{pubkey:Re.lookupTable,isSigner:!1,isWritable:!0},{pubkey:Re.authority,isSigner:!0,isWritable:!1}];return new TransactionInstruction({programId:this.programId,keys:We,data:qe})}static extendLookupTable(Re){const Fe=LOOKUP_TABLE_INSTRUCTION_LAYOUTS.ExtendLookupTable,qe=encodeData(Fe,{addresses:Re.addresses.map(Ze=>Ze.toBytes())}),We=[{pubkey:Re.lookupTable,isSigner:!1,isWritable:!0},{pubkey:Re.authority,isSigner:!0,isWritable:!1}];return Re.payer&&We.push({pubkey:Re.payer,isSigner:!0,isWritable:!0},{pubkey:SystemProgram.programId,isSigner:!1,isWritable:!1}),new TransactionInstruction({programId:this.programId,keys:We,data:qe})}static deactivateLookupTable(Re){const Fe=LOOKUP_TABLE_INSTRUCTION_LAYOUTS.DeactivateLookupTable,qe=encodeData(Fe),We=[{pubkey:Re.lookupTable,isSigner:!1,isWritable:!0},{pubkey:Re.authority,isSigner:!0,isWritable:!1}];return new TransactionInstruction({programId:this.programId,keys:We,data:qe})}static closeLookupTable(Re){const Fe=LOOKUP_TABLE_INSTRUCTION_LAYOUTS.CloseLookupTable,qe=encodeData(Fe),We=[{pubkey:Re.lookupTable,isSigner:!1,isWritable:!0},{pubkey:Re.authority,isSigner:!0,isWritable:!1},{pubkey:Re.recipient,isSigner:!1,isWritable:!0}];return new TransactionInstruction({programId:this.programId,keys:We,data:qe})}}AddressLookupTableProgram.programId=new PublicKey("AddressLookupTab1e1111111111111111111111111");class ComputeBudgetInstruction{constructor(){}static decodeInstructionType(Re){this.checkProgramId(Re.programId);const qe=u8("instruction").decode(Re.data);let We;for(const[Ze,Xe]of Object.entries(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS))if(Xe.index==qe){We=Ze;break}if(!We)throw new Error("Instruction type incorrect; not a ComputeBudgetInstruction");return We}static decodeRequestUnits(Re){this.checkProgramId(Re.programId);const{units:Fe,additionalFee:qe}=decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestUnits,Re.data);return{units:Fe,additionalFee:qe}}static decodeRequestHeapFrame(Re){this.checkProgramId(Re.programId);const{bytes:Fe}=decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestHeapFrame,Re.data);return{bytes:Fe}}static decodeSetComputeUnitLimit(Re){this.checkProgramId(Re.programId);const{units:Fe}=decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitLimit,Re.data);return{units:Fe}}static decodeSetComputeUnitPrice(Re){this.checkProgramId(Re.programId);const{microLamports:Fe}=decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitPrice,Re.data);return{microLamports:Fe}}static checkProgramId(Re){if(!Re.equals(ComputeBudgetProgram.programId))throw new Error("invalid instruction; programId is not ComputeBudgetProgram")}}const COMPUTE_BUDGET_INSTRUCTION_LAYOUTS=Object.freeze({RequestUnits:{index:0,layout:struct([u8("instruction"),u32("units"),u32("additionalFee")])},RequestHeapFrame:{index:1,layout:struct([u8("instruction"),u32("bytes")])},SetComputeUnitLimit:{index:2,layout:struct([u8("instruction"),u32("units")])},SetComputeUnitPrice:{index:3,layout:struct([u8("instruction"),u64("microLamports")])}});class ComputeBudgetProgram{constructor(){}static requestUnits(Re){const Fe=COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestUnits,qe=encodeData(Fe,Re);return new TransactionInstruction({keys:[],programId:this.programId,data:qe})}static requestHeapFrame(Re){const Fe=COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestHeapFrame,qe=encodeData(Fe,Re);return new TransactionInstruction({keys:[],programId:this.programId,data:qe})}static setComputeUnitLimit(Re){const Fe=COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitLimit,qe=encodeData(Fe,Re);return new TransactionInstruction({keys:[],programId:this.programId,data:qe})}static setComputeUnitPrice(Re){const Fe=COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitPrice,qe=encodeData(Fe,{microLamports:BigInt(Re.microLamports)});return new TransactionInstruction({keys:[],programId:this.programId,data:qe})}}ComputeBudgetProgram.programId=new PublicKey("ComputeBudget111111111111111111111111111111");const PRIVATE_KEY_BYTES$1=64,PUBLIC_KEY_BYTES$1=32,SIGNATURE_BYTES=64,ED25519_INSTRUCTION_LAYOUT=struct([u8("numSignatures"),u8("padding"),u16("signatureOffset"),u16("signatureInstructionIndex"),u16("publicKeyOffset"),u16("publicKeyInstructionIndex"),u16("messageDataOffset"),u16("messageDataSize"),u16("messageInstructionIndex")]);class Ed25519Program{constructor(){}static createInstructionWithPublicKey(Re){const{publicKey:Fe,message:qe,signature:We,instructionIndex:Ze}=Re;assert(Fe.length===PUBLIC_KEY_BYTES$1,`Public Key must be ${PUBLIC_KEY_BYTES$1} bytes but received ${Fe.length} bytes`),assert(We.length===SIGNATURE_BYTES,`Signature must be ${SIGNATURE_BYTES} bytes but received ${We.length} bytes`);const Xe=ED25519_INSTRUCTION_LAYOUT.span,Je=Xe+Fe.length,tr=Je+We.length,er=1,ir=buffer.Buffer.alloc(tr+qe.length),ur=Ze==null?65535:Ze;return ED25519_INSTRUCTION_LAYOUT.encode({numSignatures:er,padding:0,signatureOffset:Je,signatureInstructionIndex:ur,publicKeyOffset:Xe,publicKeyInstructionIndex:ur,messageDataOffset:tr,messageDataSize:qe.length,messageInstructionIndex:ur},ir),ir.fill(Fe,Xe),ir.fill(We,Je),ir.fill(qe,tr),new TransactionInstruction({keys:[],programId:Ed25519Program.programId,data:ir})}static createInstructionWithPrivateKey(Re){const{privateKey:Fe,message:qe,instructionIndex:We}=Re;assert(Fe.length===PRIVATE_KEY_BYTES$1,`Private key must be ${PRIVATE_KEY_BYTES$1} bytes but received ${Fe.length} bytes`);try{const Ze=Keypair.fromSecretKey(Fe),Xe=Ze.publicKey.toBytes(),Je=sign(qe,Ze.secretKey);return this.createInstructionWithPublicKey({publicKey:Xe,message:qe,signature:Je,instructionIndex:We})}catch(Ze){throw new Error(`Error creating instruction; ${Ze}`)}}}Ed25519Program.programId=new PublicKey("Ed25519SigVerify111111111111111111111111111");utils.hmacSha256Sync=(Ke,...Re)=>{const Fe=hmac.create(sha256$1,Ke);return Re.forEach(qe=>Fe.update(qe)),Fe.digest()};const ecdsaSign=(Ke,Re)=>signSync(Ke,Re,{der:!1,recovered:!0});utils.isValidPrivateKey;const publicKeyCreate=getPublicKey$1,PRIVATE_KEY_BYTES=32,ETHEREUM_ADDRESS_BYTES=20,PUBLIC_KEY_BYTES=64,SIGNATURE_OFFSETS_SERIALIZED_SIZE=11,SECP256K1_INSTRUCTION_LAYOUT=struct([u8("numSignatures"),u16("signatureOffset"),u8("signatureInstructionIndex"),u16("ethAddressOffset"),u8("ethAddressInstructionIndex"),u16("messageDataOffset"),u16("messageDataSize"),u8("messageInstructionIndex"),blob(20,"ethAddress"),blob(64,"signature"),u8("recoveryId")]);class Secp256k1Program{constructor(){}static publicKeyToEthAddress(Re){assert(Re.length===PUBLIC_KEY_BYTES,`Public key must be ${PUBLIC_KEY_BYTES} bytes but received ${Re.length} bytes`);try{return buffer.Buffer.from(keccak_256(toBuffer(Re))).slice(-ETHEREUM_ADDRESS_BYTES)}catch(Fe){throw new Error(`Error constructing Ethereum address: ${Fe}`)}}static createInstructionWithPublicKey(Re){const{publicKey:Fe,message:qe,signature:We,recoveryId:Ze,instructionIndex:Xe}=Re;return Secp256k1Program.createInstructionWithEthAddress({ethAddress:Secp256k1Program.publicKeyToEthAddress(Fe),message:qe,signature:We,recoveryId:Ze,instructionIndex:Xe})}static createInstructionWithEthAddress(Re){const{ethAddress:Fe,message:qe,signature:We,recoveryId:Ze,instructionIndex:Xe=0}=Re;let Je;typeof Fe=="string"?Fe.startsWith("0x")?Je=buffer.Buffer.from(Fe.substr(2),"hex"):Je=buffer.Buffer.from(Fe,"hex"):Je=Fe,assert(Je.length===ETHEREUM_ADDRESS_BYTES,`Address must be ${ETHEREUM_ADDRESS_BYTES} bytes but received ${Je.length} bytes`);const tr=1+SIGNATURE_OFFSETS_SERIALIZED_SIZE,er=tr,ir=tr+Je.length,ur=ir+We.length+1,fr=1,ar=buffer.Buffer.alloc(SECP256K1_INSTRUCTION_LAYOUT.span+qe.length);return SECP256K1_INSTRUCTION_LAYOUT.encode({numSignatures:fr,signatureOffset:ir,signatureInstructionIndex:Xe,ethAddressOffset:er,ethAddressInstructionIndex:Xe,messageDataOffset:ur,messageDataSize:qe.length,messageInstructionIndex:Xe,signature:toBuffer(We),ethAddress:toBuffer(Je),recoveryId:Ze},ar),ar.fill(toBuffer(qe),SECP256K1_INSTRUCTION_LAYOUT.span),new TransactionInstruction({keys:[],programId:Secp256k1Program.programId,data:ar})}static createInstructionWithPrivateKey(Re){const{privateKey:Fe,message:qe,instructionIndex:We}=Re;assert(Fe.length===PRIVATE_KEY_BYTES,`Private key must be ${PRIVATE_KEY_BYTES} bytes but received ${Fe.length} bytes`);try{const Ze=toBuffer(Fe),Xe=publicKeyCreate(Ze,!1).slice(1),Je=buffer.Buffer.from(keccak_256(toBuffer(qe))),[tr,er]=ecdsaSign(Je,Ze);return this.createInstructionWithPublicKey({publicKey:Xe,message:qe,signature:tr,recoveryId:er,instructionIndex:We})}catch(Ze){throw new Error(`Error creating instruction; ${Ze}`)}}}Secp256k1Program.programId=new PublicKey("KeccakSecp256k11111111111111111111111111111");const STAKE_CONFIG_ID=new PublicKey("StakeConfig11111111111111111111111111111111");class Authorized{constructor(Re,Fe){this.staker=void 0,this.withdrawer=void 0,this.staker=Re,this.withdrawer=Fe}}class Lockup{constructor(Re,Fe,qe){this.unixTimestamp=void 0,this.epoch=void 0,this.custodian=void 0,this.unixTimestamp=Re,this.epoch=Fe,this.custodian=qe}}Lockup.default=new Lockup(0,0,PublicKey.default);class StakeInstruction{constructor(){}static decodeInstructionType(Re){this.checkProgramId(Re.programId);const qe=u32("instruction").decode(Re.data);let We;for(const[Ze,Xe]of Object.entries(STAKE_INSTRUCTION_LAYOUTS))if(Xe.index==qe){We=Ze;break}if(!We)throw new Error("Instruction type incorrect; not a StakeInstruction");return We}static decodeInitialize(Re){this.checkProgramId(Re.programId),this.checkKeyLength(Re.keys,2);const{authorized:Fe,lockup:qe}=decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Initialize,Re.data);return{stakePubkey:Re.keys[0].pubkey,authorized:new Authorized(new PublicKey(Fe.staker),new PublicKey(Fe.withdrawer)),lockup:new Lockup(qe.unixTimestamp,qe.epoch,new PublicKey(qe.custodian))}}static decodeDelegate(Re){return this.checkProgramId(Re.programId),this.checkKeyLength(Re.keys,6),decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Delegate,Re.data),{stakePubkey:Re.keys[0].pubkey,votePubkey:Re.keys[1].pubkey,authorizedPubkey:Re.keys[5].pubkey}}static decodeAuthorize(Re){this.checkProgramId(Re.programId),this.checkKeyLength(Re.keys,3);const{newAuthorized:Fe,stakeAuthorizationType:qe}=decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Authorize,Re.data),We={stakePubkey:Re.keys[0].pubkey,authorizedPubkey:Re.keys[2].pubkey,newAuthorizedPubkey:new PublicKey(Fe),stakeAuthorizationType:{index:qe}};return Re.keys.length>3&&(We.custodianPubkey=Re.keys[3].pubkey),We}static decodeAuthorizeWithSeed(Re){this.checkProgramId(Re.programId),this.checkKeyLength(Re.keys,2);const{newAuthorized:Fe,stakeAuthorizationType:qe,authoritySeed:We,authorityOwner:Ze}=decodeData$1(STAKE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed,Re.data),Xe={stakePubkey:Re.keys[0].pubkey,authorityBase:Re.keys[1].pubkey,authoritySeed:We,authorityOwner:new PublicKey(Ze),newAuthorizedPubkey:new PublicKey(Fe),stakeAuthorizationType:{index:qe}};return Re.keys.length>3&&(Xe.custodianPubkey=Re.keys[3].pubkey),Xe}static decodeSplit(Re){this.checkProgramId(Re.programId),this.checkKeyLength(Re.keys,3);const{lamports:Fe}=decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Split,Re.data);return{stakePubkey:Re.keys[0].pubkey,splitStakePubkey:Re.keys[1].pubkey,authorizedPubkey:Re.keys[2].pubkey,lamports:Fe}}static decodeMerge(Re){return this.checkProgramId(Re.programId),this.checkKeyLength(Re.keys,3),decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Merge,Re.data),{stakePubkey:Re.keys[0].pubkey,sourceStakePubKey:Re.keys[1].pubkey,authorizedPubkey:Re.keys[4].pubkey}}static decodeWithdraw(Re){this.checkProgramId(Re.programId),this.checkKeyLength(Re.keys,5);const{lamports:Fe}=decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Withdraw,Re.data),qe={stakePubkey:Re.keys[0].pubkey,toPubkey:Re.keys[1].pubkey,authorizedPubkey:Re.keys[4].pubkey,lamports:Fe};return Re.keys.length>5&&(qe.custodianPubkey=Re.keys[5].pubkey),qe}static decodeDeactivate(Re){return this.checkProgramId(Re.programId),this.checkKeyLength(Re.keys,3),decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Deactivate,Re.data),{stakePubkey:Re.keys[0].pubkey,authorizedPubkey:Re.keys[2].pubkey}}static checkProgramId(Re){if(!Re.equals(StakeProgram.programId))throw new Error("invalid instruction; programId is not StakeProgram")}static checkKeyLength(Re,Fe){if(Re.length<Fe)throw new Error(`invalid instruction; found ${Re.length} keys, expected at least ${Fe}`)}}const STAKE_INSTRUCTION_LAYOUTS=Object.freeze({Initialize:{index:0,layout:struct([u32("instruction"),authorized(),lockup()])},Authorize:{index:1,layout:struct([u32("instruction"),publicKey("newAuthorized"),u32("stakeAuthorizationType")])},Delegate:{index:2,layout:struct([u32("instruction")])},Split:{index:3,layout:struct([u32("instruction"),ns64("lamports")])},Withdraw:{index:4,layout:struct([u32("instruction"),ns64("lamports")])},Deactivate:{index:5,layout:struct([u32("instruction")])},Merge:{index:7,layout:struct([u32("instruction")])},AuthorizeWithSeed:{index:8,layout:struct([u32("instruction"),publicKey("newAuthorized"),u32("stakeAuthorizationType"),rustString("authoritySeed"),publicKey("authorityOwner")])}}),StakeAuthorizationLayout=Object.freeze({Staker:{index:0},Withdrawer:{index:1}});class StakeProgram{constructor(){}static initialize(Re){const{stakePubkey:Fe,authorized:qe,lockup:We}=Re,Ze=We||Lockup.default,Xe=STAKE_INSTRUCTION_LAYOUTS.Initialize,Je=encodeData(Xe,{authorized:{staker:toBuffer(qe.staker.toBuffer()),withdrawer:toBuffer(qe.withdrawer.toBuffer())},lockup:{unixTimestamp:Ze.unixTimestamp,epoch:Ze.epoch,custodian:toBuffer(Ze.custodian.toBuffer())}}),tr={keys:[{pubkey:Fe,isSigner:!1,isWritable:!0},{pubkey:SYSVAR_RENT_PUBKEY,isSigner:!1,isWritable:!1}],programId:this.programId,data:Je};return new TransactionInstruction(tr)}static createAccountWithSeed(Re){const Fe=new Transaction;Fe.add(SystemProgram.createAccountWithSeed({fromPubkey:Re.fromPubkey,newAccountPubkey:Re.stakePubkey,basePubkey:Re.basePubkey,seed:Re.seed,lamports:Re.lamports,space:this.space,programId:this.programId}));const{stakePubkey:qe,authorized:We,lockup:Ze}=Re;return Fe.add(this.initialize({stakePubkey:qe,authorized:We,lockup:Ze}))}static createAccount(Re){const Fe=new Transaction;Fe.add(SystemProgram.createAccount({fromPubkey:Re.fromPubkey,newAccountPubkey:Re.stakePubkey,lamports:Re.lamports,space:this.space,programId:this.programId}));const{stakePubkey:qe,authorized:We,lockup:Ze}=Re;return Fe.add(this.initialize({stakePubkey:qe,authorized:We,lockup:Ze}))}static delegate(Re){const{stakePubkey:Fe,authorizedPubkey:qe,votePubkey:We}=Re,Ze=STAKE_INSTRUCTION_LAYOUTS.Delegate,Xe=encodeData(Ze);return new Transaction().add({keys:[{pubkey:Fe,isSigner:!1,isWritable:!0},{pubkey:We,isSigner:!1,isWritable:!1},{pubkey:SYSVAR_CLOCK_PUBKEY,isSigner:!1,isWritable:!1},{pubkey:SYSVAR_STAKE_HISTORY_PUBKEY,isSigner:!1,isWritable:!1},{pubkey:STAKE_CONFIG_ID,isSigner:!1,isWritable:!1},{pubkey:qe,isSigner:!0,isWritable:!1}],programId:this.programId,data:Xe})}static authorize(Re){const{stakePubkey:Fe,authorizedPubkey:qe,newAuthorizedPubkey:We,stakeAuthorizationType:Ze,custodianPubkey:Xe}=Re,Je=STAKE_INSTRUCTION_LAYOUTS.Authorize,tr=encodeData(Je,{newAuthorized:toBuffer(We.toBuffer()),stakeAuthorizationType:Ze.index}),er=[{pubkey:Fe,isSigner:!1,isWritable:!0},{pubkey:SYSVAR_CLOCK_PUBKEY,isSigner:!1,isWritable:!0},{pubkey:qe,isSigner:!0,isWritable:!1}];return Xe&&er.push({pubkey:Xe,isSigner:!1,isWritable:!1}),new Transaction().add({keys:er,programId:this.programId,data:tr})}static authorizeWithSeed(Re){const{stakePubkey:Fe,authorityBase:qe,authoritySeed:We,authorityOwner:Ze,newAuthorizedPubkey:Xe,stakeAuthorizationType:Je,custodianPubkey:tr}=Re,er=STAKE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed,ir=encodeData(er,{newAuthorized:toBuffer(Xe.toBuffer()),stakeAuthorizationType:Je.index,authoritySeed:We,authorityOwner:toBuffer(Ze.toBuffer())}),ur=[{pubkey:Fe,isSigner:!1,isWritable:!0},{pubkey:qe,isSigner:!0,isWritable:!1},{pubkey:SYSVAR_CLOCK_PUBKEY,isSigner:!1,isWritable:!1}];return tr&&ur.push({pubkey:tr,isSigner:!1,isWritable:!1}),new Transaction().add({keys:ur,programId:this.programId,data:ir})}static splitInstruction(Re){const{stakePubkey:Fe,authorizedPubkey:qe,splitStakePubkey:We,lamports:Ze}=Re,Xe=STAKE_INSTRUCTION_LAYOUTS.Split,Je=encodeData(Xe,{lamports:Ze});return new TransactionInstruction({keys:[{pubkey:Fe,isSigner:!1,isWritable:!0},{pubkey:We,isSigner:!1,isWritable:!0},{pubkey:qe,isSigner:!0,isWritable:!1}],programId:this.programId,data:Je})}static split(Re){const Fe=new Transaction;return Fe.add(SystemProgram.createAccount({fromPubkey:Re.authorizedPubkey,newAccountPubkey:Re.splitStakePubkey,lamports:0,space:this.space,programId:this.programId})),Fe.add(this.splitInstruction(Re))}static splitWithSeed(Re){const{stakePubkey:Fe,authorizedPubkey:qe,splitStakePubkey:We,basePubkey:Ze,seed:Xe,lamports:Je}=Re,tr=new Transaction;return tr.add(SystemProgram.allocate({accountPubkey:We,basePubkey:Ze,seed:Xe,space:this.space,programId:this.programId})),tr.add(this.splitInstruction({stakePubkey:Fe,authorizedPubkey:qe,splitStakePubkey:We,lamports:Je}))}static merge(Re){const{stakePubkey:Fe,sourceStakePubKey:qe,authorizedPubkey:We}=Re,Ze=STAKE_INSTRUCTION_LAYOUTS.Merge,Xe=encodeData(Ze);return new Transaction().add({keys:[{pubkey:Fe,isSigner:!1,isWritable:!0},{pubkey:qe,isSigner:!1,isWritable:!0},{pubkey:SYSVAR_CLOCK_PUBKEY,isSigner:!1,isWritable:!1},{pubkey:SYSVAR_STAKE_HISTORY_PUBKEY,isSigner:!1,isWritable:!1},{pubkey:We,isSigner:!0,isWritable:!1}],programId:this.programId,data:Xe})}static withdraw(Re){const{stakePubkey:Fe,authorizedPubkey:qe,toPubkey:We,lamports:Ze,custodianPubkey:Xe}=Re,Je=STAKE_INSTRUCTION_LAYOUTS.Withdraw,tr=encodeData(Je,{lamports:Ze}),er=[{pubkey:Fe,isSigner:!1,isWritable:!0},{pubkey:We,isSigner:!1,isWritable:!0},{pubkey:SYSVAR_CLOCK_PUBKEY,isSigner:!1,isWritable:!1},{pubkey:SYSVAR_STAKE_HISTORY_PUBKEY,isSigner:!1,isWritable:!1},{pubkey:qe,isSigner:!0,isWritable:!1}];return Xe&&er.push({pubkey:Xe,isSigner:!1,isWritable:!1}),new Transaction().add({keys:er,programId:this.programId,data:tr})}static deactivate(Re){const{stakePubkey:Fe,authorizedPubkey:qe}=Re,We=STAKE_INSTRUCTION_LAYOUTS.Deactivate,Ze=encodeData(We);return new Transaction().add({keys:[{pubkey:Fe,isSigner:!1,isWritable:!0},{pubkey:SYSVAR_CLOCK_PUBKEY,isSigner:!1,isWritable:!1},{pubkey:qe,isSigner:!0,isWritable:!1}],programId:this.programId,data:Ze})}}StakeProgram.programId=new PublicKey("Stake11111111111111111111111111111111111111");StakeProgram.space=200;class VoteInit{constructor(Re,Fe,qe,We){this.nodePubkey=void 0,this.authorizedVoter=void 0,this.authorizedWithdrawer=void 0,this.commission=void 0,this.nodePubkey=Re,this.authorizedVoter=Fe,this.authorizedWithdrawer=qe,this.commission=We}}class VoteInstruction{constructor(){}static decodeInstructionType(Re){this.checkProgramId(Re.programId);const qe=u32("instruction").decode(Re.data);let We;for(const[Ze,Xe]of Object.entries(VOTE_INSTRUCTION_LAYOUTS))if(Xe.index==qe){We=Ze;break}if(!We)throw new Error("Instruction type incorrect; not a VoteInstruction");return We}static decodeInitializeAccount(Re){this.checkProgramId(Re.programId),this.checkKeyLength(Re.keys,4);const{voteInit:Fe}=decodeData$1(VOTE_INSTRUCTION_LAYOUTS.InitializeAccount,Re.data);return{votePubkey:Re.keys[0].pubkey,nodePubkey:Re.keys[3].pubkey,voteInit:new VoteInit(new PublicKey(Fe.nodePubkey),new PublicKey(Fe.authorizedVoter),new PublicKey(Fe.authorizedWithdrawer),Fe.commission)}}static decodeAuthorize(Re){this.checkProgramId(Re.programId),this.checkKeyLength(Re.keys,3);const{newAuthorized:Fe,voteAuthorizationType:qe}=decodeData$1(VOTE_INSTRUCTION_LAYOUTS.Authorize,Re.data);return{votePubkey:Re.keys[0].pubkey,authorizedPubkey:Re.keys[2].pubkey,newAuthorizedPubkey:new PublicKey(Fe),voteAuthorizationType:{index:qe}}}static decodeAuthorizeWithSeed(Re){this.checkProgramId(Re.programId),this.checkKeyLength(Re.keys,3);const{voteAuthorizeWithSeedArgs:{currentAuthorityDerivedKeyOwnerPubkey:Fe,currentAuthorityDerivedKeySeed:qe,newAuthorized:We,voteAuthorizationType:Ze}}=decodeData$1(VOTE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed,Re.data);return{currentAuthorityDerivedKeyBasePubkey:Re.keys[2].pubkey,currentAuthorityDerivedKeyOwnerPubkey:new PublicKey(Fe),currentAuthorityDerivedKeySeed:qe,newAuthorizedPubkey:new PublicKey(We),voteAuthorizationType:{index:Ze},votePubkey:Re.keys[0].pubkey}}static decodeWithdraw(Re){this.checkProgramId(Re.programId),this.checkKeyLength(Re.keys,3);const{lamports:Fe}=decodeData$1(VOTE_INSTRUCTION_LAYOUTS.Withdraw,Re.data);return{votePubkey:Re.keys[0].pubkey,authorizedWithdrawerPubkey:Re.keys[2].pubkey,lamports:Fe,toPubkey:Re.keys[1].pubkey}}static checkProgramId(Re){if(!Re.equals(VoteProgram.programId))throw new Error("invalid instruction; programId is not VoteProgram")}static checkKeyLength(Re,Fe){if(Re.length<Fe)throw new Error(`invalid instruction; found ${Re.length} keys, expected at least ${Fe}`)}}const VOTE_INSTRUCTION_LAYOUTS=Object.freeze({InitializeAccount:{index:0,layout:struct([u32("instruction"),voteInit()])},Authorize:{index:1,layout:struct([u32("instruction"),publicKey("newAuthorized"),u32("voteAuthorizationType")])},Withdraw:{index:3,layout:struct([u32("instruction"),ns64("lamports")])},AuthorizeWithSeed:{index:10,layout:struct([u32("instruction"),voteAuthorizeWithSeedArgs()])}}),VoteAuthorizationLayout=Object.freeze({Voter:{index:0},Withdrawer:{index:1}});class VoteProgram{constructor(){}static initializeAccount(Re){const{votePubkey:Fe,nodePubkey:qe,voteInit:We}=Re,Ze=VOTE_INSTRUCTION_LAYOUTS.InitializeAccount,Xe=encodeData(Ze,{voteInit:{nodePubkey:toBuffer(We.nodePubkey.toBuffer()),authorizedVoter:toBuffer(We.authorizedVoter.toBuffer()),authorizedWithdrawer:toBuffer(We.authorizedWithdrawer.toBuffer()),commission:We.commission}}),Je={keys:[{pubkey:Fe,isSigner:!1,isWritable:!0},{pubkey:SYSVAR_RENT_PUBKEY,isSigner:!1,isWritable:!1},{pubkey:SYSVAR_CLOCK_PUBKEY,isSigner:!1,isWritable:!1},{pubkey:qe,isSigner:!0,isWritable:!1}],programId:this.programId,data:Xe};return new TransactionInstruction(Je)}static createAccount(Re){const Fe=new Transaction;return Fe.add(SystemProgram.createAccount({fromPubkey:Re.fromPubkey,newAccountPubkey:Re.votePubkey,lamports:Re.lamports,space:this.space,programId:this.programId})),Fe.add(this.initializeAccount({votePubkey:Re.votePubkey,nodePubkey:Re.voteInit.nodePubkey,voteInit:Re.voteInit}))}static authorize(Re){const{votePubkey:Fe,authorizedPubkey:qe,newAuthorizedPubkey:We,voteAuthorizationType:Ze}=Re,Xe=VOTE_INSTRUCTION_LAYOUTS.Authorize,Je=encodeData(Xe,{newAuthorized:toBuffer(We.toBuffer()),voteAuthorizationType:Ze.index}),tr=[{pubkey:Fe,isSigner:!1,isWritable:!0},{pubkey:SYSVAR_CLOCK_PUBKEY,isSigner:!1,isWritable:!1},{pubkey:qe,isSigner:!0,isWritable:!1}];return new Transaction().add({keys:tr,programId:this.programId,data:Je})}static authorizeWithSeed(Re){const{currentAuthorityDerivedKeyBasePubkey:Fe,currentAuthorityDerivedKeyOwnerPubkey:qe,currentAuthorityDerivedKeySeed:We,newAuthorizedPubkey:Ze,voteAuthorizationType:Xe,votePubkey:Je}=Re,tr=VOTE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed,er=encodeData(tr,{voteAuthorizeWithSeedArgs:{currentAuthorityDerivedKeyOwnerPubkey:toBuffer(qe.toBuffer()),currentAuthorityDerivedKeySeed:We,newAuthorized:toBuffer(Ze.toBuffer()),voteAuthorizationType:Xe.index}}),ir=[{pubkey:Je,isSigner:!1,isWritable:!0},{pubkey:SYSVAR_CLOCK_PUBKEY,isSigner:!1,isWritable:!1},{pubkey:Fe,isSigner:!0,isWritable:!1}];return new Transaction().add({keys:ir,programId:this.programId,data:er})}static withdraw(Re){const{votePubkey:Fe,authorizedWithdrawerPubkey:qe,lamports:We,toPubkey:Ze}=Re,Xe=VOTE_INSTRUCTION_LAYOUTS.Withdraw,Je=encodeData(Xe,{lamports:We}),tr=[{pubkey:Fe,isSigner:!1,isWritable:!0},{pubkey:Ze,isSigner:!1,isWritable:!0},{pubkey:qe,isSigner:!0,isWritable:!1}];return new Transaction().add({keys:tr,programId:this.programId,data:Je})}static safeWithdraw(Re,Fe,qe){if(Re.lamports>Fe-qe)throw new Error("Withdraw will leave vote account with insuffcient funds.");return VoteProgram.withdraw(Re)}}VoteProgram.programId=new PublicKey("Vote111111111111111111111111111111111111111");VoteProgram.space=3731;const VALIDATOR_INFO_KEY=new PublicKey("Va1idator1nfo111111111111111111111111111111"),InfoString=type({name:string(),website:optional(string()),details:optional(string()),keybaseUsername:optional(string())});class ValidatorInfo{constructor(Re,Fe){this.key=void 0,this.info=void 0,this.key=Re,this.info=Fe}static fromConfigData(Re){let Fe=[...Re];if(decodeLength(Fe)!==2)return null;const We=[];for(let Ze=0;Ze<2;Ze++){const Xe=new PublicKey(Fe.slice(0,PUBLIC_KEY_LENGTH));Fe=Fe.slice(PUBLIC_KEY_LENGTH);const Je=Fe.slice(0,1)[0]===1;Fe=Fe.slice(1),We.push({publicKey:Xe,isSigner:Je})}if(We[0].publicKey.equals(VALIDATOR_INFO_KEY)&&We[1].isSigner){const Ze=rustString().decode(buffer.Buffer.from(Fe)),Xe=JSON.parse(Ze);return assert$1(Xe,InfoString),new ValidatorInfo(We[1].publicKey,Xe)}return null}}const VOTE_PROGRAM_ID=new PublicKey("Vote111111111111111111111111111111111111111"),VoteAccountLayout=struct([publicKey("nodePubkey"),publicKey("authorizedWithdrawer"),u8("commission"),nu64(),seq(struct([nu64("slot"),u32("confirmationCount")]),offset(u32(),-8),"votes"),u8("rootSlotValid"),nu64("rootSlot"),nu64(),seq(struct([nu64("epoch"),publicKey("authorizedVoter")]),offset(u32(),-8),"authorizedVoters"),struct([seq(struct([publicKey("authorizedPubkey"),nu64("epochOfLastAuthorizedSwitch"),nu64("targetEpoch")]),32,"buf"),nu64("idx"),u8("isEmpty")],"priorVoters"),nu64(),seq(struct([nu64("epoch"),nu64("credits"),nu64("prevCredits")]),offset(u32(),-8),"epochCredits"),struct([nu64("slot"),nu64("timestamp")],"lastTimestamp")]);class VoteAccount{constructor(Re){this.nodePubkey=void 0,this.authorizedWithdrawer=void 0,this.commission=void 0,this.rootSlot=void 0,this.votes=void 0,this.authorizedVoters=void 0,this.priorVoters=void 0,this.epochCredits=void 0,this.lastTimestamp=void 0,this.nodePubkey=Re.nodePubkey,this.authorizedWithdrawer=Re.authorizedWithdrawer,this.commission=Re.commission,this.rootSlot=Re.rootSlot,this.votes=Re.votes,this.authorizedVoters=Re.authorizedVoters,this.priorVoters=Re.priorVoters,this.epochCredits=Re.epochCredits,this.lastTimestamp=Re.lastTimestamp}static fromAccountData(Re){const qe=VoteAccountLayout.decode(toBuffer(Re),4);let We=qe.rootSlot;return qe.rootSlotValid||(We=null),new VoteAccount({nodePubkey:new PublicKey(qe.nodePubkey),authorizedWithdrawer:new PublicKey(qe.authorizedWithdrawer),commission:qe.commission,votes:qe.votes,rootSlot:We,authorizedVoters:qe.authorizedVoters.map(parseAuthorizedVoter),priorVoters:getPriorVoters(qe.priorVoters),epochCredits:qe.epochCredits,lastTimestamp:qe.lastTimestamp})}}function parseAuthorizedVoter({authorizedVoter:Ke,epoch:Re}){return{epoch:Re,authorizedVoter:new PublicKey(Ke)}}function parsePriorVoters({authorizedPubkey:Ke,epochOfLastAuthorizedSwitch:Re,targetEpoch:Fe}){return{authorizedPubkey:new PublicKey(Ke),epochOfLastAuthorizedSwitch:Re,targetEpoch:Fe}}function getPriorVoters({buf:Ke,idx:Re,isEmpty:Fe}){return Fe?[]:[...Ke.slice(Re+1).map(parsePriorVoters),...Ke.slice(0,Re).map(parsePriorVoters)]}const endpoint={http:{devnet:"http://api.devnet.solana.com",testnet:"http://api.testnet.solana.com","mainnet-beta":"http://api.mainnet-beta.solana.com/"},https:{devnet:"https://api.devnet.solana.com",testnet:"https://api.testnet.solana.com","mainnet-beta":"https://api.mainnet-beta.solana.com/"}};function clusterApiUrl(Ke,Re){const Fe=Re===!1?"http":"https";if(!Ke)return endpoint[Fe].devnet;const qe=endpoint[Fe][Ke];if(!qe)throw new Error(`Unknown ${Fe} cluster: ${Ke}`);return qe}async function sendAndConfirmRawTransaction(Ke,Re,Fe,qe){let We,Ze;Fe&&Object.prototype.hasOwnProperty.call(Fe,"lastValidBlockHeight")?(We=Fe,Ze=qe):Ze=Fe;const Xe=Ze&&{skipPreflight:Ze.skipPreflight,preflightCommitment:Ze.preflightCommitment||Ze.commitment,minContextSlot:Ze.minContextSlot},Je=await Ke.sendRawTransaction(Re,Xe),tr=Ze&&Ze.commitment,ir=(await(We?Ke.confirmTransaction(We,tr):Ke.confirmTransaction(Je,tr))).value;if(ir.err)throw new Error(`Raw transaction ${Je} failed (${JSON.stringify(ir)})`);return Je}const LAMPORTS_PER_SOL=1e9,index_browser_esm=Object.freeze(Object.defineProperty({__proto__:null,Account,AddressLookupTableAccount,AddressLookupTableInstruction,AddressLookupTableProgram,Authorized,BLOCKHASH_CACHE_TIMEOUT_MS,BPF_LOADER_DEPRECATED_PROGRAM_ID,BPF_LOADER_PROGRAM_ID,BpfLoader,COMPUTE_BUDGET_INSTRUCTION_LAYOUTS,ComputeBudgetInstruction,ComputeBudgetProgram,Connection,Ed25519Program,Enum,EpochSchedule,FeeCalculatorLayout,Keypair,LAMPORTS_PER_SOL,LOOKUP_TABLE_INSTRUCTION_LAYOUTS,Loader,Lockup,MAX_SEED_LENGTH,Message,MessageAccountKeys,MessageV0,NONCE_ACCOUNT_LENGTH,NonceAccount,PACKET_DATA_SIZE,PUBLIC_KEY_LENGTH,PublicKey,SIGNATURE_LENGTH_IN_BYTES,SOLANA_SCHEMA,STAKE_CONFIG_ID,STAKE_INSTRUCTION_LAYOUTS,SYSTEM_INSTRUCTION_LAYOUTS,SYSVAR_CLOCK_PUBKEY,SYSVAR_EPOCH_SCHEDULE_PUBKEY,SYSVAR_INSTRUCTIONS_PUBKEY,SYSVAR_RECENT_BLOCKHASHES_PUBKEY,SYSVAR_RENT_PUBKEY,SYSVAR_REWARDS_PUBKEY,SYSVAR_SLOT_HASHES_PUBKEY,SYSVAR_SLOT_HISTORY_PUBKEY,SYSVAR_STAKE_HISTORY_PUBKEY,Secp256k1Program,SendTransactionError,SolanaJSONRPCError,SolanaJSONRPCErrorCode,StakeAuthorizationLayout,StakeInstruction,StakeProgram,Struct,SystemInstruction,SystemProgram,Transaction,TransactionExpiredBlockheightExceededError,TransactionExpiredTimeoutError,TransactionInstruction,TransactionMessage,get TransactionStatus(){return TransactionStatus},VALIDATOR_INFO_KEY,VERSION_PREFIX_MASK,VOTE_PROGRAM_ID,ValidatorInfo,VersionedMessage,VersionedTransaction,VoteAccount,VoteAuthorizationLayout,VoteInit,VoteInstruction,VoteProgram,clusterApiUrl,sendAndConfirmRawTransaction,sendAndConfirmTransaction},Symbol.toStringTag,{value:"Module"})),PROGRAM_KEY="DByFcag9yDLwRGnBCT8bJpJPM7akth4dpHXosf7eaB7s";let NETWORK="devnet";var camelcase={exports:{}};const preserveCamelCase=Ke=>{let Re=!1,Fe=!1,qe=!1;for(let We=0;We<Ke.length;We++){const Ze=Ke[We];Re&&/[a-zA-Z]/.test(Ze)&&Ze.toUpperCase()===Ze?(Ke=Ke.slice(0,We)+"-"+Ke.slice(We),Re=!1,qe=Fe,Fe=!0,We++):Fe&&qe&&/[a-zA-Z]/.test(Ze)&&Ze.toLowerCase()===Ze?(Ke=Ke.slice(0,We-1)+"-"+Ke.slice(We-1),qe=Fe,Fe=!1,Re=!0):(Re=Ze.toLowerCase()===Ze&&Ze.toUpperCase()!==Ze,qe=Fe,Fe=Ze.toUpperCase()===Ze&&Ze.toLowerCase()!==Ze)}return Ke},camelCase=(Ke,Re)=>{if(!(typeof Ke=="string"||Array.isArray(Ke)))throw new TypeError("Expected the input to be `string | string[]`");Re=Object.assign({pascalCase:!1},Re);const Fe=We=>Re.pascalCase?We.charAt(0).toUpperCase()+We.slice(1):We;return Array.isArray(Ke)?Ke=Ke.map(We=>We.trim()).filter(We=>We.length).join("-"):Ke=Ke.trim(),Ke.length===0?"":Ke.length===1?Re.pascalCase?Ke.toUpperCase():Ke.toLowerCase():(Ke!==Ke.toLowerCase()&&(Ke=preserveCamelCase(Ke)),Ke=Ke.replace(/^[_.\- ]+/,"").toLowerCase().replace(/[_.\- ]+(\w|$)/g,(We,Ze)=>Ze.toUpperCase()).replace(/\d+(\w|$)/g,We=>We.toUpperCase()),Fe(Ke))};camelcase.exports=camelCase;camelcase.exports.default=camelCase;var sha256={exports:{}};/**
 * [js-sha256]{@link https://github.com/emn178/js-sha256}
 *
 * @version 0.9.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2014-2017
 * @license MIT
 */(function(module){(function(){var ERROR="input is invalid type",WINDOW=typeof window=="object",root=WINDOW?window:{};root.JS_SHA256_NO_WINDOW&&(WINDOW=!1);var WEB_WORKER=!WINDOW&&typeof self=="object",NODE_JS=!root.JS_SHA256_NO_NODE_JS&&typeof process=="object"&&process.versions&&process.versions.node;NODE_JS?root=commonjsGlobal:WEB_WORKER&&(root=self);var COMMON_JS=!root.JS_SHA256_NO_COMMON_JS&&!0&&module.exports,ARRAY_BUFFER=!root.JS_SHA256_NO_ARRAY_BUFFER&&typeof ArrayBuffer<"u",HEX_CHARS="0123456789abcdef".split(""),EXTRA=[-2147483648,8388608,32768,128],SHIFT=[24,16,8,0],K=[1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298],OUTPUT_TYPES=["hex","array","digest","arrayBuffer"],blocks=[];(root.JS_SHA256_NO_NODE_JS||!Array.isArray)&&(Array.isArray=function(Ke){return Object.prototype.toString.call(Ke)==="[object Array]"}),ARRAY_BUFFER&&(root.JS_SHA256_NO_ARRAY_BUFFER_IS_VIEW||!ArrayBuffer.isView)&&(ArrayBuffer.isView=function(Ke){return typeof Ke=="object"&&Ke.buffer&&Ke.buffer.constructor===ArrayBuffer});var createOutputMethod=function(Ke,Re){return function(Fe){return new Sha256(Re,!0).update(Fe)[Ke]()}},createMethod=function(Ke){var Re=createOutputMethod("hex",Ke);NODE_JS&&(Re=nodeWrap(Re,Ke)),Re.create=function(){return new Sha256(Ke)},Re.update=function(We){return Re.create().update(We)};for(var Fe=0;Fe<OUTPUT_TYPES.length;++Fe){var qe=OUTPUT_TYPES[Fe];Re[qe]=createOutputMethod(qe,Ke)}return Re},nodeWrap=function(method,is224){var crypto=eval("require('crypto')"),Buffer=eval("require('buffer').Buffer"),algorithm=is224?"sha224":"sha256",nodeMethod=function(Ke){if(typeof Ke=="string")return crypto.createHash(algorithm).update(Ke,"utf8").digest("hex");if(Ke==null)throw new Error(ERROR);return Ke.constructor===ArrayBuffer&&(Ke=new Uint8Array(Ke)),Array.isArray(Ke)||ArrayBuffer.isView(Ke)||Ke.constructor===Buffer?crypto.createHash(algorithm).update(new Buffer(Ke)).digest("hex"):method(Ke)};return nodeMethod},createHmacOutputMethod=function(Ke,Re){return function(Fe,qe){return new HmacSha256(Fe,Re,!0).update(qe)[Ke]()}},createHmacMethod=function(Ke){var Re=createHmacOutputMethod("hex",Ke);Re.create=function(We){return new HmacSha256(We,Ke)},Re.update=function(We,Ze){return Re.create(We).update(Ze)};for(var Fe=0;Fe<OUTPUT_TYPES.length;++Fe){var qe=OUTPUT_TYPES[Fe];Re[qe]=createHmacOutputMethod(qe,Ke)}return Re};function Sha256(Ke,Re){Re?(blocks[0]=blocks[16]=blocks[1]=blocks[2]=blocks[3]=blocks[4]=blocks[5]=blocks[6]=blocks[7]=blocks[8]=blocks[9]=blocks[10]=blocks[11]=blocks[12]=blocks[13]=blocks[14]=blocks[15]=0,this.blocks=blocks):this.blocks=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],Ke?(this.h0=3238371032,this.h1=914150663,this.h2=812702999,this.h3=4144912697,this.h4=4290775857,this.h5=1750603025,this.h6=1694076839,this.h7=3204075428):(this.h0=1779033703,this.h1=3144134277,this.h2=1013904242,this.h3=2773480762,this.h4=1359893119,this.h5=2600822924,this.h6=528734635,this.h7=1541459225),this.block=this.start=this.bytes=this.hBytes=0,this.finalized=this.hashed=!1,this.first=!0,this.is224=Ke}Sha256.prototype.update=function(Ke){if(!this.finalized){var Re,Fe=typeof Ke;if(Fe!=="string"){if(Fe==="object"){if(Ke===null)throw new Error(ERROR);if(ARRAY_BUFFER&&Ke.constructor===ArrayBuffer)Ke=new Uint8Array(Ke);else if(!Array.isArray(Ke)&&(!ARRAY_BUFFER||!ArrayBuffer.isView(Ke)))throw new Error(ERROR)}else throw new Error(ERROR);Re=!0}for(var qe,We=0,Ze,Xe=Ke.length,Je=this.blocks;We<Xe;){if(this.hashed&&(this.hashed=!1,Je[0]=this.block,Je[16]=Je[1]=Je[2]=Je[3]=Je[4]=Je[5]=Je[6]=Je[7]=Je[8]=Je[9]=Je[10]=Je[11]=Je[12]=Je[13]=Je[14]=Je[15]=0),Re)for(Ze=this.start;We<Xe&&Ze<64;++We)Je[Ze>>2]|=Ke[We]<<SHIFT[Ze++&3];else for(Ze=this.start;We<Xe&&Ze<64;++We)qe=Ke.charCodeAt(We),qe<128?Je[Ze>>2]|=qe<<SHIFT[Ze++&3]:qe<2048?(Je[Ze>>2]|=(192|qe>>6)<<SHIFT[Ze++&3],Je[Ze>>2]|=(128|qe&63)<<SHIFT[Ze++&3]):qe<55296||qe>=57344?(Je[Ze>>2]|=(224|qe>>12)<<SHIFT[Ze++&3],Je[Ze>>2]|=(128|qe>>6&63)<<SHIFT[Ze++&3],Je[Ze>>2]|=(128|qe&63)<<SHIFT[Ze++&3]):(qe=65536+((qe&1023)<<10|Ke.charCodeAt(++We)&1023),Je[Ze>>2]|=(240|qe>>18)<<SHIFT[Ze++&3],Je[Ze>>2]|=(128|qe>>12&63)<<SHIFT[Ze++&3],Je[Ze>>2]|=(128|qe>>6&63)<<SHIFT[Ze++&3],Je[Ze>>2]|=(128|qe&63)<<SHIFT[Ze++&3]);this.lastByteIndex=Ze,this.bytes+=Ze-this.start,Ze>=64?(this.block=Je[16],this.start=Ze-64,this.hash(),this.hashed=!0):this.start=Ze}return this.bytes>4294967295&&(this.hBytes+=this.bytes/4294967296<<0,this.bytes=this.bytes%4294967296),this}},Sha256.prototype.finalize=function(){if(!this.finalized){this.finalized=!0;var Ke=this.blocks,Re=this.lastByteIndex;Ke[16]=this.block,Ke[Re>>2]|=EXTRA[Re&3],this.block=Ke[16],Re>=56&&(this.hashed||this.hash(),Ke[0]=this.block,Ke[16]=Ke[1]=Ke[2]=Ke[3]=Ke[4]=Ke[5]=Ke[6]=Ke[7]=Ke[8]=Ke[9]=Ke[10]=Ke[11]=Ke[12]=Ke[13]=Ke[14]=Ke[15]=0),Ke[14]=this.hBytes<<3|this.bytes>>>29,Ke[15]=this.bytes<<3,this.hash()}},Sha256.prototype.hash=function(){var Ke=this.h0,Re=this.h1,Fe=this.h2,qe=this.h3,We=this.h4,Ze=this.h5,Xe=this.h6,Je=this.h7,tr=this.blocks,er,ir,ur,fr,ar,yr,mr,wr,Sr,Ar,vr;for(er=16;er<64;++er)ar=tr[er-15],ir=(ar>>>7|ar<<25)^(ar>>>18|ar<<14)^ar>>>3,ar=tr[er-2],ur=(ar>>>17|ar<<15)^(ar>>>19|ar<<13)^ar>>>10,tr[er]=tr[er-16]+ir+tr[er-7]+ur<<0;for(vr=Re&Fe,er=0;er<64;er+=4)this.first?(this.is224?(wr=300032,ar=tr[0]-1413257819,Je=ar-150054599<<0,qe=ar+24177077<<0):(wr=704751109,ar=tr[0]-210244248,Je=ar-1521486534<<0,qe=ar+143694565<<0),this.first=!1):(ir=(Ke>>>2|Ke<<30)^(Ke>>>13|Ke<<19)^(Ke>>>22|Ke<<10),ur=(We>>>6|We<<26)^(We>>>11|We<<21)^(We>>>25|We<<7),wr=Ke&Re,fr=wr^Ke&Fe^vr,mr=We&Ze^~We&Xe,ar=Je+ur+mr+K[er]+tr[er],yr=ir+fr,Je=qe+ar<<0,qe=ar+yr<<0),ir=(qe>>>2|qe<<30)^(qe>>>13|qe<<19)^(qe>>>22|qe<<10),ur=(Je>>>6|Je<<26)^(Je>>>11|Je<<21)^(Je>>>25|Je<<7),Sr=qe&Ke,fr=Sr^qe&Re^wr,mr=Je&We^~Je&Ze,ar=Xe+ur+mr+K[er+1]+tr[er+1],yr=ir+fr,Xe=Fe+ar<<0,Fe=ar+yr<<0,ir=(Fe>>>2|Fe<<30)^(Fe>>>13|Fe<<19)^(Fe>>>22|Fe<<10),ur=(Xe>>>6|Xe<<26)^(Xe>>>11|Xe<<21)^(Xe>>>25|Xe<<7),Ar=Fe&qe,fr=Ar^Fe&Ke^Sr,mr=Xe&Je^~Xe&We,ar=Ze+ur+mr+K[er+2]+tr[er+2],yr=ir+fr,Ze=Re+ar<<0,Re=ar+yr<<0,ir=(Re>>>2|Re<<30)^(Re>>>13|Re<<19)^(Re>>>22|Re<<10),ur=(Ze>>>6|Ze<<26)^(Ze>>>11|Ze<<21)^(Ze>>>25|Ze<<7),vr=Re&Fe,fr=vr^Re&qe^Ar,mr=Ze&Xe^~Ze&Je,ar=We+ur+mr+K[er+3]+tr[er+3],yr=ir+fr,We=Ke+ar<<0,Ke=ar+yr<<0;this.h0=this.h0+Ke<<0,this.h1=this.h1+Re<<0,this.h2=this.h2+Fe<<0,this.h3=this.h3+qe<<0,this.h4=this.h4+We<<0,this.h5=this.h5+Ze<<0,this.h6=this.h6+Xe<<0,this.h7=this.h7+Je<<0},Sha256.prototype.hex=function(){this.finalize();var Ke=this.h0,Re=this.h1,Fe=this.h2,qe=this.h3,We=this.h4,Ze=this.h5,Xe=this.h6,Je=this.h7,tr=HEX_CHARS[Ke>>28&15]+HEX_CHARS[Ke>>24&15]+HEX_CHARS[Ke>>20&15]+HEX_CHARS[Ke>>16&15]+HEX_CHARS[Ke>>12&15]+HEX_CHARS[Ke>>8&15]+HEX_CHARS[Ke>>4&15]+HEX_CHARS[Ke&15]+HEX_CHARS[Re>>28&15]+HEX_CHARS[Re>>24&15]+HEX_CHARS[Re>>20&15]+HEX_CHARS[Re>>16&15]+HEX_CHARS[Re>>12&15]+HEX_CHARS[Re>>8&15]+HEX_CHARS[Re>>4&15]+HEX_CHARS[Re&15]+HEX_CHARS[Fe>>28&15]+HEX_CHARS[Fe>>24&15]+HEX_CHARS[Fe>>20&15]+HEX_CHARS[Fe>>16&15]+HEX_CHARS[Fe>>12&15]+HEX_CHARS[Fe>>8&15]+HEX_CHARS[Fe>>4&15]+HEX_CHARS[Fe&15]+HEX_CHARS[qe>>28&15]+HEX_CHARS[qe>>24&15]+HEX_CHARS[qe>>20&15]+HEX_CHARS[qe>>16&15]+HEX_CHARS[qe>>12&15]+HEX_CHARS[qe>>8&15]+HEX_CHARS[qe>>4&15]+HEX_CHARS[qe&15]+HEX_CHARS[We>>28&15]+HEX_CHARS[We>>24&15]+HEX_CHARS[We>>20&15]+HEX_CHARS[We>>16&15]+HEX_CHARS[We>>12&15]+HEX_CHARS[We>>8&15]+HEX_CHARS[We>>4&15]+HEX_CHARS[We&15]+HEX_CHARS[Ze>>28&15]+HEX_CHARS[Ze>>24&15]+HEX_CHARS[Ze>>20&15]+HEX_CHARS[Ze>>16&15]+HEX_CHARS[Ze>>12&15]+HEX_CHARS[Ze>>8&15]+HEX_CHARS[Ze>>4&15]+HEX_CHARS[Ze&15]+HEX_CHARS[Xe>>28&15]+HEX_CHARS[Xe>>24&15]+HEX_CHARS[Xe>>20&15]+HEX_CHARS[Xe>>16&15]+HEX_CHARS[Xe>>12&15]+HEX_CHARS[Xe>>8&15]+HEX_CHARS[Xe>>4&15]+HEX_CHARS[Xe&15];return this.is224||(tr+=HEX_CHARS[Je>>28&15]+HEX_CHARS[Je>>24&15]+HEX_CHARS[Je>>20&15]+HEX_CHARS[Je>>16&15]+HEX_CHARS[Je>>12&15]+HEX_CHARS[Je>>8&15]+HEX_CHARS[Je>>4&15]+HEX_CHARS[Je&15]),tr},Sha256.prototype.toString=Sha256.prototype.hex,Sha256.prototype.digest=function(){this.finalize();var Ke=this.h0,Re=this.h1,Fe=this.h2,qe=this.h3,We=this.h4,Ze=this.h5,Xe=this.h6,Je=this.h7,tr=[Ke>>24&255,Ke>>16&255,Ke>>8&255,Ke&255,Re>>24&255,Re>>16&255,Re>>8&255,Re&255,Fe>>24&255,Fe>>16&255,Fe>>8&255,Fe&255,qe>>24&255,qe>>16&255,qe>>8&255,qe&255,We>>24&255,We>>16&255,We>>8&255,We&255,Ze>>24&255,Ze>>16&255,Ze>>8&255,Ze&255,Xe>>24&255,Xe>>16&255,Xe>>8&255,Xe&255];return this.is224||tr.push(Je>>24&255,Je>>16&255,Je>>8&255,Je&255),tr},Sha256.prototype.array=Sha256.prototype.digest,Sha256.prototype.arrayBuffer=function(){this.finalize();var Ke=new ArrayBuffer(this.is224?28:32),Re=new DataView(Ke);return Re.setUint32(0,this.h0),Re.setUint32(4,this.h1),Re.setUint32(8,this.h2),Re.setUint32(12,this.h3),Re.setUint32(16,this.h4),Re.setUint32(20,this.h5),Re.setUint32(24,this.h6),this.is224||Re.setUint32(28,this.h7),Ke};function HmacSha256(Ke,Re,Fe){var qe,We=typeof Ke;if(We==="string"){var Ze=[],Xe=Ke.length,Je=0,tr;for(qe=0;qe<Xe;++qe)tr=Ke.charCodeAt(qe),tr<128?Ze[Je++]=tr:tr<2048?(Ze[Je++]=192|tr>>6,Ze[Je++]=128|tr&63):tr<55296||tr>=57344?(Ze[Je++]=224|tr>>12,Ze[Je++]=128|tr>>6&63,Ze[Je++]=128|tr&63):(tr=65536+((tr&1023)<<10|Ke.charCodeAt(++qe)&1023),Ze[Je++]=240|tr>>18,Ze[Je++]=128|tr>>12&63,Ze[Je++]=128|tr>>6&63,Ze[Je++]=128|tr&63);Ke=Ze}else if(We==="object"){if(Ke===null)throw new Error(ERROR);if(ARRAY_BUFFER&&Ke.constructor===ArrayBuffer)Ke=new Uint8Array(Ke);else if(!Array.isArray(Ke)&&(!ARRAY_BUFFER||!ArrayBuffer.isView(Ke)))throw new Error(ERROR)}else throw new Error(ERROR);Ke.length>64&&(Ke=new Sha256(Re,!0).update(Ke).array());var er=[],ir=[];for(qe=0;qe<64;++qe){var ur=Ke[qe]||0;er[qe]=92^ur,ir[qe]=54^ur}Sha256.call(this,Re,Fe),this.update(ir),this.oKeyPad=er,this.inner=!0,this.sharedMemory=Fe}HmacSha256.prototype=new Sha256,HmacSha256.prototype.finalize=function(){if(Sha256.prototype.finalize.call(this),this.inner){this.inner=!1;var Ke=this.array();Sha256.call(this,this.is224,this.sharedMemory),this.update(this.oKeyPad),this.update(Ke),Sha256.prototype.finalize.call(this)}};var exports=createMethod();exports.sha256=exports,exports.sha224=createMethod(!0),exports.sha256.hmac=createHmacMethod(),exports.sha224.hmac=createHmacMethod(!0),COMMON_JS?module.exports=exports:(root.sha256=exports.sha256,root.sha224=exports.sha224)})()})(sha256);var lib={},Layout$1={};class Layout{constructor(Re,Fe){if(!Number.isInteger(Re))throw new TypeError("span must be an integer");this.span=Re,this.property=Fe}makeDestinationObject(){return{}}decode(Re,Fe){throw new Error("Layout is abstract")}encode(Re,Fe,qe){throw new Error("Layout is abstract")}getSpan(Re,Fe){if(0>this.span)throw new RangeError("indeterminate span");return this.span}replicate(Re){const Fe=Object.create(this.constructor.prototype);return Object.assign(Fe,this),Fe.property=Re,Fe}fromArray(Re){}}Layout$1.Layout=Layout;function nameWithProperty(Ke,Re){return Re.property?Ke+"["+Re.property+"]":Ke}Layout$1.nameWithProperty=nameWithProperty;function bindConstructorLayout(Ke,Re){if(typeof Ke!="function")throw new TypeError("Class must be constructor");if(Ke.hasOwnProperty("layout_"))throw new Error("Class is already bound to a layout");if(!(Re&&Re instanceof Layout))throw new TypeError("layout must be a Layout");if(Re.hasOwnProperty("boundConstructor_"))throw new Error("layout is already bound to a constructor");Ke.layout_=Re,Re.boundConstructor_=Ke,Re.makeDestinationObject=()=>new Ke,Object.defineProperty(Ke.prototype,"encode",{value:function(Fe,qe){return Re.encode(this,Fe,qe)},writable:!0}),Object.defineProperty(Ke,"decode",{value:function(Fe,qe){return Re.decode(Fe,qe)},writable:!0})}Layout$1.bindConstructorLayout=bindConstructorLayout;class ExternalLayout extends Layout{isCount(){throw new Error("ExternalLayout is abstract")}}class GreedyCount extends ExternalLayout{constructor(Re,Fe){if(Re===void 0&&(Re=1),!Number.isInteger(Re)||0>=Re)throw new TypeError("elementSpan must be a (positive) integer");super(-1,Fe),this.elementSpan=Re}isCount(){return!0}decode(Re,Fe){Fe===void 0&&(Fe=0);const qe=Re.length-Fe;return Math.floor(qe/this.elementSpan)}encode(Re,Fe,qe){return 0}}class OffsetLayout extends ExternalLayout{constructor(Re,Fe,qe){if(!(Re instanceof Layout))throw new TypeError("layout must be a Layout");if(Fe===void 0)Fe=0;else if(!Number.isInteger(Fe))throw new TypeError("offset must be integer or undefined");super(Re.span,qe||Re.property),this.layout=Re,this.offset=Fe}isCount(){return this.layout instanceof UInt||this.layout instanceof UIntBE}decode(Re,Fe){return Fe===void 0&&(Fe=0),this.layout.decode(Re,Fe+this.offset)}encode(Re,Fe,qe){return qe===void 0&&(qe=0),this.layout.encode(Re,Fe,qe+this.offset)}}class UInt extends Layout{constructor(Re,Fe){if(super(Re,Fe),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(Re,Fe){return Fe===void 0&&(Fe=0),Re.readUIntLE(Fe,this.span)}encode(Re,Fe,qe){return qe===void 0&&(qe=0),Fe.writeUIntLE(Re,qe,this.span),this.span}}class UIntBE extends Layout{constructor(Re,Fe){if(super(Re,Fe),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(Re,Fe){return Fe===void 0&&(Fe=0),Re.readUIntBE(Fe,this.span)}encode(Re,Fe,qe){return qe===void 0&&(qe=0),Fe.writeUIntBE(Re,qe,this.span),this.span}}class Int extends Layout{constructor(Re,Fe){if(super(Re,Fe),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(Re,Fe){return Fe===void 0&&(Fe=0),Re.readIntLE(Fe,this.span)}encode(Re,Fe,qe){return qe===void 0&&(qe=0),Fe.writeIntLE(Re,qe,this.span),this.span}}class IntBE extends Layout{constructor(Re,Fe){if(super(Re,Fe),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(Re,Fe){return Fe===void 0&&(Fe=0),Re.readIntBE(Fe,this.span)}encode(Re,Fe,qe){return qe===void 0&&(qe=0),Fe.writeIntBE(Re,qe,this.span),this.span}}const V2E32=Math.pow(2,32);function divmodInt64(Ke){const Re=Math.floor(Ke/V2E32),Fe=Ke-Re*V2E32;return{hi32:Re,lo32:Fe}}function roundedInt64(Ke,Re){return Ke*V2E32+Re}class NearUInt64 extends Layout{constructor(Re){super(8,Re)}decode(Re,Fe){Fe===void 0&&(Fe=0);const qe=Re.readUInt32LE(Fe),We=Re.readUInt32LE(Fe+4);return roundedInt64(We,qe)}encode(Re,Fe,qe){qe===void 0&&(qe=0);const We=divmodInt64(Re);return Fe.writeUInt32LE(We.lo32,qe),Fe.writeUInt32LE(We.hi32,qe+4),8}}class NearUInt64BE extends Layout{constructor(Re){super(8,Re)}decode(Re,Fe){Fe===void 0&&(Fe=0);const qe=Re.readUInt32BE(Fe),We=Re.readUInt32BE(Fe+4);return roundedInt64(qe,We)}encode(Re,Fe,qe){qe===void 0&&(qe=0);const We=divmodInt64(Re);return Fe.writeUInt32BE(We.hi32,qe),Fe.writeUInt32BE(We.lo32,qe+4),8}}class NearInt64 extends Layout{constructor(Re){super(8,Re)}decode(Re,Fe){Fe===void 0&&(Fe=0);const qe=Re.readUInt32LE(Fe),We=Re.readInt32LE(Fe+4);return roundedInt64(We,qe)}encode(Re,Fe,qe){qe===void 0&&(qe=0);const We=divmodInt64(Re);return Fe.writeUInt32LE(We.lo32,qe),Fe.writeInt32LE(We.hi32,qe+4),8}}class NearInt64BE extends Layout{constructor(Re){super(8,Re)}decode(Re,Fe){Fe===void 0&&(Fe=0);const qe=Re.readInt32BE(Fe),We=Re.readUInt32BE(Fe+4);return roundedInt64(qe,We)}encode(Re,Fe,qe){qe===void 0&&(qe=0);const We=divmodInt64(Re);return Fe.writeInt32BE(We.hi32,qe),Fe.writeUInt32BE(We.lo32,qe+4),8}}class Float extends Layout{constructor(Re){super(4,Re)}decode(Re,Fe){return Fe===void 0&&(Fe=0),Re.readFloatLE(Fe)}encode(Re,Fe,qe){return qe===void 0&&(qe=0),Fe.writeFloatLE(Re,qe),4}}class FloatBE extends Layout{constructor(Re){super(4,Re)}decode(Re,Fe){return Fe===void 0&&(Fe=0),Re.readFloatBE(Fe)}encode(Re,Fe,qe){return qe===void 0&&(qe=0),Fe.writeFloatBE(Re,qe),4}}class Double extends Layout{constructor(Re){super(8,Re)}decode(Re,Fe){return Fe===void 0&&(Fe=0),Re.readDoubleLE(Fe)}encode(Re,Fe,qe){return qe===void 0&&(qe=0),Fe.writeDoubleLE(Re,qe),8}}class DoubleBE extends Layout{constructor(Re){super(8,Re)}decode(Re,Fe){return Fe===void 0&&(Fe=0),Re.readDoubleBE(Fe)}encode(Re,Fe,qe){return qe===void 0&&(qe=0),Fe.writeDoubleBE(Re,qe),8}}class Sequence extends Layout{constructor(Re,Fe,qe){if(!(Re instanceof Layout))throw new TypeError("elementLayout must be a Layout");if(!(Fe instanceof ExternalLayout&&Fe.isCount()||Number.isInteger(Fe)&&0<=Fe))throw new TypeError("count must be non-negative integer or an unsigned integer ExternalLayout");let We=-1;!(Fe instanceof ExternalLayout)&&0<Re.span&&(We=Fe*Re.span),super(We,qe),this.elementLayout=Re,this.count=Fe}getSpan(Re,Fe){if(0<=this.span)return this.span;Fe===void 0&&(Fe=0);let qe=0,We=this.count;if(We instanceof ExternalLayout&&(We=We.decode(Re,Fe)),0<this.elementLayout.span)qe=We*this.elementLayout.span;else{let Ze=0;for(;Ze<We;)qe+=this.elementLayout.getSpan(Re,Fe+qe),++Ze}return qe}decode(Re,Fe){Fe===void 0&&(Fe=0);const qe=[];let We=0,Ze=this.count;for(Ze instanceof ExternalLayout&&(Ze=Ze.decode(Re,Fe));We<Ze;)qe.push(this.elementLayout.decode(Re,Fe)),Fe+=this.elementLayout.getSpan(Re,Fe),We+=1;return qe}encode(Re,Fe,qe){qe===void 0&&(qe=0);const We=this.elementLayout,Ze=Re.reduce((Xe,Je)=>Xe+We.encode(Je,Fe,qe+Xe),0);return this.count instanceof ExternalLayout&&this.count.encode(Re.length,Fe,qe),Ze}}class Structure extends Layout{constructor(Re,Fe,qe){if(!(Array.isArray(Re)&&Re.reduce((Ze,Xe)=>Ze&&Xe instanceof Layout,!0)))throw new TypeError("fields must be array of Layout instances");typeof Fe=="boolean"&&qe===void 0&&(qe=Fe,Fe=void 0);for(const Ze of Re)if(0>Ze.span&&Ze.property===void 0)throw new Error("fields cannot contain unnamed variable-length layout");let We=-1;try{We=Re.reduce((Ze,Xe)=>Ze+Xe.getSpan(),0)}catch{}super(We,Fe),this.fields=Re,this.decodePrefixes=!!qe}getSpan(Re,Fe){if(0<=this.span)return this.span;Fe===void 0&&(Fe=0);let qe=0;try{qe=this.fields.reduce((We,Ze)=>{const Xe=Ze.getSpan(Re,Fe);return Fe+=Xe,We+Xe},0)}catch{throw new RangeError("indeterminate span")}return qe}decode(Re,Fe){Fe===void 0&&(Fe=0);const qe=this.makeDestinationObject();for(const We of this.fields)if(We.property!==void 0&&(qe[We.property]=We.decode(Re,Fe)),Fe+=We.getSpan(Re,Fe),this.decodePrefixes&&Re.length===Fe)break;return qe}encode(Re,Fe,qe){qe===void 0&&(qe=0);const We=qe;let Ze=0,Xe=0;for(const Je of this.fields){let tr=Je.span;if(Xe=0<tr?tr:0,Je.property!==void 0){const er=Re[Je.property];er!==void 0&&(Xe=Je.encode(er,Fe,qe),0>tr&&(tr=Je.getSpan(Fe,qe)))}Ze=qe,qe+=tr}return Ze+Xe-We}fromArray(Re){const Fe=this.makeDestinationObject();for(const qe of this.fields)qe.property!==void 0&&0<Re.length&&(Fe[qe.property]=Re.shift());return Fe}layoutFor(Re){if(typeof Re!="string")throw new TypeError("property must be string");for(const Fe of this.fields)if(Fe.property===Re)return Fe}offsetOf(Re){if(typeof Re!="string")throw new TypeError("property must be string");let Fe=0;for(const qe of this.fields){if(qe.property===Re)return Fe;0>qe.span?Fe=-1:0<=Fe&&(Fe+=qe.span)}}}class UnionDiscriminator{constructor(Re){this.property=Re}decode(){throw new Error("UnionDiscriminator is abstract")}encode(){throw new Error("UnionDiscriminator is abstract")}}class UnionLayoutDiscriminator extends UnionDiscriminator{constructor(Re,Fe){if(!(Re instanceof ExternalLayout&&Re.isCount()))throw new TypeError("layout must be an unsigned integer ExternalLayout");super(Fe||Re.property||"variant"),this.layout=Re}decode(Re,Fe){return this.layout.decode(Re,Fe)}encode(Re,Fe,qe){return this.layout.encode(Re,Fe,qe)}}class Union extends Layout{constructor(Re,Fe,qe){const We=Re instanceof UInt||Re instanceof UIntBE;if(We)Re=new UnionLayoutDiscriminator(new OffsetLayout(Re));else if(Re instanceof ExternalLayout&&Re.isCount())Re=new UnionLayoutDiscriminator(Re);else if(!(Re instanceof UnionDiscriminator))throw new TypeError("discr must be a UnionDiscriminator or an unsigned integer layout");if(Fe===void 0&&(Fe=null),!(Fe===null||Fe instanceof Layout))throw new TypeError("defaultLayout must be null or a Layout");if(Fe!==null){if(0>Fe.span)throw new Error("defaultLayout must have constant span");Fe.property===void 0&&(Fe=Fe.replicate("content"))}let Ze=-1;Fe&&(Ze=Fe.span,0<=Ze&&We&&(Ze+=Re.layout.span)),super(Ze,qe),this.discriminator=Re,this.usesPrefixDiscriminator=We,this.defaultLayout=Fe,this.registry={};let Xe=this.defaultGetSourceVariant.bind(this);this.getSourceVariant=function(Je){return Xe(Je)},this.configGetSourceVariant=function(Je){Xe=Je.bind(this)}}getSpan(Re,Fe){if(0<=this.span)return this.span;Fe===void 0&&(Fe=0);const qe=this.getVariant(Re,Fe);if(!qe)throw new Error("unable to determine span for unrecognized variant");return qe.getSpan(Re,Fe)}defaultGetSourceVariant(Re){if(Re.hasOwnProperty(this.discriminator.property)){if(this.defaultLayout&&Re.hasOwnProperty(this.defaultLayout.property))return;const Fe=this.registry[Re[this.discriminator.property]];if(Fe&&(!Fe.layout||Re.hasOwnProperty(Fe.property)))return Fe}else for(const Fe in this.registry){const qe=this.registry[Fe];if(Re.hasOwnProperty(qe.property))return qe}throw new Error("unable to infer src variant")}decode(Re,Fe){Fe===void 0&&(Fe=0);let qe;const We=this.discriminator,Ze=We.decode(Re,Fe);let Xe=this.registry[Ze];if(Xe===void 0){let Je=0;Xe=this.defaultLayout,this.usesPrefixDiscriminator&&(Je=We.layout.span),qe=this.makeDestinationObject(),qe[We.property]=Ze,qe[Xe.property]=this.defaultLayout.decode(Re,Fe+Je)}else qe=Xe.decode(Re,Fe);return qe}encode(Re,Fe,qe){qe===void 0&&(qe=0);const We=this.getSourceVariant(Re);if(We===void 0){const Ze=this.discriminator,Xe=this.defaultLayout;let Je=0;return this.usesPrefixDiscriminator&&(Je=Ze.layout.span),Ze.encode(Re[Ze.property],Fe,qe),Je+Xe.encode(Re[Xe.property],Fe,qe+Je)}return We.encode(Re,Fe,qe)}addVariant(Re,Fe,qe){const We=new VariantLayout(this,Re,Fe,qe);return this.registry[Re]=We,We}getVariant(Re,Fe){let qe=Re;return Buffer.isBuffer(Re)&&(Fe===void 0&&(Fe=0),qe=this.discriminator.decode(Re,Fe)),this.registry[qe]}}class VariantLayout extends Layout{constructor(Re,Fe,qe,We){if(!(Re instanceof Union))throw new TypeError("union must be a Union");if(!Number.isInteger(Fe)||0>Fe)throw new TypeError("variant must be a (non-negative) integer");if(typeof qe=="string"&&We===void 0&&(We=qe,qe=null),qe){if(!(qe instanceof Layout))throw new TypeError("layout must be a Layout");if(Re.defaultLayout!==null&&0<=qe.span&&qe.span>Re.defaultLayout.span)throw new Error("variant span exceeds span of containing union");if(typeof We!="string")throw new TypeError("variant must have a String property")}let Ze=Re.span;0>Re.span&&(Ze=qe?qe.span:0,0<=Ze&&Re.usesPrefixDiscriminator&&(Ze+=Re.discriminator.layout.span)),super(Ze,We),this.union=Re,this.variant=Fe,this.layout=qe||null}getSpan(Re,Fe){if(0<=this.span)return this.span;Fe===void 0&&(Fe=0);let qe=0;return this.union.usesPrefixDiscriminator&&(qe=this.union.discriminator.layout.span),qe+this.layout.getSpan(Re,Fe+qe)}decode(Re,Fe){const qe=this.makeDestinationObject();if(Fe===void 0&&(Fe=0),this!==this.union.getVariant(Re,Fe))throw new Error("variant mismatch");let We=0;return this.union.usesPrefixDiscriminator&&(We=this.union.discriminator.layout.span),this.layout?qe[this.property]=this.layout.decode(Re,Fe+We):this.property?qe[this.property]=!0:this.union.usesPrefixDiscriminator&&(qe[this.union.discriminator.property]=this.variant),qe}encode(Re,Fe,qe){qe===void 0&&(qe=0);let We=0;if(this.union.usesPrefixDiscriminator&&(We=this.union.discriminator.layout.span),this.layout&&!Re.hasOwnProperty(this.property))throw new TypeError("variant lacks property "+this.property);this.union.discriminator.encode(this.variant,Fe,qe);let Ze=We;if(this.layout&&(this.layout.encode(Re[this.property],Fe,qe+We),Ze+=this.layout.getSpan(Fe,qe+We),0<=this.union.span&&Ze>this.union.span))throw new Error("encoded variant overruns containing union");return Ze}fromArray(Re){if(this.layout)return this.layout.fromArray(Re)}}function fixBitwiseResult(Ke){return 0>Ke&&(Ke+=4294967296),Ke}class BitStructure extends Layout{constructor(Re,Fe,qe){if(!(Re instanceof UInt||Re instanceof UIntBE))throw new TypeError("word must be a UInt or UIntBE layout");if(typeof Fe=="string"&&qe===void 0&&(qe=Fe,Fe=void 0),4<Re.span)throw new RangeError("word cannot exceed 32 bits");super(Re.span,qe),this.word=Re,this.msb=!!Fe,this.fields=[];let We=0;this._packedSetValue=function(Ze){return We=fixBitwiseResult(Ze),this},this._packedGetValue=function(){return We}}decode(Re,Fe){const qe=this.makeDestinationObject();Fe===void 0&&(Fe=0);const We=this.word.decode(Re,Fe);this._packedSetValue(We);for(const Ze of this.fields)Ze.property!==void 0&&(qe[Ze.property]=Ze.decode(We));return qe}encode(Re,Fe,qe){qe===void 0&&(qe=0);const We=this.word.decode(Fe,qe);this._packedSetValue(We);for(const Ze of this.fields)if(Ze.property!==void 0){const Xe=Re[Ze.property];Xe!==void 0&&Ze.encode(Xe)}return this.word.encode(this._packedGetValue(),Fe,qe)}addField(Re,Fe){const qe=new BitField(this,Re,Fe);return this.fields.push(qe),qe}addBoolean(Re){const Fe=new Boolean$1(this,Re);return this.fields.push(Fe),Fe}fieldFor(Re){if(typeof Re!="string")throw new TypeError("property must be string");for(const Fe of this.fields)if(Fe.property===Re)return Fe}}class BitField{constructor(Re,Fe,qe){if(!(Re instanceof BitStructure))throw new TypeError("container must be a BitStructure");if(!Number.isInteger(Fe)||0>=Fe)throw new TypeError("bits must be positive integer");const We=8*Re.span,Ze=Re.fields.reduce((Xe,Je)=>Xe+Je.bits,0);if(Fe+Ze>We)throw new Error("bits too long for span remainder ("+(We-Ze)+" of "+We+" remain)");this.container=Re,this.bits=Fe,this.valueMask=(1<<Fe)-1,Fe===32&&(this.valueMask=4294967295),this.start=Ze,this.container.msb&&(this.start=We-Ze-Fe),this.wordMask=fixBitwiseResult(this.valueMask<<this.start),this.property=qe}decode(){const Re=this.container._packedGetValue();return fixBitwiseResult(Re&this.wordMask)>>>this.start}encode(Re){if(!Number.isInteger(Re)||Re!==fixBitwiseResult(Re&this.valueMask))throw new TypeError(nameWithProperty("BitField.encode",this)+" value must be integer not exceeding "+this.valueMask);const Fe=this.container._packedGetValue(),qe=fixBitwiseResult(Re<<this.start);this.container._packedSetValue(fixBitwiseResult(Fe&~this.wordMask)|qe)}}class Boolean$1 extends BitField{constructor(Re,Fe){super(Re,1,Fe)}decode(Re,Fe){return!!BitField.prototype.decode.call(this,Re,Fe)}encode(Re){return typeof Re=="boolean"&&(Re=+Re),BitField.prototype.encode.call(this,Re)}}class Blob$1 extends Layout{constructor(Re,Fe){if(!(Re instanceof ExternalLayout&&Re.isCount()||Number.isInteger(Re)&&0<=Re))throw new TypeError("length must be positive integer or an unsigned integer ExternalLayout");let qe=-1;Re instanceof ExternalLayout||(qe=Re),super(qe,Fe),this.length=Re}getSpan(Re,Fe){let qe=this.span;return 0>qe&&(qe=this.length.decode(Re,Fe)),qe}decode(Re,Fe){Fe===void 0&&(Fe=0);let qe=this.span;return 0>qe&&(qe=this.length.decode(Re,Fe)),Re.slice(Fe,Fe+qe)}encode(Re,Fe,qe){let We=this.length;if(this.length instanceof ExternalLayout&&(We=Re.length),!(Buffer.isBuffer(Re)&&We===Re.length))throw new TypeError(nameWithProperty("Blob.encode",this)+" requires (length "+We+") Buffer as src");if(qe+We>Fe.length)throw new RangeError("encoding overruns Buffer");return Fe.write(Re.toString("hex"),qe,We,"hex"),this.length instanceof ExternalLayout&&this.length.encode(We,Fe,qe),We}}class CString extends Layout{constructor(Re){super(-1,Re)}getSpan(Re,Fe){if(!Buffer.isBuffer(Re))throw new TypeError("b must be a Buffer");Fe===void 0&&(Fe=0);let qe=Fe;for(;qe<Re.length&&Re[qe]!==0;)qe+=1;return 1+qe-Fe}decode(Re,Fe,qe){Fe===void 0&&(Fe=0);let We=this.getSpan(Re,Fe);return Re.slice(Fe,Fe+We-1).toString("utf-8")}encode(Re,Fe,qe){qe===void 0&&(qe=0),typeof Re!="string"&&(Re=Re.toString());const We=new Buffer(Re,"utf8"),Ze=We.length;if(qe+Ze>Fe.length)throw new RangeError("encoding overruns Buffer");return We.copy(Fe,qe),Fe[qe+Ze]=0,Ze+1}}class UTF8 extends Layout{constructor(Re,Fe){if(typeof Re=="string"&&Fe===void 0&&(Fe=Re,Re=void 0),Re===void 0)Re=-1;else if(!Number.isInteger(Re))throw new TypeError("maxSpan must be an integer");super(-1,Fe),this.maxSpan=Re}getSpan(Re,Fe){if(!Buffer.isBuffer(Re))throw new TypeError("b must be a Buffer");return Fe===void 0&&(Fe=0),Re.length-Fe}decode(Re,Fe,qe){Fe===void 0&&(Fe=0);let We=this.getSpan(Re,Fe);if(0<=this.maxSpan&&this.maxSpan<We)throw new RangeError("text length exceeds maxSpan");return Re.slice(Fe,Fe+We).toString("utf-8")}encode(Re,Fe,qe){qe===void 0&&(qe=0),typeof Re!="string"&&(Re=Re.toString());const We=new Buffer(Re,"utf8"),Ze=We.length;if(0<=this.maxSpan&&this.maxSpan<Ze)throw new RangeError("text length exceeds maxSpan");if(qe+Ze>Fe.length)throw new RangeError("encoding overruns Buffer");return We.copy(Fe,qe),Ze}}class Constant extends Layout{constructor(Re,Fe){super(0,Fe),this.value=Re}decode(Re,Fe,qe){return this.value}encode(Re,Fe,qe){return 0}}Layout$1.ExternalLayout=ExternalLayout;Layout$1.GreedyCount=GreedyCount;Layout$1.OffsetLayout=OffsetLayout;Layout$1.UInt=UInt;Layout$1.UIntBE=UIntBE;Layout$1.Int=Int;Layout$1.IntBE=IntBE;Layout$1.Float=Float;Layout$1.FloatBE=FloatBE;Layout$1.Double=Double;Layout$1.DoubleBE=DoubleBE;Layout$1.Sequence=Sequence;Layout$1.Structure=Structure;Layout$1.UnionDiscriminator=UnionDiscriminator;Layout$1.UnionLayoutDiscriminator=UnionLayoutDiscriminator;Layout$1.Union=Union;Layout$1.VariantLayout=VariantLayout;Layout$1.BitStructure=BitStructure;Layout$1.BitField=BitField;Layout$1.Boolean=Boolean$1;Layout$1.Blob=Blob$1;Layout$1.CString=CString;Layout$1.UTF8=UTF8;Layout$1.Constant=Constant;Layout$1.greedy=(Ke,Re)=>new GreedyCount(Ke,Re);Layout$1.offset=(Ke,Re,Fe)=>new OffsetLayout(Ke,Re,Fe);Layout$1.u8=Ke=>new UInt(1,Ke);Layout$1.u16=Ke=>new UInt(2,Ke);Layout$1.u24=Ke=>new UInt(3,Ke);Layout$1.u32=Ke=>new UInt(4,Ke);Layout$1.u40=Ke=>new UInt(5,Ke);Layout$1.u48=Ke=>new UInt(6,Ke);Layout$1.nu64=Ke=>new NearUInt64(Ke);Layout$1.u16be=Ke=>new UIntBE(2,Ke);Layout$1.u24be=Ke=>new UIntBE(3,Ke);Layout$1.u32be=Ke=>new UIntBE(4,Ke);Layout$1.u40be=Ke=>new UIntBE(5,Ke);Layout$1.u48be=Ke=>new UIntBE(6,Ke);Layout$1.nu64be=Ke=>new NearUInt64BE(Ke);Layout$1.s8=Ke=>new Int(1,Ke);Layout$1.s16=Ke=>new Int(2,Ke);Layout$1.s24=Ke=>new Int(3,Ke);Layout$1.s32=Ke=>new Int(4,Ke);Layout$1.s40=Ke=>new Int(5,Ke);Layout$1.s48=Ke=>new Int(6,Ke);Layout$1.ns64=Ke=>new NearInt64(Ke);Layout$1.s16be=Ke=>new IntBE(2,Ke);Layout$1.s24be=Ke=>new IntBE(3,Ke);Layout$1.s32be=Ke=>new IntBE(4,Ke);Layout$1.s40be=Ke=>new IntBE(5,Ke);Layout$1.s48be=Ke=>new IntBE(6,Ke);Layout$1.ns64be=Ke=>new NearInt64BE(Ke);Layout$1.f32=Ke=>new Float(Ke);Layout$1.f32be=Ke=>new FloatBE(Ke);Layout$1.f64=Ke=>new Double(Ke);Layout$1.f64be=Ke=>new DoubleBE(Ke);Layout$1.struct=(Ke,Re,Fe)=>new Structure(Ke,Re,Fe);Layout$1.bits=(Ke,Re,Fe)=>new BitStructure(Ke,Re,Fe);Layout$1.seq=(Ke,Re,Fe)=>new Sequence(Ke,Re,Fe);Layout$1.union=(Ke,Re,Fe)=>new Union(Ke,Re,Fe);Layout$1.unionLayoutDiscriminator=(Ke,Re)=>new UnionLayoutDiscriminator(Ke,Re);Layout$1.blob=(Ke,Re)=>new Blob$1(Ke,Re);Layout$1.cstr=Ke=>new CString(Ke);Layout$1.utf8=(Ke,Re)=>new UTF8(Ke,Re);Layout$1.const=(Ke,Re)=>new Constant(Ke,Re);const require$$1=getAugmentedNamespace(index_browser_esm);(function(Ke){var Re=commonjsGlobal&&commonjsGlobal.__importDefault||function(Lr){return Lr&&Lr.__esModule?Lr:{default:Lr}};Object.defineProperty(Ke,"__esModule",{value:!0}),Ke.map=Ke.array=Ke.rustEnum=Ke.str=Ke.vecU8=Ke.tagged=Ke.vec=Ke.bool=Ke.option=Ke.publicKey=Ke.i128=Ke.u128=Ke.i64=Ke.u64=Ke.struct=Ke.f64=Ke.f32=Ke.i32=Ke.u32=Ke.i16=Ke.u16=Ke.i8=Ke.u8=void 0;const Fe=Layout$1,qe=require$$1,We=Re(bn$1.exports);var Ze=Layout$1;Object.defineProperty(Ke,"u8",{enumerable:!0,get:function(){return Ze.u8}}),Object.defineProperty(Ke,"i8",{enumerable:!0,get:function(){return Ze.s8}}),Object.defineProperty(Ke,"u16",{enumerable:!0,get:function(){return Ze.u16}}),Object.defineProperty(Ke,"i16",{enumerable:!0,get:function(){return Ze.s16}}),Object.defineProperty(Ke,"u32",{enumerable:!0,get:function(){return Ze.u32}}),Object.defineProperty(Ke,"i32",{enumerable:!0,get:function(){return Ze.s32}}),Object.defineProperty(Ke,"f32",{enumerable:!0,get:function(){return Ze.f32}}),Object.defineProperty(Ke,"f64",{enumerable:!0,get:function(){return Ze.f64}}),Object.defineProperty(Ke,"struct",{enumerable:!0,get:function(){return Ze.struct}});class Xe extends Fe.Layout{constructor($r,Nr,cr){super($r,cr),this.blob=Fe.blob($r),this.signed=Nr}decode($r,Nr=0){const cr=new We.default(this.blob.decode($r,Nr),10,"le");return this.signed?cr.fromTwos(this.span*8).clone():cr}encode($r,Nr,cr=0){return this.signed&&($r=$r.toTwos(this.span*8)),this.blob.encode($r.toArrayLike(Buffer,"le",this.span),Nr,cr)}}function Je(Lr){return new Xe(8,!1,Lr)}Ke.u64=Je;function tr(Lr){return new Xe(8,!0,Lr)}Ke.i64=tr;function er(Lr){return new Xe(16,!1,Lr)}Ke.u128=er;function ir(Lr){return new Xe(16,!0,Lr)}Ke.i128=ir;class ur extends Fe.Layout{constructor($r,Nr,cr,Dt){super($r.span,Dt),this.layout=$r,this.decoder=Nr,this.encoder=cr}decode($r,Nr){return this.decoder(this.layout.decode($r,Nr))}encode($r,Nr,cr){return this.layout.encode(this.encoder($r),Nr,cr)}getSpan($r,Nr){return this.layout.getSpan($r,Nr)}}function fr(Lr){return new ur(Fe.blob(32),$r=>new qe.PublicKey($r),$r=>$r.toBuffer(),Lr)}Ke.publicKey=fr;class ar extends Fe.Layout{constructor($r,Nr){super(-1,Nr),this.layout=$r,this.discriminator=Fe.u8()}encode($r,Nr,cr=0){return $r==null?this.discriminator.encode(0,Nr,cr):(this.discriminator.encode(1,Nr,cr),this.layout.encode($r,Nr,cr+1)+1)}decode($r,Nr=0){const cr=this.discriminator.decode($r,Nr);if(cr===0)return null;if(cr===1)return this.layout.decode($r,Nr+1);throw new Error("Invalid option "+this.property)}getSpan($r,Nr=0){const cr=this.discriminator.decode($r,Nr);if(cr===0)return 1;if(cr===1)return this.layout.getSpan($r,Nr+1)+1;throw new Error("Invalid option "+this.property)}}function yr(Lr,$r){return new ar(Lr,$r)}Ke.option=yr;function mr(Lr){return new ur(Fe.u8(),wr,Sr,Lr)}Ke.bool=mr;function wr(Lr){if(Lr===0)return!1;if(Lr===1)return!0;throw new Error("Invalid bool: "+Lr)}function Sr(Lr){return Lr?1:0}function Ar(Lr,$r){const Nr=Fe.u32("length"),cr=Fe.struct([Nr,Fe.seq(Lr,Fe.offset(Nr,-Nr.span),"values")]);return new ur(cr,({values:Dt})=>Dt,Dt=>({values:Dt}),$r)}Ke.vec=Ar;function vr(Lr,$r,Nr){const cr=Fe.struct([Je("tag"),$r.replicate("data")]);function Dt({tag:sr,data:lr}){if(!sr.eq(Lr))throw new Error("Invalid tag, expected: "+Lr.toString("hex")+", got: "+sr.toString("hex"));return lr}return new ur(cr,Dt,sr=>({tag:Lr,data:sr}),Nr)}Ke.tagged=vr;function Ir(Lr){const $r=Fe.u32("length"),Nr=Fe.struct([$r,Fe.blob(Fe.offset($r,-$r.span),"data")]);return new ur(Nr,({data:cr})=>cr,cr=>({data:cr}),Lr)}Ke.vecU8=Ir;function Tr(Lr){return new ur(Ir(),$r=>$r.toString("utf-8"),$r=>Buffer.from($r,"utf-8"),Lr)}Ke.str=Tr;function Pr(Lr,$r,Nr){const cr=Fe.union(Nr!=null?Nr:Fe.u8(),$r);return Lr.forEach((Dt,sr)=>cr.addVariant(sr,Dt,Dt.property)),cr}Ke.rustEnum=Pr;function Rr(Lr,$r,Nr){const cr=Fe.struct([Fe.seq(Lr,$r,"values")]);return new ur(cr,({values:Dt})=>Dt,Dt=>({values:Dt}),Nr)}Ke.array=Rr;class Br extends Fe.Layout{constructor($r,Nr,cr){super($r.span+Nr.span,cr),this.keyLayout=$r,this.valueLayout=Nr}decode($r,Nr){Nr=Nr||0;const cr=this.keyLayout.decode($r,Nr),Dt=this.valueLayout.decode($r,Nr+this.keyLayout.getSpan($r,Nr));return[cr,Dt]}encode($r,Nr,cr){cr=cr||0;const Dt=this.keyLayout.encode($r[0],Nr,cr),sr=this.valueLayout.encode($r[1],Nr,cr+Dt);return Dt+sr}getSpan($r,Nr){return this.keyLayout.getSpan($r,Nr)+this.valueLayout.getSpan($r,Nr)}}function Mr(Lr,$r,Nr){const cr=Fe.u32("length"),Dt=Fe.struct([cr,Fe.seq(new Br(Lr,$r),Fe.offset(cr,-cr.span),"values")]);return new ur(Dt,({values:sr})=>new Map(sr),sr=>({values:Array.from(sr.entries())}),Nr)}Ke.map=Mr})(lib);/*! pako 2.0.4 https://github.com/nodeca/pako @license (MIT AND Zlib) */const Z_FIXED$1=4,Z_BINARY=0,Z_TEXT=1,Z_UNKNOWN$1=2;function zero$1(Ke){let Re=Ke.length;for(;--Re>=0;)Ke[Re]=0}const STORED_BLOCK=0,STATIC_TREES=1,DYN_TREES=2,MIN_MATCH$1=3,MAX_MATCH$1=258,LENGTH_CODES$1=29,LITERALS$1=256,L_CODES$1=LITERALS$1+1+LENGTH_CODES$1,D_CODES$1=30,BL_CODES$1=19,HEAP_SIZE$1=2*L_CODES$1+1,MAX_BITS$1=15,Buf_size=16,MAX_BL_BITS=7,END_BLOCK=256,REP_3_6=16,REPZ_3_10=17,REPZ_11_138=18,extra_lbits=new Uint8Array([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0]),extra_dbits=new Uint8Array([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13]),extra_blbits=new Uint8Array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7]),bl_order=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),DIST_CODE_LEN=512,static_ltree=new Array((L_CODES$1+2)*2);zero$1(static_ltree);const static_dtree=new Array(D_CODES$1*2);zero$1(static_dtree);const _dist_code=new Array(DIST_CODE_LEN);zero$1(_dist_code);const _length_code=new Array(MAX_MATCH$1-MIN_MATCH$1+1);zero$1(_length_code);const base_length=new Array(LENGTH_CODES$1);zero$1(base_length);const base_dist=new Array(D_CODES$1);zero$1(base_dist);function StaticTreeDesc(Ke,Re,Fe,qe,We){this.static_tree=Ke,this.extra_bits=Re,this.extra_base=Fe,this.elems=qe,this.max_length=We,this.has_stree=Ke&&Ke.length}let static_l_desc,static_d_desc,static_bl_desc;function TreeDesc(Ke,Re){this.dyn_tree=Ke,this.max_code=0,this.stat_desc=Re}const d_code=Ke=>Ke<256?_dist_code[Ke]:_dist_code[256+(Ke>>>7)],put_short=(Ke,Re)=>{Ke.pending_buf[Ke.pending++]=Re&255,Ke.pending_buf[Ke.pending++]=Re>>>8&255},send_bits=(Ke,Re,Fe)=>{Ke.bi_valid>Buf_size-Fe?(Ke.bi_buf|=Re<<Ke.bi_valid&65535,put_short(Ke,Ke.bi_buf),Ke.bi_buf=Re>>Buf_size-Ke.bi_valid,Ke.bi_valid+=Fe-Buf_size):(Ke.bi_buf|=Re<<Ke.bi_valid&65535,Ke.bi_valid+=Fe)},send_code=(Ke,Re,Fe)=>{send_bits(Ke,Fe[Re*2],Fe[Re*2+1])},bi_reverse=(Ke,Re)=>{let Fe=0;do Fe|=Ke&1,Ke>>>=1,Fe<<=1;while(--Re>0);return Fe>>>1},bi_flush=Ke=>{Ke.bi_valid===16?(put_short(Ke,Ke.bi_buf),Ke.bi_buf=0,Ke.bi_valid=0):Ke.bi_valid>=8&&(Ke.pending_buf[Ke.pending++]=Ke.bi_buf&255,Ke.bi_buf>>=8,Ke.bi_valid-=8)},gen_bitlen=(Ke,Re)=>{const Fe=Re.dyn_tree,qe=Re.max_code,We=Re.stat_desc.static_tree,Ze=Re.stat_desc.has_stree,Xe=Re.stat_desc.extra_bits,Je=Re.stat_desc.extra_base,tr=Re.stat_desc.max_length;let er,ir,ur,fr,ar,yr,mr=0;for(fr=0;fr<=MAX_BITS$1;fr++)Ke.bl_count[fr]=0;for(Fe[Ke.heap[Ke.heap_max]*2+1]=0,er=Ke.heap_max+1;er<HEAP_SIZE$1;er++)ir=Ke.heap[er],fr=Fe[Fe[ir*2+1]*2+1]+1,fr>tr&&(fr=tr,mr++),Fe[ir*2+1]=fr,!(ir>qe)&&(Ke.bl_count[fr]++,ar=0,ir>=Je&&(ar=Xe[ir-Je]),yr=Fe[ir*2],Ke.opt_len+=yr*(fr+ar),Ze&&(Ke.static_len+=yr*(We[ir*2+1]+ar)));if(mr!==0){do{for(fr=tr-1;Ke.bl_count[fr]===0;)fr--;Ke.bl_count[fr]--,Ke.bl_count[fr+1]+=2,Ke.bl_count[tr]--,mr-=2}while(mr>0);for(fr=tr;fr!==0;fr--)for(ir=Ke.bl_count[fr];ir!==0;)ur=Ke.heap[--er],!(ur>qe)&&(Fe[ur*2+1]!==fr&&(Ke.opt_len+=(fr-Fe[ur*2+1])*Fe[ur*2],Fe[ur*2+1]=fr),ir--)}},gen_codes=(Ke,Re,Fe)=>{const qe=new Array(MAX_BITS$1+1);let We=0,Ze,Xe;for(Ze=1;Ze<=MAX_BITS$1;Ze++)qe[Ze]=We=We+Fe[Ze-1]<<1;for(Xe=0;Xe<=Re;Xe++){let Je=Ke[Xe*2+1];Je!==0&&(Ke[Xe*2]=bi_reverse(qe[Je]++,Je))}},tr_static_init=()=>{let Ke,Re,Fe,qe,We;const Ze=new Array(MAX_BITS$1+1);for(Fe=0,qe=0;qe<LENGTH_CODES$1-1;qe++)for(base_length[qe]=Fe,Ke=0;Ke<1<<extra_lbits[qe];Ke++)_length_code[Fe++]=qe;for(_length_code[Fe-1]=qe,We=0,qe=0;qe<16;qe++)for(base_dist[qe]=We,Ke=0;Ke<1<<extra_dbits[qe];Ke++)_dist_code[We++]=qe;for(We>>=7;qe<D_CODES$1;qe++)for(base_dist[qe]=We<<7,Ke=0;Ke<1<<extra_dbits[qe]-7;Ke++)_dist_code[256+We++]=qe;for(Re=0;Re<=MAX_BITS$1;Re++)Ze[Re]=0;for(Ke=0;Ke<=143;)static_ltree[Ke*2+1]=8,Ke++,Ze[8]++;for(;Ke<=255;)static_ltree[Ke*2+1]=9,Ke++,Ze[9]++;for(;Ke<=279;)static_ltree[Ke*2+1]=7,Ke++,Ze[7]++;for(;Ke<=287;)static_ltree[Ke*2+1]=8,Ke++,Ze[8]++;for(gen_codes(static_ltree,L_CODES$1+1,Ze),Ke=0;Ke<D_CODES$1;Ke++)static_dtree[Ke*2+1]=5,static_dtree[Ke*2]=bi_reverse(Ke,5);static_l_desc=new StaticTreeDesc(static_ltree,extra_lbits,LITERALS$1+1,L_CODES$1,MAX_BITS$1),static_d_desc=new StaticTreeDesc(static_dtree,extra_dbits,0,D_CODES$1,MAX_BITS$1),static_bl_desc=new StaticTreeDesc(new Array(0),extra_blbits,0,BL_CODES$1,MAX_BL_BITS)},init_block=Ke=>{let Re;for(Re=0;Re<L_CODES$1;Re++)Ke.dyn_ltree[Re*2]=0;for(Re=0;Re<D_CODES$1;Re++)Ke.dyn_dtree[Re*2]=0;for(Re=0;Re<BL_CODES$1;Re++)Ke.bl_tree[Re*2]=0;Ke.dyn_ltree[END_BLOCK*2]=1,Ke.opt_len=Ke.static_len=0,Ke.last_lit=Ke.matches=0},bi_windup=Ke=>{Ke.bi_valid>8?put_short(Ke,Ke.bi_buf):Ke.bi_valid>0&&(Ke.pending_buf[Ke.pending++]=Ke.bi_buf),Ke.bi_buf=0,Ke.bi_valid=0},copy_block=(Ke,Re,Fe,qe)=>{bi_windup(Ke),qe&&(put_short(Ke,Fe),put_short(Ke,~Fe)),Ke.pending_buf.set(Ke.window.subarray(Re,Re+Fe),Ke.pending),Ke.pending+=Fe},smaller=(Ke,Re,Fe,qe)=>{const We=Re*2,Ze=Fe*2;return Ke[We]<Ke[Ze]||Ke[We]===Ke[Ze]&&qe[Re]<=qe[Fe]},pqdownheap=(Ke,Re,Fe)=>{const qe=Ke.heap[Fe];let We=Fe<<1;for(;We<=Ke.heap_len&&(We<Ke.heap_len&&smaller(Re,Ke.heap[We+1],Ke.heap[We],Ke.depth)&&We++,!smaller(Re,qe,Ke.heap[We],Ke.depth));)Ke.heap[Fe]=Ke.heap[We],Fe=We,We<<=1;Ke.heap[Fe]=qe},compress_block=(Ke,Re,Fe)=>{let qe,We,Ze=0,Xe,Je;if(Ke.last_lit!==0)do qe=Ke.pending_buf[Ke.d_buf+Ze*2]<<8|Ke.pending_buf[Ke.d_buf+Ze*2+1],We=Ke.pending_buf[Ke.l_buf+Ze],Ze++,qe===0?send_code(Ke,We,Re):(Xe=_length_code[We],send_code(Ke,Xe+LITERALS$1+1,Re),Je=extra_lbits[Xe],Je!==0&&(We-=base_length[Xe],send_bits(Ke,We,Je)),qe--,Xe=d_code(qe),send_code(Ke,Xe,Fe),Je=extra_dbits[Xe],Je!==0&&(qe-=base_dist[Xe],send_bits(Ke,qe,Je)));while(Ze<Ke.last_lit);send_code(Ke,END_BLOCK,Re)},build_tree=(Ke,Re)=>{const Fe=Re.dyn_tree,qe=Re.stat_desc.static_tree,We=Re.stat_desc.has_stree,Ze=Re.stat_desc.elems;let Xe,Je,tr=-1,er;for(Ke.heap_len=0,Ke.heap_max=HEAP_SIZE$1,Xe=0;Xe<Ze;Xe++)Fe[Xe*2]!==0?(Ke.heap[++Ke.heap_len]=tr=Xe,Ke.depth[Xe]=0):Fe[Xe*2+1]=0;for(;Ke.heap_len<2;)er=Ke.heap[++Ke.heap_len]=tr<2?++tr:0,Fe[er*2]=1,Ke.depth[er]=0,Ke.opt_len--,We&&(Ke.static_len-=qe[er*2+1]);for(Re.max_code=tr,Xe=Ke.heap_len>>1;Xe>=1;Xe--)pqdownheap(Ke,Fe,Xe);er=Ze;do Xe=Ke.heap[1],Ke.heap[1]=Ke.heap[Ke.heap_len--],pqdownheap(Ke,Fe,1),Je=Ke.heap[1],Ke.heap[--Ke.heap_max]=Xe,Ke.heap[--Ke.heap_max]=Je,Fe[er*2]=Fe[Xe*2]+Fe[Je*2],Ke.depth[er]=(Ke.depth[Xe]>=Ke.depth[Je]?Ke.depth[Xe]:Ke.depth[Je])+1,Fe[Xe*2+1]=Fe[Je*2+1]=er,Ke.heap[1]=er++,pqdownheap(Ke,Fe,1);while(Ke.heap_len>=2);Ke.heap[--Ke.heap_max]=Ke.heap[1],gen_bitlen(Ke,Re),gen_codes(Fe,tr,Ke.bl_count)},scan_tree=(Ke,Re,Fe)=>{let qe,We=-1,Ze,Xe=Re[0*2+1],Je=0,tr=7,er=4;for(Xe===0&&(tr=138,er=3),Re[(Fe+1)*2+1]=65535,qe=0;qe<=Fe;qe++)Ze=Xe,Xe=Re[(qe+1)*2+1],!(++Je<tr&&Ze===Xe)&&(Je<er?Ke.bl_tree[Ze*2]+=Je:Ze!==0?(Ze!==We&&Ke.bl_tree[Ze*2]++,Ke.bl_tree[REP_3_6*2]++):Je<=10?Ke.bl_tree[REPZ_3_10*2]++:Ke.bl_tree[REPZ_11_138*2]++,Je=0,We=Ze,Xe===0?(tr=138,er=3):Ze===Xe?(tr=6,er=3):(tr=7,er=4))},send_tree=(Ke,Re,Fe)=>{let qe,We=-1,Ze,Xe=Re[0*2+1],Je=0,tr=7,er=4;for(Xe===0&&(tr=138,er=3),qe=0;qe<=Fe;qe++)if(Ze=Xe,Xe=Re[(qe+1)*2+1],!(++Je<tr&&Ze===Xe)){if(Je<er)do send_code(Ke,Ze,Ke.bl_tree);while(--Je!==0);else Ze!==0?(Ze!==We&&(send_code(Ke,Ze,Ke.bl_tree),Je--),send_code(Ke,REP_3_6,Ke.bl_tree),send_bits(Ke,Je-3,2)):Je<=10?(send_code(Ke,REPZ_3_10,Ke.bl_tree),send_bits(Ke,Je-3,3)):(send_code(Ke,REPZ_11_138,Ke.bl_tree),send_bits(Ke,Je-11,7));Je=0,We=Ze,Xe===0?(tr=138,er=3):Ze===Xe?(tr=6,er=3):(tr=7,er=4)}},build_bl_tree=Ke=>{let Re;for(scan_tree(Ke,Ke.dyn_ltree,Ke.l_desc.max_code),scan_tree(Ke,Ke.dyn_dtree,Ke.d_desc.max_code),build_tree(Ke,Ke.bl_desc),Re=BL_CODES$1-1;Re>=3&&Ke.bl_tree[bl_order[Re]*2+1]===0;Re--);return Ke.opt_len+=3*(Re+1)+5+5+4,Re},send_all_trees=(Ke,Re,Fe,qe)=>{let We;for(send_bits(Ke,Re-257,5),send_bits(Ke,Fe-1,5),send_bits(Ke,qe-4,4),We=0;We<qe;We++)send_bits(Ke,Ke.bl_tree[bl_order[We]*2+1],3);send_tree(Ke,Ke.dyn_ltree,Re-1),send_tree(Ke,Ke.dyn_dtree,Fe-1)},detect_data_type=Ke=>{let Re=4093624447,Fe;for(Fe=0;Fe<=31;Fe++,Re>>>=1)if(Re&1&&Ke.dyn_ltree[Fe*2]!==0)return Z_BINARY;if(Ke.dyn_ltree[9*2]!==0||Ke.dyn_ltree[10*2]!==0||Ke.dyn_ltree[13*2]!==0)return Z_TEXT;for(Fe=32;Fe<LITERALS$1;Fe++)if(Ke.dyn_ltree[Fe*2]!==0)return Z_TEXT;return Z_BINARY};let static_init_done=!1;const _tr_init$1=Ke=>{static_init_done||(tr_static_init(),static_init_done=!0),Ke.l_desc=new TreeDesc(Ke.dyn_ltree,static_l_desc),Ke.d_desc=new TreeDesc(Ke.dyn_dtree,static_d_desc),Ke.bl_desc=new TreeDesc(Ke.bl_tree,static_bl_desc),Ke.bi_buf=0,Ke.bi_valid=0,init_block(Ke)},_tr_stored_block$1=(Ke,Re,Fe,qe)=>{send_bits(Ke,(STORED_BLOCK<<1)+(qe?1:0),3),copy_block(Ke,Re,Fe,!0)},_tr_align$1=Ke=>{send_bits(Ke,STATIC_TREES<<1,3),send_code(Ke,END_BLOCK,static_ltree),bi_flush(Ke)},_tr_flush_block$1=(Ke,Re,Fe,qe)=>{let We,Ze,Xe=0;Ke.level>0?(Ke.strm.data_type===Z_UNKNOWN$1&&(Ke.strm.data_type=detect_data_type(Ke)),build_tree(Ke,Ke.l_desc),build_tree(Ke,Ke.d_desc),Xe=build_bl_tree(Ke),We=Ke.opt_len+3+7>>>3,Ze=Ke.static_len+3+7>>>3,Ze<=We&&(We=Ze)):We=Ze=Fe+5,Fe+4<=We&&Re!==-1?_tr_stored_block$1(Ke,Re,Fe,qe):Ke.strategy===Z_FIXED$1||Ze===We?(send_bits(Ke,(STATIC_TREES<<1)+(qe?1:0),3),compress_block(Ke,static_ltree,static_dtree)):(send_bits(Ke,(DYN_TREES<<1)+(qe?1:0),3),send_all_trees(Ke,Ke.l_desc.max_code+1,Ke.d_desc.max_code+1,Xe+1),compress_block(Ke,Ke.dyn_ltree,Ke.dyn_dtree)),init_block(Ke),qe&&bi_windup(Ke)},_tr_tally$1=(Ke,Re,Fe)=>(Ke.pending_buf[Ke.d_buf+Ke.last_lit*2]=Re>>>8&255,Ke.pending_buf[Ke.d_buf+Ke.last_lit*2+1]=Re&255,Ke.pending_buf[Ke.l_buf+Ke.last_lit]=Fe&255,Ke.last_lit++,Re===0?Ke.dyn_ltree[Fe*2]++:(Ke.matches++,Re--,Ke.dyn_ltree[(_length_code[Fe]+LITERALS$1+1)*2]++,Ke.dyn_dtree[d_code(Re)*2]++),Ke.last_lit===Ke.lit_bufsize-1);var _tr_init_1=_tr_init$1,_tr_stored_block_1=_tr_stored_block$1,_tr_flush_block_1=_tr_flush_block$1,_tr_tally_1=_tr_tally$1,_tr_align_1=_tr_align$1,trees={_tr_init:_tr_init_1,_tr_stored_block:_tr_stored_block_1,_tr_flush_block:_tr_flush_block_1,_tr_tally:_tr_tally_1,_tr_align:_tr_align_1};const adler32=(Ke,Re,Fe,qe)=>{let We=Ke&65535|0,Ze=Ke>>>16&65535|0,Xe=0;for(;Fe!==0;){Xe=Fe>2e3?2e3:Fe,Fe-=Xe;do We=We+Re[qe++]|0,Ze=Ze+We|0;while(--Xe);We%=65521,Ze%=65521}return We|Ze<<16|0};var adler32_1=adler32;const makeTable=()=>{let Ke,Re=[];for(var Fe=0;Fe<256;Fe++){Ke=Fe;for(var qe=0;qe<8;qe++)Ke=Ke&1?3988292384^Ke>>>1:Ke>>>1;Re[Fe]=Ke}return Re},crcTable=new Uint32Array(makeTable()),crc32=(Ke,Re,Fe,qe)=>{const We=crcTable,Ze=qe+Fe;Ke^=-1;for(let Xe=qe;Xe<Ze;Xe++)Ke=Ke>>>8^We[(Ke^Re[Xe])&255];return Ke^-1};var crc32_1=crc32,messages={2:"need dictionary",1:"stream end",0:"","-1":"file error","-2":"stream error","-3":"data error","-4":"insufficient memory","-5":"buffer error","-6":"incompatible version"},constants$2={Z_NO_FLUSH:0,Z_PARTIAL_FLUSH:1,Z_SYNC_FLUSH:2,Z_FULL_FLUSH:3,Z_FINISH:4,Z_BLOCK:5,Z_TREES:6,Z_OK:0,Z_STREAM_END:1,Z_NEED_DICT:2,Z_ERRNO:-1,Z_STREAM_ERROR:-2,Z_DATA_ERROR:-3,Z_MEM_ERROR:-4,Z_BUF_ERROR:-5,Z_NO_COMPRESSION:0,Z_BEST_SPEED:1,Z_BEST_COMPRESSION:9,Z_DEFAULT_COMPRESSION:-1,Z_FILTERED:1,Z_HUFFMAN_ONLY:2,Z_RLE:3,Z_FIXED:4,Z_DEFAULT_STRATEGY:0,Z_BINARY:0,Z_TEXT:1,Z_UNKNOWN:2,Z_DEFLATED:8};const{_tr_init,_tr_stored_block,_tr_flush_block,_tr_tally,_tr_align}=trees,{Z_NO_FLUSH:Z_NO_FLUSH$2,Z_PARTIAL_FLUSH,Z_FULL_FLUSH:Z_FULL_FLUSH$1,Z_FINISH:Z_FINISH$3,Z_BLOCK:Z_BLOCK$1,Z_OK:Z_OK$3,Z_STREAM_END:Z_STREAM_END$3,Z_STREAM_ERROR:Z_STREAM_ERROR$2,Z_DATA_ERROR:Z_DATA_ERROR$2,Z_BUF_ERROR:Z_BUF_ERROR$1,Z_DEFAULT_COMPRESSION:Z_DEFAULT_COMPRESSION$1,Z_FILTERED,Z_HUFFMAN_ONLY,Z_RLE,Z_FIXED,Z_DEFAULT_STRATEGY:Z_DEFAULT_STRATEGY$1,Z_UNKNOWN,Z_DEFLATED:Z_DEFLATED$2}=constants$2,MAX_MEM_LEVEL=9,MAX_WBITS$1=15,DEF_MEM_LEVEL=8,LENGTH_CODES=29,LITERALS=256,L_CODES=LITERALS+1+LENGTH_CODES,D_CODES=30,BL_CODES=19,HEAP_SIZE=2*L_CODES+1,MAX_BITS=15,MIN_MATCH=3,MAX_MATCH=258,MIN_LOOKAHEAD=MAX_MATCH+MIN_MATCH+1,PRESET_DICT=32,INIT_STATE=42,EXTRA_STATE=69,NAME_STATE=73,COMMENT_STATE=91,HCRC_STATE=103,BUSY_STATE=113,FINISH_STATE=666,BS_NEED_MORE=1,BS_BLOCK_DONE=2,BS_FINISH_STARTED=3,BS_FINISH_DONE=4,OS_CODE=3,err=(Ke,Re)=>(Ke.msg=messages[Re],Re),rank=Ke=>(Ke<<1)-(Ke>4?9:0),zero=Ke=>{let Re=Ke.length;for(;--Re>=0;)Ke[Re]=0};let HASH_ZLIB=(Ke,Re,Fe)=>(Re<<Ke.hash_shift^Fe)&Ke.hash_mask,HASH=HASH_ZLIB;const flush_pending=Ke=>{const Re=Ke.state;let Fe=Re.pending;Fe>Ke.avail_out&&(Fe=Ke.avail_out),Fe!==0&&(Ke.output.set(Re.pending_buf.subarray(Re.pending_out,Re.pending_out+Fe),Ke.next_out),Ke.next_out+=Fe,Re.pending_out+=Fe,Ke.total_out+=Fe,Ke.avail_out-=Fe,Re.pending-=Fe,Re.pending===0&&(Re.pending_out=0))},flush_block_only=(Ke,Re)=>{_tr_flush_block(Ke,Ke.block_start>=0?Ke.block_start:-1,Ke.strstart-Ke.block_start,Re),Ke.block_start=Ke.strstart,flush_pending(Ke.strm)},put_byte=(Ke,Re)=>{Ke.pending_buf[Ke.pending++]=Re},putShortMSB=(Ke,Re)=>{Ke.pending_buf[Ke.pending++]=Re>>>8&255,Ke.pending_buf[Ke.pending++]=Re&255},read_buf=(Ke,Re,Fe,qe)=>{let We=Ke.avail_in;return We>qe&&(We=qe),We===0?0:(Ke.avail_in-=We,Re.set(Ke.input.subarray(Ke.next_in,Ke.next_in+We),Fe),Ke.state.wrap===1?Ke.adler=adler32_1(Ke.adler,Re,We,Fe):Ke.state.wrap===2&&(Ke.adler=crc32_1(Ke.adler,Re,We,Fe)),Ke.next_in+=We,Ke.total_in+=We,We)},longest_match=(Ke,Re)=>{let Fe=Ke.max_chain_length,qe=Ke.strstart,We,Ze,Xe=Ke.prev_length,Je=Ke.nice_match;const tr=Ke.strstart>Ke.w_size-MIN_LOOKAHEAD?Ke.strstart-(Ke.w_size-MIN_LOOKAHEAD):0,er=Ke.window,ir=Ke.w_mask,ur=Ke.prev,fr=Ke.strstart+MAX_MATCH;let ar=er[qe+Xe-1],yr=er[qe+Xe];Ke.prev_length>=Ke.good_match&&(Fe>>=2),Je>Ke.lookahead&&(Je=Ke.lookahead);do if(We=Re,!(er[We+Xe]!==yr||er[We+Xe-1]!==ar||er[We]!==er[qe]||er[++We]!==er[qe+1])){qe+=2,We++;do;while(er[++qe]===er[++We]&&er[++qe]===er[++We]&&er[++qe]===er[++We]&&er[++qe]===er[++We]&&er[++qe]===er[++We]&&er[++qe]===er[++We]&&er[++qe]===er[++We]&&er[++qe]===er[++We]&&qe<fr);if(Ze=MAX_MATCH-(fr-qe),qe=fr-MAX_MATCH,Ze>Xe){if(Ke.match_start=Re,Xe=Ze,Ze>=Je)break;ar=er[qe+Xe-1],yr=er[qe+Xe]}}while((Re=ur[Re&ir])>tr&&--Fe!==0);return Xe<=Ke.lookahead?Xe:Ke.lookahead},fill_window=Ke=>{const Re=Ke.w_size;let Fe,qe,We,Ze,Xe;do{if(Ze=Ke.window_size-Ke.lookahead-Ke.strstart,Ke.strstart>=Re+(Re-MIN_LOOKAHEAD)){Ke.window.set(Ke.window.subarray(Re,Re+Re),0),Ke.match_start-=Re,Ke.strstart-=Re,Ke.block_start-=Re,qe=Ke.hash_size,Fe=qe;do We=Ke.head[--Fe],Ke.head[Fe]=We>=Re?We-Re:0;while(--qe);qe=Re,Fe=qe;do We=Ke.prev[--Fe],Ke.prev[Fe]=We>=Re?We-Re:0;while(--qe);Ze+=Re}if(Ke.strm.avail_in===0)break;if(qe=read_buf(Ke.strm,Ke.window,Ke.strstart+Ke.lookahead,Ze),Ke.lookahead+=qe,Ke.lookahead+Ke.insert>=MIN_MATCH)for(Xe=Ke.strstart-Ke.insert,Ke.ins_h=Ke.window[Xe],Ke.ins_h=HASH(Ke,Ke.ins_h,Ke.window[Xe+1]);Ke.insert&&(Ke.ins_h=HASH(Ke,Ke.ins_h,Ke.window[Xe+MIN_MATCH-1]),Ke.prev[Xe&Ke.w_mask]=Ke.head[Ke.ins_h],Ke.head[Ke.ins_h]=Xe,Xe++,Ke.insert--,!(Ke.lookahead+Ke.insert<MIN_MATCH)););}while(Ke.lookahead<MIN_LOOKAHEAD&&Ke.strm.avail_in!==0)},deflate_stored=(Ke,Re)=>{let Fe=65535;for(Fe>Ke.pending_buf_size-5&&(Fe=Ke.pending_buf_size-5);;){if(Ke.lookahead<=1){if(fill_window(Ke),Ke.lookahead===0&&Re===Z_NO_FLUSH$2)return BS_NEED_MORE;if(Ke.lookahead===0)break}Ke.strstart+=Ke.lookahead,Ke.lookahead=0;const qe=Ke.block_start+Fe;if((Ke.strstart===0||Ke.strstart>=qe)&&(Ke.lookahead=Ke.strstart-qe,Ke.strstart=qe,flush_block_only(Ke,!1),Ke.strm.avail_out===0)||Ke.strstart-Ke.block_start>=Ke.w_size-MIN_LOOKAHEAD&&(flush_block_only(Ke,!1),Ke.strm.avail_out===0))return BS_NEED_MORE}return Ke.insert=0,Re===Z_FINISH$3?(flush_block_only(Ke,!0),Ke.strm.avail_out===0?BS_FINISH_STARTED:BS_FINISH_DONE):(Ke.strstart>Ke.block_start&&(flush_block_only(Ke,!1),Ke.strm.avail_out===0),BS_NEED_MORE)},deflate_fast=(Ke,Re)=>{let Fe,qe;for(;;){if(Ke.lookahead<MIN_LOOKAHEAD){if(fill_window(Ke),Ke.lookahead<MIN_LOOKAHEAD&&Re===Z_NO_FLUSH$2)return BS_NEED_MORE;if(Ke.lookahead===0)break}if(Fe=0,Ke.lookahead>=MIN_MATCH&&(Ke.ins_h=HASH(Ke,Ke.ins_h,Ke.window[Ke.strstart+MIN_MATCH-1]),Fe=Ke.prev[Ke.strstart&Ke.w_mask]=Ke.head[Ke.ins_h],Ke.head[Ke.ins_h]=Ke.strstart),Fe!==0&&Ke.strstart-Fe<=Ke.w_size-MIN_LOOKAHEAD&&(Ke.match_length=longest_match(Ke,Fe)),Ke.match_length>=MIN_MATCH)if(qe=_tr_tally(Ke,Ke.strstart-Ke.match_start,Ke.match_length-MIN_MATCH),Ke.lookahead-=Ke.match_length,Ke.match_length<=Ke.max_lazy_match&&Ke.lookahead>=MIN_MATCH){Ke.match_length--;do Ke.strstart++,Ke.ins_h=HASH(Ke,Ke.ins_h,Ke.window[Ke.strstart+MIN_MATCH-1]),Fe=Ke.prev[Ke.strstart&Ke.w_mask]=Ke.head[Ke.ins_h],Ke.head[Ke.ins_h]=Ke.strstart;while(--Ke.match_length!==0);Ke.strstart++}else Ke.strstart+=Ke.match_length,Ke.match_length=0,Ke.ins_h=Ke.window[Ke.strstart],Ke.ins_h=HASH(Ke,Ke.ins_h,Ke.window[Ke.strstart+1]);else qe=_tr_tally(Ke,0,Ke.window[Ke.strstart]),Ke.lookahead--,Ke.strstart++;if(qe&&(flush_block_only(Ke,!1),Ke.strm.avail_out===0))return BS_NEED_MORE}return Ke.insert=Ke.strstart<MIN_MATCH-1?Ke.strstart:MIN_MATCH-1,Re===Z_FINISH$3?(flush_block_only(Ke,!0),Ke.strm.avail_out===0?BS_FINISH_STARTED:BS_FINISH_DONE):Ke.last_lit&&(flush_block_only(Ke,!1),Ke.strm.avail_out===0)?BS_NEED_MORE:BS_BLOCK_DONE},deflate_slow=(Ke,Re)=>{let Fe,qe,We;for(;;){if(Ke.lookahead<MIN_LOOKAHEAD){if(fill_window(Ke),Ke.lookahead<MIN_LOOKAHEAD&&Re===Z_NO_FLUSH$2)return BS_NEED_MORE;if(Ke.lookahead===0)break}if(Fe=0,Ke.lookahead>=MIN_MATCH&&(Ke.ins_h=HASH(Ke,Ke.ins_h,Ke.window[Ke.strstart+MIN_MATCH-1]),Fe=Ke.prev[Ke.strstart&Ke.w_mask]=Ke.head[Ke.ins_h],Ke.head[Ke.ins_h]=Ke.strstart),Ke.prev_length=Ke.match_length,Ke.prev_match=Ke.match_start,Ke.match_length=MIN_MATCH-1,Fe!==0&&Ke.prev_length<Ke.max_lazy_match&&Ke.strstart-Fe<=Ke.w_size-MIN_LOOKAHEAD&&(Ke.match_length=longest_match(Ke,Fe),Ke.match_length<=5&&(Ke.strategy===Z_FILTERED||Ke.match_length===MIN_MATCH&&Ke.strstart-Ke.match_start>4096)&&(Ke.match_length=MIN_MATCH-1)),Ke.prev_length>=MIN_MATCH&&Ke.match_length<=Ke.prev_length){We=Ke.strstart+Ke.lookahead-MIN_MATCH,qe=_tr_tally(Ke,Ke.strstart-1-Ke.prev_match,Ke.prev_length-MIN_MATCH),Ke.lookahead-=Ke.prev_length-1,Ke.prev_length-=2;do++Ke.strstart<=We&&(Ke.ins_h=HASH(Ke,Ke.ins_h,Ke.window[Ke.strstart+MIN_MATCH-1]),Fe=Ke.prev[Ke.strstart&Ke.w_mask]=Ke.head[Ke.ins_h],Ke.head[Ke.ins_h]=Ke.strstart);while(--Ke.prev_length!==0);if(Ke.match_available=0,Ke.match_length=MIN_MATCH-1,Ke.strstart++,qe&&(flush_block_only(Ke,!1),Ke.strm.avail_out===0))return BS_NEED_MORE}else if(Ke.match_available){if(qe=_tr_tally(Ke,0,Ke.window[Ke.strstart-1]),qe&&flush_block_only(Ke,!1),Ke.strstart++,Ke.lookahead--,Ke.strm.avail_out===0)return BS_NEED_MORE}else Ke.match_available=1,Ke.strstart++,Ke.lookahead--}return Ke.match_available&&(qe=_tr_tally(Ke,0,Ke.window[Ke.strstart-1]),Ke.match_available=0),Ke.insert=Ke.strstart<MIN_MATCH-1?Ke.strstart:MIN_MATCH-1,Re===Z_FINISH$3?(flush_block_only(Ke,!0),Ke.strm.avail_out===0?BS_FINISH_STARTED:BS_FINISH_DONE):Ke.last_lit&&(flush_block_only(Ke,!1),Ke.strm.avail_out===0)?BS_NEED_MORE:BS_BLOCK_DONE},deflate_rle=(Ke,Re)=>{let Fe,qe,We,Ze;const Xe=Ke.window;for(;;){if(Ke.lookahead<=MAX_MATCH){if(fill_window(Ke),Ke.lookahead<=MAX_MATCH&&Re===Z_NO_FLUSH$2)return BS_NEED_MORE;if(Ke.lookahead===0)break}if(Ke.match_length=0,Ke.lookahead>=MIN_MATCH&&Ke.strstart>0&&(We=Ke.strstart-1,qe=Xe[We],qe===Xe[++We]&&qe===Xe[++We]&&qe===Xe[++We])){Ze=Ke.strstart+MAX_MATCH;do;while(qe===Xe[++We]&&qe===Xe[++We]&&qe===Xe[++We]&&qe===Xe[++We]&&qe===Xe[++We]&&qe===Xe[++We]&&qe===Xe[++We]&&qe===Xe[++We]&&We<Ze);Ke.match_length=MAX_MATCH-(Ze-We),Ke.match_length>Ke.lookahead&&(Ke.match_length=Ke.lookahead)}if(Ke.match_length>=MIN_MATCH?(Fe=_tr_tally(Ke,1,Ke.match_length-MIN_MATCH),Ke.lookahead-=Ke.match_length,Ke.strstart+=Ke.match_length,Ke.match_length=0):(Fe=_tr_tally(Ke,0,Ke.window[Ke.strstart]),Ke.lookahead--,Ke.strstart++),Fe&&(flush_block_only(Ke,!1),Ke.strm.avail_out===0))return BS_NEED_MORE}return Ke.insert=0,Re===Z_FINISH$3?(flush_block_only(Ke,!0),Ke.strm.avail_out===0?BS_FINISH_STARTED:BS_FINISH_DONE):Ke.last_lit&&(flush_block_only(Ke,!1),Ke.strm.avail_out===0)?BS_NEED_MORE:BS_BLOCK_DONE},deflate_huff=(Ke,Re)=>{let Fe;for(;;){if(Ke.lookahead===0&&(fill_window(Ke),Ke.lookahead===0)){if(Re===Z_NO_FLUSH$2)return BS_NEED_MORE;break}if(Ke.match_length=0,Fe=_tr_tally(Ke,0,Ke.window[Ke.strstart]),Ke.lookahead--,Ke.strstart++,Fe&&(flush_block_only(Ke,!1),Ke.strm.avail_out===0))return BS_NEED_MORE}return Ke.insert=0,Re===Z_FINISH$3?(flush_block_only(Ke,!0),Ke.strm.avail_out===0?BS_FINISH_STARTED:BS_FINISH_DONE):Ke.last_lit&&(flush_block_only(Ke,!1),Ke.strm.avail_out===0)?BS_NEED_MORE:BS_BLOCK_DONE};function Config(Ke,Re,Fe,qe,We){this.good_length=Ke,this.max_lazy=Re,this.nice_length=Fe,this.max_chain=qe,this.func=We}const configuration_table=[new Config(0,0,0,0,deflate_stored),new Config(4,4,8,4,deflate_fast),new Config(4,5,16,8,deflate_fast),new Config(4,6,32,32,deflate_fast),new Config(4,4,16,16,deflate_slow),new Config(8,16,32,32,deflate_slow),new Config(8,16,128,128,deflate_slow),new Config(8,32,128,256,deflate_slow),new Config(32,128,258,1024,deflate_slow),new Config(32,258,258,4096,deflate_slow)],lm_init=Ke=>{Ke.window_size=2*Ke.w_size,zero(Ke.head),Ke.max_lazy_match=configuration_table[Ke.level].max_lazy,Ke.good_match=configuration_table[Ke.level].good_length,Ke.nice_match=configuration_table[Ke.level].nice_length,Ke.max_chain_length=configuration_table[Ke.level].max_chain,Ke.strstart=0,Ke.block_start=0,Ke.lookahead=0,Ke.insert=0,Ke.match_length=Ke.prev_length=MIN_MATCH-1,Ke.match_available=0,Ke.ins_h=0};function DeflateState(){this.strm=null,this.status=0,this.pending_buf=null,this.pending_buf_size=0,this.pending_out=0,this.pending=0,this.wrap=0,this.gzhead=null,this.gzindex=0,this.method=Z_DEFLATED$2,this.last_flush=-1,this.w_size=0,this.w_bits=0,this.w_mask=0,this.window=null,this.window_size=0,this.prev=null,this.head=null,this.ins_h=0,this.hash_size=0,this.hash_bits=0,this.hash_mask=0,this.hash_shift=0,this.block_start=0,this.match_length=0,this.prev_match=0,this.match_available=0,this.strstart=0,this.match_start=0,this.lookahead=0,this.prev_length=0,this.max_chain_length=0,this.max_lazy_match=0,this.level=0,this.strategy=0,this.good_match=0,this.nice_match=0,this.dyn_ltree=new Uint16Array(HEAP_SIZE*2),this.dyn_dtree=new Uint16Array((2*D_CODES+1)*2),this.bl_tree=new Uint16Array((2*BL_CODES+1)*2),zero(this.dyn_ltree),zero(this.dyn_dtree),zero(this.bl_tree),this.l_desc=null,this.d_desc=null,this.bl_desc=null,this.bl_count=new Uint16Array(MAX_BITS+1),this.heap=new Uint16Array(2*L_CODES+1),zero(this.heap),this.heap_len=0,this.heap_max=0,this.depth=new Uint16Array(2*L_CODES+1),zero(this.depth),this.l_buf=0,this.lit_bufsize=0,this.last_lit=0,this.d_buf=0,this.opt_len=0,this.static_len=0,this.matches=0,this.insert=0,this.bi_buf=0,this.bi_valid=0}const deflateResetKeep=Ke=>{if(!Ke||!Ke.state)return err(Ke,Z_STREAM_ERROR$2);Ke.total_in=Ke.total_out=0,Ke.data_type=Z_UNKNOWN;const Re=Ke.state;return Re.pending=0,Re.pending_out=0,Re.wrap<0&&(Re.wrap=-Re.wrap),Re.status=Re.wrap?INIT_STATE:BUSY_STATE,Ke.adler=Re.wrap===2?0:1,Re.last_flush=Z_NO_FLUSH$2,_tr_init(Re),Z_OK$3},deflateReset=Ke=>{const Re=deflateResetKeep(Ke);return Re===Z_OK$3&&lm_init(Ke.state),Re},deflateSetHeader=(Ke,Re)=>!Ke||!Ke.state||Ke.state.wrap!==2?Z_STREAM_ERROR$2:(Ke.state.gzhead=Re,Z_OK$3),deflateInit2=(Ke,Re,Fe,qe,We,Ze)=>{if(!Ke)return Z_STREAM_ERROR$2;let Xe=1;if(Re===Z_DEFAULT_COMPRESSION$1&&(Re=6),qe<0?(Xe=0,qe=-qe):qe>15&&(Xe=2,qe-=16),We<1||We>MAX_MEM_LEVEL||Fe!==Z_DEFLATED$2||qe<8||qe>15||Re<0||Re>9||Ze<0||Ze>Z_FIXED)return err(Ke,Z_STREAM_ERROR$2);qe===8&&(qe=9);const Je=new DeflateState;return Ke.state=Je,Je.strm=Ke,Je.wrap=Xe,Je.gzhead=null,Je.w_bits=qe,Je.w_size=1<<Je.w_bits,Je.w_mask=Je.w_size-1,Je.hash_bits=We+7,Je.hash_size=1<<Je.hash_bits,Je.hash_mask=Je.hash_size-1,Je.hash_shift=~~((Je.hash_bits+MIN_MATCH-1)/MIN_MATCH),Je.window=new Uint8Array(Je.w_size*2),Je.head=new Uint16Array(Je.hash_size),Je.prev=new Uint16Array(Je.w_size),Je.lit_bufsize=1<<We+6,Je.pending_buf_size=Je.lit_bufsize*4,Je.pending_buf=new Uint8Array(Je.pending_buf_size),Je.d_buf=1*Je.lit_bufsize,Je.l_buf=(1+2)*Je.lit_bufsize,Je.level=Re,Je.strategy=Ze,Je.method=Fe,deflateReset(Ke)},deflateInit=(Ke,Re)=>deflateInit2(Ke,Re,Z_DEFLATED$2,MAX_WBITS$1,DEF_MEM_LEVEL,Z_DEFAULT_STRATEGY$1),deflate$2=(Ke,Re)=>{let Fe,qe;if(!Ke||!Ke.state||Re>Z_BLOCK$1||Re<0)return Ke?err(Ke,Z_STREAM_ERROR$2):Z_STREAM_ERROR$2;const We=Ke.state;if(!Ke.output||!Ke.input&&Ke.avail_in!==0||We.status===FINISH_STATE&&Re!==Z_FINISH$3)return err(Ke,Ke.avail_out===0?Z_BUF_ERROR$1:Z_STREAM_ERROR$2);We.strm=Ke;const Ze=We.last_flush;if(We.last_flush=Re,We.status===INIT_STATE)if(We.wrap===2)Ke.adler=0,put_byte(We,31),put_byte(We,139),put_byte(We,8),We.gzhead?(put_byte(We,(We.gzhead.text?1:0)+(We.gzhead.hcrc?2:0)+(We.gzhead.extra?4:0)+(We.gzhead.name?8:0)+(We.gzhead.comment?16:0)),put_byte(We,We.gzhead.time&255),put_byte(We,We.gzhead.time>>8&255),put_byte(We,We.gzhead.time>>16&255),put_byte(We,We.gzhead.time>>24&255),put_byte(We,We.level===9?2:We.strategy>=Z_HUFFMAN_ONLY||We.level<2?4:0),put_byte(We,We.gzhead.os&255),We.gzhead.extra&&We.gzhead.extra.length&&(put_byte(We,We.gzhead.extra.length&255),put_byte(We,We.gzhead.extra.length>>8&255)),We.gzhead.hcrc&&(Ke.adler=crc32_1(Ke.adler,We.pending_buf,We.pending,0)),We.gzindex=0,We.status=EXTRA_STATE):(put_byte(We,0),put_byte(We,0),put_byte(We,0),put_byte(We,0),put_byte(We,0),put_byte(We,We.level===9?2:We.strategy>=Z_HUFFMAN_ONLY||We.level<2?4:0),put_byte(We,OS_CODE),We.status=BUSY_STATE);else{let Xe=Z_DEFLATED$2+(We.w_bits-8<<4)<<8,Je=-1;We.strategy>=Z_HUFFMAN_ONLY||We.level<2?Je=0:We.level<6?Je=1:We.level===6?Je=2:Je=3,Xe|=Je<<6,We.strstart!==0&&(Xe|=PRESET_DICT),Xe+=31-Xe%31,We.status=BUSY_STATE,putShortMSB(We,Xe),We.strstart!==0&&(putShortMSB(We,Ke.adler>>>16),putShortMSB(We,Ke.adler&65535)),Ke.adler=1}if(We.status===EXTRA_STATE)if(We.gzhead.extra){for(Fe=We.pending;We.gzindex<(We.gzhead.extra.length&65535)&&!(We.pending===We.pending_buf_size&&(We.gzhead.hcrc&&We.pending>Fe&&(Ke.adler=crc32_1(Ke.adler,We.pending_buf,We.pending-Fe,Fe)),flush_pending(Ke),Fe=We.pending,We.pending===We.pending_buf_size));)put_byte(We,We.gzhead.extra[We.gzindex]&255),We.gzindex++;We.gzhead.hcrc&&We.pending>Fe&&(Ke.adler=crc32_1(Ke.adler,We.pending_buf,We.pending-Fe,Fe)),We.gzindex===We.gzhead.extra.length&&(We.gzindex=0,We.status=NAME_STATE)}else We.status=NAME_STATE;if(We.status===NAME_STATE)if(We.gzhead.name){Fe=We.pending;do{if(We.pending===We.pending_buf_size&&(We.gzhead.hcrc&&We.pending>Fe&&(Ke.adler=crc32_1(Ke.adler,We.pending_buf,We.pending-Fe,Fe)),flush_pending(Ke),Fe=We.pending,We.pending===We.pending_buf_size)){qe=1;break}We.gzindex<We.gzhead.name.length?qe=We.gzhead.name.charCodeAt(We.gzindex++)&255:qe=0,put_byte(We,qe)}while(qe!==0);We.gzhead.hcrc&&We.pending>Fe&&(Ke.adler=crc32_1(Ke.adler,We.pending_buf,We.pending-Fe,Fe)),qe===0&&(We.gzindex=0,We.status=COMMENT_STATE)}else We.status=COMMENT_STATE;if(We.status===COMMENT_STATE)if(We.gzhead.comment){Fe=We.pending;do{if(We.pending===We.pending_buf_size&&(We.gzhead.hcrc&&We.pending>Fe&&(Ke.adler=crc32_1(Ke.adler,We.pending_buf,We.pending-Fe,Fe)),flush_pending(Ke),Fe=We.pending,We.pending===We.pending_buf_size)){qe=1;break}We.gzindex<We.gzhead.comment.length?qe=We.gzhead.comment.charCodeAt(We.gzindex++)&255:qe=0,put_byte(We,qe)}while(qe!==0);We.gzhead.hcrc&&We.pending>Fe&&(Ke.adler=crc32_1(Ke.adler,We.pending_buf,We.pending-Fe,Fe)),qe===0&&(We.status=HCRC_STATE)}else We.status=HCRC_STATE;if(We.status===HCRC_STATE&&(We.gzhead.hcrc?(We.pending+2>We.pending_buf_size&&flush_pending(Ke),We.pending+2<=We.pending_buf_size&&(put_byte(We,Ke.adler&255),put_byte(We,Ke.adler>>8&255),Ke.adler=0,We.status=BUSY_STATE)):We.status=BUSY_STATE),We.pending!==0){if(flush_pending(Ke),Ke.avail_out===0)return We.last_flush=-1,Z_OK$3}else if(Ke.avail_in===0&&rank(Re)<=rank(Ze)&&Re!==Z_FINISH$3)return err(Ke,Z_BUF_ERROR$1);if(We.status===FINISH_STATE&&Ke.avail_in!==0)return err(Ke,Z_BUF_ERROR$1);if(Ke.avail_in!==0||We.lookahead!==0||Re!==Z_NO_FLUSH$2&&We.status!==FINISH_STATE){let Xe=We.strategy===Z_HUFFMAN_ONLY?deflate_huff(We,Re):We.strategy===Z_RLE?deflate_rle(We,Re):configuration_table[We.level].func(We,Re);if((Xe===BS_FINISH_STARTED||Xe===BS_FINISH_DONE)&&(We.status=FINISH_STATE),Xe===BS_NEED_MORE||Xe===BS_FINISH_STARTED)return Ke.avail_out===0&&(We.last_flush=-1),Z_OK$3;if(Xe===BS_BLOCK_DONE&&(Re===Z_PARTIAL_FLUSH?_tr_align(We):Re!==Z_BLOCK$1&&(_tr_stored_block(We,0,0,!1),Re===Z_FULL_FLUSH$1&&(zero(We.head),We.lookahead===0&&(We.strstart=0,We.block_start=0,We.insert=0))),flush_pending(Ke),Ke.avail_out===0))return We.last_flush=-1,Z_OK$3}return Re!==Z_FINISH$3?Z_OK$3:We.wrap<=0?Z_STREAM_END$3:(We.wrap===2?(put_byte(We,Ke.adler&255),put_byte(We,Ke.adler>>8&255),put_byte(We,Ke.adler>>16&255),put_byte(We,Ke.adler>>24&255),put_byte(We,Ke.total_in&255),put_byte(We,Ke.total_in>>8&255),put_byte(We,Ke.total_in>>16&255),put_byte(We,Ke.total_in>>24&255)):(putShortMSB(We,Ke.adler>>>16),putShortMSB(We,Ke.adler&65535)),flush_pending(Ke),We.wrap>0&&(We.wrap=-We.wrap),We.pending!==0?Z_OK$3:Z_STREAM_END$3)},deflateEnd=Ke=>{if(!Ke||!Ke.state)return Z_STREAM_ERROR$2;const Re=Ke.state.status;return Re!==INIT_STATE&&Re!==EXTRA_STATE&&Re!==NAME_STATE&&Re!==COMMENT_STATE&&Re!==HCRC_STATE&&Re!==BUSY_STATE&&Re!==FINISH_STATE?err(Ke,Z_STREAM_ERROR$2):(Ke.state=null,Re===BUSY_STATE?err(Ke,Z_DATA_ERROR$2):Z_OK$3)},deflateSetDictionary=(Ke,Re)=>{let Fe=Re.length;if(!Ke||!Ke.state)return Z_STREAM_ERROR$2;const qe=Ke.state,We=qe.wrap;if(We===2||We===1&&qe.status!==INIT_STATE||qe.lookahead)return Z_STREAM_ERROR$2;if(We===1&&(Ke.adler=adler32_1(Ke.adler,Re,Fe,0)),qe.wrap=0,Fe>=qe.w_size){We===0&&(zero(qe.head),qe.strstart=0,qe.block_start=0,qe.insert=0);let tr=new Uint8Array(qe.w_size);tr.set(Re.subarray(Fe-qe.w_size,Fe),0),Re=tr,Fe=qe.w_size}const Ze=Ke.avail_in,Xe=Ke.next_in,Je=Ke.input;for(Ke.avail_in=Fe,Ke.next_in=0,Ke.input=Re,fill_window(qe);qe.lookahead>=MIN_MATCH;){let tr=qe.strstart,er=qe.lookahead-(MIN_MATCH-1);do qe.ins_h=HASH(qe,qe.ins_h,qe.window[tr+MIN_MATCH-1]),qe.prev[tr&qe.w_mask]=qe.head[qe.ins_h],qe.head[qe.ins_h]=tr,tr++;while(--er);qe.strstart=tr,qe.lookahead=MIN_MATCH-1,fill_window(qe)}return qe.strstart+=qe.lookahead,qe.block_start=qe.strstart,qe.insert=qe.lookahead,qe.lookahead=0,qe.match_length=qe.prev_length=MIN_MATCH-1,qe.match_available=0,Ke.next_in=Xe,Ke.input=Je,Ke.avail_in=Ze,qe.wrap=We,Z_OK$3};var deflateInit_1=deflateInit,deflateInit2_1=deflateInit2,deflateReset_1=deflateReset,deflateResetKeep_1=deflateResetKeep,deflateSetHeader_1=deflateSetHeader,deflate_2$1=deflate$2,deflateEnd_1=deflateEnd,deflateSetDictionary_1=deflateSetDictionary,deflateInfo="pako deflate (from Nodeca project)",deflate_1$2={deflateInit:deflateInit_1,deflateInit2:deflateInit2_1,deflateReset:deflateReset_1,deflateResetKeep:deflateResetKeep_1,deflateSetHeader:deflateSetHeader_1,deflate:deflate_2$1,deflateEnd:deflateEnd_1,deflateSetDictionary:deflateSetDictionary_1,deflateInfo};const _has=(Ke,Re)=>Object.prototype.hasOwnProperty.call(Ke,Re);var assign=function(Ke){const Re=Array.prototype.slice.call(arguments,1);for(;Re.length;){const Fe=Re.shift();if(!!Fe){if(typeof Fe!="object")throw new TypeError(Fe+"must be non-object");for(const qe in Fe)_has(Fe,qe)&&(Ke[qe]=Fe[qe])}}return Ke},flattenChunks=Ke=>{let Re=0;for(let qe=0,We=Ke.length;qe<We;qe++)Re+=Ke[qe].length;const Fe=new Uint8Array(Re);for(let qe=0,We=0,Ze=Ke.length;qe<Ze;qe++){let Xe=Ke[qe];Fe.set(Xe,We),We+=Xe.length}return Fe},common={assign,flattenChunks};let STR_APPLY_UIA_OK=!0;try{String.fromCharCode.apply(null,new Uint8Array(1))}catch(Ke){STR_APPLY_UIA_OK=!1}const _utf8len=new Uint8Array(256);for(let Ke=0;Ke<256;Ke++)_utf8len[Ke]=Ke>=252?6:Ke>=248?5:Ke>=240?4:Ke>=224?3:Ke>=192?2:1;_utf8len[254]=_utf8len[254]=1;var string2buf=Ke=>{if(typeof TextEncoder=="function"&&TextEncoder.prototype.encode)return new TextEncoder().encode(Ke);let Re,Fe,qe,We,Ze,Xe=Ke.length,Je=0;for(We=0;We<Xe;We++)Fe=Ke.charCodeAt(We),(Fe&64512)===55296&&We+1<Xe&&(qe=Ke.charCodeAt(We+1),(qe&64512)===56320&&(Fe=65536+(Fe-55296<<10)+(qe-56320),We++)),Je+=Fe<128?1:Fe<2048?2:Fe<65536?3:4;for(Re=new Uint8Array(Je),Ze=0,We=0;Ze<Je;We++)Fe=Ke.charCodeAt(We),(Fe&64512)===55296&&We+1<Xe&&(qe=Ke.charCodeAt(We+1),(qe&64512)===56320&&(Fe=65536+(Fe-55296<<10)+(qe-56320),We++)),Fe<128?Re[Ze++]=Fe:Fe<2048?(Re[Ze++]=192|Fe>>>6,Re[Ze++]=128|Fe&63):Fe<65536?(Re[Ze++]=224|Fe>>>12,Re[Ze++]=128|Fe>>>6&63,Re[Ze++]=128|Fe&63):(Re[Ze++]=240|Fe>>>18,Re[Ze++]=128|Fe>>>12&63,Re[Ze++]=128|Fe>>>6&63,Re[Ze++]=128|Fe&63);return Re};const buf2binstring=(Ke,Re)=>{if(Re<65534&&Ke.subarray&&STR_APPLY_UIA_OK)return String.fromCharCode.apply(null,Ke.length===Re?Ke:Ke.subarray(0,Re));let Fe="";for(let qe=0;qe<Re;qe++)Fe+=String.fromCharCode(Ke[qe]);return Fe};var buf2string=(Ke,Re)=>{const Fe=Re||Ke.length;if(typeof TextDecoder=="function"&&TextDecoder.prototype.decode)return new TextDecoder().decode(Ke.subarray(0,Re));let qe,We;const Ze=new Array(Fe*2);for(We=0,qe=0;qe<Fe;){let Xe=Ke[qe++];if(Xe<128){Ze[We++]=Xe;continue}let Je=_utf8len[Xe];if(Je>4){Ze[We++]=65533,qe+=Je-1;continue}for(Xe&=Je===2?31:Je===3?15:7;Je>1&&qe<Fe;)Xe=Xe<<6|Ke[qe++]&63,Je--;if(Je>1){Ze[We++]=65533;continue}Xe<65536?Ze[We++]=Xe:(Xe-=65536,Ze[We++]=55296|Xe>>10&1023,Ze[We++]=56320|Xe&1023)}return buf2binstring(Ze,We)},utf8border=(Ke,Re)=>{Re=Re||Ke.length,Re>Ke.length&&(Re=Ke.length);let Fe=Re-1;for(;Fe>=0&&(Ke[Fe]&192)===128;)Fe--;return Fe<0||Fe===0?Re:Fe+_utf8len[Ke[Fe]]>Re?Fe:Re},strings={string2buf,buf2string,utf8border};function ZStream(){this.input=null,this.next_in=0,this.avail_in=0,this.total_in=0,this.output=null,this.next_out=0,this.avail_out=0,this.total_out=0,this.msg="",this.state=null,this.data_type=2,this.adler=0}var zstream=ZStream;const toString$1=Object.prototype.toString,{Z_NO_FLUSH:Z_NO_FLUSH$1,Z_SYNC_FLUSH,Z_FULL_FLUSH,Z_FINISH:Z_FINISH$2,Z_OK:Z_OK$2,Z_STREAM_END:Z_STREAM_END$2,Z_DEFAULT_COMPRESSION,Z_DEFAULT_STRATEGY,Z_DEFLATED:Z_DEFLATED$1}=constants$2;function Deflate$1(Ke){this.options=common.assign({level:Z_DEFAULT_COMPRESSION,method:Z_DEFLATED$1,chunkSize:16384,windowBits:15,memLevel:8,strategy:Z_DEFAULT_STRATEGY},Ke||{});let Re=this.options;Re.raw&&Re.windowBits>0?Re.windowBits=-Re.windowBits:Re.gzip&&Re.windowBits>0&&Re.windowBits<16&&(Re.windowBits+=16),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new zstream,this.strm.avail_out=0;let Fe=deflate_1$2.deflateInit2(this.strm,Re.level,Re.method,Re.windowBits,Re.memLevel,Re.strategy);if(Fe!==Z_OK$2)throw new Error(messages[Fe]);if(Re.header&&deflate_1$2.deflateSetHeader(this.strm,Re.header),Re.dictionary){let qe;if(typeof Re.dictionary=="string"?qe=strings.string2buf(Re.dictionary):toString$1.call(Re.dictionary)==="[object ArrayBuffer]"?qe=new Uint8Array(Re.dictionary):qe=Re.dictionary,Fe=deflate_1$2.deflateSetDictionary(this.strm,qe),Fe!==Z_OK$2)throw new Error(messages[Fe]);this._dict_set=!0}}Deflate$1.prototype.push=function(Ke,Re){const Fe=this.strm,qe=this.options.chunkSize;let We,Ze;if(this.ended)return!1;for(Re===~~Re?Ze=Re:Ze=Re===!0?Z_FINISH$2:Z_NO_FLUSH$1,typeof Ke=="string"?Fe.input=strings.string2buf(Ke):toString$1.call(Ke)==="[object ArrayBuffer]"?Fe.input=new Uint8Array(Ke):Fe.input=Ke,Fe.next_in=0,Fe.avail_in=Fe.input.length;;){if(Fe.avail_out===0&&(Fe.output=new Uint8Array(qe),Fe.next_out=0,Fe.avail_out=qe),(Ze===Z_SYNC_FLUSH||Ze===Z_FULL_FLUSH)&&Fe.avail_out<=6){this.onData(Fe.output.subarray(0,Fe.next_out)),Fe.avail_out=0;continue}if(We=deflate_1$2.deflate(Fe,Ze),We===Z_STREAM_END$2)return Fe.next_out>0&&this.onData(Fe.output.subarray(0,Fe.next_out)),We=deflate_1$2.deflateEnd(this.strm),this.onEnd(We),this.ended=!0,We===Z_OK$2;if(Fe.avail_out===0){this.onData(Fe.output);continue}if(Ze>0&&Fe.next_out>0){this.onData(Fe.output.subarray(0,Fe.next_out)),Fe.avail_out=0;continue}if(Fe.avail_in===0)break}return!0};Deflate$1.prototype.onData=function(Ke){this.chunks.push(Ke)};Deflate$1.prototype.onEnd=function(Ke){Ke===Z_OK$2&&(this.result=common.flattenChunks(this.chunks)),this.chunks=[],this.err=Ke,this.msg=this.strm.msg};const BAD$1=30,TYPE$1=12;var inffast=function Ke(Re,Fe){let qe,We,Ze,Xe,Je,tr,er,ir,ur,fr,ar,yr,mr,wr,Sr,Ar,vr,Ir,Tr,Pr,Rr,Br,Mr,Lr;const $r=Re.state;qe=Re.next_in,Mr=Re.input,We=qe+(Re.avail_in-5),Ze=Re.next_out,Lr=Re.output,Xe=Ze-(Fe-Re.avail_out),Je=Ze+(Re.avail_out-257),tr=$r.dmax,er=$r.wsize,ir=$r.whave,ur=$r.wnext,fr=$r.window,ar=$r.hold,yr=$r.bits,mr=$r.lencode,wr=$r.distcode,Sr=(1<<$r.lenbits)-1,Ar=(1<<$r.distbits)-1;e:do{yr<15&&(ar+=Mr[qe++]<<yr,yr+=8,ar+=Mr[qe++]<<yr,yr+=8),vr=mr[ar&Sr];t:for(;;){if(Ir=vr>>>24,ar>>>=Ir,yr-=Ir,Ir=vr>>>16&255,Ir===0)Lr[Ze++]=vr&65535;else if(Ir&16){Tr=vr&65535,Ir&=15,Ir&&(yr<Ir&&(ar+=Mr[qe++]<<yr,yr+=8),Tr+=ar&(1<<Ir)-1,ar>>>=Ir,yr-=Ir),yr<15&&(ar+=Mr[qe++]<<yr,yr+=8,ar+=Mr[qe++]<<yr,yr+=8),vr=wr[ar&Ar];r:for(;;){if(Ir=vr>>>24,ar>>>=Ir,yr-=Ir,Ir=vr>>>16&255,Ir&16){if(Pr=vr&65535,Ir&=15,yr<Ir&&(ar+=Mr[qe++]<<yr,yr+=8,yr<Ir&&(ar+=Mr[qe++]<<yr,yr+=8)),Pr+=ar&(1<<Ir)-1,Pr>tr){Re.msg="invalid distance too far back",$r.mode=BAD$1;break e}if(ar>>>=Ir,yr-=Ir,Ir=Ze-Xe,Pr>Ir){if(Ir=Pr-Ir,Ir>ir&&$r.sane){Re.msg="invalid distance too far back",$r.mode=BAD$1;break e}if(Rr=0,Br=fr,ur===0){if(Rr+=er-Ir,Ir<Tr){Tr-=Ir;do Lr[Ze++]=fr[Rr++];while(--Ir);Rr=Ze-Pr,Br=Lr}}else if(ur<Ir){if(Rr+=er+ur-Ir,Ir-=ur,Ir<Tr){Tr-=Ir;do Lr[Ze++]=fr[Rr++];while(--Ir);if(Rr=0,ur<Tr){Ir=ur,Tr-=Ir;do Lr[Ze++]=fr[Rr++];while(--Ir);Rr=Ze-Pr,Br=Lr}}}else if(Rr+=ur-Ir,Ir<Tr){Tr-=Ir;do Lr[Ze++]=fr[Rr++];while(--Ir);Rr=Ze-Pr,Br=Lr}for(;Tr>2;)Lr[Ze++]=Br[Rr++],Lr[Ze++]=Br[Rr++],Lr[Ze++]=Br[Rr++],Tr-=3;Tr&&(Lr[Ze++]=Br[Rr++],Tr>1&&(Lr[Ze++]=Br[Rr++]))}else{Rr=Ze-Pr;do Lr[Ze++]=Lr[Rr++],Lr[Ze++]=Lr[Rr++],Lr[Ze++]=Lr[Rr++],Tr-=3;while(Tr>2);Tr&&(Lr[Ze++]=Lr[Rr++],Tr>1&&(Lr[Ze++]=Lr[Rr++]))}}else if((Ir&64)===0){vr=wr[(vr&65535)+(ar&(1<<Ir)-1)];continue r}else{Re.msg="invalid distance code",$r.mode=BAD$1;break e}break}}else if((Ir&64)===0){vr=mr[(vr&65535)+(ar&(1<<Ir)-1)];continue t}else if(Ir&32){$r.mode=TYPE$1;break e}else{Re.msg="invalid literal/length code",$r.mode=BAD$1;break e}break}}while(qe<We&&Ze<Je);Tr=yr>>3,qe-=Tr,yr-=Tr<<3,ar&=(1<<yr)-1,Re.next_in=qe,Re.next_out=Ze,Re.avail_in=qe<We?5+(We-qe):5-(qe-We),Re.avail_out=Ze<Je?257+(Je-Ze):257-(Ze-Je),$r.hold=ar,$r.bits=yr};const MAXBITS=15,ENOUGH_LENS$1=852,ENOUGH_DISTS$1=592,CODES$1=0,LENS$1=1,DISTS$1=2,lbase=new Uint16Array([3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0]),lext=new Uint8Array([16,16,16,16,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,16,72,78]),dbase=new Uint16Array([1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0]),dext=new Uint8Array([16,16,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,64,64]),inflate_table=(Ke,Re,Fe,qe,We,Ze,Xe,Je)=>{const tr=Je.bits;let er=0,ir=0,ur=0,fr=0,ar=0,yr=0,mr=0,wr=0,Sr=0,Ar=0,vr,Ir,Tr,Pr,Rr,Br=null,Mr=0,Lr;const $r=new Uint16Array(MAXBITS+1),Nr=new Uint16Array(MAXBITS+1);let cr=null,Dt=0,sr,lr,gr;for(er=0;er<=MAXBITS;er++)$r[er]=0;for(ir=0;ir<qe;ir++)$r[Re[Fe+ir]]++;for(ar=tr,fr=MAXBITS;fr>=1&&$r[fr]===0;fr--);if(ar>fr&&(ar=fr),fr===0)return We[Ze++]=1<<24|64<<16|0,We[Ze++]=1<<24|64<<16|0,Je.bits=1,0;for(ur=1;ur<fr&&$r[ur]===0;ur++);for(ar<ur&&(ar=ur),wr=1,er=1;er<=MAXBITS;er++)if(wr<<=1,wr-=$r[er],wr<0)return-1;if(wr>0&&(Ke===CODES$1||fr!==1))return-1;for(Nr[1]=0,er=1;er<MAXBITS;er++)Nr[er+1]=Nr[er]+$r[er];for(ir=0;ir<qe;ir++)Re[Fe+ir]!==0&&(Xe[Nr[Re[Fe+ir]]++]=ir);if(Ke===CODES$1?(Br=cr=Xe,Lr=19):Ke===LENS$1?(Br=lbase,Mr-=257,cr=lext,Dt-=257,Lr=256):(Br=dbase,cr=dext,Lr=-1),Ar=0,ir=0,er=ur,Rr=Ze,yr=ar,mr=0,Tr=-1,Sr=1<<ar,Pr=Sr-1,Ke===LENS$1&&Sr>ENOUGH_LENS$1||Ke===DISTS$1&&Sr>ENOUGH_DISTS$1)return 1;for(;;){sr=er-mr,Xe[ir]<Lr?(lr=0,gr=Xe[ir]):Xe[ir]>Lr?(lr=cr[Dt+Xe[ir]],gr=Br[Mr+Xe[ir]]):(lr=32+64,gr=0),vr=1<<er-mr,Ir=1<<yr,ur=Ir;do Ir-=vr,We[Rr+(Ar>>mr)+Ir]=sr<<24|lr<<16|gr|0;while(Ir!==0);for(vr=1<<er-1;Ar&vr;)vr>>=1;if(vr!==0?(Ar&=vr-1,Ar+=vr):Ar=0,ir++,--$r[er]===0){if(er===fr)break;er=Re[Fe+Xe[ir]]}if(er>ar&&(Ar&Pr)!==Tr){for(mr===0&&(mr=ar),Rr+=ur,yr=er-mr,wr=1<<yr;yr+mr<fr&&(wr-=$r[yr+mr],!(wr<=0));)yr++,wr<<=1;if(Sr+=1<<yr,Ke===LENS$1&&Sr>ENOUGH_LENS$1||Ke===DISTS$1&&Sr>ENOUGH_DISTS$1)return 1;Tr=Ar&Pr,We[Tr]=ar<<24|yr<<16|Rr-Ze|0}}return Ar!==0&&(We[Rr+Ar]=er-mr<<24|64<<16|0),Je.bits=ar,0};var inftrees=inflate_table;const CODES=0,LENS=1,DISTS=2,{Z_FINISH:Z_FINISH$1,Z_BLOCK,Z_TREES,Z_OK:Z_OK$1,Z_STREAM_END:Z_STREAM_END$1,Z_NEED_DICT:Z_NEED_DICT$1,Z_STREAM_ERROR:Z_STREAM_ERROR$1,Z_DATA_ERROR:Z_DATA_ERROR$1,Z_MEM_ERROR:Z_MEM_ERROR$1,Z_BUF_ERROR,Z_DEFLATED}=constants$2,HEAD=1,FLAGS=2,TIME=3,OS=4,EXLEN=5,EXTRA=6,NAME=7,COMMENT=8,HCRC=9,DICTID=10,DICT=11,TYPE=12,TYPEDO=13,STORED=14,COPY_=15,COPY=16,TABLE=17,LENLENS=18,CODELENS=19,LEN_=20,LEN=21,LENEXT=22,DIST=23,DISTEXT=24,MATCH=25,LIT=26,CHECK=27,LENGTH=28,DONE=29,BAD=30,MEM=31,SYNC=32,ENOUGH_LENS=852,ENOUGH_DISTS=592,MAX_WBITS=15,DEF_WBITS=MAX_WBITS,zswap32=Ke=>(Ke>>>24&255)+(Ke>>>8&65280)+((Ke&65280)<<8)+((Ke&255)<<24);function InflateState(){this.mode=0,this.last=!1,this.wrap=0,this.havedict=!1,this.flags=0,this.dmax=0,this.check=0,this.total=0,this.head=null,this.wbits=0,this.wsize=0,this.whave=0,this.wnext=0,this.window=null,this.hold=0,this.bits=0,this.length=0,this.offset=0,this.extra=0,this.lencode=null,this.distcode=null,this.lenbits=0,this.distbits=0,this.ncode=0,this.nlen=0,this.ndist=0,this.have=0,this.next=null,this.lens=new Uint16Array(320),this.work=new Uint16Array(288),this.lendyn=null,this.distdyn=null,this.sane=0,this.back=0,this.was=0}const inflateResetKeep=Ke=>{if(!Ke||!Ke.state)return Z_STREAM_ERROR$1;const Re=Ke.state;return Ke.total_in=Ke.total_out=Re.total=0,Ke.msg="",Re.wrap&&(Ke.adler=Re.wrap&1),Re.mode=HEAD,Re.last=0,Re.havedict=0,Re.dmax=32768,Re.head=null,Re.hold=0,Re.bits=0,Re.lencode=Re.lendyn=new Int32Array(ENOUGH_LENS),Re.distcode=Re.distdyn=new Int32Array(ENOUGH_DISTS),Re.sane=1,Re.back=-1,Z_OK$1},inflateReset=Ke=>{if(!Ke||!Ke.state)return Z_STREAM_ERROR$1;const Re=Ke.state;return Re.wsize=0,Re.whave=0,Re.wnext=0,inflateResetKeep(Ke)},inflateReset2=(Ke,Re)=>{let Fe;if(!Ke||!Ke.state)return Z_STREAM_ERROR$1;const qe=Ke.state;return Re<0?(Fe=0,Re=-Re):(Fe=(Re>>4)+1,Re<48&&(Re&=15)),Re&&(Re<8||Re>15)?Z_STREAM_ERROR$1:(qe.window!==null&&qe.wbits!==Re&&(qe.window=null),qe.wrap=Fe,qe.wbits=Re,inflateReset(Ke))},inflateInit2=(Ke,Re)=>{if(!Ke)return Z_STREAM_ERROR$1;const Fe=new InflateState;Ke.state=Fe,Fe.window=null;const qe=inflateReset2(Ke,Re);return qe!==Z_OK$1&&(Ke.state=null),qe},inflateInit=Ke=>inflateInit2(Ke,DEF_WBITS);let virgin=!0,lenfix,distfix;const fixedtables=Ke=>{if(virgin){lenfix=new Int32Array(512),distfix=new Int32Array(32);let Re=0;for(;Re<144;)Ke.lens[Re++]=8;for(;Re<256;)Ke.lens[Re++]=9;for(;Re<280;)Ke.lens[Re++]=7;for(;Re<288;)Ke.lens[Re++]=8;for(inftrees(LENS,Ke.lens,0,288,lenfix,0,Ke.work,{bits:9}),Re=0;Re<32;)Ke.lens[Re++]=5;inftrees(DISTS,Ke.lens,0,32,distfix,0,Ke.work,{bits:5}),virgin=!1}Ke.lencode=lenfix,Ke.lenbits=9,Ke.distcode=distfix,Ke.distbits=5},updatewindow=(Ke,Re,Fe,qe)=>{let We;const Ze=Ke.state;return Ze.window===null&&(Ze.wsize=1<<Ze.wbits,Ze.wnext=0,Ze.whave=0,Ze.window=new Uint8Array(Ze.wsize)),qe>=Ze.wsize?(Ze.window.set(Re.subarray(Fe-Ze.wsize,Fe),0),Ze.wnext=0,Ze.whave=Ze.wsize):(We=Ze.wsize-Ze.wnext,We>qe&&(We=qe),Ze.window.set(Re.subarray(Fe-qe,Fe-qe+We),Ze.wnext),qe-=We,qe?(Ze.window.set(Re.subarray(Fe-qe,Fe),0),Ze.wnext=qe,Ze.whave=Ze.wsize):(Ze.wnext+=We,Ze.wnext===Ze.wsize&&(Ze.wnext=0),Ze.whave<Ze.wsize&&(Ze.whave+=We))),0},inflate$2=(Ke,Re)=>{let Fe,qe,We,Ze,Xe,Je,tr,er,ir,ur,fr,ar,yr,mr,wr=0,Sr,Ar,vr,Ir,Tr,Pr,Rr,Br;const Mr=new Uint8Array(4);let Lr,$r;const Nr=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]);if(!Ke||!Ke.state||!Ke.output||!Ke.input&&Ke.avail_in!==0)return Z_STREAM_ERROR$1;Fe=Ke.state,Fe.mode===TYPE&&(Fe.mode=TYPEDO),Xe=Ke.next_out,We=Ke.output,tr=Ke.avail_out,Ze=Ke.next_in,qe=Ke.input,Je=Ke.avail_in,er=Fe.hold,ir=Fe.bits,ur=Je,fr=tr,Br=Z_OK$1;e:for(;;)switch(Fe.mode){case HEAD:if(Fe.wrap===0){Fe.mode=TYPEDO;break}for(;ir<16;){if(Je===0)break e;Je--,er+=qe[Ze++]<<ir,ir+=8}if(Fe.wrap&2&&er===35615){Fe.check=0,Mr[0]=er&255,Mr[1]=er>>>8&255,Fe.check=crc32_1(Fe.check,Mr,2,0),er=0,ir=0,Fe.mode=FLAGS;break}if(Fe.flags=0,Fe.head&&(Fe.head.done=!1),!(Fe.wrap&1)||(((er&255)<<8)+(er>>8))%31){Ke.msg="incorrect header check",Fe.mode=BAD;break}if((er&15)!==Z_DEFLATED){Ke.msg="unknown compression method",Fe.mode=BAD;break}if(er>>>=4,ir-=4,Rr=(er&15)+8,Fe.wbits===0)Fe.wbits=Rr;else if(Rr>Fe.wbits){Ke.msg="invalid window size",Fe.mode=BAD;break}Fe.dmax=1<<Fe.wbits,Ke.adler=Fe.check=1,Fe.mode=er&512?DICTID:TYPE,er=0,ir=0;break;case FLAGS:for(;ir<16;){if(Je===0)break e;Je--,er+=qe[Ze++]<<ir,ir+=8}if(Fe.flags=er,(Fe.flags&255)!==Z_DEFLATED){Ke.msg="unknown compression method",Fe.mode=BAD;break}if(Fe.flags&57344){Ke.msg="unknown header flags set",Fe.mode=BAD;break}Fe.head&&(Fe.head.text=er>>8&1),Fe.flags&512&&(Mr[0]=er&255,Mr[1]=er>>>8&255,Fe.check=crc32_1(Fe.check,Mr,2,0)),er=0,ir=0,Fe.mode=TIME;case TIME:for(;ir<32;){if(Je===0)break e;Je--,er+=qe[Ze++]<<ir,ir+=8}Fe.head&&(Fe.head.time=er),Fe.flags&512&&(Mr[0]=er&255,Mr[1]=er>>>8&255,Mr[2]=er>>>16&255,Mr[3]=er>>>24&255,Fe.check=crc32_1(Fe.check,Mr,4,0)),er=0,ir=0,Fe.mode=OS;case OS:for(;ir<16;){if(Je===0)break e;Je--,er+=qe[Ze++]<<ir,ir+=8}Fe.head&&(Fe.head.xflags=er&255,Fe.head.os=er>>8),Fe.flags&512&&(Mr[0]=er&255,Mr[1]=er>>>8&255,Fe.check=crc32_1(Fe.check,Mr,2,0)),er=0,ir=0,Fe.mode=EXLEN;case EXLEN:if(Fe.flags&1024){for(;ir<16;){if(Je===0)break e;Je--,er+=qe[Ze++]<<ir,ir+=8}Fe.length=er,Fe.head&&(Fe.head.extra_len=er),Fe.flags&512&&(Mr[0]=er&255,Mr[1]=er>>>8&255,Fe.check=crc32_1(Fe.check,Mr,2,0)),er=0,ir=0}else Fe.head&&(Fe.head.extra=null);Fe.mode=EXTRA;case EXTRA:if(Fe.flags&1024&&(ar=Fe.length,ar>Je&&(ar=Je),ar&&(Fe.head&&(Rr=Fe.head.extra_len-Fe.length,Fe.head.extra||(Fe.head.extra=new Uint8Array(Fe.head.extra_len)),Fe.head.extra.set(qe.subarray(Ze,Ze+ar),Rr)),Fe.flags&512&&(Fe.check=crc32_1(Fe.check,qe,ar,Ze)),Je-=ar,Ze+=ar,Fe.length-=ar),Fe.length))break e;Fe.length=0,Fe.mode=NAME;case NAME:if(Fe.flags&2048){if(Je===0)break e;ar=0;do Rr=qe[Ze+ar++],Fe.head&&Rr&&Fe.length<65536&&(Fe.head.name+=String.fromCharCode(Rr));while(Rr&&ar<Je);if(Fe.flags&512&&(Fe.check=crc32_1(Fe.check,qe,ar,Ze)),Je-=ar,Ze+=ar,Rr)break e}else Fe.head&&(Fe.head.name=null);Fe.length=0,Fe.mode=COMMENT;case COMMENT:if(Fe.flags&4096){if(Je===0)break e;ar=0;do Rr=qe[Ze+ar++],Fe.head&&Rr&&Fe.length<65536&&(Fe.head.comment+=String.fromCharCode(Rr));while(Rr&&ar<Je);if(Fe.flags&512&&(Fe.check=crc32_1(Fe.check,qe,ar,Ze)),Je-=ar,Ze+=ar,Rr)break e}else Fe.head&&(Fe.head.comment=null);Fe.mode=HCRC;case HCRC:if(Fe.flags&512){for(;ir<16;){if(Je===0)break e;Je--,er+=qe[Ze++]<<ir,ir+=8}if(er!==(Fe.check&65535)){Ke.msg="header crc mismatch",Fe.mode=BAD;break}er=0,ir=0}Fe.head&&(Fe.head.hcrc=Fe.flags>>9&1,Fe.head.done=!0),Ke.adler=Fe.check=0,Fe.mode=TYPE;break;case DICTID:for(;ir<32;){if(Je===0)break e;Je--,er+=qe[Ze++]<<ir,ir+=8}Ke.adler=Fe.check=zswap32(er),er=0,ir=0,Fe.mode=DICT;case DICT:if(Fe.havedict===0)return Ke.next_out=Xe,Ke.avail_out=tr,Ke.next_in=Ze,Ke.avail_in=Je,Fe.hold=er,Fe.bits=ir,Z_NEED_DICT$1;Ke.adler=Fe.check=1,Fe.mode=TYPE;case TYPE:if(Re===Z_BLOCK||Re===Z_TREES)break e;case TYPEDO:if(Fe.last){er>>>=ir&7,ir-=ir&7,Fe.mode=CHECK;break}for(;ir<3;){if(Je===0)break e;Je--,er+=qe[Ze++]<<ir,ir+=8}switch(Fe.last=er&1,er>>>=1,ir-=1,er&3){case 0:Fe.mode=STORED;break;case 1:if(fixedtables(Fe),Fe.mode=LEN_,Re===Z_TREES){er>>>=2,ir-=2;break e}break;case 2:Fe.mode=TABLE;break;case 3:Ke.msg="invalid block type",Fe.mode=BAD}er>>>=2,ir-=2;break;case STORED:for(er>>>=ir&7,ir-=ir&7;ir<32;){if(Je===0)break e;Je--,er+=qe[Ze++]<<ir,ir+=8}if((er&65535)!==(er>>>16^65535)){Ke.msg="invalid stored block lengths",Fe.mode=BAD;break}if(Fe.length=er&65535,er=0,ir=0,Fe.mode=COPY_,Re===Z_TREES)break e;case COPY_:Fe.mode=COPY;case COPY:if(ar=Fe.length,ar){if(ar>Je&&(ar=Je),ar>tr&&(ar=tr),ar===0)break e;We.set(qe.subarray(Ze,Ze+ar),Xe),Je-=ar,Ze+=ar,tr-=ar,Xe+=ar,Fe.length-=ar;break}Fe.mode=TYPE;break;case TABLE:for(;ir<14;){if(Je===0)break e;Je--,er+=qe[Ze++]<<ir,ir+=8}if(Fe.nlen=(er&31)+257,er>>>=5,ir-=5,Fe.ndist=(er&31)+1,er>>>=5,ir-=5,Fe.ncode=(er&15)+4,er>>>=4,ir-=4,Fe.nlen>286||Fe.ndist>30){Ke.msg="too many length or distance symbols",Fe.mode=BAD;break}Fe.have=0,Fe.mode=LENLENS;case LENLENS:for(;Fe.have<Fe.ncode;){for(;ir<3;){if(Je===0)break e;Je--,er+=qe[Ze++]<<ir,ir+=8}Fe.lens[Nr[Fe.have++]]=er&7,er>>>=3,ir-=3}for(;Fe.have<19;)Fe.lens[Nr[Fe.have++]]=0;if(Fe.lencode=Fe.lendyn,Fe.lenbits=7,Lr={bits:Fe.lenbits},Br=inftrees(CODES,Fe.lens,0,19,Fe.lencode,0,Fe.work,Lr),Fe.lenbits=Lr.bits,Br){Ke.msg="invalid code lengths set",Fe.mode=BAD;break}Fe.have=0,Fe.mode=CODELENS;case CODELENS:for(;Fe.have<Fe.nlen+Fe.ndist;){for(;wr=Fe.lencode[er&(1<<Fe.lenbits)-1],Sr=wr>>>24,Ar=wr>>>16&255,vr=wr&65535,!(Sr<=ir);){if(Je===0)break e;Je--,er+=qe[Ze++]<<ir,ir+=8}if(vr<16)er>>>=Sr,ir-=Sr,Fe.lens[Fe.have++]=vr;else{if(vr===16){for($r=Sr+2;ir<$r;){if(Je===0)break e;Je--,er+=qe[Ze++]<<ir,ir+=8}if(er>>>=Sr,ir-=Sr,Fe.have===0){Ke.msg="invalid bit length repeat",Fe.mode=BAD;break}Rr=Fe.lens[Fe.have-1],ar=3+(er&3),er>>>=2,ir-=2}else if(vr===17){for($r=Sr+3;ir<$r;){if(Je===0)break e;Je--,er+=qe[Ze++]<<ir,ir+=8}er>>>=Sr,ir-=Sr,Rr=0,ar=3+(er&7),er>>>=3,ir-=3}else{for($r=Sr+7;ir<$r;){if(Je===0)break e;Je--,er+=qe[Ze++]<<ir,ir+=8}er>>>=Sr,ir-=Sr,Rr=0,ar=11+(er&127),er>>>=7,ir-=7}if(Fe.have+ar>Fe.nlen+Fe.ndist){Ke.msg="invalid bit length repeat",Fe.mode=BAD;break}for(;ar--;)Fe.lens[Fe.have++]=Rr}}if(Fe.mode===BAD)break;if(Fe.lens[256]===0){Ke.msg="invalid code -- missing end-of-block",Fe.mode=BAD;break}if(Fe.lenbits=9,Lr={bits:Fe.lenbits},Br=inftrees(LENS,Fe.lens,0,Fe.nlen,Fe.lencode,0,Fe.work,Lr),Fe.lenbits=Lr.bits,Br){Ke.msg="invalid literal/lengths set",Fe.mode=BAD;break}if(Fe.distbits=6,Fe.distcode=Fe.distdyn,Lr={bits:Fe.distbits},Br=inftrees(DISTS,Fe.lens,Fe.nlen,Fe.ndist,Fe.distcode,0,Fe.work,Lr),Fe.distbits=Lr.bits,Br){Ke.msg="invalid distances set",Fe.mode=BAD;break}if(Fe.mode=LEN_,Re===Z_TREES)break e;case LEN_:Fe.mode=LEN;case LEN:if(Je>=6&&tr>=258){Ke.next_out=Xe,Ke.avail_out=tr,Ke.next_in=Ze,Ke.avail_in=Je,Fe.hold=er,Fe.bits=ir,inffast(Ke,fr),Xe=Ke.next_out,We=Ke.output,tr=Ke.avail_out,Ze=Ke.next_in,qe=Ke.input,Je=Ke.avail_in,er=Fe.hold,ir=Fe.bits,Fe.mode===TYPE&&(Fe.back=-1);break}for(Fe.back=0;wr=Fe.lencode[er&(1<<Fe.lenbits)-1],Sr=wr>>>24,Ar=wr>>>16&255,vr=wr&65535,!(Sr<=ir);){if(Je===0)break e;Je--,er+=qe[Ze++]<<ir,ir+=8}if(Ar&&(Ar&240)===0){for(Ir=Sr,Tr=Ar,Pr=vr;wr=Fe.lencode[Pr+((er&(1<<Ir+Tr)-1)>>Ir)],Sr=wr>>>24,Ar=wr>>>16&255,vr=wr&65535,!(Ir+Sr<=ir);){if(Je===0)break e;Je--,er+=qe[Ze++]<<ir,ir+=8}er>>>=Ir,ir-=Ir,Fe.back+=Ir}if(er>>>=Sr,ir-=Sr,Fe.back+=Sr,Fe.length=vr,Ar===0){Fe.mode=LIT;break}if(Ar&32){Fe.back=-1,Fe.mode=TYPE;break}if(Ar&64){Ke.msg="invalid literal/length code",Fe.mode=BAD;break}Fe.extra=Ar&15,Fe.mode=LENEXT;case LENEXT:if(Fe.extra){for($r=Fe.extra;ir<$r;){if(Je===0)break e;Je--,er+=qe[Ze++]<<ir,ir+=8}Fe.length+=er&(1<<Fe.extra)-1,er>>>=Fe.extra,ir-=Fe.extra,Fe.back+=Fe.extra}Fe.was=Fe.length,Fe.mode=DIST;case DIST:for(;wr=Fe.distcode[er&(1<<Fe.distbits)-1],Sr=wr>>>24,Ar=wr>>>16&255,vr=wr&65535,!(Sr<=ir);){if(Je===0)break e;Je--,er+=qe[Ze++]<<ir,ir+=8}if((Ar&240)===0){for(Ir=Sr,Tr=Ar,Pr=vr;wr=Fe.distcode[Pr+((er&(1<<Ir+Tr)-1)>>Ir)],Sr=wr>>>24,Ar=wr>>>16&255,vr=wr&65535,!(Ir+Sr<=ir);){if(Je===0)break e;Je--,er+=qe[Ze++]<<ir,ir+=8}er>>>=Ir,ir-=Ir,Fe.back+=Ir}if(er>>>=Sr,ir-=Sr,Fe.back+=Sr,Ar&64){Ke.msg="invalid distance code",Fe.mode=BAD;break}Fe.offset=vr,Fe.extra=Ar&15,Fe.mode=DISTEXT;case DISTEXT:if(Fe.extra){for($r=Fe.extra;ir<$r;){if(Je===0)break e;Je--,er+=qe[Ze++]<<ir,ir+=8}Fe.offset+=er&(1<<Fe.extra)-1,er>>>=Fe.extra,ir-=Fe.extra,Fe.back+=Fe.extra}if(Fe.offset>Fe.dmax){Ke.msg="invalid distance too far back",Fe.mode=BAD;break}Fe.mode=MATCH;case MATCH:if(tr===0)break e;if(ar=fr-tr,Fe.offset>ar){if(ar=Fe.offset-ar,ar>Fe.whave&&Fe.sane){Ke.msg="invalid distance too far back",Fe.mode=BAD;break}ar>Fe.wnext?(ar-=Fe.wnext,yr=Fe.wsize-ar):yr=Fe.wnext-ar,ar>Fe.length&&(ar=Fe.length),mr=Fe.window}else mr=We,yr=Xe-Fe.offset,ar=Fe.length;ar>tr&&(ar=tr),tr-=ar,Fe.length-=ar;do We[Xe++]=mr[yr++];while(--ar);Fe.length===0&&(Fe.mode=LEN);break;case LIT:if(tr===0)break e;We[Xe++]=Fe.length,tr--,Fe.mode=LEN;break;case CHECK:if(Fe.wrap){for(;ir<32;){if(Je===0)break e;Je--,er|=qe[Ze++]<<ir,ir+=8}if(fr-=tr,Ke.total_out+=fr,Fe.total+=fr,fr&&(Ke.adler=Fe.check=Fe.flags?crc32_1(Fe.check,We,fr,Xe-fr):adler32_1(Fe.check,We,fr,Xe-fr)),fr=tr,(Fe.flags?er:zswap32(er))!==Fe.check){Ke.msg="incorrect data check",Fe.mode=BAD;break}er=0,ir=0}Fe.mode=LENGTH;case LENGTH:if(Fe.wrap&&Fe.flags){for(;ir<32;){if(Je===0)break e;Je--,er+=qe[Ze++]<<ir,ir+=8}if(er!==(Fe.total&4294967295)){Ke.msg="incorrect length check",Fe.mode=BAD;break}er=0,ir=0}Fe.mode=DONE;case DONE:Br=Z_STREAM_END$1;break e;case BAD:Br=Z_DATA_ERROR$1;break e;case MEM:return Z_MEM_ERROR$1;case SYNC:default:return Z_STREAM_ERROR$1}return Ke.next_out=Xe,Ke.avail_out=tr,Ke.next_in=Ze,Ke.avail_in=Je,Fe.hold=er,Fe.bits=ir,(Fe.wsize||fr!==Ke.avail_out&&Fe.mode<BAD&&(Fe.mode<CHECK||Re!==Z_FINISH$1))&&updatewindow(Ke,Ke.output,Ke.next_out,fr-Ke.avail_out),ur-=Ke.avail_in,fr-=Ke.avail_out,Ke.total_in+=ur,Ke.total_out+=fr,Fe.total+=fr,Fe.wrap&&fr&&(Ke.adler=Fe.check=Fe.flags?crc32_1(Fe.check,We,fr,Ke.next_out-fr):adler32_1(Fe.check,We,fr,Ke.next_out-fr)),Ke.data_type=Fe.bits+(Fe.last?64:0)+(Fe.mode===TYPE?128:0)+(Fe.mode===LEN_||Fe.mode===COPY_?256:0),(ur===0&&fr===0||Re===Z_FINISH$1)&&Br===Z_OK$1&&(Br=Z_BUF_ERROR),Br},inflateEnd=Ke=>{if(!Ke||!Ke.state)return Z_STREAM_ERROR$1;let Re=Ke.state;return Re.window&&(Re.window=null),Ke.state=null,Z_OK$1},inflateGetHeader=(Ke,Re)=>{if(!Ke||!Ke.state)return Z_STREAM_ERROR$1;const Fe=Ke.state;return(Fe.wrap&2)===0?Z_STREAM_ERROR$1:(Fe.head=Re,Re.done=!1,Z_OK$1)},inflateSetDictionary=(Ke,Re)=>{const Fe=Re.length;let qe,We,Ze;return!Ke||!Ke.state||(qe=Ke.state,qe.wrap!==0&&qe.mode!==DICT)?Z_STREAM_ERROR$1:qe.mode===DICT&&(We=1,We=adler32_1(We,Re,Fe,0),We!==qe.check)?Z_DATA_ERROR$1:(Ze=updatewindow(Ke,Re,Fe,Fe),Ze?(qe.mode=MEM,Z_MEM_ERROR$1):(qe.havedict=1,Z_OK$1))};var inflateReset_1=inflateReset,inflateReset2_1=inflateReset2,inflateResetKeep_1=inflateResetKeep,inflateInit_1=inflateInit,inflateInit2_1=inflateInit2,inflate_2$1=inflate$2,inflateEnd_1=inflateEnd,inflateGetHeader_1=inflateGetHeader,inflateSetDictionary_1=inflateSetDictionary,inflateInfo="pako inflate (from Nodeca project)",inflate_1$2={inflateReset:inflateReset_1,inflateReset2:inflateReset2_1,inflateResetKeep:inflateResetKeep_1,inflateInit:inflateInit_1,inflateInit2:inflateInit2_1,inflate:inflate_2$1,inflateEnd:inflateEnd_1,inflateGetHeader:inflateGetHeader_1,inflateSetDictionary:inflateSetDictionary_1,inflateInfo};function GZheader(){this.text=0,this.time=0,this.xflags=0,this.os=0,this.extra=null,this.extra_len=0,this.name="",this.comment="",this.hcrc=0,this.done=!1}var gzheader=GZheader;const toString=Object.prototype.toString,{Z_NO_FLUSH,Z_FINISH,Z_OK,Z_STREAM_END,Z_NEED_DICT,Z_STREAM_ERROR,Z_DATA_ERROR,Z_MEM_ERROR}=constants$2;function Inflate$1(Ke){this.options=common.assign({chunkSize:1024*64,windowBits:15,to:""},Ke||{});const Re=this.options;Re.raw&&Re.windowBits>=0&&Re.windowBits<16&&(Re.windowBits=-Re.windowBits,Re.windowBits===0&&(Re.windowBits=-15)),Re.windowBits>=0&&Re.windowBits<16&&!(Ke&&Ke.windowBits)&&(Re.windowBits+=32),Re.windowBits>15&&Re.windowBits<48&&(Re.windowBits&15)===0&&(Re.windowBits|=15),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new zstream,this.strm.avail_out=0;let Fe=inflate_1$2.inflateInit2(this.strm,Re.windowBits);if(Fe!==Z_OK)throw new Error(messages[Fe]);if(this.header=new gzheader,inflate_1$2.inflateGetHeader(this.strm,this.header),Re.dictionary&&(typeof Re.dictionary=="string"?Re.dictionary=strings.string2buf(Re.dictionary):toString.call(Re.dictionary)==="[object ArrayBuffer]"&&(Re.dictionary=new Uint8Array(Re.dictionary)),Re.raw&&(Fe=inflate_1$2.inflateSetDictionary(this.strm,Re.dictionary),Fe!==Z_OK)))throw new Error(messages[Fe])}Inflate$1.prototype.push=function(Ke,Re){const Fe=this.strm,qe=this.options.chunkSize,We=this.options.dictionary;let Ze,Xe,Je;if(this.ended)return!1;for(Re===~~Re?Xe=Re:Xe=Re===!0?Z_FINISH:Z_NO_FLUSH,toString.call(Ke)==="[object ArrayBuffer]"?Fe.input=new Uint8Array(Ke):Fe.input=Ke,Fe.next_in=0,Fe.avail_in=Fe.input.length;;){for(Fe.avail_out===0&&(Fe.output=new Uint8Array(qe),Fe.next_out=0,Fe.avail_out=qe),Ze=inflate_1$2.inflate(Fe,Xe),Ze===Z_NEED_DICT&&We&&(Ze=inflate_1$2.inflateSetDictionary(Fe,We),Ze===Z_OK?Ze=inflate_1$2.inflate(Fe,Xe):Ze===Z_DATA_ERROR&&(Ze=Z_NEED_DICT));Fe.avail_in>0&&Ze===Z_STREAM_END&&Fe.state.wrap>0&&Ke[Fe.next_in]!==0;)inflate_1$2.inflateReset(Fe),Ze=inflate_1$2.inflate(Fe,Xe);switch(Ze){case Z_STREAM_ERROR:case Z_DATA_ERROR:case Z_NEED_DICT:case Z_MEM_ERROR:return this.onEnd(Ze),this.ended=!0,!1}if(Je=Fe.avail_out,Fe.next_out&&(Fe.avail_out===0||Ze===Z_STREAM_END))if(this.options.to==="string"){let tr=strings.utf8border(Fe.output,Fe.next_out),er=Fe.next_out-tr,ir=strings.buf2string(Fe.output,tr);Fe.next_out=er,Fe.avail_out=qe-er,er&&Fe.output.set(Fe.output.subarray(tr,tr+er),0),this.onData(ir)}else this.onData(Fe.output.length===Fe.next_out?Fe.output:Fe.output.subarray(0,Fe.next_out));if(!(Ze===Z_OK&&Je===0)){if(Ze===Z_STREAM_END)return Ze=inflate_1$2.inflateEnd(this.strm),this.onEnd(Ze),this.ended=!0,!0;if(Fe.avail_in===0)break}}return!0};Inflate$1.prototype.onData=function(Ke){this.chunks.push(Ke)};Inflate$1.prototype.onEnd=function(Ke){Ke===Z_OK&&(this.options.to==="string"?this.result=this.chunks.join(""):this.result=common.flattenChunks(this.chunks)),this.chunks=[],this.err=Ke,this.msg=this.strm.msg};function inflate$1(Ke,Re){const Fe=new Inflate$1(Re);if(Fe.push(Ke),Fe.err)throw Fe.msg||messages[Fe.err];return Fe.result}function inflateRaw$1(Ke,Re){return Re=Re||{},Re.raw=!0,inflate$1(Ke,Re)}var Inflate_1$1=Inflate$1,inflate_2=inflate$1,inflateRaw_1$1=inflateRaw$1,ungzip$1=inflate$1,constants=constants$2,inflate_1$1={Inflate:Inflate_1$1,inflate:inflate_2,inflateRaw:inflateRaw_1$1,ungzip:ungzip$1,constants};const{Inflate,inflate,inflateRaw,ungzip}=inflate_1$1;var inflate_1=inflate,w=Object.freeze({__proto__:null,encode:function(Ke){return Ke.reduce((Re,Fe)=>Re+Fe.toString(16).padStart(2,"0"),"0x")},decode:function(Ke){Ke.indexOf("0x")===0&&(Ke=Ke.substr(2)),Ke.length%2==1&&(Ke="0"+Ke);let Re=Ke.match(/.{2}/g);return Re===null?buffer.Buffer.from([]):buffer.Buffer.from(Re.map(Fe=>parseInt(Fe,16)))}});function v(Ke){return new TextDecoder("utf-8").decode(Ke)}function b(Ke){return new TextEncoder().encode(Ke)}var A=Object.freeze({__proto__:null,decode:v,encode:b});function _(Ke){return bs58.encode(Ke)}var S=Object.freeze({__proto__:null,encode:_,decode:function(Ke){return bs58.decode(Ke)}});function E(Ke){return buffer.Buffer.from(toByteArray_1(Ke))}var I=Object.freeze({__proto__:null,encode:function(Ke){return fromByteArray_1(Ke)},decode:E}),k=Object.freeze({__proto__:null,hex:w,utf8:A,bs58:S,base64:I});function M(Ke){const Re=new Map;return Ke.errors&&Ke.errors.forEach(Fe=>{var qe;let We=(qe=Fe.msg)!==null&&qe!==void 0?qe:Fe.name;Re.set(Fe.code,We)}),Re}function x(Ke,...Re){if(Ke.args.length!=Re.length)throw new Error("Invalid argument length");const Fe={};let qe=0;return Ke.args.forEach(We=>{Fe[We.name]=Re[qe],qe+=1}),Fe}function P(Ke,Re={}){Ke.forEach(Fe=>{if("accounts"in Fe)P(Fe.accounts,Re[Fe.name]);else if(Re[Fe.name]===void 0)throw new Error(`Invalid arguments: ${Fe.name} not provided.`)})}function L(Ke){return Ke instanceof PublicKey?Ke:new PublicKey(Ke)}class T extends TypeError{constructor(Re,Fe){let qe;const{message:We,...Ze}=Re,{path:Xe}=Re;super(Xe.length===0?We:"At path: "+Xe.join(".")+" -- "+We),this.value=void 0,this.key=void 0,this.type=void 0,this.refinement=void 0,this.path=void 0,this.branch=void 0,this.failures=void 0,Object.assign(this,Ze),this.name=this.constructor.name,this.failures=()=>{var Je;return(Je=qe)!=null?Je:qe=[Re,...Fe()]}}}function C(Ke){return typeof Ke=="object"&&Ke!=null}function z(Ke){return typeof Ke=="string"?JSON.stringify(Ke):""+Ke}function B(Ke,Re,Fe,qe){if(Ke===!0)return;Ke===!1?Ke={}:typeof Ke=="string"&&(Ke={message:Ke});const{path:We,branch:Ze}=Re,{type:Xe}=Fe,{refinement:Je,message:tr="Expected a value of type `"+Xe+"`"+(Je?" with refinement `"+Je+"`":"")+", but received: `"+z(qe)+"`"}=Ke;return{value:qe,type:Xe,refinement:Je,key:We[We.length-1],path:We,branch:Ze,...Ke,message:tr}}function*O(Ke,Re,Fe,qe){var We;C(We=Ke)&&typeof We[Symbol.iterator]=="function"||(Ke=[Ke]);for(const Ze of Ke){const Xe=B(Ze,Re,Fe,qe);Xe&&(yield Xe)}}function*D(Ke,Re,Fe){Fe===void 0&&(Fe={});const{path:qe=[],branch:We=[Ke],coerce:Ze=!1,mask:Xe=!1}=Fe,Je={path:qe,branch:We};if(Ze&&(Ke=Re.coercer(Ke,Je),Xe&&Re.type!=="type"&&C(Re.schema)&&C(Ke)&&!Array.isArray(Ke)))for(const er in Ke)Re.schema[er]===void 0&&delete Ke[er];let tr=!0;for(const er of Re.validator(Ke,Je))tr=!1,yield[er,void 0];for(let[er,ir,ur]of Re.entries(Ke,Je)){const fr=D(ir,ur,{path:er===void 0?qe:[...qe,er],branch:er===void 0?We:[...We,ir],coerce:Ze,mask:Xe});for(const ar of fr)ar[0]?(tr=!1,yield[ar[0],void 0]):Ze&&(ir=ar[1],er===void 0?Ke=ir:Ke instanceof Map?Ke.set(er,ir):Ke instanceof Set?Ke.add(ir):C(Ke)&&(Ke[er]=ir))}if(tr)for(const er of Re.refiner(Ke,Je))tr=!1,yield[er,void 0];tr&&(yield[void 0,Ke])}class N{constructor(Re){this.TYPE=void 0,this.type=void 0,this.schema=void 0,this.coercer=void 0,this.validator=void 0,this.refiner=void 0,this.entries=void 0;const{type:Fe,schema:qe,validator:We,refiner:Ze,coercer:Xe=tr=>tr,entries:Je=function*(){}}=Re;this.type=Fe,this.schema=qe,this.entries=Je,this.coercer=Xe,this.validator=We?(tr,er)=>O(We(tr,er),er,this,tr):()=>[],this.refiner=Ze?(tr,er)=>O(Ze(tr,er),er,this,tr):()=>[]}assert(Re){return function(Fe,qe){const We=U(Fe,qe);if(We[0])throw We[0]}(Re,this)}create(Re){return R(Re,this)}is(Re){return V(Re,this)}mask(Re){return function(Fe,qe){const We=U(Fe,qe,{coerce:!0,mask:!0});if(We[0])throw We[0];return We[1]}(Re,this)}validate(Re,Fe){return Fe===void 0&&(Fe={}),U(Re,this,Fe)}}function R(Ke,Re){const Fe=U(Ke,Re,{coerce:!0});if(Fe[0])throw Fe[0];return Fe[1]}function V(Ke,Re){return!U(Ke,Re)[0]}function U(Ke,Re,Fe){Fe===void 0&&(Fe={});const qe=D(Ke,Re,Fe),We=function(Ze){const{done:Xe,value:Je}=Ze.next();return Xe?void 0:Je}(qe);return We[0]?[new T(We[0],function*(){for(const Ze of qe)Ze[0]&&(yield Ze[0])}),void 0]:[void 0,We[1]]}function j(Ke,Re){return new N({type:Ke,schema:null,validator:Re})}function $(Ke){return new N({type:"array",schema:Ke,*entries(Re){if(Ke&&Array.isArray(Re))for(const[Fe,qe]of Re.entries())yield[Fe,qe,Ke]},coercer:Re=>Array.isArray(Re)?Re.slice():Re,validator:Re=>Array.isArray(Re)||"Expected an array value, but received: "+z(Re)})}function K(Ke){const Re=z(Ke),Fe=typeof Ke;return new N({type:"literal",schema:Fe==="string"||Fe==="number"||Fe==="boolean"?Ke:null,validator:qe=>qe===Ke||"Expected the literal `"+Re+"`, but received: "+z(qe)})}function q(Ke){return new N({...Ke,validator:(Re,Fe)=>Re===null||Ke.validator(Re,Fe),refiner:(Re,Fe)=>Re===null||Ke.refiner(Re,Fe)})}function F(){return j("number",Ke=>typeof Ke=="number"&&!isNaN(Ke)||"Expected a number, but received: "+z(Ke))}function W(Ke){return new N({...Ke,validator:(Re,Fe)=>Re===void 0||Ke.validator(Re,Fe),refiner:(Re,Fe)=>Re===void 0||Ke.refiner(Re,Fe)})}function G(){return j("string",Ke=>typeof Ke=="string"||"Expected a string, but received: "+z(Ke))}function H(Ke){const Re=Object.keys(Ke);return new N({type:"type",schema:Ke,*entries(Fe){if(C(Fe))for(const qe of Re)yield[qe,Fe[qe],Ke[qe]]},validator:Fe=>C(Fe)||"Expected an object, but received: "+z(Fe)})}function J(Ke){const Re=Ke.map(Fe=>Fe.type).join(" | ");return new N({type:"union",schema:null,coercer:(Fe,qe)=>(Ke.find(We=>{const[Ze]=We.validate(Fe,{coerce:!0});return!Ze})||Z()).coercer(Fe,qe),validator(Fe,qe){const We=[];for(const Ze of Ke){const[...Xe]=D(Fe,Ze,qe),[Je]=Xe;if(!Je[0])return[];for(const[tr]of Xe)tr&&We.push(tr)}return["Expected the value to satisfy a union of `"+Re+"`, but received: "+z(Fe),...We]}})}function Z(){return j("unknown",()=>!0)}async function X(Ke,Re,Fe){if(Re.length<=99)return await Q(Ke,Re,Fe);{const qe=function(We,Ze){return Array.apply(0,new Array(Math.ceil(We.length/Ze))).map((Xe,Je)=>We.slice(Je*Ze,(Je+1)*Ze))}(Re,99);return(await Promise.all(qe.map(We=>Q(Ke,We,Fe)))).flat()}}async function Q(Ke,Re,Fe){const qe=Fe!=null?Fe:Ke.commitment;return(await Ke.getMultipleAccountsInfo(Re,qe)).map((We,Ze)=>We===null?null:{publicKey:Re[Ze],account:We})}async function Y(Ke,Re,Fe,qe,We){Fe&&Fe.length>0&&Re.sign(...Fe);const Ze=Re._compile(),Xe=Ze.serialize(),Je=Re._serialize(Xe).toString("base64"),tr={encoding:"base64",commitment:qe!=null?qe:Ke.commitment};if(We){const ur=(Array.isArray(We)?We:Ze.nonProgramIds()).map(fr=>fr.toBase58());tr.accounts={encoding:"base64",addresses:ur}}Fe&&(tr.sigVerify=!0);const er=[Je,tr],ir=R(await Ke._rpcRequest("simulateTransaction",er),rt);if("error"in ir){let ur;if("data"in ir.error&&(ur=ir.error.data.logs,ur&&Array.isArray(ur))){const fr=`
    `,ar=fr+ur.join(fr);console.error(ir.error.message,ar)}throw new SendTransactionError("failed to simulate transaction: "+ir.error.message,ur)}return ir.result}function tt(Ke){return function(Re,Fe,qe){return new N({...Re,coercer:(We,Ze)=>V(We,Fe)?Re.coercer(qe(We,Ze),Ze):Re.coercer(We,Ze)})}(nt(Ke),et,Re=>"error"in Re?Re:{...Re,result:R(Re.result,Ke)})}const et=nt(Z());function nt(Ke){return J([H({jsonrpc:K("2.0"),id:G(),result:Ke}),H({jsonrpc:K("2.0"),id:G(),error:H({code:Z(),message:G(),data:W(j("any",()=>!0))})})])}const rt=(ot=H({err:q(J([H({}),G()])),logs:q($(G())),accounts:W(q($(q(H({executable:j("boolean",Ke=>typeof Ke=="boolean"),owner:G(),lamports:F(),data:$(G()),rentEpoch:W(F())}))))),unitsConsumed:W(F())}),tt(H({context:H({slot:F()}),value:ot})));var ot,it=Object.freeze({__proto__:null,invoke:async function(Ke,Re,Fe,qe){Ke=L(Ke),qe||(qe=lt());const We=new Transaction;if(We.add(new TransactionInstruction({programId:Ke,keys:Re!=null?Re:[],data:Fe})),qe.sendAndConfirm===void 0)throw new Error("This function requires 'Provider.sendAndConfirm' to be implemented.");return await qe.sendAndConfirm(We,[])},getMultipleAccounts:X,simulateTransaction:Y});class st{constructor(Re,Fe,qe){this.connection=Re,this.wallet=Fe,this.opts=qe,this.publicKey=Fe.publicKey}static defaultOptions(){return{preflightCommitment:"processed",commitment:"processed"}}static local(Re,Fe){throw new Error("Provider local is not available on browser.")}static env(){throw new Error("Provider env is not available on browser.")}async sendAndConfirm(Re,Fe,qe){var We;qe===void 0&&(qe=this.opts),Re.feePayer=this.wallet.publicKey,Re.recentBlockhash=(await this.connection.getRecentBlockhash(qe.preflightCommitment)).blockhash,Re=await this.wallet.signTransaction(Re),(Fe!=null?Fe:[]).forEach(Xe=>{Re.partialSign(Xe)});const Ze=Re.serialize();try{return await ct(this.connection,Ze,qe)}catch(Xe){if(Xe instanceof ut){const Je=await this.connection.getTransaction(_(Re.signature),{commitment:"confirmed"});if(Je){const tr=(We=Je.meta)===null||We===void 0?void 0:We.logMessages;throw tr?new SendTransactionError(Xe.message,tr):Xe}throw Xe}throw Xe}}async sendAll(Re,Fe){Fe===void 0&&(Fe=this.opts);const qe=await this.connection.getRecentBlockhash(Fe.preflightCommitment);let We=Re.map(Je=>{var tr;let er=Je.tx,ir=(tr=Je.signers)!==null&&tr!==void 0?tr:[];return er.feePayer=this.wallet.publicKey,er.recentBlockhash=qe.blockhash,ir.forEach(ur=>{er.partialSign(ur)}),er});const Ze=await this.wallet.signAllTransactions(We),Xe=[];for(let Je=0;Je<We.length;Je+=1){const tr=Ze[Je].serialize();Xe.push(await ct(this.connection,tr,Fe))}return Xe}async simulate(Re,Fe,qe,We){Re.feePayer=this.wallet.publicKey,Re.recentBlockhash=(await this.connection.getLatestBlockhash(qe!=null?qe:this.connection.commitment)).blockhash,Re=await this.wallet.signTransaction(Re);const Ze=await Y(this.connection,Re,Fe,qe,We);if(Ze.value.err)throw new at(Ze.value);return Ze.value}}class at extends Error{constructor(Re,Fe){super(Fe),this.simulationResponse=Re}}async function ct(Ke,Re,Fe){const qe=Fe&&{skipPreflight:Fe.skipPreflight,preflightCommitment:Fe.preflightCommitment||Fe.commitment},We=await Ke.sendRawTransaction(Re,qe),Ze=(await Ke.confirmTransaction(We,Fe&&Fe.commitment)).value;if(Ze.err)throw new ut(`Raw transaction ${We} failed (${JSON.stringify(Ze)})`);return We}class ut extends Error{constructor(Re){super(Re)}}function lt(){return ht===null?st.local():ht}let ht=null;const pt=new Set(["anchor-deprecated-state","debug-logs"]),ft=new Map;function mt(Ke){return ft.get(Ke)!==void 0}var yt=Object.freeze({__proto__:null,set:function(Ke){if(!pt.has(Ke))throw new Error("Invalid feature");ft.set(Ke,!0)},isSet:mt});class gt extends Error{constructor(Re){super(Re),this.name="IdlError"}}class wt{constructor(Re){this.stack=Re}static parse(Re){var Fe;const qe=/^Program (\w*) invoke/,We=/^Program \w* success/,Ze=[];for(let Xe=0;Xe<Re.length;Xe++){if(We.exec(Re[Xe])){Ze.pop();continue}const Je=(Fe=qe.exec(Re[Xe]))===null||Fe===void 0?void 0:Fe[1];Je&&Ze.push(new PublicKey(Je))}return new wt(Ze)}}class vt extends Error{constructor(Re,Fe,qe,We,Ze,Xe){super(qe.join(`
`).replace("Program log: ","")),this.errorLogs=qe,this.logs=We,this.error={errorCode:Re,errorMessage:Fe,comparedValues:Xe,origin:Ze},this._programErrorStack=wt.parse(We)}static parse(Re){if(!Re)return null;const Fe=Re.findIndex(er=>er.startsWith("Program log: AnchorError"));if(Fe===-1)return null;const qe=Re[Fe],We=[qe];let Ze;if(Fe+1<Re.length){if(Re[Fe+1]==="Program log: Left:"){const er=/^Program log: (.*)$/,ir=er.exec(Re[Fe+2])[1],ur=er.exec(Re[Fe+4])[1];Ze=[new PublicKey(ir),new PublicKey(ur)],We.push(...Re.slice(Fe+1,Fe+5))}else if(Re[Fe+1].startsWith("Program log: Left:")){const er=/^Program log: (Left|Right): (.*)$/,ir=er.exec(Re[Fe+1])[2],ur=er.exec(Re[Fe+2])[2];We.push(...Re.slice(Fe+1,Fe+3)),Ze=[ir,ur]}}const Xe=/^Program log: AnchorError occurred\. Error Code: (.*)\. Error Number: (\d*)\. Error Message: (.*)\./.exec(qe),Je=/^Program log: AnchorError thrown in (.*):(\d*)\. Error Code: (.*)\. Error Number: (\d*)\. Error Message: (.*)\./.exec(qe),tr=/^Program log: AnchorError caused by account: (.*)\. Error Code: (.*)\. Error Number: (\d*)\. Error Message: (.*)\./.exec(qe);if(Xe){const[er,ir,ur]=Xe.slice(1,4),fr={code:er,number:parseInt(ir)};return new vt(fr,ur,We,Re,void 0,Ze)}if(Je){const[er,ir,ur,fr,ar]=Je.slice(1,6),yr={code:ur,number:parseInt(fr)},mr={file:er,line:parseInt(ir)};return new vt(yr,ar,We,Re,mr,Ze)}if(tr){const[er,ir,ur,fr]=tr.slice(1,5),ar=er,yr={code:ir,number:parseInt(ur)};return new vt(yr,fr,We,Re,ar,Ze)}return null}get program(){return this._programErrorStack.stack[this._programErrorStack.stack.length-1]}get programErrorStack(){return this._programErrorStack.stack}toString(){return this.message}}class bt extends Error{constructor(Re,Fe,qe){super(),this.code=Re,this.msg=Fe,this.logs=qe,qe&&(this._programErrorStack=wt.parse(qe))}static parse(Re,Fe){const qe=Re.toString();let We,Ze;if(qe.includes("custom program error:")){let Je=qe.split("custom program error: ");if(Je.length!==2)return null;We=Je[1]}else{const Je=qe.match(/"Custom":([0-9]+)}/g);if(!Je||Je.length>1)return null;We=Je[0].match(/([0-9]+)/g)[0]}try{Ze=parseInt(We)}catch{return null}let Xe=Fe.get(Ze);return Xe!==void 0?new bt(Ze,Xe,Re.logs):(Xe=St.get(Ze),Xe!==void 0?new bt(Ze,Xe,Re.logs):null)}get program(){var Re;return(Re=this._programErrorStack)===null||Re===void 0?void 0:Re.stack[this._programErrorStack.stack.length-1]}get programErrorStack(){var Re;return(Re=this._programErrorStack)===null||Re===void 0?void 0:Re.stack}toString(){return this.msg}}function At(Ke,Re){mt("debug-logs")&&console.log("Translating error:",Ke);const Fe=vt.parse(Ke.logs);if(Fe)return Fe;const qe=bt.parse(Ke,Re);if(qe)return qe;if(Ke.logs){const We={get:function(Ze,Xe){return Xe==="programErrorStack"?Ze.programErrorStack.stack:Xe==="program"?Ze.programErrorStack.stack[Ke.programErrorStack.stack.length-1]:Reflect.get(...arguments)}};return Ke.programErrorStack=wt.parse(Ke.logs),new Proxy(Ke,We)}return Ke}const _t={InstructionMissing:100,InstructionFallbackNotFound:101,InstructionDidNotDeserialize:102,InstructionDidNotSerialize:103,IdlInstructionStub:1e3,IdlInstructionInvalidProgram:1001,ConstraintMut:2e3,ConstraintHasOne:2001,ConstraintSigner:2002,ConstraintRaw:2003,ConstraintOwner:2004,ConstraintRentExempt:2005,ConstraintSeeds:2006,ConstraintExecutable:2007,ConstraintState:2008,ConstraintAssociated:2009,ConstraintAssociatedInit:2010,ConstraintClose:2011,ConstraintAddress:2012,ConstraintZero:2013,ConstraintTokenMint:2014,ConstraintTokenOwner:2015,ConstraintMintMintAuthority:2016,ConstraintMintFreezeAuthority:2017,ConstraintMintDecimals:2018,ConstraintSpace:2019,RequireViolated:2500,RequireEqViolated:2501,RequireKeysEqViolated:2502,RequireNeqViolated:2503,RequireKeysNeqViolated:2504,RequireGtViolated:2505,RequireGteViolated:2506,AccountDiscriminatorAlreadySet:3e3,AccountDiscriminatorNotFound:3001,AccountDiscriminatorMismatch:3002,AccountDidNotDeserialize:3003,AccountDidNotSerialize:3004,AccountNotEnoughKeys:3005,AccountNotMutable:3006,AccountOwnedByWrongProgram:3007,InvalidProgramId:3008,InvalidProgramExecutable:3009,AccountNotSigner:3010,AccountNotSystemOwned:3011,AccountNotInitialized:3012,AccountNotProgramData:3013,AccountNotAssociatedTokenAccount:3014,AccountSysvarMismatch:3015,AccountReallocExceedsLimit:3016,AccountDuplicateReallocs:3017,StateInvalidAddress:4e3,DeclaredProgramIdMismatch:4100,Deprecated:5e3},St=new Map([[_t.InstructionMissing,"8 byte instruction identifier not provided"],[_t.InstructionFallbackNotFound,"Fallback functions are not supported"],[_t.InstructionDidNotDeserialize,"The program could not deserialize the given instruction"],[_t.InstructionDidNotSerialize,"The program could not serialize the given instruction"],[_t.IdlInstructionStub,"The program was compiled without idl instructions"],[_t.IdlInstructionInvalidProgram,"The transaction was given an invalid program for the IDL instruction"],[_t.ConstraintMut,"A mut constraint was violated"],[_t.ConstraintHasOne,"A has_one constraint was violated"],[_t.ConstraintSigner,"A signer constraint was violated"],[_t.ConstraintRaw,"A raw constraint was violated"],[_t.ConstraintOwner,"An owner constraint was violated"],[_t.ConstraintRentExempt,"A rent exemption constraint was violated"],[_t.ConstraintSeeds,"A seeds constraint was violated"],[_t.ConstraintExecutable,"An executable constraint was violated"],[_t.ConstraintState,"A state constraint was violated"],[_t.ConstraintAssociated,"An associated constraint was violated"],[_t.ConstraintAssociatedInit,"An associated init constraint was violated"],[_t.ConstraintClose,"A close constraint was violated"],[_t.ConstraintAddress,"An address constraint was violated"],[_t.ConstraintZero,"Expected zero account discriminant"],[_t.ConstraintTokenMint,"A token mint constraint was violated"],[_t.ConstraintTokenOwner,"A token owner constraint was violated"],[_t.ConstraintMintMintAuthority,"A mint mint authority constraint was violated"],[_t.ConstraintMintFreezeAuthority,"A mint freeze authority constraint was violated"],[_t.ConstraintMintDecimals,"A mint decimals constraint was violated"],[_t.ConstraintSpace,"A space constraint was violated"],[_t.RequireViolated,"A require expression was violated"],[_t.RequireEqViolated,"A require_eq expression was violated"],[_t.RequireKeysEqViolated,"A require_keys_eq expression was violated"],[_t.RequireNeqViolated,"A require_neq expression was violated"],[_t.RequireKeysNeqViolated,"A require_keys_neq expression was violated"],[_t.RequireGtViolated,"A require_gt expression was violated"],[_t.RequireGteViolated,"A require_gte expression was violated"],[_t.AccountDiscriminatorAlreadySet,"The account discriminator was already set on this account"],[_t.AccountDiscriminatorNotFound,"No 8 byte discriminator was found on the account"],[_t.AccountDiscriminatorMismatch,"8 byte discriminator did not match what was expected"],[_t.AccountDidNotDeserialize,"Failed to deserialize the account"],[_t.AccountDidNotSerialize,"Failed to serialize the account"],[_t.AccountNotEnoughKeys,"Not enough account keys given to the instruction"],[_t.AccountNotMutable,"The given account is not mutable"],[_t.AccountOwnedByWrongProgram,"The given account is owned by a different program than expected"],[_t.InvalidProgramId,"Program ID was not as expected"],[_t.InvalidProgramExecutable,"Program account is not executable"],[_t.AccountNotSigner,"The given account did not sign"],[_t.AccountNotSystemOwned,"The given account is not owned by the system program"],[_t.AccountNotInitialized,"The program expected this account to be already initialized"],[_t.AccountNotProgramData,"The given account is not a program data account"],[_t.AccountNotAssociatedTokenAccount,"The given account is not the associated token account"],[_t.AccountSysvarMismatch,"The given public key does not match the required sysvar"],[_t.AccountReallocExceedsLimit,"The account reallocation exceeds the MAX_PERMITTED_DATA_INCREASE limit"],[_t.AccountDuplicateReallocs,"The account was duplicated for more than one reallocation"],[_t.StateInvalidAddress,"The given state account does not have the correct address"],[_t.DeclaredProgramIdMismatch,"The declared program id does not match the actual program id"],[_t.Deprecated,"The API being used is deprecated and should no longer be used"]]);/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */var Et=function(){return Et=Object.assign||function(Ke){for(var Re,Fe=1,qe=arguments.length;Fe<qe;Fe++)for(var We in Re=arguments[Fe])Object.prototype.hasOwnProperty.call(Re,We)&&(Ke[We]=Re[We]);return Ke},Et.apply(this,arguments)};function It(Ke){return Ke.toLowerCase()}var kt=[/([a-z0-9])([A-Z])/g,/([A-Z])([A-Z][a-z])/g],Mt=/[^A-Z0-9]+/gi;function xt(Ke,Re,Fe){return Re instanceof RegExp?Ke.replace(Re,Fe):Re.reduce(function(qe,We){return qe.replace(We,Fe)},Ke)}function Pt(Ke,Re){return Re===void 0&&(Re={}),function(Fe,qe){qe===void 0&&(qe={});for(var We=qe.splitRegexp,Ze=We===void 0?kt:We,Xe=qe.stripRegexp,Je=Xe===void 0?Mt:Xe,tr=qe.transform,er=tr===void 0?It:tr,ir=qe.delimiter,ur=ir===void 0?" ":ir,fr=xt(xt(Fe,Ze,"$1\0$2"),Je,"\0"),ar=0,yr=fr.length;fr.charAt(ar)==="\0";)ar++;for(;fr.charAt(yr-1)==="\0";)yr--;return fr.slice(ar,yr).split("\0").map(er).join(ur)}(Ke,Et({delimiter:"."},Re))}class Lt{static fieldLayout(Re,Fe){const qe=Re.name!==void 0?camelcase.exports(Re.name):void 0;switch(Re.type){case"bool":return lib.bool(qe);case"u8":return lib.u8(qe);case"i8":return lib.i8(qe);case"u16":return lib.u16(qe);case"i16":return lib.i16(qe);case"u32":return lib.u32(qe);case"i32":return lib.i32(qe);case"f32":return lib.f32(qe);case"u64":return lib.u64(qe);case"i64":return lib.i64(qe);case"f64":return lib.f64(qe);case"u128":return lib.u128(qe);case"i128":return lib.i128(qe);case"bytes":return lib.vecU8(qe);case"string":return lib.str(qe);case"publicKey":return lib.publicKey(qe);default:if("vec"in Re.type)return lib.vec(Lt.fieldLayout({name:void 0,type:Re.type.vec},Fe),qe);if("option"in Re.type)return lib.option(Lt.fieldLayout({name:void 0,type:Re.type.option},Fe),qe);if("defined"in Re.type){const We=Re.type.defined;if(Fe===void 0)throw new gt("User defined types not provided");const Ze=Fe.filter(Xe=>Xe.name===We);if(Ze.length!==1)throw new gt(`Type not found: ${JSON.stringify(Re)}`);return Lt.typeDefLayout(Ze[0],Fe,qe)}if("array"in Re.type){let We=Re.type.array[0],Ze=Re.type.array[1],Xe=Lt.fieldLayout({name:void 0,type:We},Fe);return lib.array(Xe,Ze,qe)}throw new Error(`Not yet implemented: ${Re}`)}}static typeDefLayout(Re,Fe=[],qe){if(Re.type.kind==="struct"){const We=Re.type.fields.map(Ze=>Lt.fieldLayout(Ze,Fe));return lib.struct(We,qe)}if(Re.type.kind==="enum"){let We=Re.type.variants.map(Ze=>{const Xe=camelcase.exports(Ze.name);if(Ze.fields===void 0)return lib.struct([],Xe);const Je=Ze.fields.map(tr=>{if(!tr.hasOwnProperty("name"))throw new Error("Tuple enum variants not yet implemented.");return Lt.fieldLayout(tr,Fe)});return lib.struct(Je,Xe)});return qe!==void 0?lib.rustEnum(We).replicate(qe):lib.rustEnum(We,qe)}throw new Error(`Unknown type kint: ${Re}`)}}class Tt{constructor(Re){this.idl=Re,this.ixLayout=Tt.parseIxLayout(Re);const Fe=new Map;Re.instructions.forEach(qe=>{const We=zt("global",qe.name);Fe.set(bs58.encode(We),{layout:this.ixLayout.get(qe.name),name:qe.name})}),Re.state&&Re.state.methods.map(qe=>{const We=zt("state",qe.name);Fe.set(bs58.encode(We),{layout:this.ixLayout.get(qe.name),name:qe.name})}),this.sighashLayouts=Fe}encode(Re,Fe){return this._encode("global",Re,Fe)}encodeState(Re,Fe){return this._encode("state",Re,Fe)}_encode(Re,Fe,qe){const We=buffer.Buffer.alloc(1e3),Ze=camelcase.exports(Fe),Xe=this.ixLayout.get(Ze);if(!Xe)throw new Error(`Unknown method: ${Ze}`);const Je=Xe.encode(qe,We),tr=We.slice(0,Je);return buffer.Buffer.concat([zt(Re,Fe),tr])}static parseIxLayout(Re){const Fe=(Re.state?Re.state.methods:[]).map(qe=>{let We=qe.args.map(Xe=>{var Je,tr;return Lt.fieldLayout(Xe,Array.from([...(Je=Re.accounts)!==null&&Je!==void 0?Je:[],...(tr=Re.types)!==null&&tr!==void 0?tr:[]]))});const Ze=camelcase.exports(qe.name);return[Ze,lib.struct(We,Ze)]}).concat(Re.instructions.map(qe=>{let We=qe.args.map(Xe=>{var Je,tr;return Lt.fieldLayout(Xe,Array.from([...(Je=Re.accounts)!==null&&Je!==void 0?Je:[],...(tr=Re.types)!==null&&tr!==void 0?tr:[]]))});const Ze=camelcase.exports(qe.name);return[Ze,lib.struct(We,Ze)]}));return new Map(Fe)}decode(Re,Fe="hex"){typeof Re=="string"&&(Re=Fe==="hex"?buffer.Buffer.from(Re,"hex"):bs58.decode(Re));let qe=bs58.encode(Re.slice(0,8)),We=Re.slice(8);const Ze=this.sighashLayouts.get(qe);return Ze?{data:Ze.layout.decode(We),name:Ze.name}:null}format(Re,Fe){return Ct.format(Re,Fe,this.idl)}}class Ct{static format(Re,Fe,qe){const We=qe.instructions.filter(Je=>Re.name===Je.name)[0];if(We===void 0)return console.error("Invalid instruction given"),null;const Ze=We.args.map(Je=>({name:Je.name,type:Ct.formatIdlType(Je.type),data:Ct.formatIdlData(Je,Re.data[Je.name],qe.types)})),Xe=Ct.flattenIdlAccounts(We.accounts);return{args:Ze,accounts:Fe.map((Je,tr)=>tr<Xe.length?{name:Xe[tr].name,...Je}:{name:void 0,...Je})}}static formatIdlType(Re){if(typeof Re=="string")return Re;if("vec"in Re)return`Vec<${this.formatIdlType(Re.vec)}>`;if("option"in Re)return`Option<${this.formatIdlType(Re.option)}>`;if("defined"in Re)return Re.defined;if("array"in Re)return`Array<${Re.array[0]}; ${Re.array[1]}>`;throw new Error(`Unknown IDL type: ${Re}`)}static formatIdlData(Re,Fe,qe){if(typeof Re.type=="string")return Fe.toString();if(Re.type.hasOwnProperty("vec"))return"["+Fe.map(We=>this.formatIdlData({name:"",type:Re.type.vec},We)).join(", ")+"]";if(Re.type.hasOwnProperty("option"))return Fe===null?"null":this.formatIdlData({name:"",type:Re.type.option},Fe,qe);if(Re.type.hasOwnProperty("defined")){if(qe===void 0)throw new Error("User defined types not provided");const We=qe.filter(Ze=>Ze.name===Re.type.defined);if(We.length!==1)throw new Error(`Type not found: ${Re.type.defined}`);return Ct.formatIdlDataDefined(We[0],Fe,qe)}return"unknown"}static formatIdlDataDefined(Re,Fe,qe){if(Re.type.kind==="struct"){const We=Re.type;return"{ "+Object.keys(Fe).map(Ze=>{const Xe=We.fields.filter(Je=>Je.name===Ze)[0];if(Xe===void 0)throw new Error("Unable to find type");return Ze+": "+Ct.formatIdlData(Xe,Fe[Ze],qe)}).join(", ")+" }"}if(Re.type.variants.length===0)return"{}";if(Re.type.variants[0].name){const We=Re.type.variants,Ze=Object.keys(Fe)[0],Xe=Fe[Ze],Je=Object.keys(Xe).map(er=>{var ir;const ur=Xe[er],fr=(ir=We[Ze])===null||ir===void 0?void 0:ir.filter(ar=>ar.name===er)[0];if(fr===void 0)throw new Error("Unable to find variant");return er+": "+Ct.formatIdlData(fr,ur,qe)}).join(", "),tr=camelcase.exports(Ze,{pascalCase:!0});return Je.length===0?tr:`${tr} { ${Je} }`}return"Tuple formatting not yet implemented"}static flattenIdlAccounts(Re,Fe){return Re.map(qe=>{const We=function(Ze){const Xe=Ze.replace(/([A-Z])/g," $1");return Xe.charAt(0).toUpperCase()+Xe.slice(1)}(qe.name);if(qe.hasOwnProperty("accounts")){const Ze=Fe?`${Fe} > ${We}`:We;return Ct.flattenIdlAccounts(qe.accounts,Ze)}return{...qe,name:Fe?`${Fe} > ${We}`:We}}).flat()}}function zt(Ke,Re){var Fe;let qe=`${Ke}:${Fe===void 0&&(Fe={}),Pt(Re,Et({delimiter:"_"},Fe))}`;return buffer.Buffer.from(sha256.exports.sha256.digest(qe)).slice(0,8)}function Bt(Ke,Re){if(Re.type.kind==="enum"){let Fe=Re.type.variants.map(qe=>qe.fields===void 0?0:qe.fields.map(We=>{if(typeof We!="object"||!("name"in We))throw new Error("Tuple enum variants not yet implemented.");return Ot(Ke,We.type)}).reduce((We,Ze)=>We+Ze));return Math.max(...Fe)+1}return Re.type.fields===void 0?0:Re.type.fields.map(Fe=>Ot(Ke,Fe.type)).reduce((Fe,qe)=>Fe+qe,0)}function Ot(Ke,Re){var Fe,qe;switch(Re){case"bool":case"u8":case"i8":case"bytes":case"string":return 1;case"i16":case"u16":return 2;case"u32":case"i32":case"f32":return 4;case"u64":case"i64":case"f64":return 8;case"u128":case"i128":return 16;case"publicKey":return 32;default:if("vec"in Re)return 1;if("option"in Re)return 1+Ot(Ke,Re.option);if("coption"in Re)return 4+Ot(Ke,Re.coption);if("defined"in Re){const We=(qe=(Fe=Ke.types)===null||Fe===void 0?void 0:Fe.filter(Ze=>Ze.name===Re.defined))!==null&&qe!==void 0?qe:[];if(We.length!==1)throw new gt(`Type not found: ${JSON.stringify(Re)}`);return Bt(Ke,We[0])}if("array"in Re){let We=Re.array[0],Ze=Re.array[1];return Ot(Ke,We)*Ze}throw new Error(`Invalid type ${JSON.stringify(Re)}`)}}class Nt{constructor(Re){if(Re.accounts===void 0)return void(this.accountLayouts=new Map);const Fe=Re.accounts.map(qe=>[qe.name,Lt.typeDefLayout(qe,Re.types)]);this.accountLayouts=new Map(Fe),this.idl=Re}async encode(Re,Fe){const qe=buffer.Buffer.alloc(1e3),We=this.accountLayouts.get(Re);if(!We)throw new Error(`Unknown account: ${Re}`);const Ze=We.encode(Fe,qe);let Xe=qe.slice(0,Ze),Je=Nt.accountDiscriminator(Re);return buffer.Buffer.concat([Je,Xe])}decode(Re,Fe){if(Nt.accountDiscriminator(Re).compare(Fe.slice(0,8)))throw new Error("Invalid account discriminator");return this.decodeUnchecked(Re,Fe)}decodeUnchecked(Re,Fe){const qe=Fe.slice(8),We=this.accountLayouts.get(Re);if(!We)throw new Error(`Unknown account: ${Re}`);return We.decode(qe)}memcmp(Re,Fe){const qe=Nt.accountDiscriminator(Re);return{offset:0,bytes:bs58.encode(Fe?buffer.Buffer.concat([qe,Fe]):qe)}}size(Re){var Fe;return 8+((Fe=Bt(this.idl,Re))!==null&&Fe!==void 0?Fe:0)}static accountDiscriminator(Re){return buffer.Buffer.from(sha256.exports.sha256.digest(`account:${camelcase.exports(Re,{pascalCase:!0})}`)).slice(0,8)}}class Rt{constructor(Re){if(Re.events===void 0)return void(this.layouts=new Map);const Fe=Re.events.map(qe=>{let We={name:qe.name,type:{kind:"struct",fields:qe.fields.map(Ze=>({name:Ze.name,type:Ze.type}))}};return[qe.name,Lt.typeDefLayout(We,Re.types)]});this.layouts=new Map(Fe),this.discriminators=new Map(Re.events===void 0?[]:Re.events.map(qe=>[fromByteArray_1(Vt(qe.name)),qe.name]))}decode(Re){let Fe;try{Fe=buffer.Buffer.from(toByteArray_1(Re))}catch{return null}const qe=fromByteArray_1(Fe.slice(0,8)),We=this.discriminators.get(qe);if(We===void 0)return null;const Ze=this.layouts.get(We);if(!Ze)throw new Error(`Unknown event: ${We}`);return{data:Ze.decode(Fe.slice(8)),name:We}}}function Vt(Ke){return buffer.Buffer.from(sha256.exports.sha256.digest(`event:${Ke}`)).slice(0,8)}class Ut{constructor(Re){if(Re.state===void 0)throw new Error("Idl state not defined.");this.layout=Lt.typeDefLayout(Re.state.struct,Re.types)}async encode(Re,Fe){const qe=buffer.Buffer.alloc(1e3),We=this.layout.encode(Fe,qe),Ze=await jt(Re),Xe=qe.slice(0,We);return buffer.Buffer.concat([Ze,Xe])}decode(Re){const Fe=Re.slice(8);return this.layout.decode(Fe)}}async function jt(Ke){let Re=mt("anchor-deprecated-state")?"account":"state";return buffer.Buffer.from(sha256.exports.sha256.digest(`${Re}:${Ke}`)).slice(0,8)}class $t{constructor(Re){if(Re.types===void 0)return void(this.typeLayouts=new Map);const Fe=Re.types.map(qe=>[qe.name,Lt.typeDefLayout(qe,Re.types)]);this.typeLayouts=new Map(Fe),this.idl=Re}encode(Re,Fe){const qe=buffer.Buffer.alloc(1e3),We=this.typeLayouts.get(Re);if(!We)throw new Error(`Unknown type: ${Re}`);const Ze=We.encode(Fe,qe);return qe.slice(0,Ze)}decode(Re,Fe){const qe=this.typeLayouts.get(Re);if(!qe)throw new Error(`Unknown type: ${Re}`);return qe.decode(Fe)}}class Kt{constructor(Re){this.instruction=new Tt(Re),this.accounts=new Nt(Re),this.events=new Rt(Re),Re.state&&(this.state=new Ut(Re)),this.types=new $t(Re)}}var qt=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{};function Ft(Ke){return Ke&&Ke.__esModule&&Object.prototype.hasOwnProperty.call(Ke,"default")?Ke.default:Ke}class Wt{constructor(Re,Fe){if(!Number.isInteger(Re))throw new TypeError("span must be an integer");this.span=Re,this.property=Fe}makeDestinationObject(){return{}}decode(Re,Fe){throw new Error("Layout is abstract")}encode(Re,Fe,qe){throw new Error("Layout is abstract")}getSpan(Re,Fe){if(0>this.span)throw new RangeError("indeterminate span");return this.span}replicate(Re){const Fe=Object.create(this.constructor.prototype);return Object.assign(Fe,this),Fe.property=Re,Fe}fromArray(Re){}}var Gt=Wt;class Ht extends Wt{isCount(){throw new Error("ExternalLayout is abstract")}}class Jt extends Ht{constructor(Re,Fe,qe){if(!(Re instanceof Wt))throw new TypeError("layout must be a Layout");if(Fe===void 0)Fe=0;else if(!Number.isInteger(Fe))throw new TypeError("offset must be integer or undefined");super(Re.span,qe||Re.property),this.layout=Re,this.offset=Fe}isCount(){return this.layout instanceof Zt||this.layout instanceof Xt}decode(Re,Fe){return Fe===void 0&&(Fe=0),this.layout.decode(Re,Fe+this.offset)}encode(Re,Fe,qe){return qe===void 0&&(qe=0),this.layout.encode(Re,Fe,qe+this.offset)}}class Zt extends Wt{constructor(Re,Fe){if(super(Re,Fe),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(Re,Fe){return Fe===void 0&&(Fe=0),Re.readUIntLE(Fe,this.span)}encode(Re,Fe,qe){return qe===void 0&&(qe=0),Fe.writeUIntLE(Re,qe,this.span),this.span}}class Xt extends Wt{constructor(Re,Fe){if(super(Re,Fe),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(Re,Fe){return Fe===void 0&&(Fe=0),Re.readUIntBE(Fe,this.span)}encode(Re,Fe,qe){return qe===void 0&&(qe=0),Fe.writeUIntBE(Re,qe,this.span),this.span}}const Qt=Math.pow(2,32);function Yt(Ke){const Re=Math.floor(Ke/Qt);return{hi32:Re,lo32:Ke-Re*Qt}}function te(Ke,Re){return Ke*Qt+Re}class ee extends Wt{constructor(Re){super(8,Re)}decode(Re,Fe){Fe===void 0&&(Fe=0);const qe=Re.readUInt32LE(Fe);return te(Re.readUInt32LE(Fe+4),qe)}encode(Re,Fe,qe){qe===void 0&&(qe=0);const We=Yt(Re);return Fe.writeUInt32LE(We.lo32,qe),Fe.writeUInt32LE(We.hi32,qe+4),8}}class ne extends Wt{constructor(Re){super(8,Re)}decode(Re,Fe){Fe===void 0&&(Fe=0);const qe=Re.readUInt32LE(Fe);return te(Re.readInt32LE(Fe+4),qe)}encode(Re,Fe,qe){qe===void 0&&(qe=0);const We=Yt(Re);return Fe.writeUInt32LE(We.lo32,qe),Fe.writeInt32LE(We.hi32,qe+4),8}}class re extends Wt{constructor(Re,Fe,qe){if(!Array.isArray(Re)||!Re.reduce((Ze,Xe)=>Ze&&Xe instanceof Wt,!0))throw new TypeError("fields must be array of Layout instances");typeof Fe=="boolean"&&qe===void 0&&(qe=Fe,Fe=void 0);for(const Ze of Re)if(0>Ze.span&&Ze.property===void 0)throw new Error("fields cannot contain unnamed variable-length layout");let We=-1;try{We=Re.reduce((Ze,Xe)=>Ze+Xe.getSpan(),0)}catch{}super(We,Fe),this.fields=Re,this.decodePrefixes=!!qe}getSpan(Re,Fe){if(0<=this.span)return this.span;Fe===void 0&&(Fe=0);let qe=0;try{qe=this.fields.reduce((We,Ze)=>{const Xe=Ze.getSpan(Re,Fe);return Fe+=Xe,We+Xe},0)}catch{throw new RangeError("indeterminate span")}return qe}decode(Re,Fe){Fe===void 0&&(Fe=0);const qe=this.makeDestinationObject();for(const We of this.fields)if(We.property!==void 0&&(qe[We.property]=We.decode(Re,Fe)),Fe+=We.getSpan(Re,Fe),this.decodePrefixes&&Re.length===Fe)break;return qe}encode(Re,Fe,qe){qe===void 0&&(qe=0);const We=qe;let Ze=0,Xe=0;for(const Je of this.fields){let tr=Je.span;if(Xe=0<tr?tr:0,Je.property!==void 0){const er=Re[Je.property];er!==void 0&&(Xe=Je.encode(er,Fe,qe),0>tr&&(tr=Je.getSpan(Fe,qe)))}Ze=qe,qe+=tr}return Ze+Xe-We}fromArray(Re){const Fe=this.makeDestinationObject();for(const qe of this.fields)qe.property!==void 0&&0<Re.length&&(Fe[qe.property]=Re.shift());return Fe}layoutFor(Re){if(typeof Re!="string")throw new TypeError("property must be string");for(const Fe of this.fields)if(Fe.property===Re)return Fe}offsetOf(Re){if(typeof Re!="string")throw new TypeError("property must be string");let Fe=0;for(const qe of this.fields){if(qe.property===Re)return Fe;0>qe.span?Fe=-1:0<=Fe&&(Fe+=qe.span)}}}class oe{constructor(Re){this.property=Re}decode(){throw new Error("UnionDiscriminator is abstract")}encode(){throw new Error("UnionDiscriminator is abstract")}}class ie extends oe{constructor(Re,Fe){if(!(Re instanceof Ht&&Re.isCount()))throw new TypeError("layout must be an unsigned integer ExternalLayout");super(Fe||Re.property||"variant"),this.layout=Re}decode(Re,Fe){return this.layout.decode(Re,Fe)}encode(Re,Fe,qe){return this.layout.encode(Re,Fe,qe)}}class se extends Wt{constructor(Re,Fe,qe){const We=Re instanceof Zt||Re instanceof Xt;if(We)Re=new ie(new Jt(Re));else if(Re instanceof Ht&&Re.isCount())Re=new ie(Re);else if(!(Re instanceof oe))throw new TypeError("discr must be a UnionDiscriminator or an unsigned integer layout");if(Fe===void 0&&(Fe=null),!(Fe===null||Fe instanceof Wt))throw new TypeError("defaultLayout must be null or a Layout");if(Fe!==null){if(0>Fe.span)throw new Error("defaultLayout must have constant span");Fe.property===void 0&&(Fe=Fe.replicate("content"))}let Ze=-1;Fe&&(Ze=Fe.span,0<=Ze&&We&&(Ze+=Re.layout.span)),super(Ze,qe),this.discriminator=Re,this.usesPrefixDiscriminator=We,this.defaultLayout=Fe,this.registry={};let Xe=this.defaultGetSourceVariant.bind(this);this.getSourceVariant=function(Je){return Xe(Je)},this.configGetSourceVariant=function(Je){Xe=Je.bind(this)}}getSpan(Re,Fe){if(0<=this.span)return this.span;Fe===void 0&&(Fe=0);const qe=this.getVariant(Re,Fe);if(!qe)throw new Error("unable to determine span for unrecognized variant");return qe.getSpan(Re,Fe)}defaultGetSourceVariant(Re){if(Re.hasOwnProperty(this.discriminator.property)){if(this.defaultLayout&&Re.hasOwnProperty(this.defaultLayout.property))return;const Fe=this.registry[Re[this.discriminator.property]];if(Fe&&(!Fe.layout||Re.hasOwnProperty(Fe.property)))return Fe}else for(const Fe in this.registry){const qe=this.registry[Fe];if(Re.hasOwnProperty(qe.property))return qe}throw new Error("unable to infer src variant")}decode(Re,Fe){let qe;Fe===void 0&&(Fe=0);const We=this.discriminator,Ze=We.decode(Re,Fe);let Xe=this.registry[Ze];if(Xe===void 0){let Je=0;Xe=this.defaultLayout,this.usesPrefixDiscriminator&&(Je=We.layout.span),qe=this.makeDestinationObject(),qe[We.property]=Ze,qe[Xe.property]=this.defaultLayout.decode(Re,Fe+Je)}else qe=Xe.decode(Re,Fe);return qe}encode(Re,Fe,qe){qe===void 0&&(qe=0);const We=this.getSourceVariant(Re);if(We===void 0){const Ze=this.discriminator,Xe=this.defaultLayout;let Je=0;return this.usesPrefixDiscriminator&&(Je=Ze.layout.span),Ze.encode(Re[Ze.property],Fe,qe),Je+Xe.encode(Re[Xe.property],Fe,qe+Je)}return We.encode(Re,Fe,qe)}addVariant(Re,Fe,qe){const We=new ae(this,Re,Fe,qe);return this.registry[Re]=We,We}getVariant(Re,Fe){let qe=Re;return Buffer.isBuffer(Re)&&(Fe===void 0&&(Fe=0),qe=this.discriminator.decode(Re,Fe)),this.registry[qe]}}class ae extends Wt{constructor(Re,Fe,qe,We){if(!(Re instanceof se))throw new TypeError("union must be a Union");if(!Number.isInteger(Fe)||0>Fe)throw new TypeError("variant must be a (non-negative) integer");if(typeof qe=="string"&&We===void 0&&(We=qe,qe=null),qe){if(!(qe instanceof Wt))throw new TypeError("layout must be a Layout");if(Re.defaultLayout!==null&&0<=qe.span&&qe.span>Re.defaultLayout.span)throw new Error("variant span exceeds span of containing union");if(typeof We!="string")throw new TypeError("variant must have a String property")}let Ze=Re.span;0>Re.span&&(Ze=qe?qe.span:0,0<=Ze&&Re.usesPrefixDiscriminator&&(Ze+=Re.discriminator.layout.span)),super(Ze,We),this.union=Re,this.variant=Fe,this.layout=qe||null}getSpan(Re,Fe){if(0<=this.span)return this.span;Fe===void 0&&(Fe=0);let qe=0;return this.union.usesPrefixDiscriminator&&(qe=this.union.discriminator.layout.span),qe+this.layout.getSpan(Re,Fe+qe)}decode(Re,Fe){const qe=this.makeDestinationObject();if(Fe===void 0&&(Fe=0),this!==this.union.getVariant(Re,Fe))throw new Error("variant mismatch");let We=0;return this.union.usesPrefixDiscriminator&&(We=this.union.discriminator.layout.span),this.layout?qe[this.property]=this.layout.decode(Re,Fe+We):this.property?qe[this.property]=!0:this.union.usesPrefixDiscriminator&&(qe[this.union.discriminator.property]=this.variant),qe}encode(Re,Fe,qe){qe===void 0&&(qe=0);let We=0;if(this.union.usesPrefixDiscriminator&&(We=this.union.discriminator.layout.span),this.layout&&!Re.hasOwnProperty(this.property))throw new TypeError("variant lacks property "+this.property);this.union.discriminator.encode(this.variant,Fe,qe);let Ze=We;if(this.layout&&(this.layout.encode(Re[this.property],Fe,qe+We),Ze+=this.layout.getSpan(Fe,qe+We),0<=this.union.span&&Ze>this.union.span))throw new Error("encoded variant overruns containing union");return Ze}fromArray(Re){if(this.layout)return this.layout.fromArray(Re)}}class ce extends Wt{constructor(Re,Fe){if(!(Re instanceof Ht&&Re.isCount()||Number.isInteger(Re)&&0<=Re))throw new TypeError("length must be positive integer or an unsigned integer ExternalLayout");let qe=-1;Re instanceof Ht||(qe=Re),super(qe,Fe),this.length=Re}getSpan(Re,Fe){let qe=this.span;return 0>qe&&(qe=this.length.decode(Re,Fe)),qe}decode(Re,Fe){Fe===void 0&&(Fe=0);let qe=this.span;return 0>qe&&(qe=this.length.decode(Re,Fe)),Re.slice(Fe,Fe+qe)}encode(Re,Fe,qe){let We=this.length;if(this.length instanceof Ht&&(We=Re.length),!Buffer.isBuffer(Re)||We!==Re.length)throw new TypeError((Ze="Blob.encode",((Xe=this).property?Ze+"["+Xe.property+"]":Ze)+" requires (length "+We+") Buffer as src"));var Ze,Xe;if(qe+We>Fe.length)throw new RangeError("encoding overruns Buffer");return Fe.write(Re.toString("hex"),qe,We,"hex"),this.length instanceof Ht&&this.length.encode(We,Fe,qe),We}}var ue=(Ke,Re,Fe)=>new Jt(Ke,Re,Fe),de=Ke=>new Zt(1,Ke),le=Ke=>new Zt(4,Ke),he=Ke=>new ee(Ke),pe=Ke=>new ne(Ke),fe=(Ke,Re,Fe)=>new re(Ke,Re,Fe),me=(Ke,Re,Fe)=>new se(Ke,Re,Fe),ye=(Ke,Re)=>new ce(Ke,Re);class ge{constructor(Re){}encode(Re,Fe){switch(camelcase.exports(Re)){case"initializeMint":return function({decimals:qe,mintAuthority:We,freezeAuthority:Ze}){return be({initializeMint:{decimals:qe,mintAuthority:We.toBuffer(),freezeAuthorityOption:!!Ze,freezeAuthority:(Ze||PublicKey.default).toBuffer()}})}(Fe);case"initializeAccount":return be({initializeAccount:{}});case"initializeMultisig":return function({m:qe}){return be({initializeMultisig:{m:qe}})}(Fe);case"transfer":return function({amount:qe}){return be({transfer:{amount:qe}})}(Fe);case"approve":return function({amount:qe}){return be({approve:{amount:qe}})}(Fe);case"revoke":return be({revoke:{}});case"setAuthority":return function({authorityType:qe,newAuthority:We}){return be({setAuthority:{authorityType:qe,newAuthority:We}})}(Fe);case"mintTo":return function({amount:qe}){return be({mintTo:{amount:qe}})}(Fe);case"burn":return function({amount:qe}){return be({burn:{amount:qe}})}(Fe);case"closeAccount":return be({closeAccount:{}});case"freezeAccount":return be({freezeAccount:{}});case"thawAccount":return be({thawAccount:{}});case"transferChecked":return function({amount:qe,decimals:We}){return be({transferChecked:{amount:qe,decimals:We}})}(Fe);case"approvedChecked":return function({amount:qe,decimals:We}){return be({approveChecked:{amount:qe,decimals:We}})}(Fe);case"mintToChecked":return function({amount:qe,decimals:We}){return be({mintToChecked:{amount:qe,decimals:We}})}(Fe);case"burnChecked":return function({amount:qe,decimals:We}){return be({burnChecked:{amount:qe,decimals:We}})}(Fe);case"intializeAccount2":return function({authority:qe}){return be({initilaizeAccount2:{authority:qe}})}(Fe);case"syncNative":return be({syncNative:{}});case"initializeAccount3":return function({authority:qe}){return be({initializeAccount3:{authority:qe}})}(Fe);case"initializeMultisig2":return function({m:qe}){return be({initializeMultisig2:{m:qe}})}(Fe);case"initializeMint2":return function({decimals:qe,mintAuthority:We,freezeAuthority:Ze}){return be({encodeInitializeMint2:{decimals:qe,mintAuthority:We,freezeAuthority:Ze}})}(Fe);default:throw new Error(`Invalid instruction: ${Re}`)}}encodeState(Re,Fe){throw new Error("SPL token does not have state")}}const we=me(de("instruction"));function ve(Ke){return ye(32,Ke)}function be(Ke){let Re=Buffer.alloc(Ae),Fe=we.encode(Ke,Re);return Re.slice(0,Fe)}we.addVariant(0,fe([de("decimals"),ye(32,"mintAuthority"),de("freezeAuthorityOption"),ve("freezeAuthority")]),"initializeMint"),we.addVariant(1,fe([]),"initializeAccount"),we.addVariant(2,fe([de("m")]),"initializeMultisig"),we.addVariant(3,fe([he("amount")]),"transfer"),we.addVariant(4,fe([he("amount")]),"approve"),we.addVariant(5,fe([]),"revoke"),we.addVariant(6,fe([de("authorityType"),de("newAuthorityOption"),ve("newAuthority")]),"setAuthority"),we.addVariant(7,fe([he("amount")]),"mintTo"),we.addVariant(8,fe([he("amount")]),"burn"),we.addVariant(9,fe([]),"closeAccount"),we.addVariant(10,fe([]),"freezeAccount"),we.addVariant(11,fe([]),"thawAccount"),we.addVariant(12,fe([he("amount"),de("decimals")]),"transferChecked"),we.addVariant(13,fe([he("amount"),de("decimals")]),"approvedChecked"),we.addVariant(14,fe([he("amount"),de("decimals")]),"mintToChecked"),we.addVariant(15,fe([he("amount"),de("decimals")]),"burnedChecked"),we.addVariant(16,fe([ve("authority")]),"InitializeAccount2"),we.addVariant(17,fe([]),"syncNative"),we.addVariant(18,fe([ve("authority")]),"initializeAccount3"),we.addVariant(19,fe([de("m")]),"initializeMultisig2"),we.addVariant(20,fe([de("decimals"),ve("mintAuthority"),de("freezeAuthorityOption"),ve("freezeAuthority")]),"initializeMint2");const Ae=Math.max(...Object.values(we.registry).map(Ke=>Ke.span));class _e{constructor(Re){}encode(Re,Fe){throw new Error("SPL token does not have state")}decode(Re){throw new Error("SPL token does not have state")}}function Se(Ke){return new ke(ye(8),Re=>Le.fromBuffer(Re),Re=>Re.toBuffer(),Ke)}function Ee(Ke){return new ke(ye(32),Re=>new PublicKey(Re),Re=>Re.toBuffer(),Ke)}function Ie(Ke,Re){return new Me(Ke,Re)}class ke extends Gt{constructor(Re,Fe,qe,We){super(Re.span,We),this.layout=Re,this.decoder=Fe,this.encoder=qe}decode(Re,Fe){return this.decoder(this.layout.decode(Re,Fe))}encode(Re,Fe,qe){return this.layout.encode(this.encoder(Re),Fe,qe)}getSpan(Re,Fe){return this.layout.getSpan(Re,Fe)}}class Me extends Gt{constructor(Re,Fe){super(-1,Fe),this.layout=Re,this.discriminator=le()}encode(Re,Fe,qe=0){return Re==null?this.layout.span+this.discriminator.encode(0,Fe,qe):(this.discriminator.encode(1,Fe,qe),this.layout.encode(Re,Fe,qe+4)+4)}decode(Re,Fe=0){const qe=this.discriminator.decode(Re,Fe);if(qe===0)return null;if(qe===1)return this.layout.decode(Re,Fe+4);throw new Error("Invalid coption "+this.layout.property)}getSpan(Re,Fe=0){return this.layout.getSpan(Re,Fe+4)+4}}function xe(Ke){if(Ke===0)return!1;if(Ke===1)return!0;throw new Error("Invalid bool: "+Ke)}function Pe(Ke){return Ke?1:0}class Le extends u{toBuffer(){const Re=super.toArray().reverse(),Fe=Buffer.from(Re);if(Fe.length===8)return Fe;if(Fe.length>=8)throw new Error("u64 too large");const qe=Buffer.alloc(8);return Fe.copy(qe),qe}static fromBuffer(Re){if(Re.length!==8)throw new Error(`Invalid buffer length: ${Re.length}`);return new Le([...Re].reverse().map(Fe=>`00${Fe.toString(16)}`.slice(-2)).join(""),16)}}class Te{constructor(Re){this.idl=Re}async encode(Re,Fe){switch(Re){case"token":{const qe=Buffer.alloc(165),We=Be.encode(Fe,qe);return qe.slice(0,We)}case"mint":{const qe=Buffer.alloc(82),We=Ce.encode(Fe,qe);return qe.slice(0,We)}default:throw new Error(`Invalid account name: ${Re}`)}}decode(Re,Fe){return this.decodeUnchecked(Re,Fe)}decodeUnchecked(Re,Fe){switch(Re){case"token":return function(qe){return Be.decode(qe)}(Fe);case"mint":return function(qe){return Ce.decode(qe)}(Fe);default:throw new Error(`Invalid account name: ${Re}`)}}memcmp(Re,Fe){switch(Re){case"token":return{dataSize:165};case"mint":return{dataSize:82};default:throw new Error(`Invalid account name: ${Re}`)}}size(Re){var Fe;return(Fe=Bt(this.idl,Re))!==null&&Fe!==void 0?Fe:0}}const Ce=fe([Ie(Ee(),"mintAuthority"),Se("supply"),de("decimals"),(ze="isInitialized",new ke(de(),xe,Pe,ze)),Ie(Ee(),"freezeAuthority")]);var ze;const Be=fe([Ee("mint"),Ee("authority"),Se("amount"),Ie(Ee(),"delegate"),de("state"),Ie(Se(),"isNative"),Se("delegatedAmount"),Ie(Ee(),"closeAuthority")]);class Oe{constructor(Re){}decode(Re){throw new Error("SPL token program does not have events")}}class De{constructor(Re){}encode(Re,Fe){throw new Error("SPL token does not have user-defined types")}decode(Re,Fe){throw new Error("SPL token does not have user-defined types")}}class Ne{constructor(Re){this.instruction=new ge(Re),this.accounts=new Te(Re),this.events=new Oe(Re),this.state=new _e(Re),this.types=new De(Re)}}class Ve extends Gt{constructor(Re){super(-1,Re),this.property=Re,this.layout=fe([le("length"),le("lengthPadding"),ye(ue(le(),-8),"chars")],this.property)}encode(Re,Fe,qe=0){if(Re==null)return this.layout.span;const We={chars:Buffer.from(Re,"utf8")};return this.layout.encode(We,Fe,qe)}decode(Re,Fe=0){return this.layout.decode(Re,Fe).chars.toString()}getSpan(Re,Fe=0){return le().span+le().span+new u(new Uint8Array(Re).slice(Fe,Fe+4),10,"le").toNumber()}}function Ue(Ke){return new Ve(Ke)}function je(Ke){return ye(32,Ke)}const $e=me(le("instruction"));$e.addVariant(0,fe([pe("lamports"),pe("space"),je("owner")]),"createAccount"),$e.addVariant(1,fe([je("owner")]),"assign"),$e.addVariant(2,fe([pe("lamports")]),"transfer"),$e.addVariant(3,fe([je("base"),Ue("seed"),pe("lamports"),pe("space"),je("owner")]),"createAccountWithSeed"),$e.addVariant(4,fe([je("authorized")]),"advanceNonceAccount"),$e.addVariant(5,fe([pe("lamports")]),"withdrawNonceAccount"),$e.addVariant(6,fe([je("authorized")]),"initializeNonceAccount"),$e.addVariant(7,fe([je("authorized")]),"authorizeNonceAccount"),$e.addVariant(8,fe([pe("space")]),"allocate"),$e.addVariant(9,fe([je("base"),Ue("seed"),pe("space"),je("owner")]),"allocateWithSeed"),$e.addVariant(10,fe([je("base"),Ue("seed"),je("owner")]),"assignWithSeed"),$e.addVariant(11,fe([pe("lamports"),Ue("seed"),je("owner")]),"transferWithSeed");Math.max(...Object.values($e.registry).map(Ke=>Ke.span));class Ge extends Gt{constructor(Re,Fe,qe,We){super(Re.span,We),this.layout=Re,this.decoder=Fe,this.encoder=qe}decode(Re,Fe){return this.decoder(this.layout.decode(Re,Fe))}encode(Re,Fe,qe){return this.layout.encode(this.encoder(Re),Fe,qe)}getSpan(Re,Fe){return this.layout.getSpan(Re,Fe)}}function He(Ke){return new Ge(ye(32),Re=>new PublicKey(Re),Re=>Re.toBuffer(),Ke)}fe([le("version"),le("state"),He("authorizedPubkey"),He("nonce"),fe([he("lamportsPerSignature")],"feeCalculator")]);var Ye=Object.freeze({__proto__:null,hash:function(Ke){return sha256.exports.sha256(Ke)}});function tn(Ke,Re,Fe){const qe=buffer.Buffer.concat([Ke.toBuffer(),buffer.Buffer.from(Re),Fe.toBuffer()]),We=sha256.exports.sha256.digest(qe);return new PublicKey(buffer.Buffer.from(We))}function en(Ke,Re){let Fe=buffer.Buffer.alloc(0);Ke.forEach(function(Ze){if(Ze.length>32)throw new TypeError("Max seed length exceeded");Fe=buffer.Buffer.concat([Fe,rn(Ze)])}),Fe=buffer.Buffer.concat([Fe,Re.toBuffer(),buffer.Buffer.from("ProgramDerivedAddress")]);let qe=sha256.exports.sha256(new Uint8Array(Fe)),We=new u(qe,16).toArray(void 0,32);if(PublicKey.isOnCurve(new Uint8Array(We)))throw new Error("Invalid seeds, address must fall off the curve");return new PublicKey(We)}function nn(Ke,Re){let Fe,qe=255;for(;qe!=0;){try{Fe=en(Ke.concat(buffer.Buffer.from([qe])),Re)}catch(We){if(We instanceof TypeError)throw We;qe--;continue}return[Fe,qe]}throw new Error("Unable to find a viable program address nonce")}const rn=Ke=>Ke instanceof buffer.Buffer?Ke:Ke instanceof Uint8Array?buffer.Buffer.from(Ke.buffer,Ke.byteOffset,Ke.byteLength):buffer.Buffer.from(Ke);async function on(Ke,...Re){let Fe=[buffer.Buffer.from([97,110,99,104,111,114])];Re.forEach(We=>{Fe.push(We instanceof buffer.Buffer?We:L(We).toBuffer())});const[qe]=await PublicKey.findProgramAddress(Fe,L(Ke));return qe}var sn=Object.freeze({__proto__:null,createWithSeedSync:tn,createProgramAddressSync:en,findProgramAddressSync:nn,associated:on});const an=new PublicKey("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"),cn=new PublicKey("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL");var un=Object.freeze({__proto__:null,TOKEN_PROGRAM_ID:an,ASSOCIATED_PROGRAM_ID:cn,associatedAddress:async function({mint:Ke,owner:Re}){return(await PublicKey.findProgramAddress([Re.toBuffer(),an.toBuffer(),Ke.toBuffer()],cn))[0]}}),dn={exports:{}};(function(Ke,Re){var Fe=typeof self<"u"?self:qt,qe=function(){function Ze(){this.fetch=!1,this.DOMException=Fe.DOMException}return Ze.prototype=Fe,new Ze}();(function(Ze){(function(Xe){var Je="URLSearchParams"in Ze,tr="Symbol"in Ze&&"iterator"in Symbol,er="FileReader"in Ze&&"Blob"in Ze&&function(){try{return new Blob,!0}catch{return!1}}(),ir="FormData"in Ze,ur="ArrayBuffer"in Ze;if(ur)var fr=["[object Int8Array]","[object Uint8Array]","[object Uint8ClampedArray]","[object Int16Array]","[object Uint16Array]","[object Int32Array]","[object Uint32Array]","[object Float32Array]","[object Float64Array]"],ar=ArrayBuffer.isView||function(cr){return cr&&fr.indexOf(Object.prototype.toString.call(cr))>-1};function yr(cr){if(typeof cr!="string"&&(cr=String(cr)),/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(cr))throw new TypeError("Invalid character in header field name");return cr.toLowerCase()}function mr(cr){return typeof cr!="string"&&(cr=String(cr)),cr}function wr(cr){var Dt={next:function(){var sr=cr.shift();return{done:sr===void 0,value:sr}}};return tr&&(Dt[Symbol.iterator]=function(){return Dt}),Dt}function Sr(cr){this.map={},cr instanceof Sr?cr.forEach(function(Dt,sr){this.append(sr,Dt)},this):Array.isArray(cr)?cr.forEach(function(Dt){this.append(Dt[0],Dt[1])},this):cr&&Object.getOwnPropertyNames(cr).forEach(function(Dt){this.append(Dt,cr[Dt])},this)}function Ar(cr){if(cr.bodyUsed)return Promise.reject(new TypeError("Already read"));cr.bodyUsed=!0}function vr(cr){return new Promise(function(Dt,sr){cr.onload=function(){Dt(cr.result)},cr.onerror=function(){sr(cr.error)}})}function Ir(cr){var Dt=new FileReader,sr=vr(Dt);return Dt.readAsArrayBuffer(cr),sr}function Tr(cr){if(cr.slice)return cr.slice(0);var Dt=new Uint8Array(cr.byteLength);return Dt.set(new Uint8Array(cr)),Dt.buffer}function Pr(){return this.bodyUsed=!1,this._initBody=function(cr){var Dt;this._bodyInit=cr,cr?typeof cr=="string"?this._bodyText=cr:er&&Blob.prototype.isPrototypeOf(cr)?this._bodyBlob=cr:ir&&FormData.prototype.isPrototypeOf(cr)?this._bodyFormData=cr:Je&&URLSearchParams.prototype.isPrototypeOf(cr)?this._bodyText=cr.toString():ur&&er&&(Dt=cr)&&DataView.prototype.isPrototypeOf(Dt)?(this._bodyArrayBuffer=Tr(cr.buffer),this._bodyInit=new Blob([this._bodyArrayBuffer])):ur&&(ArrayBuffer.prototype.isPrototypeOf(cr)||ar(cr))?this._bodyArrayBuffer=Tr(cr):this._bodyText=cr=Object.prototype.toString.call(cr):this._bodyText="",this.headers.get("content-type")||(typeof cr=="string"?this.headers.set("content-type","text/plain;charset=UTF-8"):this._bodyBlob&&this._bodyBlob.type?this.headers.set("content-type",this._bodyBlob.type):Je&&URLSearchParams.prototype.isPrototypeOf(cr)&&this.headers.set("content-type","application/x-www-form-urlencoded;charset=UTF-8"))},er&&(this.blob=function(){var cr=Ar(this);if(cr)return cr;if(this._bodyBlob)return Promise.resolve(this._bodyBlob);if(this._bodyArrayBuffer)return Promise.resolve(new Blob([this._bodyArrayBuffer]));if(this._bodyFormData)throw new Error("could not read FormData body as blob");return Promise.resolve(new Blob([this._bodyText]))},this.arrayBuffer=function(){return this._bodyArrayBuffer?Ar(this)||Promise.resolve(this._bodyArrayBuffer):this.blob().then(Ir)}),this.text=function(){var cr=Ar(this);if(cr)return cr;if(this._bodyBlob)return function(Dt){var sr=new FileReader,lr=vr(sr);return sr.readAsText(Dt),lr}(this._bodyBlob);if(this._bodyArrayBuffer)return Promise.resolve(function(Dt){for(var sr=new Uint8Array(Dt),lr=new Array(sr.length),gr=0;gr<sr.length;gr++)lr[gr]=String.fromCharCode(sr[gr]);return lr.join("")}(this._bodyArrayBuffer));if(this._bodyFormData)throw new Error("could not read FormData body as text");return Promise.resolve(this._bodyText)},ir&&(this.formData=function(){return this.text().then(Mr)}),this.json=function(){return this.text().then(JSON.parse)},this}Sr.prototype.append=function(cr,Dt){cr=yr(cr),Dt=mr(Dt);var sr=this.map[cr];this.map[cr]=sr?sr+", "+Dt:Dt},Sr.prototype.delete=function(cr){delete this.map[yr(cr)]},Sr.prototype.get=function(cr){return cr=yr(cr),this.has(cr)?this.map[cr]:null},Sr.prototype.has=function(cr){return this.map.hasOwnProperty(yr(cr))},Sr.prototype.set=function(cr,Dt){this.map[yr(cr)]=mr(Dt)},Sr.prototype.forEach=function(cr,Dt){for(var sr in this.map)this.map.hasOwnProperty(sr)&&cr.call(Dt,this.map[sr],sr,this)},Sr.prototype.keys=function(){var cr=[];return this.forEach(function(Dt,sr){cr.push(sr)}),wr(cr)},Sr.prototype.values=function(){var cr=[];return this.forEach(function(Dt){cr.push(Dt)}),wr(cr)},Sr.prototype.entries=function(){var cr=[];return this.forEach(function(Dt,sr){cr.push([sr,Dt])}),wr(cr)},tr&&(Sr.prototype[Symbol.iterator]=Sr.prototype.entries);var Rr=["DELETE","GET","HEAD","OPTIONS","POST","PUT"];function Br(cr,Dt){var sr,lr,gr=(Dt=Dt||{}).body;if(cr instanceof Br){if(cr.bodyUsed)throw new TypeError("Already read");this.url=cr.url,this.credentials=cr.credentials,Dt.headers||(this.headers=new Sr(cr.headers)),this.method=cr.method,this.mode=cr.mode,this.signal=cr.signal,gr||cr._bodyInit==null||(gr=cr._bodyInit,cr.bodyUsed=!0)}else this.url=String(cr);if(this.credentials=Dt.credentials||this.credentials||"same-origin",!Dt.headers&&this.headers||(this.headers=new Sr(Dt.headers)),this.method=(sr=Dt.method||this.method||"GET",lr=sr.toUpperCase(),Rr.indexOf(lr)>-1?lr:sr),this.mode=Dt.mode||this.mode||null,this.signal=Dt.signal||this.signal,this.referrer=null,(this.method==="GET"||this.method==="HEAD")&&gr)throw new TypeError("Body not allowed for GET or HEAD requests");this._initBody(gr)}function Mr(cr){var Dt=new FormData;return cr.trim().split("&").forEach(function(sr){if(sr){var lr=sr.split("="),gr=lr.shift().replace(/\+/g," "),_r=lr.join("=").replace(/\+/g," ");Dt.append(decodeURIComponent(gr),decodeURIComponent(_r))}}),Dt}function Lr(cr,Dt){Dt||(Dt={}),this.type="default",this.status=Dt.status===void 0?200:Dt.status,this.ok=this.status>=200&&this.status<300,this.statusText="statusText"in Dt?Dt.statusText:"OK",this.headers=new Sr(Dt.headers),this.url=Dt.url||"",this._initBody(cr)}Br.prototype.clone=function(){return new Br(this,{body:this._bodyInit})},Pr.call(Br.prototype),Pr.call(Lr.prototype),Lr.prototype.clone=function(){return new Lr(this._bodyInit,{status:this.status,statusText:this.statusText,headers:new Sr(this.headers),url:this.url})},Lr.error=function(){var cr=new Lr(null,{status:0,statusText:""});return cr.type="error",cr};var $r=[301,302,303,307,308];Lr.redirect=function(cr,Dt){if($r.indexOf(Dt)===-1)throw new RangeError("Invalid status code");return new Lr(null,{status:Dt,headers:{location:cr}})},Xe.DOMException=Ze.DOMException;try{new Xe.DOMException}catch{Xe.DOMException=function(Dt,sr){this.message=Dt,this.name=sr;var lr=Error(Dt);this.stack=lr.stack},Xe.DOMException.prototype=Object.create(Error.prototype),Xe.DOMException.prototype.constructor=Xe.DOMException}function Nr(cr,Dt){return new Promise(function(sr,lr){var gr=new Br(cr,Dt);if(gr.signal&&gr.signal.aborted)return lr(new Xe.DOMException("Aborted","AbortError"));var _r=new XMLHttpRequest;function xr(){_r.abort()}_r.onload=function(){var kr,pr,rr={status:_r.status,statusText:_r.statusText,headers:(kr=_r.getAllResponseHeaders()||"",pr=new Sr,kr.replace(/\r?\n[\t ]+/g," ").split(/\r?\n/).forEach(function(Cr){var Or=Cr.split(":"),Ur=Or.shift().trim();if(Ur){var qr=Or.join(":").trim();pr.append(Ur,qr)}}),pr)};rr.url="responseURL"in _r?_r.responseURL:rr.headers.get("X-Request-URL");var hr="response"in _r?_r.response:_r.responseText;sr(new Lr(hr,rr))},_r.onerror=function(){lr(new TypeError("Network request failed"))},_r.ontimeout=function(){lr(new TypeError("Network request failed"))},_r.onabort=function(){lr(new Xe.DOMException("Aborted","AbortError"))},_r.open(gr.method,gr.url,!0),gr.credentials==="include"?_r.withCredentials=!0:gr.credentials==="omit"&&(_r.withCredentials=!1),"responseType"in _r&&er&&(_r.responseType="blob"),gr.headers.forEach(function(kr,pr){_r.setRequestHeader(pr,kr)}),gr.signal&&(gr.signal.addEventListener("abort",xr),_r.onreadystatechange=function(){_r.readyState===4&&gr.signal.removeEventListener("abort",xr)}),_r.send(gr._bodyInit===void 0?null:gr._bodyInit)})}Nr.polyfill=!0,Ze.fetch||(Ze.fetch=Nr,Ze.Headers=Sr,Ze.Request=Br,Ze.Response=Lr),Xe.Headers=Sr,Xe.Request=Br,Xe.Response=Lr,Xe.fetch=Nr,Object.defineProperty(Xe,"__esModule",{value:!0})})({})})(qe),qe.fetch.ponyfill=!0,delete qe.fetch.polyfill;var We=qe;(Re=We.fetch).default=We.fetch,Re.fetch=We.fetch,Re.Headers=We.Headers,Re.Request=We.Request,Re.Response=We.Response,Ke.exports=Re})(dn,dn.exports);var ln=Ft(dn.exports);async function hn(Ke,Re){const Fe=await Ke.getAccountInfo(Re);if(Fe===null)throw new Error("program account not found");const{program:qe}=fn(Fe.data),We=await Ke.getAccountInfo(qe.programdataAddress);if(We===null)throw new Error("program data account not found");const{programData:Ze}=fn(We.data);return Ze}const pn=lib.rustEnum([lib.struct([],"uninitialized"),lib.struct([lib.option(lib.publicKey(),"authorityAddress")],"buffer"),lib.struct([lib.publicKey("programdataAddress")],"program"),lib.struct([lib.u64("slot"),lib.option(lib.publicKey(),"upgradeAuthorityAddress")],"programData")],void 0,lib.u32());function fn(Ke){return pn.decode(Ke)}var mn=Object.freeze({__proto__:null,verifiedBuild:async function(Ke,Re,Fe=5){const qe=`https://api.apr.dev/api/v0/program/${Re.toString()}/latest?limit=${Fe}`,[We,Ze]=await Promise.all([hn(Ke,Re),ln(qe)]),Xe=(await Ze.json()).filter(tr=>!tr.aborted&&tr.state==="Built"&&tr.verified==="Verified");if(Xe.length===0)return null;const Je=Xe[0];return We.slot.toNumber()!==Je.verified_slot?null:Je},fetchData:hn,decodeUpgradeableLoaderState:fn});Object.freeze({__proto__:null,sha256:Ye,rpc:it,publicKey:sn,bytes:k,token:un,features:yt,registry:mn});const gn=lib.struct([lib.publicKey("authority"),lib.vecU8("data")]);function wn(Ke,Re){var Fe,qe;let We={};const Ze=Ke.args?Ke.args.length:0;if(Re.length>Ze){if(Re.length!==Ze+1)throw new Error(`provided too many arguments ${Re} to instruction ${Ke==null?void 0:Ke.name} expecting: ${(qe=(Fe=Ke.args)===null||Fe===void 0?void 0:Fe.map(Xe=>Xe.name))!==null&&qe!==void 0?qe:[]}`);We=Re.pop()}return[Re,We]}class vn{static build(Re,Fe,qe){if(Re.name==="_inner")throw new gt("the _inner name is reserved");const We=(...Ze)=>{const[Xe,Je]=wn(Re,[...Ze]);P(Re.accounts,Je.accounts);const tr=We.accounts(Je.accounts);return Je.remainingAccounts!==void 0&&tr.push(...Je.remainingAccounts),mt("debug-logs")&&console.log("Outgoing account metas:",tr),new TransactionInstruction({keys:tr,programId:qe,data:Fe(Re.name,x(Re,...Xe))})};return We.accounts=Ze=>vn.accountsArray(Ze,Re.accounts,Re.name),We}static accountsArray(Re,Fe,qe){return Re?Fe.map(We=>{if(("accounts"in We?We.accounts:void 0)!==void 0){const Ze=Re[We.name];return vn.accountsArray(Ze,We.accounts,qe).flat()}{const Ze=We;let Xe;try{Xe=L(Re[We.name])}catch{throw new Error(`Wrong input type for account "${We.name}" in the instruction accounts object${qe!==void 0?' for instruction "'+qe+'"':""}. Expected PublicKey or string.`)}return{pubkey:Xe,isWritable:Ze.isMut,isSigner:Ze.isSigner}}}).flat():[]}}class bn{static build(Re,Fe,qe,We){return async(...Ze)=>{var Xe;const Je=Fe(...Ze),[,tr]=wn(Re,[...Ze]);if(We.sendAndConfirm===void 0)throw new Error("This function requires 'Provider.sendAndConfirm' to be implemented.");try{return await We.sendAndConfirm(Je,(Xe=tr.signers)!==null&&Xe!==void 0?Xe:[],tr.options)}catch(er){throw At(er,qe)}}}}class An{static build(Re,Fe){return(...qe)=>{var We,Ze,Xe;const[,Je]=wn(Re,[...qe]),tr=new Transaction;if(Je.preInstructions&&Je.instructions)throw new Error("instructions is deprecated, use preInstructions");return(We=Je.preInstructions)===null||We===void 0||We.forEach(er=>tr.add(er)),(Ze=Je.instructions)===null||Ze===void 0||Ze.forEach(er=>tr.add(er)),tr.add(Fe(...qe)),(Xe=Je.postInstructions)===null||Xe===void 0||Xe.forEach(er=>tr.add(er)),tr}}}class _n{constructor(Re,Fe,qe=lt(),We=new Kt(Re)){this.provider=qe,this.coder=We,this._idl=Re,this._programId=Fe,this._address=Sn(Fe),this._sub=null;const[Ze,Xe,Je]=(()=>{var tr;let er={},ir={},ur={};return(tr=Re.state)===null||tr===void 0||tr.methods.forEach(fr=>{const ar=vn.build(fr,(Sr,Ar)=>We.instruction.encodeState(Sr,Ar),Fe);ar.accounts=Sr=>function(vr,Ir,Tr,Pr){if(Tr.name==="new"){const[Rr]=nn([],vr);if(Ir.wallet===void 0)throw new Error("This function requires the Provider interface implementor to have a 'wallet' field.");return[{pubkey:Ir.wallet.publicKey,isWritable:!1,isSigner:!0},{pubkey:Sn(vr),isWritable:!0,isSigner:!1},{pubkey:Rr,isWritable:!1,isSigner:!1},{pubkey:SystemProgram.programId,isWritable:!1,isSigner:!1},{pubkey:vr,isWritable:!1,isSigner:!1}]}return P(Tr.accounts,Pr),[{pubkey:Sn(vr),isWritable:!0,isSigner:!1}]}(Fe,qe,fr,Sr).concat(vn.accountsArray(Sr,fr.accounts,fr.name));const yr=An.build(fr,ar),mr=bn.build(fr,yr,M(Re),qe),wr=camelcase.exports(fr.name);er[wr]=ar,ir[wr]=yr,ur[wr]=mr}),[er,ir,ur]})();this.instruction=Ze,this.transaction=Xe,this.rpc=Je}get programId(){return this._programId}async fetch(){const Re=this.address(),Fe=await this.provider.connection.getAccountInfo(Re);if(Fe===null)throw new Error(`Account does not exist ${Re.toString()}`);const qe=this._idl.state;if(!qe)throw new Error("State is not specified in IDL.");if((await jt(qe.struct.name)).compare(Fe.data.slice(0,8)))throw new Error("Invalid account discriminator");return this.coder.state.decode(Fe.data)}address(){return this._address}subscribe(Re){if(this._sub!==null)return this._sub.ee;const Fe=new y,qe=this.provider.connection.onAccountChange(this.address(),We=>{const Ze=this.coder.state.decode(We.data);Fe.emit("change",Ze)},Re);return this._sub={ee:Fe,listener:qe},Fe}unsubscribe(){this._sub!==null&&this.provider.connection.removeAccountChangeListener(this._sub.listener).then(async()=>{this._sub=null}).catch(console.error)}}function Sn(Ke){let[Re]=nn([],Ke);return tn(Re,"unversioned",Ke)}class En{constructor(Re,Fe,qe,We,Ze){this._idlAccount=Fe,this._programId=qe,this._provider=We!=null?We:lt(),this._coder=Ze!=null?Ze:new Kt(Re),this._size=this._coder.accounts.size(Fe)}get size(){return this._size}get programId(){return this._programId}get provider(){return this._provider}get coder(){return this._coder}async fetchNullable(Re,Fe){const qe=await this.getAccountInfo(Re,Fe);return qe===null?null:this._coder.accounts.decode(this._idlAccount.name,qe.data)}async fetch(Re,Fe){const qe=await this.fetchNullable(Re,Fe);if(qe===null)throw new Error(`Account does not exist ${Re.toString()}`);return qe}async fetchMultiple(Re,Fe){return(await X(this._provider.connection,Re.map(qe=>L(qe)),Fe)).map(qe=>qe==null?null:this._coder.accounts.decode(this._idlAccount.name,qe==null?void 0:qe.account.data))}async all(Re){return(await this._provider.connection.getProgramAccounts(this._programId,{commitment:this._provider.connection.commitment,filters:[{memcmp:this.coder.accounts.memcmp(this._idlAccount.name,Re instanceof Buffer?Re:void 0)},...Array.isArray(Re)?Re:[]]})).map(({pubkey:Fe,account:qe})=>({publicKey:Fe,account:this._coder.accounts.decode(this._idlAccount.name,qe.data)}))}subscribe(Re,Fe){const qe=In.get(Re.toString());if(qe)return qe.ee;const We=new y;Re=L(Re);const Ze=this._provider.connection.onAccountChange(Re,Xe=>{const Je=this._coder.accounts.decode(this._idlAccount.name,Xe.data);We.emit("change",Je)},Fe);return In.set(Re.toString(),{ee:We,listener:Ze}),We}async unsubscribe(Re){let Fe=In.get(Re.toString());Fe?In&&await this._provider.connection.removeAccountChangeListener(Fe.listener).then(()=>{In.delete(Re.toString())}).catch(console.error):console.warn("Address is not subscribed")}async createInstruction(Re,Fe){const qe=this.size;if(this._provider.wallet===void 0)throw new Error("This function requires the Provider interface implementor to have a 'wallet' field.");return SystemProgram.createAccount({fromPubkey:this._provider.wallet.publicKey,newAccountPubkey:Re.publicKey,space:Fe!=null?Fe:qe,lamports:await this._provider.connection.getMinimumBalanceForRentExemption(Fe!=null?Fe:qe),programId:this._programId})}async associated(...Re){const Fe=await this.associatedAddress(...Re);return await this.fetch(Fe)}async associatedAddress(...Re){return await on(this._programId,...Re)}async getAccountInfo(Re,Fe){return await this._provider.connection.getAccountInfo(L(Re),Fe)}}const In=new Map,kn=13,Mn=14;class xn{constructor(Re,Fe,qe){this._programId=Re,this._provider=Fe,this._eventParser=new Pn(Re,qe),this._eventCallbacks=new Map,this._eventListeners=new Map,this._listenerIdCount=0}addEventListener(Re,Fe){var qe;let We=this._listenerIdCount;return this._listenerIdCount+=1,Re in this._eventCallbacks||this._eventListeners.set(Re,[]),this._eventListeners.set(Re,((qe=this._eventListeners.get(Re))!==null&&qe!==void 0?qe:[]).concat(We)),this._eventCallbacks.set(We,[Re,Fe]),this._onLogsSubscriptionId!==void 0||(this._onLogsSubscriptionId=this._provider.connection.onLogs(this._programId,(Ze,Xe)=>{if(!Ze.err)for(const Je of this._eventParser.parseLogs(Ze.logs)){const tr=this._eventListeners.get(Je.name);tr&&tr.forEach(er=>{const ir=this._eventCallbacks.get(er);if(ir){const[,ur]=ir;ur(Je.data,Xe.slot,Ze.signature)}})}})),We}async removeEventListener(Re){const Fe=this._eventCallbacks.get(Re);if(!Fe)throw new Error(`Event listener ${Re} doesn't exist!`);const[qe]=Fe;let We=this._eventListeners.get(qe);if(!We)throw new Error(`Event listeners don't exist for ${qe}!`);this._eventCallbacks.delete(Re),We=We.filter(Ze=>Ze!==Re),We.length===0&&this._eventListeners.delete(qe),this._eventCallbacks.size==0&&((void 0)(this._eventListeners.size===0),this._onLogsSubscriptionId!==void 0&&(await this._provider.connection.removeOnLogsListener(this._onLogsSubscriptionId),this._onLogsSubscriptionId=void 0))}}class Pn{constructor(Re,Fe){this.coder=Fe,this.programId=Re}*parseLogs(Re){const Fe=new Tn(Re),qe=new Ln;let We=Fe.next();for(;We!==null;){let[Ze,Xe,Je]=this.handleLog(qe,We);Ze&&(yield Ze),Xe&&qe.push(Xe),Je&&qe.pop(),We=Fe.next()}}handleLog(Re,Fe){return Re.stack.length>0&&Re.program()===this.programId.toString()?this.handleProgramLog(Fe):[null,...this.handleSystemLog(Fe)]}handleProgramLog(Re){if(Re.startsWith("Program log: ")||Re.startsWith("Program data: ")){const Fe=Re.startsWith("Program log: ")?Re.slice(kn):Re.slice(Mn);return[this.coder.events.decode(Fe),null,!1]}return[null,...this.handleSystemLog(Re)]}handleSystemLog(Re){const Fe=Re.split(":")[0];return Fe.match(/^Program (.*) success/g)!==null?[null,!0]:Fe.startsWith(`Program ${this.programId.toString()} invoke`)?[this.programId.toString(),!1]:Fe.includes("invoke")?["cpi",!1]:[null,!1]}}class Ln{constructor(){this.stack=[]}program(){return(void 0)(this.stack.length>0),this.stack[this.stack.length-1]}push(Re){this.stack.push(Re)}pop(){(void 0)(this.stack.length>0),this.stack.pop()}}class Tn{constructor(Re){this.logs=Re}next(){if(this.logs.length===0)return null;let Re=this.logs[0];return this.logs=this.logs.slice(1),Re}}new PublicKey("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA");function zn(){return new Ne(Bn)}const Bn={version:"0.1.0",name:"spl_token",instructions:[{name:"initializeMint",accounts:[{name:"mint",isMut:!0,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1}],args:[{name:"decimals",type:"u8"},{name:"mintAuthority",type:"publicKey"},{name:"freezeAuthority",type:{coption:"publicKey"}}]},{name:"initializeAccount",accounts:[{name:"account",isMut:!0,isSigner:!1},{name:"mint",isMut:!1,isSigner:!1},{name:"authority",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1}],args:[]},{name:"initializeMultisig",accounts:[{name:"account",isMut:!0,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1}],args:[{name:"m",type:"u8"}]},{name:"transfer",accounts:[{name:"source",isMut:!0,isSigner:!1},{name:"destination",isMut:!0,isSigner:!1},{name:"authority",isMut:!1,isSigner:!0}],args:[{name:"amount",type:"u64"}]},{name:"approve",accounts:[{name:"source",isMut:!0,isSigner:!1},{name:"delegate",isMut:!1,isSigner:!1},{name:"authority",isMut:!1,isSigner:!0}],args:[{name:"amount",type:"u64"}]},{name:"revoke",accounts:[{name:"source",isMut:!0,isSigner:!1},{name:"authority",isMut:!1,isSigner:!0}],args:[]},{name:"setAuthority",accounts:[{name:"mint",isMut:!0,isSigner:!1},{name:"authority",isMut:!1,isSigner:!0}],args:[{name:"authorityType",type:"u8"},{name:"newAuthority",type:{coption:"publicKey"}}]},{name:"mintTo",accounts:[{name:"mint",isMut:!0,isSigner:!1},{name:"to",isMut:!0,isSigner:!1},{name:"authority",isMut:!1,isSigner:!0}],args:[{name:"amount",type:"u64"}]},{name:"burn",accounts:[{name:"source",isMut:!0,isSigner:!1},{name:"mint",isMut:!0,isSigner:!1},{name:"authority",isMut:!1,isSigner:!0}],args:[{name:"amount",type:"u64"}]},{name:"closeAccount",accounts:[{name:"account",isMut:!0,isSigner:!1},{name:"destination",isMut:!0,isSigner:!1},{name:"authority",isMut:!1,isSigner:!1}],args:[]},{name:"freezeAccount",accounts:[{name:"account",isMut:!0,isSigner:!1},{name:"mint",isMut:!1,isSigner:!1},{name:"authority",isMut:!1,isSigner:!0}],args:[]},{name:"thawAccount",accounts:[{name:"account",isMut:!0,isSigner:!1},{name:"mint",isMut:!1,isSigner:!1},{name:"authority",isMut:!1,isSigner:!0}],args:[]},{name:"transferChecked",accounts:[{name:"source",isMut:!0,isSigner:!1},{name:"mint",isMut:!1,isSigner:!1},{name:"destination",isMut:!0,isSigner:!1},{name:"authority",isMut:!1,isSigner:!0}],args:[{name:"amount",type:"u64"},{name:"decimals",type:"u8"}]},{name:"approveChecked",accounts:[{name:"source",isMut:!0,isSigner:!1},{name:"mint",isMut:!1,isSigner:!1},{name:"delegate",isMut:!1,isSigner:!1},{name:"authority",isMut:!1,isSigner:!0}],args:[{name:"amount",type:"u64"},{name:"decimals",type:"u8"}]},{name:"mintToChecked",accounts:[{name:"mint",isMut:!0,isSigner:!1},{name:"to",isMut:!0,isSigner:!1},{name:"authority",isMut:!1,isSigner:!0}],args:[{name:"amount",type:"u64"},{name:"decimals",type:"u8"}]},{name:"burnChecked",accounts:[{name:"source",isMut:!0,isSigner:!1},{name:"mint",isMut:!0,isSigner:!1},{name:"authority",isMut:!1,isSigner:!0}],args:[{name:"amount",type:"u64"},{name:"decimals",type:"u8"}]},{name:"initializeAccount2",accounts:[{name:"account",isMut:!0,isSigner:!1},{name:"mint",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1}],args:[{name:"authority",type:"publicKey"}]},{name:"syncNative",accounts:[{name:"account",isMut:!0,isSigner:!1}],args:[]},{name:"initializeAccount3",accounts:[{name:"account",isMut:!0,isSigner:!1},{name:"mint",isMut:!1,isSigner:!1}],args:[{name:"authority",type:"publicKey"}]},{name:"initializeMultisig2",accounts:[{name:"account",isMut:!0,isSigner:!1}],args:[{name:"m",type:"u8"}]},{name:"initializeMint2",accounts:[{name:"mint",isMut:!0,isSigner:!1}],args:[{name:"decimals",type:"u8"},{name:"mintAuthority",type:"publicKey"},{name:"freezeAuthority",type:{coption:"publicKey"}}]}],accounts:[{name:"mint",type:{kind:"struct",fields:[{name:"mintAuthority",type:{coption:"publicKey"}},{name:"supply",type:"u64"},{name:"decimals",type:"u8"},{name:"isInitialized",type:"bool"},{name:"freezeAuthority",type:{coption:"publicKey"}}]}},{name:"token",type:{kind:"struct",fields:[{name:"mint",type:"publicKey"},{name:"authority",type:"publicKey"},{name:"amount",type:"u64"},{name:"delegate",type:{coption:"publicKey"}},{name:"state",type:"u8"},{name:"isNative",type:{coption:"u64"}},{name:"delegatedAmount",type:"u64"},{name:"closeAuthority",type:{coption:"publicKey"}}]}}]};class On{constructor(Re,Fe,qe,We,Ze,Xe){this._args=Re,this._accounts=Fe,this._provider=qe,this._programId=We,this._idlIx=Ze,this._accountStore=new Dn(qe,Xe)}async resolve(){for(let Re=0;Re<this._idlIx.accounts.length;Re+=1){const Fe=this._idlIx.accounts[Re],qe=camelcase.exports(Fe.name);if(!Fe.isSigner||this._accounts[qe])Reflect.has(On.CONST_ACCOUNTS,qe)&&!this._accounts[qe]&&(this._accounts[qe]=On.CONST_ACCOUNTS[qe]);else{if(this._provider.wallet===void 0)throw new Error("This function requires the Provider interface implementor to have a 'wallet' field.");this._accounts[qe]=this._provider.wallet.publicKey}}for(let Re=0;Re<this._idlIx.accounts.length;Re+=1){const Fe=this._idlIx.accounts[Re],qe=camelcase.exports(Fe.name);Fe.pda&&Fe.pda.seeds.length>0&&!this._accounts[qe]&&await this.autoPopulatePda(Fe)}}async autoPopulatePda(Re){if(!Re.pda||!Re.pda.seeds)throw new Error("Must have seeds");const Fe=await Promise.all(Re.pda.seeds.map(Ze=>this.toBuffer(Ze))),qe=await this.parseProgramId(Re),[We]=await PublicKey.findProgramAddress(Fe,qe);this._accounts[camelcase.exports(Re.name)]=We}async parseProgramId(Re){var Fe;if(!(!((Fe=Re.pda)===null||Fe===void 0)&&Fe.programId))return this._programId;switch(Re.pda.programId.kind){case"const":return new PublicKey(this.toBufferConst(Re.pda.programId.value));case"arg":return this.argValue(Re.pda.programId);case"account":return await this.accountValue(Re.pda.programId);default:throw new Error(`Unexpected program seed kind: ${Re.pda.programId.kind}`)}}async toBuffer(Re){switch(Re.kind){case"const":return this.toBufferConst(Re);case"arg":return await this.toBufferArg(Re);case"account":return await this.toBufferAccount(Re);default:throw new Error(`Unexpected seed kind: ${Re.kind}`)}}toBufferConst(Re){return this.toBufferValue(Re.type,Re.value)}async toBufferArg(Re){const Fe=this.argValue(Re);return this.toBufferValue(Re.type,Fe)}argValue(Re){const Fe=camelcase.exports(Re.path.split(".")[0]),qe=this._idlIx.args.findIndex(We=>We.name===Fe);if(qe===-1)throw new Error(`Unable to find argument for seed: ${Fe}`);return this._args[qe]}async toBufferAccount(Re){const Fe=await this.accountValue(Re);return this.toBufferValue(Re.type,Fe)}async accountValue(Re){const Fe=Re.path.split("."),qe=Fe[0],We=this._accounts[camelcase.exports(qe)];if(Fe.length===1)return We;const Ze=await this._accountStore.fetchAccount(Re.account,We);return this.parseAccountValue(Ze,Fe.slice(1))}parseAccountValue(Re,Fe){let qe;for(;Fe.length>0;)qe=Re[camelcase.exports(Fe[0])],Fe=Fe.slice(1);return qe}toBufferValue(Re,Fe){switch(Re){case"u8":return Buffer.from([Fe]);case"u16":let qe=Buffer.alloc(2);return qe.writeUInt16LE(Fe),qe;case"u32":let We=Buffer.alloc(4);return We.writeUInt32LE(Fe),We;case"u64":let Ze=Buffer.alloc(8);return Ze.writeBigUInt64LE(BigInt(Fe)),Ze;case"string":return Buffer.from(b(Fe));case"publicKey":return Fe.toBuffer();default:if(Re.array)return Buffer.from(Fe);throw new Error(`Unexpected seed type: ${Re}`)}}}On.CONST_ACCOUNTS={associatedTokenProgram:cn,rent:SYSVAR_RENT_PUBKEY,systemProgram:SystemProgram.programId,tokenProgram:an};class Dn{constructor(Re,Fe){this._provider=Re,this._accounts=Fe,this._cache=new Map}async fetchAccount(Re,Fe){const qe=Fe.toString();if(!this._cache.has(qe))if(Re==="TokenAccount"){const We=await this._provider.connection.getAccountInfo(Fe);if(We===null)throw new Error(`invalid account info for ${qe}`);const Ze=zn().accounts.decode("token",We.data);this._cache.set(qe,Ze)}else{const We=this._accounts[camelcase.exports(Re)].fetch(Fe);this._cache.set(qe,We)}return this._cache.get(qe)}}class Nn{static build(Re,Fe,qe,We,Ze,Xe,Je,tr,er){return(...ir)=>new Rn(ir,We,Ze,Xe,Je,tr,Re,Fe,qe,er)}}class Rn{constructor(Re,Fe,qe,We,Ze,Xe,Je,tr,er,ir){this._args=Re,this._ixFn=Fe,this._txFn=qe,this._rpcFn=We,this._simulateFn=Ze,this._viewFn=Xe,this._accounts={},this._remainingAccounts=[],this._signers=[],this._preInstructions=[],this._postInstructions=[],this._autoResolveAccounts=!0,this._accountsResolver=new On(Re,this._accounts,Je,tr,er,ir)}async pubkeys(){return this._autoResolveAccounts&&await this._accountsResolver.resolve(),this._accounts}accounts(Re){return this._autoResolveAccounts=!0,Object.assign(this._accounts,Re),this}accountsStrict(Re){return this._autoResolveAccounts=!1,Object.assign(this._accounts,Re),this}signers(Re){return this._signers=this._signers.concat(Re),this}remainingAccounts(Re){return this._remainingAccounts=this._remainingAccounts.concat(Re),this}preInstructions(Re){return this._preInstructions=this._preInstructions.concat(Re),this}postInstructions(Re){return this._postInstructions=this._postInstructions.concat(Re),this}async rpc(Re){return this._autoResolveAccounts&&await this._accountsResolver.resolve(),this._rpcFn(...this._args,{accounts:this._accounts,signers:this._signers,remainingAccounts:this._remainingAccounts,preInstructions:this._preInstructions,postInstructions:this._postInstructions,options:Re})}async view(Re){if(this._autoResolveAccounts&&await this._accountsResolver.resolve(),!this._viewFn)throw new Error("Method does not support views");return this._viewFn(...this._args,{accounts:this._accounts,signers:this._signers,remainingAccounts:this._remainingAccounts,preInstructions:this._preInstructions,postInstructions:this._postInstructions,options:Re})}async simulate(Re){return this._autoResolveAccounts&&await this._accountsResolver.resolve(),this._simulateFn(...this._args,{accounts:this._accounts,signers:this._signers,remainingAccounts:this._remainingAccounts,preInstructions:this._preInstructions,postInstructions:this._postInstructions,options:Re})}async instruction(){return this._autoResolveAccounts&&await this._accountsResolver.resolve(),this._ixFn(...this._args,{accounts:this._accounts,signers:this._signers,remainingAccounts:this._remainingAccounts,preInstructions:this._preInstructions,postInstructions:this._postInstructions})}async transaction(){return this._autoResolveAccounts&&await this._accountsResolver.resolve(),this._txFn(...this._args,{accounts:this._accounts,signers:this._signers,remainingAccounts:this._remainingAccounts,preInstructions:this._preInstructions,postInstructions:this._postInstructions})}}class Vn{constructor(Re,Fe,qe,We){Fe=L(Fe),qe||(qe=lt()),this._idl=Re,this._provider=qe,this._programId=Fe,this._coder=We!=null?We:new Kt(Re),this._events=new xn(this._programId,qe,this._coder);const[Ze,Xe,Je,tr,er,ir,ur,fr]=class{static build(ar,yr,mr,wr){const Sr={},Ar={},vr={},Ir={},Tr={},Pr={},Rr=M(ar),Br=ar.accounts?class{static build(Lr,$r,Nr,cr){var Dt;const sr={};return(Dt=Lr.accounts)===null||Dt===void 0||Dt.forEach(lr=>{const gr=camelcase.exports(lr.name);sr[gr]=new En(Lr,lr,Nr,cr,$r)}),sr}}.build(ar,yr,mr,wr):{},Mr=class{static build(Lr,$r,Nr,cr){if(Lr.state!==void 0)return new _n(Lr,Nr,cr,$r)}}.build(ar,yr,mr,wr);return ar.instructions.forEach(Lr=>{const $r=vn.build(Lr,(_r,xr)=>yr.instruction.encode(_r,xr),mr),Nr=An.build(Lr,$r),cr=bn.build(Lr,Nr,Rr,wr),Dt=class{static build(_r,xr,kr,pr,rr,hr,Cr){return async(...Or)=>{var Ur;const qr=xr(...Or),[,Fr]=wn(_r,[...Or]);let zr;if(pr.simulate===void 0)throw new Error("This function requires 'Provider.simulate' to be implemented.");try{zr=await pr.simulate(qr,Fr.signers,(Ur=Fr.options)===null||Ur===void 0?void 0:Ur.commitment)}catch(Gr){throw At(Gr,kr)}if(zr===void 0)throw new Error("Unable to simulate transaction");const Yr=zr.logs;if(!Yr)throw new Error("Simulated logs not found");const Wr=[];if(Cr.events){let Gr=new Pn(hr,rr);for(const Hn of Gr.parseLogs(Yr))Wr.push(Hn)}return{events:Wr,raw:Yr}}}}.build(Lr,Nr,Rr,wr,yr,mr,ar),sr=class{static build(_r,xr,kr,pr){const rr=xr.accounts.find(Cr=>Cr.isMut),hr=!!xr.returns;if(!rr&&hr)return async(...Cr)=>{var Or,Ur;let qr=await kr(...Cr);const Fr=`Program return: ${_r} `;let zr=qr.raw.find(Gr=>Gr.startsWith(Fr));if(!zr)throw new Error("View expected return log");let Yr=E(zr.slice(Fr.length)),Wr=xr.returns;if(!Wr)throw new Error("View expected return type");return Lt.fieldLayout({type:Wr},Array.from([...(Or=pr.accounts)!==null&&Or!==void 0?Or:[],...(Ur=pr.types)!==null&&Ur!==void 0?Ur:[]])).decode(Yr)}}}.build(mr,Lr,Dt,ar),lr=Nn.build(wr,mr,Lr,$r,Nr,cr,Dt,sr,Br),gr=camelcase.exports(Lr.name);Ar[gr]=$r,vr[gr]=Nr,Sr[gr]=cr,Ir[gr]=Dt,Tr[gr]=lr,sr&&(Pr[gr]=sr)}),[Sr,Ar,vr,Br,Ir,Tr,Mr,Pr]}}.build(Re,this._coder,Fe,qe);this.rpc=Ze,this.instruction=Xe,this.transaction=Je,this.account=tr,this.simulate=er,this.methods=ir,this.state=ur,this.views=fr}get programId(){return this._programId}get idl(){return this._idl}get coder(){return this._coder}get provider(){return this._provider}static async at(Re,Fe){const qe=L(Re),We=await Vn.fetchIdl(qe,Fe);if(!We)throw new Error(`IDL not found for program: ${Re.toString()}`);return new Vn(We,qe,Fe)}static async fetchIdl(Re,Fe){Fe=Fe!=null?Fe:lt();const qe=L(Re),We=await async function(er){const ir=(await PublicKey.findProgramAddress([],er))[0];return await PublicKey.createWithSeed(ir,"anchor:idl",er)}(qe),Ze=await Fe.connection.getAccountInfo(We);if(!Ze)return null;let Xe=(Je=Ze.data.slice(8),gn.decode(Je));var Je;const tr=inflate_1(Xe.data);return JSON.parse(v(tr))}addEventListener(Re,Fe){return this._events.addEventListener(Re,Fe)}async removeEventListener(Re){return await this._events.removeEventListener(Re)}}new PublicKey("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL");new PublicKey("11111111111111111111111111111111");const _keypair={publicKey:{0:113,1:111,2:234,3:67,4:72,5:32,6:190,7:55,8:243,9:64,10:43,11:46,12:158,13:18,14:99,15:146,16:76,17:163,18:117,19:206,20:240,21:94,22:91,23:57,24:27,25:128,26:91,27:114,28:231,29:225,30:146,31:185},secretKey:{0:161,1:133,2:44,3:68,4:54,5:36,6:149,7:153,8:20,9:232,10:86,11:88,12:169,13:165,14:108,15:110,16:173,17:249,18:226,19:38,20:41,21:224,22:174,23:49,24:230,25:104,26:17,27:26,28:191,29:247,30:27,31:236,32:113,33:111,34:234,35:67,36:72,37:32,38:190,39:55,40:243,41:64,42:43,43:46,44:158,45:18,46:99,47:146,48:76,49:163,50:117,51:206,52:240,53:94,54:91,55:57,56:27,57:128,58:91,59:114,60:231,61:225,62:146,63:185}},KeyPair={_keypair},network=clusterApiUrl(NETWORK),opts={preflightCommitment:"processed"},programID=new PublicKey(PROGRAM_KEY),getProvider=()=>{const Ke=new Connection(network,opts.preflightCommitment);return new st(Ke,window.solana,opts)},connectWallet=async()=>{const Ke=window.solana;if(!Ke)throw new Error("no solana connection");if(await Ke.connect({onlyIfTrusted:!1}),!Ke.isPhantom)throw new Error("no phnatom connection");return Ke},getBaseAccount=()=>{const Ke=Object.values(KeyPair._keypair.secretKey),Re=new Uint8Array(Ke);return Keypair.fromSecretKey(Re)},getProgram=async()=>{const Ke=getProvider(),Re=await Vn.fetchIdl(programID,Ke);return new Vn(Re,programID,Ke)};function checkIsImage(Ke){return/^https?:\/\/.+\.(jpg|jpeg|png|webp|avif|gif|svg)$/.test(Ke)}const baseAccount=getBaseAccount(),createGifAccount=async()=>{try{const Ke=getProvider(),Re=await getProgram();console.log("createGifAccount"),console.log("provider.wallet.publicKey",Ke.wallet.publicKey.toString()),await Re.methods.startStuffOff().accounts({baseAccount:baseAccount.publicKey,user:Ke.wallet.publicKey,systemProgram:SystemProgram.programId}).signers([baseAccount]).rpc(),console.log("Created a new BaseAccount w/ address:",baseAccount.publicKey.toString())}catch(Ke){console.log("123 error: ",Ke)}},getGifList=async()=>{const Fe=(await(await getProgram()).account.baseAccount.fetch(baseAccount.publicKey)).gifList;return Fe||[]},sendGif=async Ke=>{if(Ke.length<=0)return console.log("Empty input. Try again.");const Re=getProvider(),Fe=await getProgram();console.log("program",Fe),await Fe.methods.addGif(Ke).accounts({baseAccount:baseAccount.publicKey,user:Re.wallet.publicKey}).rpc(),console.log("success added gif")},voteGif=async Ke=>{if(Ke.length<=0)return console.log("Empty input. Try again.");const Re=getProvider(),Fe=await getProgram();try{await Fe.methods.voteGif(Ke).accounts({baseAccount:baseAccount.publicKey,user:Re.wallet.publicKey}).rpc()}catch(qe){console.log("error",qe)}console.log("success voted gif")};var colorName={aliceblue:[240,248,255],antiquewhite:[250,235,215],aqua:[0,255,255],aquamarine:[127,255,212],azure:[240,255,255],beige:[245,245,220],bisque:[255,228,196],black:[0,0,0],blanchedalmond:[255,235,205],blue:[0,0,255],blueviolet:[138,43,226],brown:[165,42,42],burlywood:[222,184,135],cadetblue:[95,158,160],chartreuse:[127,255,0],chocolate:[210,105,30],coral:[255,127,80],cornflowerblue:[100,149,237],cornsilk:[255,248,220],crimson:[220,20,60],cyan:[0,255,255],darkblue:[0,0,139],darkcyan:[0,139,139],darkgoldenrod:[184,134,11],darkgray:[169,169,169],darkgreen:[0,100,0],darkgrey:[169,169,169],darkkhaki:[189,183,107],darkmagenta:[139,0,139],darkolivegreen:[85,107,47],darkorange:[255,140,0],darkorchid:[153,50,204],darkred:[139,0,0],darksalmon:[233,150,122],darkseagreen:[143,188,143],darkslateblue:[72,61,139],darkslategray:[47,79,79],darkslategrey:[47,79,79],darkturquoise:[0,206,209],darkviolet:[148,0,211],deeppink:[255,20,147],deepskyblue:[0,191,255],dimgray:[105,105,105],dimgrey:[105,105,105],dodgerblue:[30,144,255],firebrick:[178,34,34],floralwhite:[255,250,240],forestgreen:[34,139,34],fuchsia:[255,0,255],gainsboro:[220,220,220],ghostwhite:[248,248,255],gold:[255,215,0],goldenrod:[218,165,32],gray:[128,128,128],green:[0,128,0],greenyellow:[173,255,47],grey:[128,128,128],honeydew:[240,255,240],hotpink:[255,105,180],indianred:[205,92,92],indigo:[75,0,130],ivory:[255,255,240],khaki:[240,230,140],lavender:[230,230,250],lavenderblush:[255,240,245],lawngreen:[124,252,0],lemonchiffon:[255,250,205],lightblue:[173,216,230],lightcoral:[240,128,128],lightcyan:[224,255,255],lightgoldenrodyellow:[250,250,210],lightgray:[211,211,211],lightgreen:[144,238,144],lightgrey:[211,211,211],lightpink:[255,182,193],lightsalmon:[255,160,122],lightseagreen:[32,178,170],lightskyblue:[135,206,250],lightslategray:[119,136,153],lightslategrey:[119,136,153],lightsteelblue:[176,196,222],lightyellow:[255,255,224],lime:[0,255,0],limegreen:[50,205,50],linen:[250,240,230],magenta:[255,0,255],maroon:[128,0,0],mediumaquamarine:[102,205,170],mediumblue:[0,0,205],mediumorchid:[186,85,211],mediumpurple:[147,112,219],mediumseagreen:[60,179,113],mediumslateblue:[123,104,238],mediumspringgreen:[0,250,154],mediumturquoise:[72,209,204],mediumvioletred:[199,21,133],midnightblue:[25,25,112],mintcream:[245,255,250],mistyrose:[255,228,225],moccasin:[255,228,181],navajowhite:[255,222,173],navy:[0,0,128],oldlace:[253,245,230],olive:[128,128,0],olivedrab:[107,142,35],orange:[255,165,0],orangered:[255,69,0],orchid:[218,112,214],palegoldenrod:[238,232,170],palegreen:[152,251,152],paleturquoise:[175,238,238],palevioletred:[219,112,147],papayawhip:[255,239,213],peachpuff:[255,218,185],peru:[205,133,63],pink:[255,192,203],plum:[221,160,221],powderblue:[176,224,230],purple:[128,0,128],rebeccapurple:[102,51,153],red:[255,0,0],rosybrown:[188,143,143],royalblue:[65,105,225],saddlebrown:[139,69,19],salmon:[250,128,114],sandybrown:[244,164,96],seagreen:[46,139,87],seashell:[255,245,238],sienna:[160,82,45],silver:[192,192,192],skyblue:[135,206,235],slateblue:[106,90,205],slategray:[112,128,144],slategrey:[112,128,144],snow:[255,250,250],springgreen:[0,255,127],steelblue:[70,130,180],tan:[210,180,140],teal:[0,128,128],thistle:[216,191,216],tomato:[255,99,71],turquoise:[64,224,208],violet:[238,130,238],wheat:[245,222,179],white:[255,255,255],whitesmoke:[245,245,245],yellow:[255,255,0],yellowgreen:[154,205,50]};const cssKeywords=colorName,reverseKeywords={};for(const Ke of Object.keys(cssKeywords))reverseKeywords[cssKeywords[Ke]]=Ke;const convert$1={rgb:{channels:3,labels:"rgb"},hsl:{channels:3,labels:"hsl"},hsv:{channels:3,labels:"hsv"},hwb:{channels:3,labels:"hwb"},cmyk:{channels:4,labels:"cmyk"},xyz:{channels:3,labels:"xyz"},lab:{channels:3,labels:"lab"},lch:{channels:3,labels:"lch"},hex:{channels:1,labels:["hex"]},keyword:{channels:1,labels:["keyword"]},ansi16:{channels:1,labels:["ansi16"]},ansi256:{channels:1,labels:["ansi256"]},hcg:{channels:3,labels:["h","c","g"]},apple:{channels:3,labels:["r16","g16","b16"]},gray:{channels:1,labels:["gray"]}};var conversions$2=convert$1;for(const Ke of Object.keys(convert$1)){if(!("channels"in convert$1[Ke]))throw new Error("missing channels property: "+Ke);if(!("labels"in convert$1[Ke]))throw new Error("missing channel labels property: "+Ke);if(convert$1[Ke].labels.length!==convert$1[Ke].channels)throw new Error("channel and label counts mismatch: "+Ke);const{channels:Re,labels:Fe}=convert$1[Ke];delete convert$1[Ke].channels,delete convert$1[Ke].labels,Object.defineProperty(convert$1[Ke],"channels",{value:Re}),Object.defineProperty(convert$1[Ke],"labels",{value:Fe})}convert$1.rgb.hsl=function(Ke){const Re=Ke[0]/255,Fe=Ke[1]/255,qe=Ke[2]/255,We=Math.min(Re,Fe,qe),Ze=Math.max(Re,Fe,qe),Xe=Ze-We;let Je,tr;Ze===We?Je=0:Re===Ze?Je=(Fe-qe)/Xe:Fe===Ze?Je=2+(qe-Re)/Xe:qe===Ze&&(Je=4+(Re-Fe)/Xe),Je=Math.min(Je*60,360),Je<0&&(Je+=360);const er=(We+Ze)/2;return Ze===We?tr=0:er<=.5?tr=Xe/(Ze+We):tr=Xe/(2-Ze-We),[Je,tr*100,er*100]};convert$1.rgb.hsv=function(Ke){let Re,Fe,qe,We,Ze;const Xe=Ke[0]/255,Je=Ke[1]/255,tr=Ke[2]/255,er=Math.max(Xe,Je,tr),ir=er-Math.min(Xe,Je,tr),ur=function(fr){return(er-fr)/6/ir+1/2};return ir===0?(We=0,Ze=0):(Ze=ir/er,Re=ur(Xe),Fe=ur(Je),qe=ur(tr),Xe===er?We=qe-Fe:Je===er?We=1/3+Re-qe:tr===er&&(We=2/3+Fe-Re),We<0?We+=1:We>1&&(We-=1)),[We*360,Ze*100,er*100]};convert$1.rgb.hwb=function(Ke){const Re=Ke[0],Fe=Ke[1];let qe=Ke[2];const We=convert$1.rgb.hsl(Ke)[0],Ze=1/255*Math.min(Re,Math.min(Fe,qe));return qe=1-1/255*Math.max(Re,Math.max(Fe,qe)),[We,Ze*100,qe*100]};convert$1.rgb.cmyk=function(Ke){const Re=Ke[0]/255,Fe=Ke[1]/255,qe=Ke[2]/255,We=Math.min(1-Re,1-Fe,1-qe),Ze=(1-Re-We)/(1-We)||0,Xe=(1-Fe-We)/(1-We)||0,Je=(1-qe-We)/(1-We)||0;return[Ze*100,Xe*100,Je*100,We*100]};function comparativeDistance(Ke,Re){return(Ke[0]-Re[0])**2+(Ke[1]-Re[1])**2+(Ke[2]-Re[2])**2}convert$1.rgb.keyword=function(Ke){const Re=reverseKeywords[Ke];if(Re)return Re;let Fe=1/0,qe;for(const We of Object.keys(cssKeywords)){const Ze=cssKeywords[We],Xe=comparativeDistance(Ke,Ze);Xe<Fe&&(Fe=Xe,qe=We)}return qe};convert$1.keyword.rgb=function(Ke){return cssKeywords[Ke]};convert$1.rgb.xyz=function(Ke){let Re=Ke[0]/255,Fe=Ke[1]/255,qe=Ke[2]/255;Re=Re>.04045?((Re+.055)/1.055)**2.4:Re/12.92,Fe=Fe>.04045?((Fe+.055)/1.055)**2.4:Fe/12.92,qe=qe>.04045?((qe+.055)/1.055)**2.4:qe/12.92;const We=Re*.4124+Fe*.3576+qe*.1805,Ze=Re*.2126+Fe*.7152+qe*.0722,Xe=Re*.0193+Fe*.1192+qe*.9505;return[We*100,Ze*100,Xe*100]};convert$1.rgb.lab=function(Ke){const Re=convert$1.rgb.xyz(Ke);let Fe=Re[0],qe=Re[1],We=Re[2];Fe/=95.047,qe/=100,We/=108.883,Fe=Fe>.008856?Fe**(1/3):7.787*Fe+16/116,qe=qe>.008856?qe**(1/3):7.787*qe+16/116,We=We>.008856?We**(1/3):7.787*We+16/116;const Ze=116*qe-16,Xe=500*(Fe-qe),Je=200*(qe-We);return[Ze,Xe,Je]};convert$1.hsl.rgb=function(Ke){const Re=Ke[0]/360,Fe=Ke[1]/100,qe=Ke[2]/100;let We,Ze,Xe;if(Fe===0)return Xe=qe*255,[Xe,Xe,Xe];qe<.5?We=qe*(1+Fe):We=qe+Fe-qe*Fe;const Je=2*qe-We,tr=[0,0,0];for(let er=0;er<3;er++)Ze=Re+1/3*-(er-1),Ze<0&&Ze++,Ze>1&&Ze--,6*Ze<1?Xe=Je+(We-Je)*6*Ze:2*Ze<1?Xe=We:3*Ze<2?Xe=Je+(We-Je)*(2/3-Ze)*6:Xe=Je,tr[er]=Xe*255;return tr};convert$1.hsl.hsv=function(Ke){const Re=Ke[0];let Fe=Ke[1]/100,qe=Ke[2]/100,We=Fe;const Ze=Math.max(qe,.01);qe*=2,Fe*=qe<=1?qe:2-qe,We*=Ze<=1?Ze:2-Ze;const Xe=(qe+Fe)/2,Je=qe===0?2*We/(Ze+We):2*Fe/(qe+Fe);return[Re,Je*100,Xe*100]};convert$1.hsv.rgb=function(Ke){const Re=Ke[0]/60,Fe=Ke[1]/100;let qe=Ke[2]/100;const We=Math.floor(Re)%6,Ze=Re-Math.floor(Re),Xe=255*qe*(1-Fe),Je=255*qe*(1-Fe*Ze),tr=255*qe*(1-Fe*(1-Ze));switch(qe*=255,We){case 0:return[qe,tr,Xe];case 1:return[Je,qe,Xe];case 2:return[Xe,qe,tr];case 3:return[Xe,Je,qe];case 4:return[tr,Xe,qe];case 5:return[qe,Xe,Je]}};convert$1.hsv.hsl=function(Ke){const Re=Ke[0],Fe=Ke[1]/100,qe=Ke[2]/100,We=Math.max(qe,.01);let Ze,Xe;Xe=(2-Fe)*qe;const Je=(2-Fe)*We;return Ze=Fe*We,Ze/=Je<=1?Je:2-Je,Ze=Ze||0,Xe/=2,[Re,Ze*100,Xe*100]};convert$1.hwb.rgb=function(Ke){const Re=Ke[0]/360;let Fe=Ke[1]/100,qe=Ke[2]/100;const We=Fe+qe;let Ze;We>1&&(Fe/=We,qe/=We);const Xe=Math.floor(6*Re),Je=1-qe;Ze=6*Re-Xe,(Xe&1)!==0&&(Ze=1-Ze);const tr=Fe+Ze*(Je-Fe);let er,ir,ur;switch(Xe){default:case 6:case 0:er=Je,ir=tr,ur=Fe;break;case 1:er=tr,ir=Je,ur=Fe;break;case 2:er=Fe,ir=Je,ur=tr;break;case 3:er=Fe,ir=tr,ur=Je;break;case 4:er=tr,ir=Fe,ur=Je;break;case 5:er=Je,ir=Fe,ur=tr;break}return[er*255,ir*255,ur*255]};convert$1.cmyk.rgb=function(Ke){const Re=Ke[0]/100,Fe=Ke[1]/100,qe=Ke[2]/100,We=Ke[3]/100,Ze=1-Math.min(1,Re*(1-We)+We),Xe=1-Math.min(1,Fe*(1-We)+We),Je=1-Math.min(1,qe*(1-We)+We);return[Ze*255,Xe*255,Je*255]};convert$1.xyz.rgb=function(Ke){const Re=Ke[0]/100,Fe=Ke[1]/100,qe=Ke[2]/100;let We,Ze,Xe;return We=Re*3.2406+Fe*-1.5372+qe*-.4986,Ze=Re*-.9689+Fe*1.8758+qe*.0415,Xe=Re*.0557+Fe*-.204+qe*1.057,We=We>.0031308?1.055*We**(1/2.4)-.055:We*12.92,Ze=Ze>.0031308?1.055*Ze**(1/2.4)-.055:Ze*12.92,Xe=Xe>.0031308?1.055*Xe**(1/2.4)-.055:Xe*12.92,We=Math.min(Math.max(0,We),1),Ze=Math.min(Math.max(0,Ze),1),Xe=Math.min(Math.max(0,Xe),1),[We*255,Ze*255,Xe*255]};convert$1.xyz.lab=function(Ke){let Re=Ke[0],Fe=Ke[1],qe=Ke[2];Re/=95.047,Fe/=100,qe/=108.883,Re=Re>.008856?Re**(1/3):7.787*Re+16/116,Fe=Fe>.008856?Fe**(1/3):7.787*Fe+16/116,qe=qe>.008856?qe**(1/3):7.787*qe+16/116;const We=116*Fe-16,Ze=500*(Re-Fe),Xe=200*(Fe-qe);return[We,Ze,Xe]};convert$1.lab.xyz=function(Ke){const Re=Ke[0],Fe=Ke[1],qe=Ke[2];let We,Ze,Xe;Ze=(Re+16)/116,We=Fe/500+Ze,Xe=Ze-qe/200;const Je=Ze**3,tr=We**3,er=Xe**3;return Ze=Je>.008856?Je:(Ze-16/116)/7.787,We=tr>.008856?tr:(We-16/116)/7.787,Xe=er>.008856?er:(Xe-16/116)/7.787,We*=95.047,Ze*=100,Xe*=108.883,[We,Ze,Xe]};convert$1.lab.lch=function(Ke){const Re=Ke[0],Fe=Ke[1],qe=Ke[2];let We;We=Math.atan2(qe,Fe)*360/2/Math.PI,We<0&&(We+=360);const Xe=Math.sqrt(Fe*Fe+qe*qe);return[Re,Xe,We]};convert$1.lch.lab=function(Ke){const Re=Ke[0],Fe=Ke[1],We=Ke[2]/360*2*Math.PI,Ze=Fe*Math.cos(We),Xe=Fe*Math.sin(We);return[Re,Ze,Xe]};convert$1.rgb.ansi16=function(Ke,Re=null){const[Fe,qe,We]=Ke;let Ze=Re===null?convert$1.rgb.hsv(Ke)[2]:Re;if(Ze=Math.round(Ze/50),Ze===0)return 30;let Xe=30+(Math.round(We/255)<<2|Math.round(qe/255)<<1|Math.round(Fe/255));return Ze===2&&(Xe+=60),Xe};convert$1.hsv.ansi16=function(Ke){return convert$1.rgb.ansi16(convert$1.hsv.rgb(Ke),Ke[2])};convert$1.rgb.ansi256=function(Ke){const Re=Ke[0],Fe=Ke[1],qe=Ke[2];return Re===Fe&&Fe===qe?Re<8?16:Re>248?231:Math.round((Re-8)/247*24)+232:16+36*Math.round(Re/255*5)+6*Math.round(Fe/255*5)+Math.round(qe/255*5)};convert$1.ansi16.rgb=function(Ke){let Re=Ke%10;if(Re===0||Re===7)return Ke>50&&(Re+=3.5),Re=Re/10.5*255,[Re,Re,Re];const Fe=(~~(Ke>50)+1)*.5,qe=(Re&1)*Fe*255,We=(Re>>1&1)*Fe*255,Ze=(Re>>2&1)*Fe*255;return[qe,We,Ze]};convert$1.ansi256.rgb=function(Ke){if(Ke>=232){const Ze=(Ke-232)*10+8;return[Ze,Ze,Ze]}Ke-=16;let Re;const Fe=Math.floor(Ke/36)/5*255,qe=Math.floor((Re=Ke%36)/6)/5*255,We=Re%6/5*255;return[Fe,qe,We]};convert$1.rgb.hex=function(Ke){const Fe=(((Math.round(Ke[0])&255)<<16)+((Math.round(Ke[1])&255)<<8)+(Math.round(Ke[2])&255)).toString(16).toUpperCase();return"000000".substring(Fe.length)+Fe};convert$1.hex.rgb=function(Ke){const Re=Ke.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);if(!Re)return[0,0,0];let Fe=Re[0];Re[0].length===3&&(Fe=Fe.split("").map(Je=>Je+Je).join(""));const qe=parseInt(Fe,16),We=qe>>16&255,Ze=qe>>8&255,Xe=qe&255;return[We,Ze,Xe]};convert$1.rgb.hcg=function(Ke){const Re=Ke[0]/255,Fe=Ke[1]/255,qe=Ke[2]/255,We=Math.max(Math.max(Re,Fe),qe),Ze=Math.min(Math.min(Re,Fe),qe),Xe=We-Ze;let Je,tr;return Xe<1?Je=Ze/(1-Xe):Je=0,Xe<=0?tr=0:We===Re?tr=(Fe-qe)/Xe%6:We===Fe?tr=2+(qe-Re)/Xe:tr=4+(Re-Fe)/Xe,tr/=6,tr%=1,[tr*360,Xe*100,Je*100]};convert$1.hsl.hcg=function(Ke){const Re=Ke[1]/100,Fe=Ke[2]/100,qe=Fe<.5?2*Re*Fe:2*Re*(1-Fe);let We=0;return qe<1&&(We=(Fe-.5*qe)/(1-qe)),[Ke[0],qe*100,We*100]};convert$1.hsv.hcg=function(Ke){const Re=Ke[1]/100,Fe=Ke[2]/100,qe=Re*Fe;let We=0;return qe<1&&(We=(Fe-qe)/(1-qe)),[Ke[0],qe*100,We*100]};convert$1.hcg.rgb=function(Ke){const Re=Ke[0]/360,Fe=Ke[1]/100,qe=Ke[2]/100;if(Fe===0)return[qe*255,qe*255,qe*255];const We=[0,0,0],Ze=Re%1*6,Xe=Ze%1,Je=1-Xe;let tr=0;switch(Math.floor(Ze)){case 0:We[0]=1,We[1]=Xe,We[2]=0;break;case 1:We[0]=Je,We[1]=1,We[2]=0;break;case 2:We[0]=0,We[1]=1,We[2]=Xe;break;case 3:We[0]=0,We[1]=Je,We[2]=1;break;case 4:We[0]=Xe,We[1]=0,We[2]=1;break;default:We[0]=1,We[1]=0,We[2]=Je}return tr=(1-Fe)*qe,[(Fe*We[0]+tr)*255,(Fe*We[1]+tr)*255,(Fe*We[2]+tr)*255]};convert$1.hcg.hsv=function(Ke){const Re=Ke[1]/100,Fe=Ke[2]/100,qe=Re+Fe*(1-Re);let We=0;return qe>0&&(We=Re/qe),[Ke[0],We*100,qe*100]};convert$1.hcg.hsl=function(Ke){const Re=Ke[1]/100,qe=Ke[2]/100*(1-Re)+.5*Re;let We=0;return qe>0&&qe<.5?We=Re/(2*qe):qe>=.5&&qe<1&&(We=Re/(2*(1-qe))),[Ke[0],We*100,qe*100]};convert$1.hcg.hwb=function(Ke){const Re=Ke[1]/100,Fe=Ke[2]/100,qe=Re+Fe*(1-Re);return[Ke[0],(qe-Re)*100,(1-qe)*100]};convert$1.hwb.hcg=function(Ke){const Re=Ke[1]/100,qe=1-Ke[2]/100,We=qe-Re;let Ze=0;return We<1&&(Ze=(qe-We)/(1-We)),[Ke[0],We*100,Ze*100]};convert$1.apple.rgb=function(Ke){return[Ke[0]/65535*255,Ke[1]/65535*255,Ke[2]/65535*255]};convert$1.rgb.apple=function(Ke){return[Ke[0]/255*65535,Ke[1]/255*65535,Ke[2]/255*65535]};convert$1.gray.rgb=function(Ke){return[Ke[0]/100*255,Ke[0]/100*255,Ke[0]/100*255]};convert$1.gray.hsl=function(Ke){return[0,0,Ke[0]]};convert$1.gray.hsv=convert$1.gray.hsl;convert$1.gray.hwb=function(Ke){return[0,100,Ke[0]]};convert$1.gray.cmyk=function(Ke){return[0,0,0,Ke[0]]};convert$1.gray.lab=function(Ke){return[Ke[0],0,0]};convert$1.gray.hex=function(Ke){const Re=Math.round(Ke[0]/100*255)&255,qe=((Re<<16)+(Re<<8)+Re).toString(16).toUpperCase();return"000000".substring(qe.length)+qe};convert$1.rgb.gray=function(Ke){return[(Ke[0]+Ke[1]+Ke[2])/3/255*100]};const conversions$1=conversions$2;function buildGraph(){const Ke={},Re=Object.keys(conversions$1);for(let Fe=Re.length,qe=0;qe<Fe;qe++)Ke[Re[qe]]={distance:-1,parent:null};return Ke}function deriveBFS(Ke){const Re=buildGraph(),Fe=[Ke];for(Re[Ke].distance=0;Fe.length;){const qe=Fe.pop(),We=Object.keys(conversions$1[qe]);for(let Ze=We.length,Xe=0;Xe<Ze;Xe++){const Je=We[Xe],tr=Re[Je];tr.distance===-1&&(tr.distance=Re[qe].distance+1,tr.parent=qe,Fe.unshift(Je))}}return Re}function link(Ke,Re){return function(Fe){return Re(Ke(Fe))}}function wrapConversion(Ke,Re){const Fe=[Re[Ke].parent,Ke];let qe=conversions$1[Re[Ke].parent][Ke],We=Re[Ke].parent;for(;Re[We].parent;)Fe.unshift(Re[We].parent),qe=link(conversions$1[Re[We].parent][We],qe),We=Re[We].parent;return qe.conversion=Fe,qe}var route$1=function(Ke){const Re=deriveBFS(Ke),Fe={},qe=Object.keys(Re);for(let We=qe.length,Ze=0;Ze<We;Ze++){const Xe=qe[Ze];Re[Xe].parent!==null&&(Fe[Xe]=wrapConversion(Xe,Re))}return Fe};const conversions=conversions$2,route=route$1,convert={},models=Object.keys(conversions);function wrapRaw(Ke){const Re=function(...Fe){const qe=Fe[0];return qe==null?qe:(qe.length>1&&(Fe=qe),Ke(Fe))};return"conversion"in Ke&&(Re.conversion=Ke.conversion),Re}function wrapRounded(Ke){const Re=function(...Fe){const qe=Fe[0];if(qe==null)return qe;qe.length>1&&(Fe=qe);const We=Ke(Fe);if(typeof We=="object")for(let Ze=We.length,Xe=0;Xe<Ze;Xe++)We[Xe]=Math.round(We[Xe]);return We};return"conversion"in Ke&&(Re.conversion=Ke.conversion),Re}models.forEach(Ke=>{convert[Ke]={},Object.defineProperty(convert[Ke],"channels",{value:conversions[Ke].channels}),Object.defineProperty(convert[Ke],"labels",{value:conversions[Ke].labels});const Re=route(Ke);Object.keys(Re).forEach(qe=>{const We=Re[qe];convert[Ke][qe]=wrapRounded(We),convert[Ke][qe].raw=wrapRaw(We)})});var colorConvert=convert;function getRandomColor({canBeBlank:Ke=!0,dominantColor:Re=null}){if(Ke&&Math.random()<.3)return"#FFFFFFAA";let Fe;if(Re){const qe=Math.random()*60-30;Fe=Math.floor(Re+qe),Fe=Math.max(Math.min(Fe,256),0)}else Fe=Math.floor(Math.random()*256);return"#"+colorConvert.hsl.hex(Fe,100,80)}function generateAvatar({blocks:Ke=6,width:Re=100,fromPixels:Fe}){const qe=Re/Ke,We=Math.random()*256,Ze=Math.random()*256;let Xe;Fe?Xe=Fe:Xe=new Array(Ke*Ke/2).fill(null).map((yr,mr)=>getRandomColor(Ke===4?{canBeBlank:![4,5,6].includes(mr),dominantColor:Math.random()>.9?We:Ze}:Ke===6?{canBeBlank:![13,14].includes(mr),dominantColor:Math.random()>.9?We:Ze}:{}));let Je="",tr=0;for(let yr=0;yr<Ke/2;yr++)for(let mr=0;mr<Ke;mr++)Je+=`
        <rect 
          fill="${Xe[tr]}" 
          x="${qe*yr}" 
          y="${qe*mr}" 
          width="${qe}" 
          height="${qe}"
        ></rect>
      `,tr++;tr=0;for(let yr=Ke-1;yr>Ke/2-1;yr--)for(let mr=0;mr<Ke;mr++)Je+=`
        <rect 
          fill="${Xe[tr]}" 
          x="${qe*yr}" 
          y="${qe*mr}" 
          width="${qe}" 
          height="${qe}"
        ></rect>
      `,tr++;const er=`
    <svg 
      xmlns="http://www.w3.org/2000/svg" 
      width="${Re}" 
      height="${Re}" 
      version="1.1"
    >
      <rect 
        fill="#cccccc" 
        x="0" 
        y="0" 
        width="${Re}" 
        height="${Re}"
      ></rect>
      
      ${Je}
    </svg>
  `;let ir;typeof window>"u"?ir=Buffer.from(er).toString("base64"):ir=btoa(er);const ur={base64:`data:image/svg+xml;base64,${ir}`,pixels:Xe};if(typeof DOMParser<"u"){var fr=new DOMParser,ar=fr.parseFromString(er,"image/svg+xml");ur.svgElement=ar.firstChild}return ur}function createAvatarGenerator(){let Ke={};return Re=>{const Fe=Ke[Re],qe=generateAvatar({blocks:6,width:50,fromPixels:Fe});return Fe||(Ke={[Re]:qe.pixels,...Ke}),qe}}const avatarGenerator=createAvatarGenerator();function Likes({value:Ke=0,onChange:Re=()=>null}){const[Fe,qe]=p(!1),[We,Ze]=p(!1),[Xe,Je]=p(Ke),tr=T$2(async()=>{Ze(!0),await Re(!0),qe(!0),Je(er=>er+1),Ze(!1)},[Re]);return Fe?o("div",{className:"text-red-500 flex items-center cursor-not-allowed",children:[o("svg",{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 24 24",fill:"currentColor",className:"w-5 h-5",children:o("path",{d:"M11.645 20.91l-.007-.003-.022-.012a15.247 15.247 0 01-.383-.218 25.18 25.18 0 01-4.244-3.17C4.688 15.36 2.25 12.174 2.25 8.25 2.25 5.322 4.714 3 7.688 3A5.5 5.5 0 0112 5.052 5.5 5.5 0 0116.313 3c2.973 0 5.437 2.322 5.437 5.25 0 3.925-2.438 7.111-4.739 9.256a25.175 25.175 0 01-4.244 3.17 15.247 15.247 0 01-.383.219l-.022.012-.007.004-.003.001a.752.752 0 01-.704 0l-.003-.001z"})}),o("span",{className:"px-1",children:Xe})]}):o("button",{disabled:We,className:cl("text-red-500 flex items-center",{"animate-pulse cursor-not-allowed":We}),onClick:tr,children:[o("svg",{xmlns:"http://www.w3.org/2000/svg",fill:"none",viewBox:"0 0 24 24",strokeWidth:2,stroke:"currentColor",className:"w-5 h-5",children:o("path",{strokeLinecap:"round",strokeLinejoin:"round",d:"M21 8.25c0-2.485-2.099-4.5-4.688-4.5-1.935 0-3.597 1.126-4.312 2.733-.715-1.607-2.377-2.733-4.313-2.733C5.1 3.75 3 5.765 3 8.25c0 7.22 9 12 9 12s9-4.78 9-12z"})}),o("span",{className:"px-1",children:Ke})]})}function ImagePreview({item:Ke}){const Re=F$2(()=>Ke.userAddress.toString(),[Ke]),Fe=F$2(()=>Ke.votes.length,[Ke]),qe=T$2(async()=>voteGif(Ke.gifLink),[Ke]),We=F$2(()=>avatarGenerator(Re),[Re]);return o("div",{className:"h-full border-2 border-black rounded-xl p-2 py-0 flex flex-col z-10 bg-white shadow-[6px_6px_0_0_#000]",children:[o("div",{className:"py-2 px-1 flex justify-between items-center",children:[o("img",{className:"h-8 w-8 rounded-full border border-purple-800",src:We.base64}),o("div",{className:"truncate pl-8",children:o("span",{children:Re})})]}),o("img",{className:"w-full h-full max-h-64 rounded-xl border border-stone-200",src:Ke.gifLink}),o("div",{className:"py-2 px-1 flex justify-between items-center space-x-2",children:[o(Likes,{value:Fe,onChange:qe}),o("button",{className:"text-green-600 flex justify-between items-center",children:o("span",{className:"text-xs",children:"Donate"})})]})]})}const base="_base_ezksi_1",styles_module={base},usePhantomWallet=()=>{const[Ke,Re]=p(null),Fe=T$2(async()=>{const qe=await connectWallet();Re(qe.publicKey.toString())},[]);return[Ke,Fe]};function App(){const[Ke,Re]=p([]),[Fe,qe]=p(!1),[We,Ze]=p(!1),[Xe,Je]=usePhantomWallet(),tr=F$2(()=>(Ke==null?void 0:Ke.length)>0&&Xe,[Xe,Ke]),er=T$2(async()=>{try{qe(!0);const mr=await getGifList();if(!mr)return;const wr=mr==null?void 0:mr.filter(Sr=>Sr.gifLink);Re(wr),Ze(!0)}catch(mr){console.log("error",mr)}finally{qe(!1)}},[]),ir=T$2(async()=>{try{qe(!0),await createGifAccount()}finally{qe(!1)}await er()},[er]);h(()=>{Xe&&async function(){await er()}()},[Xe,er]);const ur=T$2(async()=>{try{qe(!0),await Je()}finally{qe(!1)}},[Je]),fr=T$2(async mr=>{if(!checkIsImage(mr))return toast.error("The link doesn't seem to work",{icon:o("span",{className:"text-xl",children:"\u{1F914}"})});try{qe(!0),await sendGif(mr),await er()}catch(wr){console.log("error",wr)}finally{qe(!1)}},[er]),ar=T$2(async(mr,{reset:wr})=>{await fr(mr.gifLink),wr()},[fr]),yr=T$2(()=>Xe?!We&&!Fe?o("button",{onClick:ir,className:" m-auto flex items-center justify-center rounded-xl border-2 border-black px-6 py-2 font-bold shadow-[6px_6px_0_0_#000] transition hover:shadow-none focus:outline-none focus:ring ring-purple-500/50 active:bg-purple-200/50 max-w-xs",children:"Create account"}):o("div",{className:cl("w-full max-w-2xl m-auto"),children:o(GifLinkForm,{onSubmit:ar})}):o("button",{onClick:ur,className:" m-auto text-lg flex items-center justify-center rounded-xl border-2 border-black px-12 py-4 font-bold shadow-[6px_6px_0_0_#000] transition hover:shadow-none focus:outline-none focus:ring ring-purple-500/50 active:bg-purple-200/50 max-w-xs",children:["Connect Wallet",o("span",{"aria-hidden":"true",className:"ml-1.5",role:"img",children:"\u{1F517}"})]}),[Xe,Fe,ir,We,ar,ur]);return o(p$1,{children:[o("div",{className:"min-h-screen p-4 md:p-12 flex flex-col",children:[Fe&&o("div",{className:"fixed top-3 left-6 opacity-85 animate-in rounded-full fade-in shadow-xl flex justify-center items-center bg-white",children:o("svg",{className:"animate-spin -ml-1 h-8 w-8 text-purple-900",xmlns:"http://www.w3.org/2000/svg",fill:"none",viewBox:"0 0 24 24",children:[o("circle",{className:"opacity-25",cx:"12",cy:"12",r:"10",stroke:"currentColor",strokeWidth:"4"}),o("path",{className:"opacity-75",fill:"currentColor",d:"M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"})]})}),o("section",{className:cl("text-black flex justify-center transition-transform duration-700",{"translate-y-20":!We}),children:o("div",{className:"w-full max-w-screen-xl py-32 lg:flex lg:items-center flex justify-center",children:o("div",{className:"max-w-3xl text-center flex flex-col justify-center items-center space-y-12 w-full",children:[o("div",{className:"flex flex-col justify-center items-center space-y-3",children:[o("h1",{className:"text-4xl sm:text-5xl font-extrabold text-center",children:o("span",{className:"text-center text-transparent bg-clip-text bg-gradient-to-r from-green-500 via-black  to-purple-600",children:"Solana Gif Portal"})}),o("p",{className:"max-w-xl sm:text-xl sm:leading-relaxed",children:["View your GIF collection in"," ",o("span",{className:"text-transparent bg-clip-text bg-gradient-to-r from-black  to-purple-800",children:"the metaverse"})," ","\u2728"]})]}),o("div",{className:cl("w-full",{"opacity-50 animate-pulse cursor-not-allowed":Fe}),children:yr()})]})})}),tr&&o("section",{className:"",children:o("div",{children:o("div",{className:"grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-6",children:Ke.reverse().map((mr,wr)=>o("div",{children:o(ImagePreview,{item:mr})},wr))})})}),o("div",{className:"absolute top-3 right-6 space-x-5",children:[o("a",{href:"https://github.com/maksim-romanov/solana-gif-portal",target:"_blank",className:"inline-block text-sm cursor-pointer text-transparent bg-clip-text bg-gradient-to-r from-green-500 to-purple-600 grayscale hover:grayscale-0 font-bold opacity-30 hover:opacity-100",rel:"noreferrer",children:"Github"}),o("a",{href:"https://t.me/romanovmaksim",target:"_blank",className:"inline-block text-sm cursor-pointer text-transparent bg-clip-text bg-gradient-to-r from-green-500 to-blue-400 grayscale hover:grayscale-0 font-bold opacity-30 hover:opacity-100",rel:"noreferrer",children:"Telegram"}),o("a",{href:"https://explorer.solana.com/address/DByFcag9yDLwRGnBCT8bJpJPM7akth4dpHXosf7eaB7s?cluster=devnet",target:"_blank",className:"inline-block text-sm cursor-pointer text-transparent bg-clip-text bg-gradient-to-r from-green-800 to-green-500 font-bold opacity-60 hover:opacity-100",rel:"noreferrer",children:"SOL Explorer"})]})]}),o(ToastContainer,{position:"top-center",closeButton:()=>null,autoClose:2e3,hideProgressBar:!0,closeOnClick:!0,theme:"light"})]})}P$2(o(App,{}),document.getElementById("app"));
