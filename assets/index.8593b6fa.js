(function(){const Re=document.createElement("link").relList;if(Re&&Re.supports&&Re.supports("modulepreload"))return;for(const qe of document.querySelectorAll('link[rel="modulepreload"]'))We(qe);new MutationObserver(qe=>{for(const Ze of qe)if(Ze.type==="childList")for(const Xe of Ze.addedNodes)Xe.tagName==="LINK"&&Xe.rel==="modulepreload"&&We(Xe)}).observe(document,{childList:!0,subtree:!0});function Fe(qe){const Ze={};return qe.integrity&&(Ze.integrity=qe.integrity),qe.referrerpolicy&&(Ze.referrerPolicy=qe.referrerpolicy),qe.crossorigin==="use-credentials"?Ze.credentials="include":qe.crossorigin==="anonymous"?Ze.credentials="omit":Ze.credentials="same-origin",Ze}function We(qe){if(qe.ep)return;qe.ep=!0;const Ze=Fe(qe);fetch(qe.href,Ze)}})();var commonjsGlobal=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{};function getAugmentedNamespace(Ke){var Re=Ke.default;if(typeof Re=="function"){var Fe=function(){return Re.apply(this,arguments)};Fe.prototype=Re.prototype}else Fe={};return Object.defineProperty(Fe,"__esModule",{value:!0}),Object.keys(Ke).forEach(function(We){var qe=Object.getOwnPropertyDescriptor(Ke,We);Object.defineProperty(Fe,We,qe.get?qe:{enumerable:!0,get:function(){return Ke[We]}})}),Fe}var buffer$1={},base64Js={};base64Js.byteLength=byteLength;var toByteArray_1=base64Js.toByteArray=toByteArray,fromByteArray_1=base64Js.fromByteArray=fromByteArray,lookup=[],revLookup=[],Arr=typeof Uint8Array<"u"?Uint8Array:Array,code="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";for(var i$2=0,len=code.length;i$2<len;++i$2)lookup[i$2]=code[i$2],revLookup[code.charCodeAt(i$2)]=i$2;revLookup["-".charCodeAt(0)]=62;revLookup["_".charCodeAt(0)]=63;function getLens(Ke){var Re=Ke.length;if(Re%4>0)throw new Error("Invalid string. Length must be a multiple of 4");var Fe=Ke.indexOf("=");Fe===-1&&(Fe=Re);var We=Fe===Re?0:4-Fe%4;return[Fe,We]}function byteLength(Ke){var Re=getLens(Ke),Fe=Re[0],We=Re[1];return(Fe+We)*3/4-We}function _byteLength(Ke,Re,Fe){return(Re+Fe)*3/4-Fe}function toByteArray(Ke){var Re,Fe=getLens(Ke),We=Fe[0],qe=Fe[1],Ze=new Arr(_byteLength(Ke,We,qe)),Xe=0,Je=qe>0?We-4:We,tr;for(tr=0;tr<Je;tr+=4)Re=revLookup[Ke.charCodeAt(tr)]<<18|revLookup[Ke.charCodeAt(tr+1)]<<12|revLookup[Ke.charCodeAt(tr+2)]<<6|revLookup[Ke.charCodeAt(tr+3)],Ze[Xe++]=Re>>16&255,Ze[Xe++]=Re>>8&255,Ze[Xe++]=Re&255;return qe===2&&(Re=revLookup[Ke.charCodeAt(tr)]<<2|revLookup[Ke.charCodeAt(tr+1)]>>4,Ze[Xe++]=Re&255),qe===1&&(Re=revLookup[Ke.charCodeAt(tr)]<<10|revLookup[Ke.charCodeAt(tr+1)]<<4|revLookup[Ke.charCodeAt(tr+2)]>>2,Ze[Xe++]=Re>>8&255,Ze[Xe++]=Re&255),Ze}function tripletToBase64(Ke){return lookup[Ke>>18&63]+lookup[Ke>>12&63]+lookup[Ke>>6&63]+lookup[Ke&63]}function encodeChunk(Ke,Re,Fe){for(var We,qe=[],Ze=Re;Ze<Fe;Ze+=3)We=(Ke[Ze]<<16&16711680)+(Ke[Ze+1]<<8&65280)+(Ke[Ze+2]&255),qe.push(tripletToBase64(We));return qe.join("")}function fromByteArray(Ke){for(var Re,Fe=Ke.length,We=Fe%3,qe=[],Ze=16383,Xe=0,Je=Fe-We;Xe<Je;Xe+=Ze)qe.push(encodeChunk(Ke,Xe,Xe+Ze>Je?Je:Xe+Ze));return We===1?(Re=Ke[Fe-1],qe.push(lookup[Re>>2]+lookup[Re<<4&63]+"==")):We===2&&(Re=(Ke[Fe-2]<<8)+Ke[Fe-1],qe.push(lookup[Re>>10]+lookup[Re>>4&63]+lookup[Re<<2&63]+"=")),qe.join("")}var ieee754={};/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */ieee754.read=function(Ke,Re,Fe,We,qe){var Ze,Xe,Je=qe*8-We-1,tr=(1<<Je)-1,er=tr>>1,ir=-7,lr=Fe?qe-1:0,fr=Fe?-1:1,ur=Ke[Re+lr];for(lr+=fr,Ze=ur&(1<<-ir)-1,ur>>=-ir,ir+=Je;ir>0;Ze=Ze*256+Ke[Re+lr],lr+=fr,ir-=8);for(Xe=Ze&(1<<-ir)-1,Ze>>=-ir,ir+=We;ir>0;Xe=Xe*256+Ke[Re+lr],lr+=fr,ir-=8);if(Ze===0)Ze=1-er;else{if(Ze===tr)return Xe?NaN:(ur?-1:1)*(1/0);Xe=Xe+Math.pow(2,We),Ze=Ze-er}return(ur?-1:1)*Xe*Math.pow(2,Ze-We)};ieee754.write=function(Ke,Re,Fe,We,qe,Ze){var Xe,Je,tr,er=Ze*8-qe-1,ir=(1<<er)-1,lr=ir>>1,fr=qe===23?Math.pow(2,-24)-Math.pow(2,-77):0,ur=We?0:Ze-1,mr=We?1:-1,br=Re<0||Re===0&&1/Re<0?1:0;for(Re=Math.abs(Re),isNaN(Re)||Re===1/0?(Je=isNaN(Re)?1:0,Xe=ir):(Xe=Math.floor(Math.log(Re)/Math.LN2),Re*(tr=Math.pow(2,-Xe))<1&&(Xe--,tr*=2),Xe+lr>=1?Re+=fr/tr:Re+=fr*Math.pow(2,1-lr),Re*tr>=2&&(Xe++,tr/=2),Xe+lr>=ir?(Je=0,Xe=ir):Xe+lr>=1?(Je=(Re*tr-1)*Math.pow(2,qe),Xe=Xe+lr):(Je=Re*Math.pow(2,lr-1)*Math.pow(2,qe),Xe=0));qe>=8;Ke[Fe+ur]=Je&255,ur+=mr,Je/=256,qe-=8);for(Xe=Xe<<qe|Je,er+=qe;er>0;Ke[Fe+ur]=Xe&255,ur+=mr,Xe/=256,er-=8);Ke[Fe+ur-mr]|=br*128};/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */(function(Ke){const Re=base64Js,Fe=ieee754,We=typeof Symbol=="function"&&typeof Symbol.for=="function"?Symbol.for("nodejs.util.inspect.custom"):null;Ke.Buffer=Je,Ke.SlowBuffer=kr,Ke.INSPECT_MAX_BYTES=50;const qe=2147483647;Ke.kMaxLength=qe,Je.TYPED_ARRAY_SUPPORT=Ze(),!Je.TYPED_ARRAY_SUPPORT&&typeof console<"u"&&typeof console.error=="function"&&console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");function Ze(){try{const nr=new Uint8Array(1),Qe={foo:function(){return 42}};return Object.setPrototypeOf(Qe,Uint8Array.prototype),Object.setPrototypeOf(nr,Qe),nr.foo()===42}catch{return!1}}Object.defineProperty(Je.prototype,"parent",{enumerable:!0,get:function(){if(!!Je.isBuffer(this))return this.buffer}}),Object.defineProperty(Je.prototype,"offset",{enumerable:!0,get:function(){if(!!Je.isBuffer(this))return this.byteOffset}});function Xe(nr){if(nr>qe)throw new RangeError('The value "'+nr+'" is invalid for option "size"');const Qe=new Uint8Array(nr);return Object.setPrototypeOf(Qe,Je.prototype),Qe}function Je(nr,Qe,dt){if(typeof nr=="number"){if(typeof Qe=="string")throw new TypeError('The "string" argument must be of type string. Received type number');return lr(nr)}return tr(nr,Qe,dt)}Je.poolSize=8192;function tr(nr,Qe,dt){if(typeof nr=="string")return fr(nr,Qe);if(ArrayBuffer.isView(nr))return mr(nr);if(nr==null)throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof nr);if(Cn(nr,ArrayBuffer)||nr&&Cn(nr.buffer,ArrayBuffer)||typeof SharedArrayBuffer<"u"&&(Cn(nr,SharedArrayBuffer)||nr&&Cn(nr.buffer,SharedArrayBuffer)))return br(nr,Qe,dt);if(typeof nr=="number")throw new TypeError('The "value" argument must not be of type number. Received type number');const or=nr.valueOf&&nr.valueOf();if(or!=null&&or!==nr)return Je.from(or,Qe,dt);const dr=wr(nr);if(dr)return dr;if(typeof Symbol<"u"&&Symbol.toPrimitive!=null&&typeof nr[Symbol.toPrimitive]=="function")return Je.from(nr[Symbol.toPrimitive]("string"),Qe,dt);throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof nr)}Je.from=function(nr,Qe,dt){return tr(nr,Qe,dt)},Object.setPrototypeOf(Je.prototype,Uint8Array.prototype),Object.setPrototypeOf(Je,Uint8Array);function er(nr){if(typeof nr!="number")throw new TypeError('"size" argument must be of type number');if(nr<0)throw new RangeError('The value "'+nr+'" is invalid for option "size"')}function ir(nr,Qe,dt){return er(nr),nr<=0?Xe(nr):Qe!==void 0?typeof dt=="string"?Xe(nr).fill(Qe,dt):Xe(nr).fill(Qe):Xe(nr)}Je.alloc=function(nr,Qe,dt){return ir(nr,Qe,dt)};function lr(nr){return er(nr),Xe(nr<0?0:Sr(nr)|0)}Je.allocUnsafe=function(nr){return lr(nr)},Je.allocUnsafeSlow=function(nr){return lr(nr)};function fr(nr,Qe){if((typeof Qe!="string"||Qe==="")&&(Qe="utf8"),!Je.isEncoding(Qe))throw new TypeError("Unknown encoding: "+Qe);const dt=Er(nr,Qe)|0;let or=Xe(dt);const dr=or.write(nr,Qe);return dr!==dt&&(or=or.slice(0,dr)),or}function ur(nr){const Qe=nr.length<0?0:Sr(nr.length)|0,dt=Xe(Qe);for(let or=0;or<Qe;or+=1)dt[or]=nr[or]&255;return dt}function mr(nr){if(Cn(nr,Uint8Array)){const Qe=new Uint8Array(nr);return br(Qe.buffer,Qe.byteOffset,Qe.byteLength)}return ur(nr)}function br(nr,Qe,dt){if(Qe<0||nr.byteLength<Qe)throw new RangeError('"offset" is outside of buffer bounds');if(nr.byteLength<Qe+(dt||0))throw new RangeError('"length" is outside of buffer bounds');let or;return Qe===void 0&&dt===void 0?or=new Uint8Array(nr):dt===void 0?or=new Uint8Array(nr,Qe):or=new Uint8Array(nr,Qe,dt),Object.setPrototypeOf(or,Je.prototype),or}function wr(nr){if(Je.isBuffer(nr)){const Qe=Sr(nr.length)|0,dt=Xe(Qe);return dt.length===0||nr.copy(dt,0,0,Qe),dt}if(nr.length!==void 0)return typeof nr.length!="number"||Fn(nr.length)?Xe(0):ur(nr);if(nr.type==="Buffer"&&Array.isArray(nr.data))return ur(nr.data)}function Sr(nr){if(nr>=qe)throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x"+qe.toString(16)+" bytes");return nr|0}function kr(nr){return+nr!=nr&&(nr=0),Je.alloc(+nr)}Je.isBuffer=function(Qe){return Qe!=null&&Qe._isBuffer===!0&&Qe!==Je.prototype},Je.compare=function(Qe,dt){if(Cn(Qe,Uint8Array)&&(Qe=Je.from(Qe,Qe.offset,Qe.byteLength)),Cn(dt,Uint8Array)&&(dt=Je.from(dt,dt.offset,dt.byteLength)),!Je.isBuffer(Qe)||!Je.isBuffer(dt))throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');if(Qe===dt)return 0;let or=Qe.length,dr=dt.length;for(let gr=0,vr=Math.min(or,dr);gr<vr;++gr)if(Qe[gr]!==dt[gr]){or=Qe[gr],dr=dt[gr];break}return or<dr?-1:dr<or?1:0},Je.isEncoding=function(Qe){switch(String(Qe).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"latin1":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return!0;default:return!1}},Je.concat=function(Qe,dt){if(!Array.isArray(Qe))throw new TypeError('"list" argument must be an Array of Buffers');if(Qe.length===0)return Je.alloc(0);let or;if(dt===void 0)for(dt=0,or=0;or<Qe.length;++or)dt+=Qe[or].length;const dr=Je.allocUnsafe(dt);let gr=0;for(or=0;or<Qe.length;++or){let vr=Qe[or];if(Cn(vr,Uint8Array))gr+vr.length>dr.length?(Je.isBuffer(vr)||(vr=Je.from(vr)),vr.copy(dr,gr)):Uint8Array.prototype.set.call(dr,vr,gr);else if(Je.isBuffer(vr))vr.copy(dr,gr);else throw new TypeError('"list" argument must be an Array of Buffers');gr+=vr.length}return dr};function Er(nr,Qe){if(Je.isBuffer(nr))return nr.length;if(ArrayBuffer.isView(nr)||Cn(nr,ArrayBuffer))return nr.byteLength;if(typeof nr!="string")throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type '+typeof nr);const dt=nr.length,or=arguments.length>2&&arguments[2]===!0;if(!or&&dt===0)return 0;let dr=!1;for(;;)switch(Qe){case"ascii":case"latin1":case"binary":return dt;case"utf8":case"utf-8":return Qr(nr).length;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return dt*2;case"hex":return dt>>>1;case"base64":return $n(nr).length;default:if(dr)return or?-1:Qr(nr).length;Qe=(""+Qe).toLowerCase(),dr=!0}}Je.byteLength=Er;function Ir(nr,Qe,dt){let or=!1;if((Qe===void 0||Qe<0)&&(Qe=0),Qe>this.length||((dt===void 0||dt>this.length)&&(dt=this.length),dt<=0)||(dt>>>=0,Qe>>>=0,dt<=Qe))return"";for(nr||(nr="utf8");;)switch(nr){case"hex":return xr(this,Qe,dt);case"utf8":case"utf-8":return Dt(this,Qe,dt);case"ascii":return yr(this,Qe,dt);case"latin1":case"binary":return _r(this,Qe,dt);case"base64":return ar(this,Qe,dt);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return Ar(this,Qe,dt);default:if(or)throw new TypeError("Unknown encoding: "+nr);nr=(nr+"").toLowerCase(),or=!0}}Je.prototype._isBuffer=!0;function Rr(nr,Qe,dt){const or=nr[Qe];nr[Qe]=nr[dt],nr[dt]=or}Je.prototype.swap16=function(){const Qe=this.length;if(Qe%2!==0)throw new RangeError("Buffer size must be a multiple of 16-bits");for(let dt=0;dt<Qe;dt+=2)Rr(this,dt,dt+1);return this},Je.prototype.swap32=function(){const Qe=this.length;if(Qe%4!==0)throw new RangeError("Buffer size must be a multiple of 32-bits");for(let dt=0;dt<Qe;dt+=4)Rr(this,dt,dt+3),Rr(this,dt+1,dt+2);return this},Je.prototype.swap64=function(){const Qe=this.length;if(Qe%8!==0)throw new RangeError("Buffer size must be a multiple of 64-bits");for(let dt=0;dt<Qe;dt+=8)Rr(this,dt,dt+7),Rr(this,dt+1,dt+6),Rr(this,dt+2,dt+5),Rr(this,dt+3,dt+4);return this},Je.prototype.toString=function(){const Qe=this.length;return Qe===0?"":arguments.length===0?Dt(this,0,Qe):Ir.apply(this,arguments)},Je.prototype.toLocaleString=Je.prototype.toString,Je.prototype.equals=function(Qe){if(!Je.isBuffer(Qe))throw new TypeError("Argument must be a Buffer");return this===Qe?!0:Je.compare(this,Qe)===0},Je.prototype.inspect=function(){let Qe="";const dt=Ke.INSPECT_MAX_BYTES;return Qe=this.toString("hex",0,dt).replace(/(.{2})/g,"$1 ").trim(),this.length>dt&&(Qe+=" ... "),"<Buffer "+Qe+">"},We&&(Je.prototype[We]=Je.prototype.inspect),Je.prototype.compare=function(Qe,dt,or,dr,gr){if(Cn(Qe,Uint8Array)&&(Qe=Je.from(Qe,Qe.offset,Qe.byteLength)),!Je.isBuffer(Qe))throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type '+typeof Qe);if(dt===void 0&&(dt=0),or===void 0&&(or=Qe?Qe.length:0),dr===void 0&&(dr=0),gr===void 0&&(gr=this.length),dt<0||or>Qe.length||dr<0||gr>this.length)throw new RangeError("out of range index");if(dr>=gr&&dt>=or)return 0;if(dr>=gr)return-1;if(dt>=or)return 1;if(dt>>>=0,or>>>=0,dr>>>=0,gr>>>=0,this===Qe)return 0;let vr=gr-dr,Dr=or-dt;const Vr=Math.min(vr,Dr),Kr=this.slice(dr,gr),jr=Qe.slice(dt,or);for(let Hr=0;Hr<Vr;++Hr)if(Kr[Hr]!==jr[Hr]){vr=Kr[Hr],Dr=jr[Hr];break}return vr<Dr?-1:Dr<vr?1:0};function Pr(nr,Qe,dt,or,dr){if(nr.length===0)return-1;if(typeof dt=="string"?(or=dt,dt=0):dt>2147483647?dt=2147483647:dt<-2147483648&&(dt=-2147483648),dt=+dt,Fn(dt)&&(dt=dr?0:nr.length-1),dt<0&&(dt=nr.length+dt),dt>=nr.length){if(dr)return-1;dt=nr.length-1}else if(dt<0)if(dr)dt=0;else return-1;if(typeof Qe=="string"&&(Qe=Je.from(Qe,or)),Je.isBuffer(Qe))return Qe.length===0?-1:Br(nr,Qe,dt,or,dr);if(typeof Qe=="number")return Qe=Qe&255,typeof Uint8Array.prototype.indexOf=="function"?dr?Uint8Array.prototype.indexOf.call(nr,Qe,dt):Uint8Array.prototype.lastIndexOf.call(nr,Qe,dt):Br(nr,[Qe],dt,or,dr);throw new TypeError("val must be string, number or Buffer")}function Br(nr,Qe,dt,or,dr){let gr=1,vr=nr.length,Dr=Qe.length;if(or!==void 0&&(or=String(or).toLowerCase(),or==="ucs2"||or==="ucs-2"||or==="utf16le"||or==="utf-16le")){if(nr.length<2||Qe.length<2)return-1;gr=2,vr/=2,Dr/=2,dt/=2}function Vr(jr,Hr){return gr===1?jr[Hr]:jr.readUInt16BE(Hr*gr)}let Kr;if(dr){let jr=-1;for(Kr=dt;Kr<vr;Kr++)if(Vr(nr,Kr)===Vr(Qe,jr===-1?0:Kr-jr)){if(jr===-1&&(jr=Kr),Kr-jr+1===Dr)return jr*gr}else jr!==-1&&(Kr-=Kr-jr),jr=-1}else for(dt+Dr>vr&&(dt=vr-Dr),Kr=dt;Kr>=0;Kr--){let jr=!0;for(let Hr=0;Hr<Dr;Hr++)if(Vr(nr,Kr+Hr)!==Vr(Qe,Hr)){jr=!1;break}if(jr)return Kr}return-1}Je.prototype.includes=function(Qe,dt,or){return this.indexOf(Qe,dt,or)!==-1},Je.prototype.indexOf=function(Qe,dt,or){return Pr(this,Qe,dt,or,!0)},Je.prototype.lastIndexOf=function(Qe,dt,or){return Pr(this,Qe,dt,or,!1)};function Or(nr,Qe,dt,or){dt=Number(dt)||0;const dr=nr.length-dt;or?(or=Number(or),or>dr&&(or=dr)):or=dr;const gr=Qe.length;or>gr/2&&(or=gr/2);let vr;for(vr=0;vr<or;++vr){const Dr=parseInt(Qe.substr(vr*2,2),16);if(Fn(Dr))return vr;nr[dt+vr]=Dr}return vr}function Nr(nr,Qe,dt,or){return Jr(Qr(Qe,nr.length-dt),nr,dt,or)}function Cr(nr,Qe,dt,or){return Jr(jn(Qe),nr,dt,or)}function Tr(nr,Qe,dt,or){return Jr($n(Qe),nr,dt,or)}function Mr(nr,Qe,dt,or){return Jr(fi(Qe,nr.length-dt),nr,dt,or)}Je.prototype.write=function(Qe,dt,or,dr){if(dt===void 0)dr="utf8",or=this.length,dt=0;else if(or===void 0&&typeof dt=="string")dr=dt,or=this.length,dt=0;else if(isFinite(dt))dt=dt>>>0,isFinite(or)?(or=or>>>0,dr===void 0&&(dr="utf8")):(dr=or,or=void 0);else throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");const gr=this.length-dt;if((or===void 0||or>gr)&&(or=gr),Qe.length>0&&(or<0||dt<0)||dt>this.length)throw new RangeError("Attempt to write outside buffer bounds");dr||(dr="utf8");let vr=!1;for(;;)switch(dr){case"hex":return Or(this,Qe,dt,or);case"utf8":case"utf-8":return Nr(this,Qe,dt,or);case"ascii":case"latin1":case"binary":return Cr(this,Qe,dt,or);case"base64":return Tr(this,Qe,dt,or);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return Mr(this,Qe,dt,or);default:if(vr)throw new TypeError("Unknown encoding: "+dr);dr=(""+dr).toLowerCase(),vr=!0}},Je.prototype.toJSON=function(){return{type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}};function ar(nr,Qe,dt){return Qe===0&&dt===nr.length?Re.fromByteArray(nr):Re.fromByteArray(nr.slice(Qe,dt))}function Dt(nr,Qe,dt){dt=Math.min(nr.length,dt);const or=[];let dr=Qe;for(;dr<dt;){const gr=nr[dr];let vr=null,Dr=gr>239?4:gr>223?3:gr>191?2:1;if(dr+Dr<=dt){let Vr,Kr,jr,Hr;switch(Dr){case 1:gr<128&&(vr=gr);break;case 2:Vr=nr[dr+1],(Vr&192)===128&&(Hr=(gr&31)<<6|Vr&63,Hr>127&&(vr=Hr));break;case 3:Vr=nr[dr+1],Kr=nr[dr+2],(Vr&192)===128&&(Kr&192)===128&&(Hr=(gr&15)<<12|(Vr&63)<<6|Kr&63,Hr>2047&&(Hr<55296||Hr>57343)&&(vr=Hr));break;case 4:Vr=nr[dr+1],Kr=nr[dr+2],jr=nr[dr+3],(Vr&192)===128&&(Kr&192)===128&&(jr&192)===128&&(Hr=(gr&15)<<18|(Vr&63)<<12|(Kr&63)<<6|jr&63,Hr>65535&&Hr<1114112&&(vr=Hr))}}vr===null?(vr=65533,Dr=1):vr>65535&&(vr-=65536,or.push(vr>>>10&1023|55296),vr=56320|vr&1023),or.push(vr),dr+=Dr}return cr(or)}const sr=4096;function cr(nr){const Qe=nr.length;if(Qe<=sr)return String.fromCharCode.apply(String,nr);let dt="",or=0;for(;or<Qe;)dt+=String.fromCharCode.apply(String,nr.slice(or,or+=sr));return dt}function yr(nr,Qe,dt){let or="";dt=Math.min(nr.length,dt);for(let dr=Qe;dr<dt;++dr)or+=String.fromCharCode(nr[dr]&127);return or}function _r(nr,Qe,dt){let or="";dt=Math.min(nr.length,dt);for(let dr=Qe;dr<dt;++dr)or+=String.fromCharCode(nr[dr]);return or}function xr(nr,Qe,dt){const or=nr.length;(!Qe||Qe<0)&&(Qe=0),(!dt||dt<0||dt>or)&&(dt=or);let dr="";for(let gr=Qe;gr<dt;++gr)dr+=Kn[nr[gr]];return dr}function Ar(nr,Qe,dt){const or=nr.slice(Qe,dt);let dr="";for(let gr=0;gr<or.length-1;gr+=2)dr+=String.fromCharCode(or[gr]+or[gr+1]*256);return dr}Je.prototype.slice=function(Qe,dt){const or=this.length;Qe=~~Qe,dt=dt===void 0?or:~~dt,Qe<0?(Qe+=or,Qe<0&&(Qe=0)):Qe>or&&(Qe=or),dt<0?(dt+=or,dt<0&&(dt=0)):dt>or&&(dt=or),dt<Qe&&(dt=Qe);const dr=this.subarray(Qe,dt);return Object.setPrototypeOf(dr,Je.prototype),dr};function pr(nr,Qe,dt){if(nr%1!==0||nr<0)throw new RangeError("offset is not uint");if(nr+Qe>dt)throw new RangeError("Trying to access beyond buffer length")}Je.prototype.readUintLE=Je.prototype.readUIntLE=function(Qe,dt,or){Qe=Qe>>>0,dt=dt>>>0,or||pr(Qe,dt,this.length);let dr=this[Qe],gr=1,vr=0;for(;++vr<dt&&(gr*=256);)dr+=this[Qe+vr]*gr;return dr},Je.prototype.readUintBE=Je.prototype.readUIntBE=function(Qe,dt,or){Qe=Qe>>>0,dt=dt>>>0,or||pr(Qe,dt,this.length);let dr=this[Qe+--dt],gr=1;for(;dt>0&&(gr*=256);)dr+=this[Qe+--dt]*gr;return dr},Je.prototype.readUint8=Je.prototype.readUInt8=function(Qe,dt){return Qe=Qe>>>0,dt||pr(Qe,1,this.length),this[Qe]},Je.prototype.readUint16LE=Je.prototype.readUInt16LE=function(Qe,dt){return Qe=Qe>>>0,dt||pr(Qe,2,this.length),this[Qe]|this[Qe+1]<<8},Je.prototype.readUint16BE=Je.prototype.readUInt16BE=function(Qe,dt){return Qe=Qe>>>0,dt||pr(Qe,2,this.length),this[Qe]<<8|this[Qe+1]},Je.prototype.readUint32LE=Je.prototype.readUInt32LE=function(Qe,dt){return Qe=Qe>>>0,dt||pr(Qe,4,this.length),(this[Qe]|this[Qe+1]<<8|this[Qe+2]<<16)+this[Qe+3]*16777216},Je.prototype.readUint32BE=Je.prototype.readUInt32BE=function(Qe,dt){return Qe=Qe>>>0,dt||pr(Qe,4,this.length),this[Qe]*16777216+(this[Qe+1]<<16|this[Qe+2]<<8|this[Qe+3])},Je.prototype.readBigUInt64LE=Wn(function(Qe){Qe=Qe>>>0,Hn(Qe,"offset");const dt=this[Qe],or=this[Qe+7];(dt===void 0||or===void 0)&&Xr(Qe,this.length-8);const dr=dt+this[++Qe]*2**8+this[++Qe]*2**16+this[++Qe]*2**24,gr=this[++Qe]+this[++Qe]*2**8+this[++Qe]*2**16+or*2**24;return BigInt(dr)+(BigInt(gr)<<BigInt(32))}),Je.prototype.readBigUInt64BE=Wn(function(Qe){Qe=Qe>>>0,Hn(Qe,"offset");const dt=this[Qe],or=this[Qe+7];(dt===void 0||or===void 0)&&Xr(Qe,this.length-8);const dr=dt*2**24+this[++Qe]*2**16+this[++Qe]*2**8+this[++Qe],gr=this[++Qe]*2**24+this[++Qe]*2**16+this[++Qe]*2**8+or;return(BigInt(dr)<<BigInt(32))+BigInt(gr)}),Je.prototype.readIntLE=function(Qe,dt,or){Qe=Qe>>>0,dt=dt>>>0,or||pr(Qe,dt,this.length);let dr=this[Qe],gr=1,vr=0;for(;++vr<dt&&(gr*=256);)dr+=this[Qe+vr]*gr;return gr*=128,dr>=gr&&(dr-=Math.pow(2,8*dt)),dr},Je.prototype.readIntBE=function(Qe,dt,or){Qe=Qe>>>0,dt=dt>>>0,or||pr(Qe,dt,this.length);let dr=dt,gr=1,vr=this[Qe+--dr];for(;dr>0&&(gr*=256);)vr+=this[Qe+--dr]*gr;return gr*=128,vr>=gr&&(vr-=Math.pow(2,8*dt)),vr},Je.prototype.readInt8=function(Qe,dt){return Qe=Qe>>>0,dt||pr(Qe,1,this.length),this[Qe]&128?(255-this[Qe]+1)*-1:this[Qe]},Je.prototype.readInt16LE=function(Qe,dt){Qe=Qe>>>0,dt||pr(Qe,2,this.length);const or=this[Qe]|this[Qe+1]<<8;return or&32768?or|4294901760:or},Je.prototype.readInt16BE=function(Qe,dt){Qe=Qe>>>0,dt||pr(Qe,2,this.length);const or=this[Qe+1]|this[Qe]<<8;return or&32768?or|4294901760:or},Je.prototype.readInt32LE=function(Qe,dt){return Qe=Qe>>>0,dt||pr(Qe,4,this.length),this[Qe]|this[Qe+1]<<8|this[Qe+2]<<16|this[Qe+3]<<24},Je.prototype.readInt32BE=function(Qe,dt){return Qe=Qe>>>0,dt||pr(Qe,4,this.length),this[Qe]<<24|this[Qe+1]<<16|this[Qe+2]<<8|this[Qe+3]},Je.prototype.readBigInt64LE=Wn(function(Qe){Qe=Qe>>>0,Hn(Qe,"offset");const dt=this[Qe],or=this[Qe+7];(dt===void 0||or===void 0)&&Xr(Qe,this.length-8);const dr=this[Qe+4]+this[Qe+5]*2**8+this[Qe+6]*2**16+(or<<24);return(BigInt(dr)<<BigInt(32))+BigInt(dt+this[++Qe]*2**8+this[++Qe]*2**16+this[++Qe]*2**24)}),Je.prototype.readBigInt64BE=Wn(function(Qe){Qe=Qe>>>0,Hn(Qe,"offset");const dt=this[Qe],or=this[Qe+7];(dt===void 0||or===void 0)&&Xr(Qe,this.length-8);const dr=(dt<<24)+this[++Qe]*2**16+this[++Qe]*2**8+this[++Qe];return(BigInt(dr)<<BigInt(32))+BigInt(this[++Qe]*2**24+this[++Qe]*2**16+this[++Qe]*2**8+or)}),Je.prototype.readFloatLE=function(Qe,dt){return Qe=Qe>>>0,dt||pr(Qe,4,this.length),Fe.read(this,Qe,!0,23,4)},Je.prototype.readFloatBE=function(Qe,dt){return Qe=Qe>>>0,dt||pr(Qe,4,this.length),Fe.read(this,Qe,!1,23,4)},Je.prototype.readDoubleLE=function(Qe,dt){return Qe=Qe>>>0,dt||pr(Qe,8,this.length),Fe.read(this,Qe,!0,52,8)},Je.prototype.readDoubleBE=function(Qe,dt){return Qe=Qe>>>0,dt||pr(Qe,8,this.length),Fe.read(this,Qe,!1,52,8)};function rr(nr,Qe,dt,or,dr,gr){if(!Je.isBuffer(nr))throw new TypeError('"buffer" argument must be a Buffer instance');if(Qe>dr||Qe<gr)throw new RangeError('"value" argument is out of bounds');if(dt+or>nr.length)throw new RangeError("Index out of range")}Je.prototype.writeUintLE=Je.prototype.writeUIntLE=function(Qe,dt,or,dr){if(Qe=+Qe,dt=dt>>>0,or=or>>>0,!dr){const Dr=Math.pow(2,8*or)-1;rr(this,Qe,dt,or,Dr,0)}let gr=1,vr=0;for(this[dt]=Qe&255;++vr<or&&(gr*=256);)this[dt+vr]=Qe/gr&255;return dt+or},Je.prototype.writeUintBE=Je.prototype.writeUIntBE=function(Qe,dt,or,dr){if(Qe=+Qe,dt=dt>>>0,or=or>>>0,!dr){const Dr=Math.pow(2,8*or)-1;rr(this,Qe,dt,or,Dr,0)}let gr=or-1,vr=1;for(this[dt+gr]=Qe&255;--gr>=0&&(vr*=256);)this[dt+gr]=Qe/vr&255;return dt+or},Je.prototype.writeUint8=Je.prototype.writeUInt8=function(Qe,dt,or){return Qe=+Qe,dt=dt>>>0,or||rr(this,Qe,dt,1,255,0),this[dt]=Qe&255,dt+1},Je.prototype.writeUint16LE=Je.prototype.writeUInt16LE=function(Qe,dt,or){return Qe=+Qe,dt=dt>>>0,or||rr(this,Qe,dt,2,65535,0),this[dt]=Qe&255,this[dt+1]=Qe>>>8,dt+2},Je.prototype.writeUint16BE=Je.prototype.writeUInt16BE=function(Qe,dt,or){return Qe=+Qe,dt=dt>>>0,or||rr(this,Qe,dt,2,65535,0),this[dt]=Qe>>>8,this[dt+1]=Qe&255,dt+2},Je.prototype.writeUint32LE=Je.prototype.writeUInt32LE=function(Qe,dt,or){return Qe=+Qe,dt=dt>>>0,or||rr(this,Qe,dt,4,4294967295,0),this[dt+3]=Qe>>>24,this[dt+2]=Qe>>>16,this[dt+1]=Qe>>>8,this[dt]=Qe&255,dt+4},Je.prototype.writeUint32BE=Je.prototype.writeUInt32BE=function(Qe,dt,or){return Qe=+Qe,dt=dt>>>0,or||rr(this,Qe,dt,4,4294967295,0),this[dt]=Qe>>>24,this[dt+1]=Qe>>>16,this[dt+2]=Qe>>>8,this[dt+3]=Qe&255,dt+4};function hr(nr,Qe,dt,or,dr){Gr(Qe,or,dr,nr,dt,7);let gr=Number(Qe&BigInt(4294967295));nr[dt++]=gr,gr=gr>>8,nr[dt++]=gr,gr=gr>>8,nr[dt++]=gr,gr=gr>>8,nr[dt++]=gr;let vr=Number(Qe>>BigInt(32)&BigInt(4294967295));return nr[dt++]=vr,vr=vr>>8,nr[dt++]=vr,vr=vr>>8,nr[dt++]=vr,vr=vr>>8,nr[dt++]=vr,dt}function $r(nr,Qe,dt,or,dr){Gr(Qe,or,dr,nr,dt,7);let gr=Number(Qe&BigInt(4294967295));nr[dt+7]=gr,gr=gr>>8,nr[dt+6]=gr,gr=gr>>8,nr[dt+5]=gr,gr=gr>>8,nr[dt+4]=gr;let vr=Number(Qe>>BigInt(32)&BigInt(4294967295));return nr[dt+3]=vr,vr=vr>>8,nr[dt+2]=vr,vr=vr>>8,nr[dt+1]=vr,vr=vr>>8,nr[dt]=vr,dt+8}Je.prototype.writeBigUInt64LE=Wn(function(Qe,dt=0){return hr(this,Qe,dt,BigInt(0),BigInt("0xffffffffffffffff"))}),Je.prototype.writeBigUInt64BE=Wn(function(Qe,dt=0){return $r(this,Qe,dt,BigInt(0),BigInt("0xffffffffffffffff"))}),Je.prototype.writeIntLE=function(Qe,dt,or,dr){if(Qe=+Qe,dt=dt>>>0,!dr){const Vr=Math.pow(2,8*or-1);rr(this,Qe,dt,or,Vr-1,-Vr)}let gr=0,vr=1,Dr=0;for(this[dt]=Qe&255;++gr<or&&(vr*=256);)Qe<0&&Dr===0&&this[dt+gr-1]!==0&&(Dr=1),this[dt+gr]=(Qe/vr>>0)-Dr&255;return dt+or},Je.prototype.writeIntBE=function(Qe,dt,or,dr){if(Qe=+Qe,dt=dt>>>0,!dr){const Vr=Math.pow(2,8*or-1);rr(this,Qe,dt,or,Vr-1,-Vr)}let gr=or-1,vr=1,Dr=0;for(this[dt+gr]=Qe&255;--gr>=0&&(vr*=256);)Qe<0&&Dr===0&&this[dt+gr+1]!==0&&(Dr=1),this[dt+gr]=(Qe/vr>>0)-Dr&255;return dt+or},Je.prototype.writeInt8=function(Qe,dt,or){return Qe=+Qe,dt=dt>>>0,or||rr(this,Qe,dt,1,127,-128),Qe<0&&(Qe=255+Qe+1),this[dt]=Qe&255,dt+1},Je.prototype.writeInt16LE=function(Qe,dt,or){return Qe=+Qe,dt=dt>>>0,or||rr(this,Qe,dt,2,32767,-32768),this[dt]=Qe&255,this[dt+1]=Qe>>>8,dt+2},Je.prototype.writeInt16BE=function(Qe,dt,or){return Qe=+Qe,dt=dt>>>0,or||rr(this,Qe,dt,2,32767,-32768),this[dt]=Qe>>>8,this[dt+1]=Qe&255,dt+2},Je.prototype.writeInt32LE=function(Qe,dt,or){return Qe=+Qe,dt=dt>>>0,or||rr(this,Qe,dt,4,2147483647,-2147483648),this[dt]=Qe&255,this[dt+1]=Qe>>>8,this[dt+2]=Qe>>>16,this[dt+3]=Qe>>>24,dt+4},Je.prototype.writeInt32BE=function(Qe,dt,or){return Qe=+Qe,dt=dt>>>0,or||rr(this,Qe,dt,4,2147483647,-2147483648),Qe<0&&(Qe=4294967295+Qe+1),this[dt]=Qe>>>24,this[dt+1]=Qe>>>16,this[dt+2]=Qe>>>8,this[dt+3]=Qe&255,dt+4},Je.prototype.writeBigInt64LE=Wn(function(Qe,dt=0){return hr(this,Qe,dt,-BigInt("0x8000000000000000"),BigInt("0x7fffffffffffffff"))}),Je.prototype.writeBigInt64BE=Wn(function(Qe,dt=0){return $r(this,Qe,dt,-BigInt("0x8000000000000000"),BigInt("0x7fffffffffffffff"))});function Lr(nr,Qe,dt,or,dr,gr){if(dt+or>nr.length)throw new RangeError("Index out of range");if(dt<0)throw new RangeError("Index out of range")}function Ur(nr,Qe,dt,or,dr){return Qe=+Qe,dt=dt>>>0,dr||Lr(nr,Qe,dt,4),Fe.write(nr,Qe,dt,or,23,4),dt+4}Je.prototype.writeFloatLE=function(Qe,dt,or){return Ur(this,Qe,dt,!0,or)},Je.prototype.writeFloatBE=function(Qe,dt,or){return Ur(this,Qe,dt,!1,or)};function Wr(nr,Qe,dt,or,dr){return Qe=+Qe,dt=dt>>>0,dr||Lr(nr,Qe,dt,8),Fe.write(nr,Qe,dt,or,52,8),dt+8}Je.prototype.writeDoubleLE=function(Qe,dt,or){return Wr(this,Qe,dt,!0,or)},Je.prototype.writeDoubleBE=function(Qe,dt,or){return Wr(this,Qe,dt,!1,or)},Je.prototype.copy=function(Qe,dt,or,dr){if(!Je.isBuffer(Qe))throw new TypeError("argument should be a Buffer");if(or||(or=0),!dr&&dr!==0&&(dr=this.length),dt>=Qe.length&&(dt=Qe.length),dt||(dt=0),dr>0&&dr<or&&(dr=or),dr===or||Qe.length===0||this.length===0)return 0;if(dt<0)throw new RangeError("targetStart out of bounds");if(or<0||or>=this.length)throw new RangeError("Index out of range");if(dr<0)throw new RangeError("sourceEnd out of bounds");dr>this.length&&(dr=this.length),Qe.length-dt<dr-or&&(dr=Qe.length-dt+or);const gr=dr-or;return this===Qe&&typeof Uint8Array.prototype.copyWithin=="function"?this.copyWithin(dt,or,dr):Uint8Array.prototype.set.call(Qe,this.subarray(or,dr),dt),gr},Je.prototype.fill=function(Qe,dt,or,dr){if(typeof Qe=="string"){if(typeof dt=="string"?(dr=dt,dt=0,or=this.length):typeof or=="string"&&(dr=or,or=this.length),dr!==void 0&&typeof dr!="string")throw new TypeError("encoding must be a string");if(typeof dr=="string"&&!Je.isEncoding(dr))throw new TypeError("Unknown encoding: "+dr);if(Qe.length===1){const vr=Qe.charCodeAt(0);(dr==="utf8"&&vr<128||dr==="latin1")&&(Qe=vr)}}else typeof Qe=="number"?Qe=Qe&255:typeof Qe=="boolean"&&(Qe=Number(Qe));if(dt<0||this.length<dt||this.length<or)throw new RangeError("Out of range index");if(or<=dt)return this;dt=dt>>>0,or=or===void 0?this.length:or>>>0,Qe||(Qe=0);let gr;if(typeof Qe=="number")for(gr=dt;gr<or;++gr)this[gr]=Qe;else{const vr=Je.isBuffer(Qe)?Qe:Je.from(Qe,dr),Dr=vr.length;if(Dr===0)throw new TypeError('The value "'+Qe+'" is invalid for argument "value"');for(gr=0;gr<or-dt;++gr)this[gr+dt]=vr[gr%Dr]}return this};const Fr={};function zr(nr,Qe,dt){Fr[nr]=class extends dt{constructor(){super(),Object.defineProperty(this,"message",{value:Qe.apply(this,arguments),writable:!0,configurable:!0}),this.name=`${this.name} [${nr}]`,this.stack,delete this.name}get code(){return nr}set code(dr){Object.defineProperty(this,"code",{configurable:!0,enumerable:!0,value:dr,writable:!0})}toString(){return`${this.name} [${nr}]: ${this.message}`}}}zr("ERR_BUFFER_OUT_OF_BOUNDS",function(nr){return nr?`${nr} is outside of buffer bounds`:"Attempt to access memory outside buffer bounds"},RangeError),zr("ERR_INVALID_ARG_TYPE",function(nr,Qe){return`The "${nr}" argument must be of type number. Received type ${typeof Qe}`},TypeError),zr("ERR_OUT_OF_RANGE",function(nr,Qe,dt){let or=`The value of "${nr}" is out of range.`,dr=dt;return Number.isInteger(dt)&&Math.abs(dt)>2**32?dr=Yr(String(dt)):typeof dt=="bigint"&&(dr=String(dt),(dt>BigInt(2)**BigInt(32)||dt<-(BigInt(2)**BigInt(32)))&&(dr=Yr(dr)),dr+="n"),or+=` It must be ${Qe}. Received ${dr}`,or},RangeError);function Yr(nr){let Qe="",dt=nr.length;const or=nr[0]==="-"?1:0;for(;dt>=or+4;dt-=3)Qe=`_${nr.slice(dt-3,dt)}${Qe}`;return`${nr.slice(0,dt)}${Qe}`}function qr(nr,Qe,dt){Hn(Qe,"offset"),(nr[Qe]===void 0||nr[Qe+dt]===void 0)&&Xr(Qe,nr.length-(dt+1))}function Gr(nr,Qe,dt,or,dr,gr){if(nr>dt||nr<Qe){const vr=typeof Qe=="bigint"?"n":"";let Dr;throw gr>3?Qe===0||Qe===BigInt(0)?Dr=`>= 0${vr} and < 2${vr} ** ${(gr+1)*8}${vr}`:Dr=`>= -(2${vr} ** ${(gr+1)*8-1}${vr}) and < 2 ** ${(gr+1)*8-1}${vr}`:Dr=`>= ${Qe}${vr} and <= ${dt}${vr}`,new Fr.ERR_OUT_OF_RANGE("value",Dr,nr)}qr(or,dr,gr)}function Hn(nr,Qe){if(typeof nr!="number")throw new Fr.ERR_INVALID_ARG_TYPE(Qe,"number",nr)}function Xr(nr,Qe,dt){throw Math.floor(nr)!==nr?(Hn(nr,dt),new Fr.ERR_OUT_OF_RANGE(dt||"offset","an integer",nr)):Qe<0?new Fr.ERR_BUFFER_OUT_OF_BOUNDS:new Fr.ERR_OUT_OF_RANGE(dt||"offset",`>= ${dt?1:0} and <= ${Qe}`,nr)}const Zr=/[^+/0-9A-Za-z-_]/g;function qn(nr){if(nr=nr.split("=")[0],nr=nr.trim().replace(Zr,""),nr.length<2)return"";for(;nr.length%4!==0;)nr=nr+"=";return nr}function Qr(nr,Qe){Qe=Qe||1/0;let dt;const or=nr.length;let dr=null;const gr=[];for(let vr=0;vr<or;++vr){if(dt=nr.charCodeAt(vr),dt>55295&&dt<57344){if(!dr){if(dt>56319){(Qe-=3)>-1&&gr.push(239,191,189);continue}else if(vr+1===or){(Qe-=3)>-1&&gr.push(239,191,189);continue}dr=dt;continue}if(dt<56320){(Qe-=3)>-1&&gr.push(239,191,189),dr=dt;continue}dt=(dr-55296<<10|dt-56320)+65536}else dr&&(Qe-=3)>-1&&gr.push(239,191,189);if(dr=null,dt<128){if((Qe-=1)<0)break;gr.push(dt)}else if(dt<2048){if((Qe-=2)<0)break;gr.push(dt>>6|192,dt&63|128)}else if(dt<65536){if((Qe-=3)<0)break;gr.push(dt>>12|224,dt>>6&63|128,dt&63|128)}else if(dt<1114112){if((Qe-=4)<0)break;gr.push(dt>>18|240,dt>>12&63|128,dt>>6&63|128,dt&63|128)}else throw new Error("Invalid code point")}return gr}function jn(nr){const Qe=[];for(let dt=0;dt<nr.length;++dt)Qe.push(nr.charCodeAt(dt)&255);return Qe}function fi(nr,Qe){let dt,or,dr;const gr=[];for(let vr=0;vr<nr.length&&!((Qe-=2)<0);++vr)dt=nr.charCodeAt(vr),or=dt>>8,dr=dt%256,gr.push(dr),gr.push(or);return gr}function $n(nr){return Re.toByteArray(qn(nr))}function Jr(nr,Qe,dt,or){let dr;for(dr=0;dr<or&&!(dr+dt>=Qe.length||dr>=nr.length);++dr)Qe[dr+dt]=nr[dr];return dr}function Cn(nr,Qe){return nr instanceof Qe||nr!=null&&nr.constructor!=null&&nr.constructor.name!=null&&nr.constructor.name===Qe.name}function Fn(nr){return nr!==nr}const Kn=function(){const nr="0123456789abcdef",Qe=new Array(256);for(let dt=0;dt<16;++dt){const or=dt*16;for(let dr=0;dr<16;++dr)Qe[or+dr]=nr[dt]+nr[dr]}return Qe}();function Wn(nr){return typeof BigInt>"u"?Un:nr}function Un(){throw new Error("BigInt not supported")}})(buffer$1);window.Buffer=buffer$1.Buffer;const index="";var n,l$1,u$2,t$1,o$2,r$1,f$2={},e$1=[],c$1=/acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;function s$2(Ke,Re){for(var Fe in Re)Ke[Fe]=Re[Fe];return Ke}function a$1(Ke){var Re=Ke.parentNode;Re&&Re.removeChild(Ke)}function h$1(Ke,Re,Fe){var We,qe,Ze,Xe={};for(Ze in Re)Ze=="key"?We=Re[Ze]:Ze=="ref"?qe=Re[Ze]:Xe[Ze]=Re[Ze];if(arguments.length>2&&(Xe.children=arguments.length>3?n.call(arguments,2):Fe),typeof Ke=="function"&&Ke.defaultProps!=null)for(Ze in Ke.defaultProps)Xe[Ze]===void 0&&(Xe[Ze]=Ke.defaultProps[Ze]);return v$2(Ke,Xe,We,qe,null)}function v$2(Ke,Re,Fe,We,qe){var Ze={type:Ke,props:Re,key:Fe,ref:We,__k:null,__:null,__b:0,__e:null,__d:void 0,__c:null,__h:null,constructor:void 0,__v:qe==null?++u$2:qe};return qe==null&&l$1.vnode!=null&&l$1.vnode(Ze),Ze}function y$2(){return{current:null}}function p$1(Ke){return Ke.children}function d$1(Ke,Re){this.props=Ke,this.context=Re}function _$3(Ke,Re){if(Re==null)return Ke.__?_$3(Ke.__,Ke.__.__k.indexOf(Ke)+1):null;for(var Fe;Re<Ke.__k.length;Re++)if((Fe=Ke.__k[Re])!=null&&Fe.__e!=null)return Fe.__e;return typeof Ke.type=="function"?_$3(Ke):null}function k$3(Ke){var Re,Fe;if((Ke=Ke.__)!=null&&Ke.__c!=null){for(Ke.__e=Ke.__c.base=null,Re=0;Re<Ke.__k.length;Re++)if((Fe=Ke.__k[Re])!=null&&Fe.__e!=null){Ke.__e=Ke.__c.base=Fe.__e;break}return k$3(Ke)}}function b$2(Ke){(!Ke.__d&&(Ke.__d=!0)&&t$1.push(Ke)&&!g$2.__r++||o$2!==l$1.debounceRendering)&&((o$2=l$1.debounceRendering)||setTimeout)(g$2)}function g$2(){for(var Ke;g$2.__r=t$1.length;)Ke=t$1.sort(function(Re,Fe){return Re.__v.__b-Fe.__v.__b}),t$1=[],Ke.some(function(Re){var Fe,We,qe,Ze,Xe,Je;Re.__d&&(Xe=(Ze=(Fe=Re).__v).__e,(Je=Fe.__P)&&(We=[],(qe=s$2({},Ze)).__v=Ze.__v+1,j$3(Je,Ze,qe,Fe.__n,Je.ownerSVGElement!==void 0,Ze.__h!=null?[Xe]:null,We,Xe==null?_$3(Ze):Xe,Ze.__h),z$3(We,Ze),Ze.__e!=Xe&&k$3(Ze)))})}function w$3(Ke,Re,Fe,We,qe,Ze,Xe,Je,tr,er){var ir,lr,fr,ur,mr,br,wr,Sr=We&&We.__k||e$1,kr=Sr.length;for(Fe.__k=[],ir=0;ir<Re.length;ir++)if((ur=Fe.__k[ir]=(ur=Re[ir])==null||typeof ur=="boolean"?null:typeof ur=="string"||typeof ur=="number"||typeof ur=="bigint"?v$2(null,ur,null,null,ur):Array.isArray(ur)?v$2(p$1,{children:ur},null,null,null):ur.__b>0?v$2(ur.type,ur.props,ur.key,ur.ref?ur.ref:null,ur.__v):ur)!=null){if(ur.__=Fe,ur.__b=Fe.__b+1,(fr=Sr[ir])===null||fr&&ur.key==fr.key&&ur.type===fr.type)Sr[ir]=void 0;else for(lr=0;lr<kr;lr++){if((fr=Sr[lr])&&ur.key==fr.key&&ur.type===fr.type){Sr[lr]=void 0;break}fr=null}j$3(Ke,ur,fr=fr||f$2,qe,Ze,Xe,Je,tr,er),mr=ur.__e,(lr=ur.ref)&&fr.ref!=lr&&(wr||(wr=[]),fr.ref&&wr.push(fr.ref,null,ur),wr.push(lr,ur.__c||mr,ur)),mr!=null?(br==null&&(br=mr),typeof ur.type=="function"&&ur.__k===fr.__k?ur.__d=tr=m$1(ur,tr,Ke):tr=A$3(Ke,ur,fr,Sr,mr,tr),typeof Fe.type=="function"&&(Fe.__d=tr)):tr&&fr.__e==tr&&tr.parentNode!=Ke&&(tr=_$3(fr))}for(Fe.__e=br,ir=kr;ir--;)Sr[ir]!=null&&N$2(Sr[ir],Sr[ir]);if(wr)for(ir=0;ir<wr.length;ir++)M$2(wr[ir],wr[++ir],wr[++ir])}function m$1(Ke,Re,Fe){for(var We,qe=Ke.__k,Ze=0;qe&&Ze<qe.length;Ze++)(We=qe[Ze])&&(We.__=Ke,Re=typeof We.type=="function"?m$1(We,Re,Fe):A$3(Fe,We,We,qe,We.__e,Re));return Re}function x$3(Ke,Re){return Re=Re||[],Ke==null||typeof Ke=="boolean"||(Array.isArray(Ke)?Ke.some(function(Fe){x$3(Fe,Re)}):Re.push(Ke)),Re}function A$3(Ke,Re,Fe,We,qe,Ze){var Xe,Je,tr;if(Re.__d!==void 0)Xe=Re.__d,Re.__d=void 0;else if(Fe==null||qe!=Ze||qe.parentNode==null)e:if(Ze==null||Ze.parentNode!==Ke)Ke.appendChild(qe),Xe=null;else{for(Je=Ze,tr=0;(Je=Je.nextSibling)&&tr<We.length;tr+=2)if(Je==qe)break e;Ke.insertBefore(qe,Ze),Xe=Ze}return Xe!==void 0?Xe:qe.nextSibling}function C$2(Ke,Re,Fe,We,qe){var Ze;for(Ze in Fe)Ze==="children"||Ze==="key"||Ze in Re||H$2(Ke,Ze,null,Fe[Ze],We);for(Ze in Re)qe&&typeof Re[Ze]!="function"||Ze==="children"||Ze==="key"||Ze==="value"||Ze==="checked"||Fe[Ze]===Re[Ze]||H$2(Ke,Ze,Re[Ze],Fe[Ze],We)}function $$2(Ke,Re,Fe){Re[0]==="-"?Ke.setProperty(Re,Fe):Ke[Re]=Fe==null?"":typeof Fe!="number"||c$1.test(Re)?Fe:Fe+"px"}function H$2(Ke,Re,Fe,We,qe){var Ze;e:if(Re==="style")if(typeof Fe=="string")Ke.style.cssText=Fe;else{if(typeof We=="string"&&(Ke.style.cssText=We=""),We)for(Re in We)Fe&&Re in Fe||$$2(Ke.style,Re,"");if(Fe)for(Re in Fe)We&&Fe[Re]===We[Re]||$$2(Ke.style,Re,Fe[Re])}else if(Re[0]==="o"&&Re[1]==="n")Ze=Re!==(Re=Re.replace(/Capture$/,"")),Re=Re.toLowerCase()in Ke?Re.toLowerCase().slice(2):Re.slice(2),Ke.l||(Ke.l={}),Ke.l[Re+Ze]=Fe,Fe?We||Ke.addEventListener(Re,Ze?T$3:I$2,Ze):Ke.removeEventListener(Re,Ze?T$3:I$2,Ze);else if(Re!=="dangerouslySetInnerHTML"){if(qe)Re=Re.replace(/xlink(H|:h)/,"h").replace(/sName$/,"s");else if(Re!=="href"&&Re!=="list"&&Re!=="form"&&Re!=="tabIndex"&&Re!=="download"&&Re in Ke)try{Ke[Re]=Fe==null?"":Fe;break e}catch{}typeof Fe=="function"||(Fe==null||Fe===!1&&Re.indexOf("-")==-1?Ke.removeAttribute(Re):Ke.setAttribute(Re,Fe))}}function I$2(Ke){this.l[Ke.type+!1](l$1.event?l$1.event(Ke):Ke)}function T$3(Ke){this.l[Ke.type+!0](l$1.event?l$1.event(Ke):Ke)}function j$3(Ke,Re,Fe,We,qe,Ze,Xe,Je,tr){var er,ir,lr,fr,ur,mr,br,wr,Sr,kr,Er,Ir,Rr,Pr,Br,Or=Re.type;if(Re.constructor!==void 0)return null;Fe.__h!=null&&(tr=Fe.__h,Je=Re.__e=Fe.__e,Re.__h=null,Ze=[Je]),(er=l$1.__b)&&er(Re);try{e:if(typeof Or=="function"){if(wr=Re.props,Sr=(er=Or.contextType)&&We[er.__c],kr=er?Sr?Sr.props.value:er.__:We,Fe.__c?br=(ir=Re.__c=Fe.__c).__=ir.__E:("prototype"in Or&&Or.prototype.render?Re.__c=ir=new Or(wr,kr):(Re.__c=ir=new d$1(wr,kr),ir.constructor=Or,ir.render=O$2),Sr&&Sr.sub(ir),ir.props=wr,ir.state||(ir.state={}),ir.context=kr,ir.__n=We,lr=ir.__d=!0,ir.__h=[],ir._sb=[]),ir.__s==null&&(ir.__s=ir.state),Or.getDerivedStateFromProps!=null&&(ir.__s==ir.state&&(ir.__s=s$2({},ir.__s)),s$2(ir.__s,Or.getDerivedStateFromProps(wr,ir.__s))),fr=ir.props,ur=ir.state,lr)Or.getDerivedStateFromProps==null&&ir.componentWillMount!=null&&ir.componentWillMount(),ir.componentDidMount!=null&&ir.__h.push(ir.componentDidMount);else{if(Or.getDerivedStateFromProps==null&&wr!==fr&&ir.componentWillReceiveProps!=null&&ir.componentWillReceiveProps(wr,kr),!ir.__e&&ir.shouldComponentUpdate!=null&&ir.shouldComponentUpdate(wr,ir.__s,kr)===!1||Re.__v===Fe.__v){for(ir.props=wr,ir.state=ir.__s,Re.__v!==Fe.__v&&(ir.__d=!1),ir.__v=Re,Re.__e=Fe.__e,Re.__k=Fe.__k,Re.__k.forEach(function(Nr){Nr&&(Nr.__=Re)}),Er=0;Er<ir._sb.length;Er++)ir.__h.push(ir._sb[Er]);ir._sb=[],ir.__h.length&&Xe.push(ir);break e}ir.componentWillUpdate!=null&&ir.componentWillUpdate(wr,ir.__s,kr),ir.componentDidUpdate!=null&&ir.__h.push(function(){ir.componentDidUpdate(fr,ur,mr)})}if(ir.context=kr,ir.props=wr,ir.__v=Re,ir.__P=Ke,Ir=l$1.__r,Rr=0,"prototype"in Or&&Or.prototype.render){for(ir.state=ir.__s,ir.__d=!1,Ir&&Ir(Re),er=ir.render(ir.props,ir.state,ir.context),Pr=0;Pr<ir._sb.length;Pr++)ir.__h.push(ir._sb[Pr]);ir._sb=[]}else do ir.__d=!1,Ir&&Ir(Re),er=ir.render(ir.props,ir.state,ir.context),ir.state=ir.__s;while(ir.__d&&++Rr<25);ir.state=ir.__s,ir.getChildContext!=null&&(We=s$2(s$2({},We),ir.getChildContext())),lr||ir.getSnapshotBeforeUpdate==null||(mr=ir.getSnapshotBeforeUpdate(fr,ur)),Br=er!=null&&er.type===p$1&&er.key==null?er.props.children:er,w$3(Ke,Array.isArray(Br)?Br:[Br],Re,Fe,We,qe,Ze,Xe,Je,tr),ir.base=Re.__e,Re.__h=null,ir.__h.length&&Xe.push(ir),br&&(ir.__E=ir.__=null),ir.__e=!1}else Ze==null&&Re.__v===Fe.__v?(Re.__k=Fe.__k,Re.__e=Fe.__e):Re.__e=L$2(Fe.__e,Re,Fe,We,qe,Ze,Xe,tr);(er=l$1.diffed)&&er(Re)}catch(Nr){Re.__v=null,(tr||Ze!=null)&&(Re.__e=Je,Re.__h=!!tr,Ze[Ze.indexOf(Je)]=null),l$1.__e(Nr,Re,Fe)}}function z$3(Ke,Re){l$1.__c&&l$1.__c(Re,Ke),Ke.some(function(Fe){try{Ke=Fe.__h,Fe.__h=[],Ke.some(function(We){We.call(Fe)})}catch(We){l$1.__e(We,Fe.__v)}})}function L$2(Ke,Re,Fe,We,qe,Ze,Xe,Je){var tr,er,ir,lr=Fe.props,fr=Re.props,ur=Re.type,mr=0;if(ur==="svg"&&(qe=!0),Ze!=null){for(;mr<Ze.length;mr++)if((tr=Ze[mr])&&"setAttribute"in tr==!!ur&&(ur?tr.localName===ur:tr.nodeType===3)){Ke=tr,Ze[mr]=null;break}}if(Ke==null){if(ur===null)return document.createTextNode(fr);Ke=qe?document.createElementNS("http://www.w3.org/2000/svg",ur):document.createElement(ur,fr.is&&fr),Ze=null,Je=!1}if(ur===null)lr===fr||Je&&Ke.data===fr||(Ke.data=fr);else{if(Ze=Ze&&n.call(Ke.childNodes),er=(lr=Fe.props||f$2).dangerouslySetInnerHTML,ir=fr.dangerouslySetInnerHTML,!Je){if(Ze!=null)for(lr={},mr=0;mr<Ke.attributes.length;mr++)lr[Ke.attributes[mr].name]=Ke.attributes[mr].value;(ir||er)&&(ir&&(er&&ir.__html==er.__html||ir.__html===Ke.innerHTML)||(Ke.innerHTML=ir&&ir.__html||""))}if(C$2(Ke,fr,lr,qe,Je),ir)Re.__k=[];else if(mr=Re.props.children,w$3(Ke,Array.isArray(mr)?mr:[mr],Re,Fe,We,qe&&ur!=="foreignObject",Ze,Xe,Ze?Ze[0]:Fe.__k&&_$3(Fe,0),Je),Ze!=null)for(mr=Ze.length;mr--;)Ze[mr]!=null&&a$1(Ze[mr]);Je||("value"in fr&&(mr=fr.value)!==void 0&&(mr!==Ke.value||ur==="progress"&&!mr||ur==="option"&&mr!==lr.value)&&H$2(Ke,"value",mr,lr.value,!1),"checked"in fr&&(mr=fr.checked)!==void 0&&mr!==Ke.checked&&H$2(Ke,"checked",mr,lr.checked,!1))}return Ke}function M$2(Ke,Re,Fe){try{typeof Ke=="function"?Ke(Re):Ke.current=Re}catch(We){l$1.__e(We,Fe)}}function N$2(Ke,Re,Fe){var We,qe;if(l$1.unmount&&l$1.unmount(Ke),(We=Ke.ref)&&(We.current&&We.current!==Ke.__e||M$2(We,null,Re)),(We=Ke.__c)!=null){if(We.componentWillUnmount)try{We.componentWillUnmount()}catch(Ze){l$1.__e(Ze,Re)}We.base=We.__P=null,Ke.__c=void 0}if(We=Ke.__k)for(qe=0;qe<We.length;qe++)We[qe]&&N$2(We[qe],Re,Fe||typeof Ke.type!="function");Fe||Ke.__e==null||a$1(Ke.__e),Ke.__=Ke.__e=Ke.__d=void 0}function O$2(Ke,Re,Fe){return this.constructor(Ke,Fe)}function P$2(Ke,Re,Fe){var We,qe,Ze;l$1.__&&l$1.__(Ke,Re),qe=(We=typeof Fe=="function")?null:Fe&&Fe.__k||Re.__k,Ze=[],j$3(Re,Ke=(!We&&Fe||Re).__k=h$1(p$1,null,[Ke]),qe||f$2,f$2,Re.ownerSVGElement!==void 0,!We&&Fe?[Fe]:qe?null:Re.firstChild?n.call(Re.childNodes):null,Ze,!We&&Fe?Fe:qe?qe.__e:Re.firstChild,We),z$3(Ze,Ke)}function S$1(Ke,Re){P$2(Ke,Re,S$1)}function q$3(Ke,Re,Fe){var We,qe,Ze,Xe=s$2({},Ke.props);for(Ze in Re)Ze=="key"?We=Re[Ze]:Ze=="ref"?qe=Re[Ze]:Xe[Ze]=Re[Ze];return arguments.length>2&&(Xe.children=arguments.length>3?n.call(arguments,2):Fe),v$2(Ke.type,Xe,We||Ke.key,qe||Ke.ref,null)}function B$3(Ke,Re){var Fe={__c:Re="__cC"+r$1++,__:Ke,Consumer:function(We,qe){return We.children(qe)},Provider:function(We){var qe,Ze;return this.getChildContext||(qe=[],(Ze={})[Re]=this,this.getChildContext=function(){return Ze},this.shouldComponentUpdate=function(Xe){this.props.value!==Xe.value&&qe.some(b$2)},this.sub=function(Xe){qe.push(Xe);var Je=Xe.componentWillUnmount;Xe.componentWillUnmount=function(){qe.splice(qe.indexOf(Xe),1),Je&&Je.call(Xe)}}),We.children}};return Fe.Provider.__=Fe.Consumer.contextType=Fe}n=e$1.slice,l$1={__e:function(Ke,Re,Fe,We){for(var qe,Ze,Xe;Re=Re.__;)if((qe=Re.__c)&&!qe.__)try{if((Ze=qe.constructor)&&Ze.getDerivedStateFromError!=null&&(qe.setState(Ze.getDerivedStateFromError(Ke)),Xe=qe.__d),qe.componentDidCatch!=null&&(qe.componentDidCatch(Ke,We||{}),Xe=qe.__d),Xe)return qe.__E=qe}catch(Je){Ke=Je}throw Ke}},u$2=0,d$1.prototype.setState=function(Ke,Re){var Fe;Fe=this.__s!=null&&this.__s!==this.state?this.__s:this.__s=s$2({},this.state),typeof Ke=="function"&&(Ke=Ke(s$2({},Fe),this.props)),Ke&&s$2(Fe,Ke),Ke!=null&&this.__v&&(Re&&this._sb.push(Re),b$2(this))},d$1.prototype.forceUpdate=function(Ke){this.__v&&(this.__e=!0,Ke&&this.__h.push(Ke),b$2(this))},d$1.prototype.render=p$1,t$1=[],g$2.__r=0,r$1=0;const ReactToastify="";var classnames={exports:{}};/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/(function(Ke){(function(){var Re={}.hasOwnProperty;function Fe(){for(var We=[],qe=0;qe<arguments.length;qe++){var Ze=arguments[qe];if(!!Ze){var Xe=typeof Ze;if(Xe==="string"||Xe==="number")We.push(Ze);else if(Array.isArray(Ze)){if(Ze.length){var Je=Fe.apply(null,Ze);Je&&We.push(Je)}}else if(Xe==="object"){if(Ze.toString!==Object.prototype.toString&&!Ze.toString.toString().includes("[native code]")){We.push(Ze.toString());continue}for(var tr in Ze)Re.call(Ze,tr)&&Ze[tr]&&We.push(tr)}}}return We.join(" ")}Ke.exports?(Fe.default=Fe,Ke.exports=Fe):window.classNames=Fe})()})(classnames);const cl=classnames.exports;var t,r,u$1,i$1,o$1=0,f$1=[],c=[],e=l$1.__b,a=l$1.__r,v$1=l$1.diffed,l=l$1.__c,m=l$1.unmount;function d(Ke,Re){l$1.__h&&l$1.__h(r,Ke,o$1||Re),o$1=0;var Fe=r.__H||(r.__H={__:[],__h:[]});return Ke>=Fe.__.length&&Fe.__.push({__V:c}),Fe.__[Ke]}function p(Ke){return o$1=1,y$1(B$2,Ke)}function y$1(Ke,Re,Fe){var We=d(t++,2);if(We.t=Ke,!We.__c&&(We.__=[Fe?Fe(Re):B$2(void 0,Re),function(Ze){var Xe=We.__N?We.__N[0]:We.__[0],Je=We.t(Xe,Ze);Xe!==Je&&(We.__N=[Je,We.__[1]],We.__c.setState({}))}],We.__c=r,!r.u)){r.u=!0;var qe=r.shouldComponentUpdate;r.shouldComponentUpdate=function(Ze,Xe,Je){if(!We.__c.__H)return!0;var tr=We.__c.__H.__.filter(function(ir){return ir.__c});if(tr.every(function(ir){return!ir.__N}))return!qe||qe.call(this,Ze,Xe,Je);var er=!1;return tr.forEach(function(ir){if(ir.__N){var lr=ir.__[0];ir.__=ir.__N,ir.__N=void 0,lr!==ir.__[0]&&(er=!0)}}),!(!er&&We.__c.props===Ze)&&(!qe||qe.call(this,Ze,Xe,Je))}}return We.__N||We.__}function h(Ke,Re){var Fe=d(t++,3);!l$1.__s&&z$2(Fe.__H,Re)&&(Fe.__=Ke,Fe.i=Re,r.__H.__h.push(Fe))}function s$1(Ke,Re){var Fe=d(t++,4);!l$1.__s&&z$2(Fe.__H,Re)&&(Fe.__=Ke,Fe.i=Re,r.__h.push(Fe))}function _$2(Ke){return o$1=5,F$2(function(){return{current:Ke}},[])}function A$2(Ke,Re,Fe){o$1=6,s$1(function(){return typeof Ke=="function"?(Ke(Re()),function(){return Ke(null)}):Ke?(Ke.current=Re(),function(){return Ke.current=null}):void 0},Fe==null?Fe:Fe.concat(Ke))}function F$2(Ke,Re){var Fe=d(t++,7);return z$2(Fe.__H,Re)?(Fe.__V=Ke(),Fe.i=Re,Fe.__h=Ke,Fe.__V):Fe.__}function T$2(Ke,Re){return o$1=8,F$2(function(){return Ke},Re)}function q$2(Ke){var Re=r.context[Ke.__c],Fe=d(t++,9);return Fe.c=Ke,Re?(Fe.__==null&&(Fe.__=!0,Re.sub(r)),Re.props.value):Ke.__}function x$2(Ke,Re){l$1.useDebugValue&&l$1.useDebugValue(Re?Re(Ke):Ke)}function V$2(){var Ke=d(t++,11);return Ke.__||(Ke.__="P"+function(Re){for(var Fe=0,We=Re.length;We>0;)Fe=(Fe<<5)-Fe+Re.charCodeAt(--We)|0;return Fe}(r.__v.__m)+t),Ke.__}function b$1(){for(var Ke;Ke=f$1.shift();)if(Ke.__P&&Ke.__H)try{Ke.__H.__h.forEach(k$2),Ke.__H.__h.forEach(w$2),Ke.__H.__h=[]}catch(Re){Ke.__H.__h=[],l$1.__e(Re,Ke.__v)}}l$1.__b=function(Ke){typeof Ke.type!="function"||Ke.__m||Ke.__===null?Ke.__m||(Ke.__m=Ke.__&&Ke.__.__m?Ke.__.__m:""):Ke.__m=(Ke.__&&Ke.__.__m?Ke.__.__m:"")+(Ke.__&&Ke.__.__k?Ke.__.__k.indexOf(Ke):0),r=null,e&&e(Ke)},l$1.__r=function(Ke){a&&a(Ke),t=0;var Re=(r=Ke.__c).__H;Re&&(u$1===r?(Re.__h=[],r.__h=[],Re.__.forEach(function(Fe){Fe.__N&&(Fe.__=Fe.__N),Fe.__V=c,Fe.__N=Fe.i=void 0})):(Re.__h.forEach(k$2),Re.__h.forEach(w$2),Re.__h=[])),u$1=r},l$1.diffed=function(Ke){v$1&&v$1(Ke);var Re=Ke.__c;Re&&Re.__H&&(Re.__H.__h.length&&(f$1.push(Re)!==1&&i$1===l$1.requestAnimationFrame||((i$1=l$1.requestAnimationFrame)||j$2)(b$1)),Re.__H.__.forEach(function(Fe){Fe.i&&(Fe.__H=Fe.i),Fe.__V!==c&&(Fe.__=Fe.__V),Fe.i=void 0,Fe.__V=c})),u$1=r=null},l$1.__c=function(Ke,Re){Re.some(function(Fe){try{Fe.__h.forEach(k$2),Fe.__h=Fe.__h.filter(function(We){return!We.__||w$2(We)})}catch(We){Re.some(function(qe){qe.__h&&(qe.__h=[])}),Re=[],l$1.__e(We,Fe.__v)}}),l&&l(Ke,Re)},l$1.unmount=function(Ke){m&&m(Ke);var Re,Fe=Ke.__c;Fe&&Fe.__H&&(Fe.__H.__.forEach(function(We){try{k$2(We)}catch(qe){Re=qe}}),Fe.__H=void 0,Re&&l$1.__e(Re,Fe.__v))};var g$1=typeof requestAnimationFrame=="function";function j$2(Ke){var Re,Fe=function(){clearTimeout(We),g$1&&cancelAnimationFrame(Re),setTimeout(Ke)},We=setTimeout(Fe,100);g$1&&(Re=requestAnimationFrame(Fe))}function k$2(Ke){var Re=r,Fe=Ke.__c;typeof Fe=="function"&&(Ke.__c=void 0,Fe()),r=Re}function w$2(Ke){var Re=r;Ke.__c=Ke.__(),r=Re}function z$2(Ke,Re){return!Ke||Ke.length!==Re.length||Re.some(function(Fe,We){return Fe!==Ke[We]})}function B$2(Ke,Re){return typeof Re=="function"?Re(Ke):Re}function _extends(){return _extends=Object.assign?Object.assign.bind():function(Ke){for(var Re=1;Re<arguments.length;Re++){var Fe=arguments[Re];for(var We in Fe)Object.prototype.hasOwnProperty.call(Fe,We)&&(Ke[We]=Fe[We])}return Ke},_extends.apply(this,arguments)}function _objectWithoutPropertiesLoose(Ke,Re){if(Ke==null)return{};var Fe={},We=Object.keys(Ke),qe,Ze;for(Ze=0;Ze<We.length;Ze++)qe=We[Ze],!(Re.indexOf(qe)>=0)&&(Fe[qe]=Ke[qe]);return Fe}function g(Ke,Re){for(var Fe in Re)Ke[Fe]=Re[Fe];return Ke}function C$1(Ke,Re){for(var Fe in Ke)if(Fe!=="__source"&&!(Fe in Re))return!0;for(var We in Re)if(We!=="__source"&&Ke[We]!==Re[We])return!0;return!1}function E$1(Ke){this.props=Ke}function w$1(Ke,Re){function Fe(qe){var Ze=this.props.ref,Xe=Ze==qe.ref;return!Xe&&Ze&&(Ze.call?Ze(null):Ze.current=null),Re?!Re(this.props,qe)||!Xe:C$1(this.props,qe)}function We(qe){return this.shouldComponentUpdate=Fe,h$1(Ke,qe)}return We.displayName="Memo("+(Ke.displayName||Ke.name)+")",We.prototype.isReactComponent=!0,We.__f=!0,We}(E$1.prototype=new d$1).isPureReactComponent=!0,E$1.prototype.shouldComponentUpdate=function(Ke,Re){return C$1(this.props,Ke)||C$1(this.state,Re)};var R$1=l$1.__b;l$1.__b=function(Ke){Ke.type&&Ke.type.__f&&Ke.ref&&(Ke.props.ref=Ke.ref,Ke.ref=null),R$1&&R$1(Ke)};var x$1=typeof Symbol<"u"&&Symbol.for&&Symbol.for("react.forward_ref")||3911;function N$1(Ke){function Re(Fe){var We=g({},Fe);return delete We.ref,Ke(We,Fe.ref||null)}return Re.$$typeof=x$1,Re.render=Re,Re.prototype.isReactComponent=Re.__f=!0,Re.displayName="ForwardRef("+(Ke.displayName||Ke.name)+")",Re}var k$1=function(Ke,Re){return Ke==null?null:x$3(x$3(Ke).map(Re))},A$1={map:k$1,forEach:k$1,count:function(Ke){return Ke?x$3(Ke).length:0},only:function(Ke){var Re=x$3(Ke);if(Re.length!==1)throw"Children.only";return Re[0]},toArray:x$3},O$1=l$1.__e;l$1.__e=function(Ke,Re,Fe,We){if(Ke.then){for(var qe,Ze=Re;Ze=Ze.__;)if((qe=Ze.__c)&&qe.__c)return Re.__e==null&&(Re.__e=Fe.__e,Re.__k=Fe.__k),qe.__c(Ke,Re)}O$1(Ke,Re,Fe,We)};var T$1=l$1.unmount;function I$1(Ke,Re,Fe){return Ke&&(Ke.__c&&Ke.__c.__H&&(Ke.__c.__H.__.forEach(function(We){typeof We.__c=="function"&&We.__c()}),Ke.__c.__H=null),(Ke=g({},Ke)).__c!=null&&(Ke.__c.__P===Fe&&(Ke.__c.__P=Re),Ke.__c=null),Ke.__k=Ke.__k&&Ke.__k.map(function(We){return I$1(We,Re,Fe)})),Ke}function L$1(Ke,Re,Fe){return Ke&&(Ke.__v=null,Ke.__k=Ke.__k&&Ke.__k.map(function(We){return L$1(We,Re,Fe)}),Ke.__c&&Ke.__c.__P===Re&&(Ke.__e&&Fe.insertBefore(Ke.__e,Ke.__d),Ke.__c.__e=!0,Ke.__c.__P=Fe)),Ke}function U$1(){this.__u=0,this.t=null,this.__b=null}function D$1(Ke){var Re=Ke.__.__c;return Re&&Re.__a&&Re.__a(Ke)}function F$1(Ke){var Re,Fe,We;function qe(Ze){if(Re||(Re=Ke()).then(function(Xe){Fe=Xe.default||Xe},function(Xe){We=Xe}),We)throw We;if(!Fe)throw Re;return h$1(Fe,Ze)}return qe.displayName="Lazy",qe.__f=!0,qe}function M$1(){this.u=null,this.o=null}l$1.unmount=function(Ke){var Re=Ke.__c;Re&&Re.__R&&Re.__R(),Re&&Ke.__h===!0&&(Ke.type=null),T$1&&T$1(Ke)},(U$1.prototype=new d$1).__c=function(Ke,Re){var Fe=Re.__c,We=this;We.t==null&&(We.t=[]),We.t.push(Fe);var qe=D$1(We.__v),Ze=!1,Xe=function(){Ze||(Ze=!0,Fe.__R=null,qe?qe(Je):Je())};Fe.__R=Xe;var Je=function(){if(!--We.__u){if(We.state.__a){var er=We.state.__a;We.__v.__k[0]=L$1(er,er.__c.__P,er.__c.__O)}var ir;for(We.setState({__a:We.__b=null});ir=We.t.pop();)ir.forceUpdate()}},tr=Re.__h===!0;We.__u++||tr||We.setState({__a:We.__b=We.__v.__k[0]}),Ke.then(Xe,Xe)},U$1.prototype.componentWillUnmount=function(){this.t=[]},U$1.prototype.render=function(Ke,Re){if(this.__b){if(this.__v.__k){var Fe=document.createElement("div"),We=this.__v.__k[0].__c;this.__v.__k[0]=I$1(this.__b,Fe,We.__O=We.__P)}this.__b=null}var qe=Re.__a&&h$1(p$1,null,Ke.fallback);return qe&&(qe.__h=null),[h$1(p$1,null,Re.__a?null:Ke.children),qe]};var V$1=function(Ke,Re,Fe){if(++Fe[1]===Fe[0]&&Ke.o.delete(Re),Ke.props.revealOrder&&(Ke.props.revealOrder[0]!=="t"||!Ke.o.size))for(Fe=Ke.u;Fe;){for(;Fe.length>3;)Fe.pop()();if(Fe[1]<Fe[0])break;Ke.u=Fe=Fe[2]}};function W$1(Ke){return this.getChildContext=function(){return Ke.context},Ke.children}function P$1(Ke){var Re=this,Fe=Ke.i;Re.componentWillUnmount=function(){P$2(null,Re.l),Re.l=null,Re.i=null},Re.i&&Re.i!==Fe&&Re.componentWillUnmount(),Ke.__v?(Re.l||(Re.i=Fe,Re.l={nodeType:1,parentNode:Fe,childNodes:[],appendChild:function(We){this.childNodes.push(We),Re.i.appendChild(We)},insertBefore:function(We,qe){this.childNodes.push(We),Re.i.appendChild(We)},removeChild:function(We){this.childNodes.splice(this.childNodes.indexOf(We)>>>1,1),Re.i.removeChild(We)}}),P$2(h$1(W$1,{context:Re.context},Ke.__v),Re.l)):Re.l&&Re.componentWillUnmount()}function $$1(Ke,Re){var Fe=h$1(P$1,{__v:Ke,i:Re});return Fe.containerInfo=Re,Fe}(M$1.prototype=new d$1).__a=function(Ke){var Re=this,Fe=D$1(Re.__v),We=Re.o.get(Ke);return We[0]++,function(qe){var Ze=function(){Re.props.revealOrder?(We.push(qe),V$1(Re,Ke,We)):qe()};Fe?Fe(Ze):Ze()}},M$1.prototype.render=function(Ke){this.u=null,this.o=new Map;var Re=x$3(Ke.children);Ke.revealOrder&&Ke.revealOrder[0]==="b"&&Re.reverse();for(var Fe=Re.length;Fe--;)this.o.set(Re[Fe],this.u=[1,0,this.u]);return Ke.children},M$1.prototype.componentDidUpdate=M$1.prototype.componentDidMount=function(){var Ke=this;this.o.forEach(function(Re,Fe){V$1(Ke,Fe,Re)})};var j$1=typeof Symbol<"u"&&Symbol.for&&Symbol.for("react.element")||60103,z$1=/^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|dominant|fill|flood|font|glyph(?!R)|horiz|image|letter|lighting|marker(?!H|W|U)|overline|paint|pointer|shape|stop|strikethrough|stroke|text(?!L)|transform|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/,B$1=typeof document<"u",H$1=function(Ke){return(typeof Symbol<"u"&&typeof Symbol()=="symbol"?/fil|che|rad/i:/fil|che|ra/i).test(Ke)};function Z$1(Ke,Re,Fe){return Re.__k==null&&(Re.textContent=""),P$2(Ke,Re),typeof Fe=="function"&&Fe(),Ke?Ke.__c:null}function Y$1(Ke,Re,Fe){return S$1(Ke,Re),typeof Fe=="function"&&Fe(),Ke?Ke.__c:null}d$1.prototype.isReactComponent={},["componentWillMount","componentWillReceiveProps","componentWillUpdate"].forEach(function(Ke){Object.defineProperty(d$1.prototype,Ke,{configurable:!0,get:function(){return this["UNSAFE_"+Ke]},set:function(Re){Object.defineProperty(this,Ke,{configurable:!0,writable:!0,value:Re})}})});var q$1=l$1.event;function G$1(){}function J$1(){return this.cancelBubble}function K$1(){return this.defaultPrevented}l$1.event=function(Ke){return q$1&&(Ke=q$1(Ke)),Ke.persist=G$1,Ke.isPropagationStopped=J$1,Ke.isDefaultPrevented=K$1,Ke.nativeEvent=Ke};var Q$1,X$1={configurable:!0,get:function(){return this.class}},nn$1=l$1.vnode;l$1.vnode=function(Ke){var Re=Ke.type,Fe=Ke.props,We=Fe;if(typeof Re=="string"){var qe=Re.indexOf("-")===-1;for(var Ze in We={},Fe){var Xe=Fe[Ze];B$1&&Ze==="children"&&Re==="noscript"||Ze==="value"&&"defaultValue"in Fe&&Xe==null||(Ze==="defaultValue"&&"value"in Fe&&Fe.value==null?Ze="value":Ze==="download"&&Xe===!0?Xe="":/ondoubleclick/i.test(Ze)?Ze="ondblclick":/^onchange(textarea|input)/i.test(Ze+Re)&&!H$1(Fe.type)?Ze="oninput":/^onfocus$/i.test(Ze)?Ze="onfocusin":/^onblur$/i.test(Ze)?Ze="onfocusout":/^on(Ani|Tra|Tou|BeforeInp|Compo)/.test(Ze)?Ze=Ze.toLowerCase():qe&&z$1.test(Ze)?Ze=Ze.replace(/[A-Z0-9]/g,"-$&").toLowerCase():Xe===null&&(Xe=void 0),/^oninput$/i.test(Ze)&&(Ze=Ze.toLowerCase(),We[Ze]&&(Ze="oninputCapture")),We[Ze]=Xe)}Re=="select"&&We.multiple&&Array.isArray(We.value)&&(We.value=x$3(Fe.children).forEach(function(Je){Je.props.selected=We.value.indexOf(Je.props.value)!=-1})),Re=="select"&&We.defaultValue!=null&&(We.value=x$3(Fe.children).forEach(function(Je){Je.props.selected=We.multiple?We.defaultValue.indexOf(Je.props.value)!=-1:We.defaultValue==Je.props.value})),Ke.props=We,Fe.class!=Fe.className&&(X$1.enumerable="className"in Fe,Fe.className!=null&&(We.class=Fe.className),Object.defineProperty(We,"className",X$1))}Ke.$$typeof=j$1,nn$1&&nn$1(Ke)};var tn$1=l$1.__r;l$1.__r=function(Ke){tn$1&&tn$1(Ke),Q$1=Ke.__c};var en$1={ReactCurrentDispatcher:{current:{readContext:function(Ke){return Q$1.__n[Ke.__c].props.value}}}};function un$1(Ke){return h$1.bind(null,Ke)}function on$1(Ke){return!!Ke&&Ke.$$typeof===j$1}function ln$1(Ke){return on$1(Ke)?q$3.apply(null,arguments):Ke}function cn$1(Ke){return!!Ke.__k&&(P$2(null,Ke),!0)}function fn$1(Ke){return Ke&&(Ke.base||Ke.nodeType===1&&Ke)||null}var an$1=function(Ke,Re){return Ke(Re)},sn$1=function(Ke,Re){return Ke(Re)},hn$1=p$1;function vn$1(Ke){Ke()}function dn$1(Ke){return Ke}function pn$1(){return[!1,vn$1]}var mn$1=s$1;function yn(Ke,Re){var Fe=Re(),We=p({h:{__:Fe,v:Re}}),qe=We[0].h,Ze=We[1];return s$1(function(){qe.__=Fe,qe.v=Re,qe.__!==Re()&&Ze({h:qe})},[Ke,Fe,Re]),h(function(){return qe.__!==qe.v()&&Ze({h:qe}),Ke(function(){qe.__!==qe.v()&&Ze({h:qe})})},[Ke]),Fe}var _n$1={useState:p,useId:V$2,useReducer:y$1,useEffect:h,useLayoutEffect:s$1,useInsertionEffect:mn$1,useTransition:pn$1,useDeferredValue:dn$1,useSyncExternalStore:yn,startTransition:vn$1,useRef:_$2,useImperativeHandle:A$2,useMemo:F$2,useCallback:T$2,useContext:q$2,useDebugValue:x$2,version:"17.0.2",Children:A$1,render:Z$1,hydrate:Y$1,unmountComponentAtNode:cn$1,createPortal:$$1,createElement:h$1,createContext:B$3,createFactory:un$1,cloneElement:ln$1,createRef:y$2,Fragment:p$1,isValidElement:on$1,findDOMNode:fn$1,Component:d$1,PureComponent:E$1,memo:w$1,forwardRef:N$1,flushSync:sn$1,unstable_batchedUpdates:an$1,StrictMode:hn$1,Suspense:U$1,SuspenseList:M$1,lazy:F$1,__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED:en$1},charCodeOfDot=".".charCodeAt(0),reEscapeChar=/\\(\\)?/g,rePropName=RegExp(`[^.[\\]]+|\\[(?:([^"'][^[]*)|(["'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))`,"g"),stringToPath=function(Re){var Fe=[];return Re.charCodeAt(0)===charCodeOfDot&&Fe.push(""),Re.replace(rePropName,function(We,qe,Ze,Xe){var Je=We;Ze?Je=Xe.replace(reEscapeChar,"$1"):qe&&(Je=qe.trim()),Fe.push(Je)}),Fe},keysCache={},toPath=function(Re){if(Re==null||!Re.length)return[];if(typeof Re!="string")throw new Error("toPath() expects a string");return keysCache[Re]==null&&(keysCache[Re]=stringToPath(Re)),keysCache[Re]},getIn=function(Re,Fe){for(var We=toPath(Fe),qe=Re,Ze=0;Ze<We.length;Ze++){var Xe=We[Ze];if(qe==null||typeof qe!="object"||Array.isArray(qe)&&isNaN(Xe))return;qe=qe[Xe]}return qe};function _toPropertyKey(Ke){var Re=_toPrimitive(Ke,"string");return typeof Re=="symbol"?Re:String(Re)}function _toPrimitive(Ke,Re){if(typeof Ke!="object"||Ke===null)return Ke;var Fe=Ke[Symbol.toPrimitive];if(Fe!==void 0){var We=Fe.call(Ke,Re||"default");if(typeof We!="object")return We;throw new TypeError("@@toPrimitive must return a primitive value.")}return(Re==="string"?String:Number)(Ke)}var setInRecursor=function Ke(Re,Fe,We,qe,Ze){if(Fe>=We.length)return qe;var Xe=We[Fe];if(isNaN(Xe)){var Je;if(Re==null){var tr,er=Ke(void 0,Fe+1,We,qe,Ze);return er===void 0?void 0:(tr={},tr[Xe]=er,tr)}if(Array.isArray(Re))throw new Error("Cannot set a non-numeric property on an array");var ir=Ke(Re[Xe],Fe+1,We,qe,Ze);if(ir===void 0){var lr=Object.keys(Re).length;if(Re[Xe]===void 0&&lr===0)return;if(Re[Xe]!==void 0&&lr<=1)return!isNaN(We[Fe-1])&&!Ze?{}:void 0;Re[Xe];var fr=_objectWithoutPropertiesLoose(Re,[Xe].map(_toPropertyKey));return fr}return _extends({},Re,(Je={},Je[Xe]=ir,Je))}var ur=Number(Xe);if(Re==null){var mr=Ke(void 0,Fe+1,We,qe,Ze);if(mr===void 0)return;var br=[];return br[ur]=mr,br}if(!Array.isArray(Re))throw new Error("Cannot set a numeric property on an object");var wr=Re[ur],Sr=Ke(wr,Fe+1,We,qe,Ze),kr=[].concat(Re);if(Ze&&Sr===void 0){if(kr.splice(ur,1),kr.length===0)return}else kr[ur]=Sr;return kr},setIn=function(Re,Fe,We,qe){if(qe===void 0&&(qe=!1),Re==null)throw new Error("Cannot call setIn() with "+String(Re)+" state");if(Fe==null)throw new Error("Cannot call setIn() with "+String(Fe)+" key");return setInRecursor(Re,0,toPath(Fe),We,qe)},FORM_ERROR="FINAL_FORM/form-error",ARRAY_ERROR="FINAL_FORM/array-error";function publishFieldState(Ke,Re){var Fe=Ke.errors,We=Ke.initialValues,qe=Ke.lastSubmittedValues,Ze=Ke.submitErrors,Xe=Ke.submitFailed,Je=Ke.submitSucceeded,tr=Ke.submitting,er=Ke.values,ir=Re.active,lr=Re.blur,fr=Re.change,ur=Re.data,mr=Re.focus,br=Re.modified,wr=Re.modifiedSinceLastSubmit,Sr=Re.name,kr=Re.touched,Er=Re.validating,Ir=Re.visited,Rr=getIn(er,Sr),Pr=getIn(Fe,Sr);Pr&&Pr[ARRAY_ERROR]&&(Pr=Pr[ARRAY_ERROR]);var Br=Ze&&getIn(Ze,Sr),Or=We&&getIn(We,Sr),Nr=Re.isEqual(Or,Rr),Cr=!!(qe&&!Re.isEqual(getIn(qe,Sr),Rr)),Tr=!Pr&&!Br;return{active:ir,blur:lr,change:fr,data:ur,dirty:!Nr,dirtySinceLastSubmit:Cr,error:Pr,focus:mr,initial:Or,invalid:!Tr,length:Array.isArray(Rr)?Rr.length:void 0,modified:br,modifiedSinceLastSubmit:wr,name:Sr,pristine:Nr,submitError:Br,submitFailed:Xe,submitSucceeded:Je,submitting:tr,touched:kr,valid:Tr,value:Rr,visited:Ir,validating:Er}}var fieldSubscriptionItems=["active","data","dirty","dirtySinceLastSubmit","error","initial","invalid","length","modified","modifiedSinceLastSubmit","pristine","submitError","submitFailed","submitSucceeded","submitting","touched","valid","value","visited","validating"],shallowEqual$1=function(Re,Fe){if(Re===Fe)return!0;if(typeof Re!="object"||!Re||typeof Fe!="object"||!Fe)return!1;var We=Object.keys(Re),qe=Object.keys(Fe);if(We.length!==qe.length)return!1;for(var Ze=Object.prototype.hasOwnProperty.bind(Fe),Xe=0;Xe<We.length;Xe++){var Je=We[Xe];if(!Ze(Je)||Re[Je]!==Fe[Je])return!1}return!0};function subscriptionFilter(Ke,Re,Fe,We,qe,Ze){var Xe=!1;return qe.forEach(function(Je){We[Je]&&(Ke[Je]=Re[Je],(!Fe||(~Ze.indexOf(Je)?!shallowEqual$1(Re[Je],Fe[Je]):Re[Je]!==Fe[Je]))&&(Xe=!0))}),Xe}var shallowEqualKeys$1=["data"],filterFieldState=function(Re,Fe,We,qe){var Ze={blur:Re.blur,change:Re.change,focus:Re.focus,name:Re.name},Xe=subscriptionFilter(Ze,Re,Fe,We,fieldSubscriptionItems,shallowEqualKeys$1)||!Fe;return Xe||qe?Ze:void 0},formSubscriptionItems=["active","dirty","dirtyFields","dirtyFieldsSinceLastSubmit","dirtySinceLastSubmit","error","errors","hasSubmitErrors","hasValidationErrors","initialValues","invalid","modified","modifiedSinceLastSubmit","pristine","submitting","submitError","submitErrors","submitFailed","submitSucceeded","touched","valid","validating","values","visited"],shallowEqualKeys=["touched","visited"];function filterFormState(Ke,Re,Fe,We){var qe={},Ze=subscriptionFilter(qe,Ke,Re,Fe,formSubscriptionItems,shallowEqualKeys)||!Re;return Ze||We?qe:void 0}var memoize=function(Re){var Fe,We;return function(){for(var qe=arguments.length,Ze=new Array(qe),Xe=0;Xe<qe;Xe++)Ze[Xe]=arguments[Xe];return(!Fe||Ze.length!==Fe.length||Ze.some(function(Je,tr){return!shallowEqual$1(Fe[tr],Je)}))&&(Fe=Ze,We=Re.apply(void 0,Ze)),We}},isPromise=function(Ke){return!!Ke&&(typeof Ke=="object"||typeof Ke=="function")&&typeof Ke.then=="function"},version$2="4.20.7",tripleEquals=function(Re,Fe){return Re===Fe},hasAnyError=function Ke(Re){return Object.keys(Re).some(function(Fe){var We=Re[Fe];return We&&typeof We=="object"&&!(We instanceof Error)?Ke(We):typeof We<"u"})};function convertToExternalFormState(Ke){var Re=Ke.active,Fe=Ke.dirtySinceLastSubmit,We=Ke.modifiedSinceLastSubmit,qe=Ke.error,Ze=Ke.errors,Xe=Ke.initialValues,Je=Ke.pristine,tr=Ke.submitting,er=Ke.submitFailed,ir=Ke.submitSucceeded,lr=Ke.submitError,fr=Ke.submitErrors,ur=Ke.valid,mr=Ke.validating,br=Ke.values;return{active:Re,dirty:!Je,dirtySinceLastSubmit:Fe,modifiedSinceLastSubmit:We,error:qe,errors:Ze,hasSubmitErrors:!!(lr||fr&&hasAnyError(fr)),hasValidationErrors:!!(qe||hasAnyError(Ze)),invalid:!ur,initialValues:Xe,pristine:Je,submitting:tr,submitFailed:er,submitSucceeded:ir,submitError:lr,submitErrors:fr,valid:ur,validating:mr>0,values:br}}function notifySubscriber(Ke,Re,Fe,We,qe,Ze){var Xe=qe(Fe,We,Re,Ze);return Xe?(Ke(Xe),!0):!1}function notify(Ke,Re,Fe,We,qe){var Ze=Ke.entries;Object.keys(Ze).forEach(function(Xe){var Je=Ze[Number(Xe)];if(Je){var tr=Je.subscription,er=Je.subscriber,ir=Je.notified;notifySubscriber(er,tr,Re,Fe,We,qe||!ir)&&(Je.notified=!0)}})}function createForm(Ke){if(!Ke)throw new Error("No config specified");var Re=Ke.debug,Fe=Ke.destroyOnUnregister,We=Ke.keepDirtyOnReinitialize,qe=Ke.initialValues,Ze=Ke.mutators,Xe=Ke.onSubmit,Je=Ke.validate,tr=Ke.validateOnBlur;if(!Xe)throw new Error("No onSubmit function specified");var er={subscribers:{index:0,entries:{}},fieldSubscribers:{},fields:{},formState:{asyncErrors:{},dirtySinceLastSubmit:!1,modifiedSinceLastSubmit:!1,errors:{},initialValues:qe&&_extends({},qe),invalid:!1,pristine:!0,submitting:!1,submitFailed:!1,submitSucceeded:!1,resetWhileSubmitting:!1,valid:!0,validating:0,values:qe?_extends({},qe):{}},lastFormState:void 0},ir=0,lr=!1,fr=!1,ur=!1,mr=0,br={},wr=function(rr){return function(hr){return delete br[rr],hr}},Sr=function(rr,hr,$r){var Lr=getIn(rr.formState.values,hr),Ur=$r(Lr);rr.formState.values=setIn(rr.formState.values,hr,Ur)||{}},kr=function(rr,hr,$r){if(rr.fields[hr]){var Lr,Ur;rr.fields=_extends({},rr.fields,(Lr={},Lr[$r]=_extends({},rr.fields[hr],{name:$r,blur:function(){return Ar.blur($r)},change:function(zr){return Ar.change($r,zr)},focus:function(){return Ar.focus($r)},lastFieldState:void 0}),Lr)),delete rr.fields[hr],rr.fieldSubscribers=_extends({},rr.fieldSubscribers,(Ur={},Ur[$r]=rr.fieldSubscribers[hr],Ur)),delete rr.fieldSubscribers[hr];var Wr=getIn(rr.formState.values,hr);rr.formState.values=setIn(rr.formState.values,hr,void 0)||{},rr.formState.values=setIn(rr.formState.values,$r,Wr),delete rr.lastFormState}},Er=function(rr){return function(){if(Ze){for(var hr={formState:er.formState,fields:er.fields,fieldSubscribers:er.fieldSubscribers,lastFormState:er.lastFormState},$r=arguments.length,Lr=new Array($r),Ur=0;Ur<$r;Ur++)Lr[Ur]=arguments[Ur];var Wr=Ze[rr](Lr,hr,{changeValue:Sr,getIn,renameField:kr,resetFieldState:Ar.resetFieldState,setIn,shallowEqual:shallowEqual$1});return er.formState=hr.formState,er.fields=hr.fields,er.fieldSubscribers=hr.fieldSubscribers,er.lastFormState=hr.lastFormState,Or(void 0,function(){Nr(),cr()}),Wr}}},Ir=Ze?Object.keys(Ze).reduce(function(pr,rr){return pr[rr]=Er(rr),pr},{}):{},Rr=function(rr){var hr=[];if(Je){var $r=Je(_extends({},er.formState.values));isPromise($r)?hr.push($r.then(function(Lr){return rr(Lr,!0)})):rr($r,!1)}return hr},Pr=function(rr){return Object.keys(rr.validators).reduce(function(hr,$r){var Lr=rr.validators[Number($r)]();return Lr&&hr.push(Lr),hr},[])},Br=function(rr,hr){var $r=[],Lr=Pr(rr);if(Lr.length){var Ur;Lr.forEach(function(Wr){var Fr=Wr(getIn(er.formState.values,rr.name),er.formState.values,Wr.length===0||Wr.length===3?publishFieldState(er.formState,er.fields[rr.name]):void 0);if(Fr&&isPromise(Fr)){rr.validating=!0;var zr=Fr.then(function(Yr){er.fields[rr.name]&&(er.fields[rr.name].validating=!1,hr(Yr))});$r.push(zr)}else Ur||(Ur=Fr)}),hr(Ur)}return $r},Or=function(rr,hr){if(lr){fr=!0,hr();return}var $r=er.fields,Lr=er.formState,Ur=_extends({},$r),Wr=Object.keys(Ur);if(!Je&&!Wr.some(function($n){return Pr(Ur[$n]).length})){hr();return}var Fr=!1;if(rr){var zr=Ur[rr];if(zr){var Yr=zr.validateFields;Yr&&(Fr=!0,Wr=Yr.length?Yr.concat(rr):[rr])}}var qr={},Gr={},Hn={},Xr=[].concat(Rr(function($n,Jr){Jr?Gr=$n||{}:qr=$n||{}}),Wr.reduce(function($n,Jr){return $n.concat(Br($r[Jr],function(Cn){Hn[Jr]=Cn}))},[])),Zr=Xr.length>0,qn=++mr,Qr=Promise.all(Xr).then(wr(qn));Zr&&(br[qn]=Qr);var jn=function(Jr){var Cn=_extends({},Fr?Lr.errors:{},qr,Jr?Gr:Lr.asyncErrors),Fn=function(Wn){Wr.forEach(function(Un){if($r[Un]){var nr=getIn(qr,Un),Qe=getIn(Cn,Un),dt=Pr(Ur[Un]).length,or=Hn[Un];Wn(Un,dt&&or||Je&&nr||(!nr&&!Fr?Qe:void 0))}})};Fn(function(Kn,Wn){Cn=setIn(Cn,Kn,Wn)||{}}),Fn(function(Kn,Wn){if(Wn&&Wn[ARRAY_ERROR]){var Un=getIn(Cn,Kn),nr=[].concat(Un);nr[ARRAY_ERROR]=Wn[ARRAY_ERROR],Cn=setIn(Cn,Kn,nr)}}),shallowEqual$1(Lr.errors,Cn)||(Lr.errors=Cn),Jr&&(Lr.asyncErrors=Gr),Lr.error=qr[FORM_ERROR]};if(Zr&&(er.formState.validating++,hr()),jn(!1),hr(),Zr){var fi=function(){er.formState.validating--,hr()};Qr.then(function(){mr>qn||jn(!0)}).then(fi,fi)}},Nr=function(rr){if(!ir){var hr=er.fields,$r=er.fieldSubscribers,Lr=er.formState,Ur=_extends({},hr),Wr=function(zr){var Yr=Ur[zr],qr=publishFieldState(Lr,Yr),Gr=Yr.lastFieldState;Yr.lastFieldState=qr;var Hn=$r[zr];Hn&&notify(Hn,qr,Gr,filterFieldState,Gr===void 0)};rr?Wr(rr):Object.keys(Ur).forEach(Wr)}},Cr=function(){Object.keys(er.fields).forEach(function(rr){er.fields[rr].touched=!0})},Tr=function(){return!!(er.formState.error||hasAnyError(er.formState.errors))},Mr=function(){var rr=er.fields,hr=er.formState,$r=er.lastFormState,Lr=_extends({},rr),Ur=Object.keys(Lr),Wr=!1,Fr=Ur.reduce(function(Zr,qn){var Qr=!Lr[qn].isEqual(getIn(hr.values,qn),getIn(hr.initialValues||{},qn));return Qr&&(Wr=!0,Zr[qn]=!0),Zr},{}),zr=Ur.reduce(function(Zr,qn){var Qr=hr.lastSubmittedValues||{};return Lr[qn].isEqual(getIn(hr.values,qn),getIn(Qr,qn))||(Zr[qn]=!0),Zr},{});hr.pristine=!Wr,hr.dirtySinceLastSubmit=!!(hr.lastSubmittedValues&&Object.values(zr).some(function(Zr){return Zr})),hr.modifiedSinceLastSubmit=!!(hr.lastSubmittedValues&&Object.keys(Lr).some(function(Zr){return Lr[Zr].modifiedSinceLastSubmit})),hr.valid=!hr.error&&!hr.submitError&&!hasAnyError(hr.errors)&&!(hr.submitErrors&&hasAnyError(hr.submitErrors));var Yr=convertToExternalFormState(hr),qr=Ur.reduce(function(Zr,qn){return Zr.modified[qn]=Lr[qn].modified,Zr.touched[qn]=Lr[qn].touched,Zr.visited[qn]=Lr[qn].visited,Zr},{modified:{},touched:{},visited:{}}),Gr=qr.modified,Hn=qr.touched,Xr=qr.visited;return Yr.dirtyFields=$r&&shallowEqual$1($r.dirtyFields,Fr)?$r.dirtyFields:Fr,Yr.dirtyFieldsSinceLastSubmit=$r&&shallowEqual$1($r.dirtyFieldsSinceLastSubmit,zr)?$r.dirtyFieldsSinceLastSubmit:zr,Yr.modified=$r&&shallowEqual$1($r.modified,Gr)?$r.modified:Gr,Yr.touched=$r&&shallowEqual$1($r.touched,Hn)?$r.touched:Hn,Yr.visited=$r&&shallowEqual$1($r.visited,Xr)?$r.visited:Xr,$r&&shallowEqual$1($r,Yr)?$r:Yr},ar=function(){return Re&&!0&&Re(Mr(),Object.keys(er.fields).reduce(function(rr,hr){return rr[hr]=er.fields[hr],rr},{}))},Dt=!1,sr=!1,cr=function pr(){if(Dt)sr=!0;else{if(Dt=!0,ar(),!ir&&!(lr&&ur)){var rr=er.lastFormState,hr=Mr();hr!==rr&&(er.lastFormState=hr,notify(er.subscribers,hr,rr,filterFormState))}Dt=!1,sr&&(sr=!1,pr())}},yr=function(){return Object.keys(er.fields).some(function(rr){return er.fields[rr].beforeSubmit&&er.fields[rr].beforeSubmit()===!1})},_r=function(){return Object.keys(er.fields).forEach(function(rr){return er.fields[rr].afterSubmit&&er.fields[rr].afterSubmit()})},xr=function(){return Object.keys(er.fields).forEach(function(rr){return er.fields[rr].modifiedSinceLastSubmit=!1})};Or(void 0,function(){cr()});var Ar={batch:function(rr){ir++,rr(),ir--,Nr(),cr()},blur:function(rr){var hr=er.fields,$r=er.formState,Lr=hr[rr];Lr&&(delete $r.active,hr[rr]=_extends({},Lr,{active:!1,touched:!0}),tr?Or(rr,function(){Nr(),cr()}):(Nr(),cr()))},change:function(rr,hr){var $r=er.fields,Lr=er.formState;if(getIn(Lr.values,rr)!==hr){Sr(er,rr,function(){return hr});var Ur=$r[rr];Ur&&($r[rr]=_extends({},Ur,{modified:!0,modifiedSinceLastSubmit:!!Lr.lastSubmittedValues})),tr?(Nr(),cr()):Or(rr,function(){Nr(),cr()})}},get destroyOnUnregister(){return!!Fe},set destroyOnUnregister(pr){Fe=pr},focus:function(rr){var hr=er.fields[rr];hr&&!hr.active&&(er.formState.active=rr,hr.active=!0,hr.visited=!0,Nr(),cr())},mutators:Ir,getFieldState:function(rr){var hr=er.fields[rr];return hr&&hr.lastFieldState},getRegisteredFields:function(){return Object.keys(er.fields)},getState:function(){return Mr()},initialize:function(rr){var hr=er.fields,$r=er.formState,Lr=_extends({},hr),Ur=typeof rr=="function"?rr($r.values):rr;We||($r.values=Ur);var Wr=We?Object.keys(Lr).reduce(function(Fr,zr){var Yr=Lr[zr],qr=Yr.isEqual(getIn($r.values,zr),getIn($r.initialValues||{},zr));return qr||(Fr[zr]=getIn($r.values,zr)),Fr},{}):{};$r.initialValues=Ur,$r.values=Ur,Object.keys(Wr).forEach(function(Fr){$r.values=setIn($r.values,Fr,Wr[Fr])||{}}),Or(void 0,function(){Nr(),cr()})},isValidationPaused:function(){return lr},pauseValidation:function(rr){rr===void 0&&(rr=!0),lr=!0,ur=rr},registerField:function(rr,hr,$r,Lr){$r===void 0&&($r={}),er.fieldSubscribers[rr]||(er.fieldSubscribers[rr]={index:0,entries:{}});var Ur=er.fieldSubscribers[rr].index++;er.fieldSubscribers[rr].entries[Ur]={subscriber:memoize(hr),subscription:$r,notified:!1},er.fields[rr]||(er.fields[rr]={active:!1,afterSubmit:Lr&&Lr.afterSubmit,beforeSubmit:Lr&&Lr.beforeSubmit,blur:function(){return Ar.blur(rr)},change:function(Gr){return Ar.change(rr,Gr)},data:Lr&&Lr.data||{},focus:function(){return Ar.focus(rr)},isEqual:Lr&&Lr.isEqual||tripleEquals,lastFieldState:void 0,modified:!1,modifiedSinceLastSubmit:!1,name:rr,touched:!1,valid:!0,validateFields:Lr&&Lr.validateFields,validators:{},validating:!1,visited:!1});var Wr=!1,Fr=Lr&&Lr.silent,zr=function(){Fr?Nr(rr):(cr(),Nr())};if(Lr){Wr=!!(Lr.getValidator&&Lr.getValidator()),Lr.getValidator&&(er.fields[rr].validators[Ur]=Lr.getValidator);var Yr=getIn(er.formState.values,rr)===void 0;Lr.initialValue!==void 0&&(Yr||getIn(er.formState.values,rr)===getIn(er.formState.initialValues,rr))&&(er.formState.initialValues=setIn(er.formState.initialValues||{},rr,Lr.initialValue),er.formState.values=setIn(er.formState.values,rr,Lr.initialValue),Or(void 0,zr)),Lr.defaultValue!==void 0&&Lr.initialValue===void 0&&getIn(er.formState.initialValues,rr)===void 0&&Yr&&(er.formState.values=setIn(er.formState.values,rr,Lr.defaultValue))}return Wr?Or(void 0,zr):zr(),function(){var qr=!1;er.fields[rr]&&(qr=!!(er.fields[rr].validators[Ur]&&er.fields[rr].validators[Ur]()),delete er.fields[rr].validators[Ur]);var Gr=!!er.fieldSubscribers[rr];Gr&&delete er.fieldSubscribers[rr].entries[Ur];var Hn=Gr&&!Object.keys(er.fieldSubscribers[rr].entries).length;Hn&&(delete er.fieldSubscribers[rr],delete er.fields[rr],qr&&(er.formState.errors=setIn(er.formState.errors,rr,void 0)||{}),Fe&&(er.formState.values=setIn(er.formState.values,rr,void 0,!0)||{})),Fr||(qr?Or(void 0,function(){cr(),Nr()}):Hn&&cr())}},reset:function(rr){rr===void 0&&(rr=er.formState.initialValues),er.formState.submitting&&(er.formState.resetWhileSubmitting=!0),er.formState.submitFailed=!1,er.formState.submitSucceeded=!1,delete er.formState.submitError,delete er.formState.submitErrors,delete er.formState.lastSubmittedValues,Ar.initialize(rr||{})},resetFieldState:function(rr){er.fields[rr]=_extends({},er.fields[rr],{active:!1,lastFieldState:void 0,modified:!1,touched:!1,valid:!0,validating:!1,visited:!1}),Or(void 0,function(){Nr(),cr()})},restart:function(rr){rr===void 0&&(rr=er.formState.initialValues),Ar.batch(function(){for(var hr in er.fields)Ar.resetFieldState(hr),er.fields[hr]=_extends({},er.fields[hr],{active:!1,lastFieldState:void 0,modified:!1,modifiedSinceLastSubmit:!1,touched:!1,valid:!0,validating:!1,visited:!1});Ar.reset(rr)})},resumeValidation:function(){lr=!1,ur=!1,fr&&Or(void 0,function(){Nr(),cr()}),fr=!1},setConfig:function(rr,hr){switch(rr){case"debug":Re=hr;break;case"destroyOnUnregister":Fe=hr;break;case"initialValues":Ar.initialize(hr);break;case"keepDirtyOnReinitialize":We=hr;break;case"mutators":Ze=hr,hr?(Object.keys(Ir).forEach(function($r){$r in hr||delete Ir[$r]}),Object.keys(hr).forEach(function($r){Ir[$r]=Er($r)})):Object.keys(Ir).forEach(function($r){delete Ir[$r]});break;case"onSubmit":Xe=hr;break;case"validate":Je=hr,Or(void 0,function(){Nr(),cr()});break;case"validateOnBlur":tr=hr;break;default:throw new Error("Unrecognised option "+rr)}},submit:function(){var rr=er.formState;if(!rr.submitting){if(delete rr.submitErrors,delete rr.submitError,rr.lastSubmittedValues=_extends({},rr.values),Tr()){Cr(),xr(),er.formState.submitFailed=!0,cr(),Nr();return}var hr=Object.keys(br);if(hr.length){Promise.all(hr.map(function(zr){return br[Number(zr)]})).then(Ar.submit,console.error);return}var $r=yr();if(!$r){var Lr,Ur=!1,Wr=function(Yr){rr.submitting=!1;var qr=rr.resetWhileSubmitting;return qr&&(rr.resetWhileSubmitting=!1),Yr&&hasAnyError(Yr)?(rr.submitFailed=!0,rr.submitSucceeded=!1,rr.submitErrors=Yr,rr.submitError=Yr[FORM_ERROR],Cr()):(qr||(rr.submitFailed=!1,rr.submitSucceeded=!0),_r()),cr(),Nr(),Ur=!0,Lr&&Lr(Yr),Yr};rr.submitting=!0,rr.submitFailed=!1,rr.submitSucceeded=!1,rr.lastSubmittedValues=_extends({},rr.values),xr();var Fr=Xe(rr.values,Ar,Wr);if(!Ur){if(Fr&&isPromise(Fr))return cr(),Nr(),Fr.then(Wr,function(zr){throw Wr(),zr});if(Xe.length>=3)return cr(),Nr(),new Promise(function(zr){Lr=zr});Wr(Fr)}}}},subscribe:function(rr,hr){if(!rr)throw new Error("No callback given.");if(!hr)throw new Error("No subscription provided. What values do you want to listen to?");var $r=memoize(rr),Lr=er.subscribers,Ur=Lr.index++;Lr.entries[Ur]={subscriber:$r,subscription:hr,notified:!1};var Wr=Mr();return notifySubscriber($r,hr,Wr,Wr,filterFormState,!0),function(){delete Lr.entries[Ur]}}};return Ar}var _excluded$3=["render","children","component"];function renderComponent(Ke,Re,Fe){var We=Ke.render,qe=Ke.children,Ze=Ke.component,Xe=_objectWithoutPropertiesLoose(Ke,_excluded$3);if(Ze)return h$1(Ze,Object.assign(Re,Xe,{children:qe,render:We}));if(We)return We(qe===void 0?Object.assign(Re,Xe):Object.assign(Re,Xe,{children:qe}));if(typeof qe!="function")throw new Error("Must specify either a render prop, a render function as children, or a component prop to "+Fe);return qe(Object.assign(Re,Xe))}function useWhenValueChanges(Ke,Re,Fe){Fe===void 0&&(Fe=function(Ze,Xe){return Ze===Xe});var We=_n$1.useRef(Ke);_n$1.useEffect(function(){Fe(Ke,We.current)||(Re(),We.current=Ke)})}function useConstant(Ke){var Re=_n$1.useRef();return Re.current||(Re.current=Ke()),Re.current}var shallowEqual=function(Re,Fe){if(Re===Fe)return!0;if(typeof Re!="object"||!Re||typeof Fe!="object"||!Fe)return!1;var We=Object.keys(Re),qe=Object.keys(Fe);if(We.length!==qe.length)return!1;for(var Ze=Object.prototype.hasOwnProperty.bind(Fe),Xe=0;Xe<We.length;Xe++){var Je=We[Xe];if(!Ze(Je)||Re[Je]!==Fe[Je])return!1}return!0},isSyntheticEvent=function(Re){return!!(Re&&typeof Re.stopPropagation=="function")},ReactFinalFormContext=B$3();function useLatest(Ke){var Re=_n$1.useRef(Ke);return _n$1.useEffect(function(){Re.current=Ke}),Re}var version$1="6.5.8",addLazyState=function(Re,Fe,We){We.forEach(function(qe){Object.defineProperty(Re,qe,{get:function(){return Fe[qe]},enumerable:!0})})},addLazyFormState=function(Re,Fe){return addLazyState(Re,Fe,["active","dirty","dirtyFields","dirtySinceLastSubmit","dirtyFieldsSinceLastSubmit","error","errors","hasSubmitErrors","hasValidationErrors","initialValues","invalid","modified","modifiedSinceLastSubmit","pristine","submitError","submitErrors","submitFailed","submitSucceeded","submitting","touched","valid","validating","values","visited"])},addLazyFieldMetaState=function(Re,Fe){return addLazyState(Re,Fe,["active","data","dirty","dirtySinceLastSubmit","error","initial","invalid","length","modified","modifiedSinceLastSubmit","pristine","submitError","submitFailed","submitSucceeded","submitting","touched","valid","validating","visited"])},_excluded$2=["debug","decorators","destroyOnUnregister","form","initialValues","initialValuesEqual","keepDirtyOnReinitialize","mutators","onSubmit","subscription","validate","validateOnBlur"],versions={"final-form":version$2,"react-final-form":version$1},all$1=formSubscriptionItems.reduce(function(Ke,Re){return Ke[Re]=!0,Ke},{});function ReactFinalForm(Ke){var Re=Ke.debug,Fe=Ke.decorators,We=Fe===void 0?[]:Fe,qe=Ke.destroyOnUnregister,Ze=Ke.form,Xe=Ke.initialValues,Je=Ke.initialValuesEqual,tr=Ke.keepDirtyOnReinitialize,er=Ke.mutators,ir=Ke.onSubmit,lr=Ke.subscription,fr=lr===void 0?all$1:lr,ur=Ke.validate,mr=Ke.validateOnBlur,br=_objectWithoutPropertiesLoose(Ke,_excluded$2),wr={debug:Re,destroyOnUnregister:qe,initialValues:Xe,keepDirtyOnReinitialize:tr,mutators:er,onSubmit:ir,validate:ur,validateOnBlur:mr},Sr=useConstant(function(){var Or=Ze||createForm(wr);return Or.pauseValidation(),Or}),kr=p(function(){var Or={};return Sr.subscribe(function(Nr){Or=Nr},fr)(),Or}),Er=kr[0],Ir=kr[1],Rr=useLatest(Er);h(function(){Sr.isValidationPaused()&&Sr.resumeValidation();var Or=[Sr.subscribe(function(Nr){shallowEqual(Nr,Rr.current)||Ir(Nr)},fr)].concat(We?We.map(function(Nr){return Nr(Sr)}):[]);return function(){Sr.pauseValidation(),Or.reverse().forEach(function(Nr){return Nr()})}},We),useWhenValueChanges(Re,function(){Sr.setConfig("debug",Re)}),useWhenValueChanges(qe,function(){Sr.destroyOnUnregister=!!qe}),useWhenValueChanges(tr,function(){Sr.setConfig("keepDirtyOnReinitialize",tr)}),useWhenValueChanges(Xe,function(){Sr.setConfig("initialValues",Xe)},Je||shallowEqual),useWhenValueChanges(er,function(){Sr.setConfig("mutators",er)}),useWhenValueChanges(ir,function(){Sr.setConfig("onSubmit",ir)}),useWhenValueChanges(ur,function(){Sr.setConfig("validate",ur)}),useWhenValueChanges(mr,function(){Sr.setConfig("validateOnBlur",mr)});var Pr=function(Nr){return Nr&&(typeof Nr.preventDefault=="function"&&Nr.preventDefault(),typeof Nr.stopPropagation=="function"&&Nr.stopPropagation()),Sr.submit()},Br={form:_extends({},Sr,{reset:function(Nr){isSyntheticEvent(Nr)?Sr.reset():Sr.reset(Nr)}}),handleSubmit:Pr};return addLazyFormState(Br,Er),h$1(ReactFinalFormContext.Provider,{value:Sr},renderComponent(_extends({},br,{__versions:versions}),Br,"ReactFinalForm"))}function useForm(Ke){var Re=q$2(ReactFinalFormContext);if(!Re)throw new Error((Ke||"useForm")+" must be used inside of a <Form> component");return Re}var isReactNative=typeof window<"u"&&window.navigator&&window.navigator.product&&window.navigator.product==="ReactNative",getSelectedValues=function(Re){var Fe=[];if(Re)for(var We=0;We<Re.length;We++){var qe=Re[We];qe.selected&&Fe.push(qe.value)}return Fe},getValue=function(Re,Fe,We,qe){if(!qe&&Re.nativeEvent&&Re.nativeEvent.text!==void 0||qe&&Re.nativeEvent)return Re.nativeEvent.text;var Ze=Re,Xe=Ze.target,Je=Xe.type,tr=Xe.value,er=Xe.checked;switch(Je){case"checkbox":if(We!==void 0){if(er)return Array.isArray(Fe)?Fe.concat(We):[We];if(!Array.isArray(Fe))return Fe;var ir=Fe.indexOf(We);return ir<0?Fe:Fe.slice(0,ir).concat(Fe.slice(ir+1))}else return!!er;case"select-multiple":return getSelectedValues(Re.target.options);default:return tr}};function useConstantCallback(Ke){var Re=_$2(Ke);return h(function(){Re.current=Ke}),T$2(function(){for(var Fe=arguments.length,We=new Array(Fe),qe=0;qe<Fe;qe++)We[qe]=arguments[qe];return Re.current.apply(null,We)},[])}var all=fieldSubscriptionItems.reduce(function(Ke,Re){return Ke[Re]=!0,Ke},{}),defaultFormat=function(Re,Fe){return Re===void 0?"":Re},defaultParse=function(Re,Fe){return Re===""?void 0:Re},defaultIsEqual=function(Re,Fe){return Re===Fe};function useField(Ke,Re){Re===void 0&&(Re={});var Fe=Re,We=Fe.afterSubmit,qe=Fe.allowNull,Ze=Fe.component,Xe=Fe.data,Je=Fe.defaultValue,tr=Fe.format,er=tr===void 0?defaultFormat:tr,ir=Fe.formatOnBlur,lr=Fe.initialValue,fr=Fe.multiple,ur=Fe.parse,mr=ur===void 0?defaultParse:ur,br=Fe.subscription,wr=br===void 0?all:br,Sr=Fe.type,kr=Fe.validateFields,Er=Fe.value,Ir=useForm("useField"),Rr=useLatest(Re),Pr=function(sr,cr){return Ir.registerField(Ke,sr,wr,{afterSubmit:We,beforeSubmit:function(){var _r=Rr.current,xr=_r.beforeSubmit,Ar=_r.formatOnBlur,pr=_r.format,rr=pr===void 0?defaultFormat:pr;if(Ar){var hr=Ir.getFieldState(Ke),$r=hr.value,Lr=rr($r,Ke);Lr!==$r&&Ir.change(Ke,Lr)}return xr&&xr()},data:Xe,defaultValue:Je,getValidator:function(){return Rr.current.validate},initialValue:lr,isEqual:function(_r,xr){return(Rr.current.isEqual||defaultIsEqual)(_r,xr)},silent:cr,validateFields:kr})},Br=_$2(!0),Or=p(function(){var Dt={},sr=Ir.destroyOnUnregister;return Ir.destroyOnUnregister=!1,Pr(function(cr){Dt=cr},!0)(),Ir.destroyOnUnregister=sr,Dt}),Nr=Or[0],Cr=Or[1];h(function(){return Pr(function(Dt){Br.current?Br.current=!1:Cr(Dt)},!1)},[Ke,Xe,Je,lr]);var Tr={};addLazyFieldMetaState(Tr,Nr);var Mr={name:Ke,get value(){var Dt=Nr.value;return ir?Ze==="input"&&(Dt=defaultFormat(Dt)):Dt=er(Dt,Ke),Dt===null&&!qe&&(Dt=""),Sr==="checkbox"||Sr==="radio"?Er:Ze==="select"&&fr?Dt||[]:Dt},get checked(){var Dt=Nr.value;if(Sr==="checkbox")return Dt=er(Dt,Ke),Er===void 0?!!Dt:!!(Array.isArray(Dt)&&~Dt.indexOf(Er));if(Sr==="radio")return er(Dt,Ke)===Er},onBlur:useConstantCallback(function(Dt){if(Nr.blur(),ir){var sr=Ir.getFieldState(Nr.name);Nr.change(er(sr.value,Nr.name))}}),onChange:useConstantCallback(function(Dt){var sr=Dt&&Dt.target?getValue(Dt,Nr.value,Er,isReactNative):Dt;Nr.change(mr(sr,Ke))}),onFocus:useConstantCallback(function(Dt){return Nr.focus()})};fr&&(Mr.multiple=fr),Sr!==void 0&&(Mr.type=Sr);var ar={input:Mr,meta:Tr};return ar}var _excluded=["afterSubmit","allowNull","beforeSubmit","children","component","data","defaultValue","format","formatOnBlur","initialValue","isEqual","multiple","name","parse","subscription","type","validate","validateFields","value"],Field=N$1(function(Re,Fe){var We=Re.afterSubmit,qe=Re.allowNull,Ze=Re.beforeSubmit,Xe=Re.children,Je=Re.component,tr=Re.data,er=Re.defaultValue,ir=Re.format,lr=Re.formatOnBlur,fr=Re.initialValue,ur=Re.isEqual,mr=Re.multiple,br=Re.name,wr=Re.parse,Sr=Re.subscription,kr=Re.type,Er=Re.validate,Ir=Re.validateFields,Rr=Re.value,Pr=_objectWithoutPropertiesLoose(Re,_excluded),Br=useField(br,{afterSubmit:We,allowNull:qe,beforeSubmit:Ze,children:Xe,component:Je,data:tr,defaultValue:er,format:ir,formatOnBlur:lr,initialValue:fr,isEqual:ur,multiple:mr,parse:wr,subscription:Sr,type:kr,validate:Er,validateFields:Ir,value:Rr});if(typeof Xe=="function")return Xe(_extends({},Br,Pr));if(typeof Je=="string")return h$1(Je,_extends({},Br.input,{children:Xe,ref:Fe},Pr));if(!br)throw new Error("prop name cannot be undefined in <Field> component");return renderComponent(_extends({children:Xe,component:Je,ref:Fe},Pr),Br,"Field("+br+")")}),_$1=0;function o(Ke,Re,Fe,We,qe){var Ze,Xe,Je={};for(Xe in Re)Xe=="ref"?Ze=Re[Xe]:Je[Xe]=Re[Xe];var tr={type:Ke,props:Je,key:Fe,ref:Ze,__k:null,__:null,__b:0,__e:null,__d:void 0,__c:null,__h:null,constructor:void 0,__v:--_$1,__source:qe,__self:We};if(typeof Ke=="function"&&(Ze=Ke.defaultProps))for(Xe in Ze)Je[Xe]===void 0&&(Je[Xe]=Ze[Xe]);return l$1.vnode&&l$1.vnode(tr),tr}function FormGroup({children:Ke,meta:Re}){const Fe=T$2(()=>Re.touched&&Re.error?o("div",{children:o("span",{children:Re.error})}):null,[Re]);return o("div",{className:"w-full",children:[o("div",{children:Ke}),Fe()]})}function TextInput(Ke){const{input:Re,placeholder:Fe}=Ke;return o("input",{...Re,id:Re.name,placeholder:Fe,className:"outline-0 bg-white border-2 border-black text-gray-900 sm:text-lg rounded-xl group-focus-within:ring-primary-600 group-focus-within:border-primary-600 block w-full p-3 px-4 shadow-[6px_6px_0_0_#000] transition focus:shadow-none focus:border-slate-700 focus:ring ring-purple-500/50"})}function GifLinkForm({onSubmit:Ke}){return o(ReactFinalForm,{onSubmit:Ke,render:({handleSubmit:Re})=>o("form",{onSubmit:Re,className:"w-full",children:o("div",{className:"w-full flex flex-col space-y-8 sm:space-y-0 sm:flex-row justify-between items-center sm:items-stretch space-x-0 sm:space-x-3 group",children:[o(Field,{name:"gifLink",placeholder:"Gif link here to metaverse here ...",children:({meta:Fe,input:We,placeholder:qe})=>o(FormGroup,{meta:Fe,input:We,children:o(TextInput,{input:We,placeholder:qe})})}),o("button",{type:"submit",className:"flex items-center justify-center rounded-xl border-2 border-black px-6 py-2 font-bold shadow-[6px_6px_0_0_#000] transition hover:shadow-none focus:outline-none focus:ring ring-purple-500/50 active:bg-purple-200/50 max-w-xs",children:["Mint",o("span",{"aria-hidden":"true",className:"ml-1.5",role:"img",children:"\u{1F680}"})]})]})})})}const button="_button_16vgv_1",s={button};var buffer={};/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */(function(Ke){const Re=base64Js,Fe=ieee754,We=typeof Symbol=="function"&&typeof Symbol.for=="function"?Symbol.for("nodejs.util.inspect.custom"):null;Ke.Buffer=Je,Ke.SlowBuffer=kr,Ke.INSPECT_MAX_BYTES=50;const qe=2147483647;Ke.kMaxLength=qe,Je.TYPED_ARRAY_SUPPORT=Ze(),!Je.TYPED_ARRAY_SUPPORT&&typeof console<"u"&&typeof console.error=="function"&&console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");function Ze(){try{const nr=new Uint8Array(1),Qe={foo:function(){return 42}};return Object.setPrototypeOf(Qe,Uint8Array.prototype),Object.setPrototypeOf(nr,Qe),nr.foo()===42}catch{return!1}}Object.defineProperty(Je.prototype,"parent",{enumerable:!0,get:function(){if(!!Je.isBuffer(this))return this.buffer}}),Object.defineProperty(Je.prototype,"offset",{enumerable:!0,get:function(){if(!!Je.isBuffer(this))return this.byteOffset}});function Xe(nr){if(nr>qe)throw new RangeError('The value "'+nr+'" is invalid for option "size"');const Qe=new Uint8Array(nr);return Object.setPrototypeOf(Qe,Je.prototype),Qe}function Je(nr,Qe,dt){if(typeof nr=="number"){if(typeof Qe=="string")throw new TypeError('The "string" argument must be of type string. Received type number');return lr(nr)}return tr(nr,Qe,dt)}Je.poolSize=8192;function tr(nr,Qe,dt){if(typeof nr=="string")return fr(nr,Qe);if(ArrayBuffer.isView(nr))return mr(nr);if(nr==null)throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof nr);if(Cn(nr,ArrayBuffer)||nr&&Cn(nr.buffer,ArrayBuffer)||typeof SharedArrayBuffer<"u"&&(Cn(nr,SharedArrayBuffer)||nr&&Cn(nr.buffer,SharedArrayBuffer)))return br(nr,Qe,dt);if(typeof nr=="number")throw new TypeError('The "value" argument must not be of type number. Received type number');const or=nr.valueOf&&nr.valueOf();if(or!=null&&or!==nr)return Je.from(or,Qe,dt);const dr=wr(nr);if(dr)return dr;if(typeof Symbol<"u"&&Symbol.toPrimitive!=null&&typeof nr[Symbol.toPrimitive]=="function")return Je.from(nr[Symbol.toPrimitive]("string"),Qe,dt);throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof nr)}Je.from=function(nr,Qe,dt){return tr(nr,Qe,dt)},Object.setPrototypeOf(Je.prototype,Uint8Array.prototype),Object.setPrototypeOf(Je,Uint8Array);function er(nr){if(typeof nr!="number")throw new TypeError('"size" argument must be of type number');if(nr<0)throw new RangeError('The value "'+nr+'" is invalid for option "size"')}function ir(nr,Qe,dt){return er(nr),nr<=0?Xe(nr):Qe!==void 0?typeof dt=="string"?Xe(nr).fill(Qe,dt):Xe(nr).fill(Qe):Xe(nr)}Je.alloc=function(nr,Qe,dt){return ir(nr,Qe,dt)};function lr(nr){return er(nr),Xe(nr<0?0:Sr(nr)|0)}Je.allocUnsafe=function(nr){return lr(nr)},Je.allocUnsafeSlow=function(nr){return lr(nr)};function fr(nr,Qe){if((typeof Qe!="string"||Qe==="")&&(Qe="utf8"),!Je.isEncoding(Qe))throw new TypeError("Unknown encoding: "+Qe);const dt=Er(nr,Qe)|0;let or=Xe(dt);const dr=or.write(nr,Qe);return dr!==dt&&(or=or.slice(0,dr)),or}function ur(nr){const Qe=nr.length<0?0:Sr(nr.length)|0,dt=Xe(Qe);for(let or=0;or<Qe;or+=1)dt[or]=nr[or]&255;return dt}function mr(nr){if(Cn(nr,Uint8Array)){const Qe=new Uint8Array(nr);return br(Qe.buffer,Qe.byteOffset,Qe.byteLength)}return ur(nr)}function br(nr,Qe,dt){if(Qe<0||nr.byteLength<Qe)throw new RangeError('"offset" is outside of buffer bounds');if(nr.byteLength<Qe+(dt||0))throw new RangeError('"length" is outside of buffer bounds');let or;return Qe===void 0&&dt===void 0?or=new Uint8Array(nr):dt===void 0?or=new Uint8Array(nr,Qe):or=new Uint8Array(nr,Qe,dt),Object.setPrototypeOf(or,Je.prototype),or}function wr(nr){if(Je.isBuffer(nr)){const Qe=Sr(nr.length)|0,dt=Xe(Qe);return dt.length===0||nr.copy(dt,0,0,Qe),dt}if(nr.length!==void 0)return typeof nr.length!="number"||Fn(nr.length)?Xe(0):ur(nr);if(nr.type==="Buffer"&&Array.isArray(nr.data))return ur(nr.data)}function Sr(nr){if(nr>=qe)throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x"+qe.toString(16)+" bytes");return nr|0}function kr(nr){return+nr!=nr&&(nr=0),Je.alloc(+nr)}Je.isBuffer=function(Qe){return Qe!=null&&Qe._isBuffer===!0&&Qe!==Je.prototype},Je.compare=function(Qe,dt){if(Cn(Qe,Uint8Array)&&(Qe=Je.from(Qe,Qe.offset,Qe.byteLength)),Cn(dt,Uint8Array)&&(dt=Je.from(dt,dt.offset,dt.byteLength)),!Je.isBuffer(Qe)||!Je.isBuffer(dt))throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');if(Qe===dt)return 0;let or=Qe.length,dr=dt.length;for(let gr=0,vr=Math.min(or,dr);gr<vr;++gr)if(Qe[gr]!==dt[gr]){or=Qe[gr],dr=dt[gr];break}return or<dr?-1:dr<or?1:0},Je.isEncoding=function(Qe){switch(String(Qe).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"latin1":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return!0;default:return!1}},Je.concat=function(Qe,dt){if(!Array.isArray(Qe))throw new TypeError('"list" argument must be an Array of Buffers');if(Qe.length===0)return Je.alloc(0);let or;if(dt===void 0)for(dt=0,or=0;or<Qe.length;++or)dt+=Qe[or].length;const dr=Je.allocUnsafe(dt);let gr=0;for(or=0;or<Qe.length;++or){let vr=Qe[or];if(Cn(vr,Uint8Array))gr+vr.length>dr.length?(Je.isBuffer(vr)||(vr=Je.from(vr)),vr.copy(dr,gr)):Uint8Array.prototype.set.call(dr,vr,gr);else if(Je.isBuffer(vr))vr.copy(dr,gr);else throw new TypeError('"list" argument must be an Array of Buffers');gr+=vr.length}return dr};function Er(nr,Qe){if(Je.isBuffer(nr))return nr.length;if(ArrayBuffer.isView(nr)||Cn(nr,ArrayBuffer))return nr.byteLength;if(typeof nr!="string")throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type '+typeof nr);const dt=nr.length,or=arguments.length>2&&arguments[2]===!0;if(!or&&dt===0)return 0;let dr=!1;for(;;)switch(Qe){case"ascii":case"latin1":case"binary":return dt;case"utf8":case"utf-8":return Qr(nr).length;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return dt*2;case"hex":return dt>>>1;case"base64":return $n(nr).length;default:if(dr)return or?-1:Qr(nr).length;Qe=(""+Qe).toLowerCase(),dr=!0}}Je.byteLength=Er;function Ir(nr,Qe,dt){let or=!1;if((Qe===void 0||Qe<0)&&(Qe=0),Qe>this.length||((dt===void 0||dt>this.length)&&(dt=this.length),dt<=0)||(dt>>>=0,Qe>>>=0,dt<=Qe))return"";for(nr||(nr="utf8");;)switch(nr){case"hex":return xr(this,Qe,dt);case"utf8":case"utf-8":return Dt(this,Qe,dt);case"ascii":return yr(this,Qe,dt);case"latin1":case"binary":return _r(this,Qe,dt);case"base64":return ar(this,Qe,dt);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return Ar(this,Qe,dt);default:if(or)throw new TypeError("Unknown encoding: "+nr);nr=(nr+"").toLowerCase(),or=!0}}Je.prototype._isBuffer=!0;function Rr(nr,Qe,dt){const or=nr[Qe];nr[Qe]=nr[dt],nr[dt]=or}Je.prototype.swap16=function(){const Qe=this.length;if(Qe%2!==0)throw new RangeError("Buffer size must be a multiple of 16-bits");for(let dt=0;dt<Qe;dt+=2)Rr(this,dt,dt+1);return this},Je.prototype.swap32=function(){const Qe=this.length;if(Qe%4!==0)throw new RangeError("Buffer size must be a multiple of 32-bits");for(let dt=0;dt<Qe;dt+=4)Rr(this,dt,dt+3),Rr(this,dt+1,dt+2);return this},Je.prototype.swap64=function(){const Qe=this.length;if(Qe%8!==0)throw new RangeError("Buffer size must be a multiple of 64-bits");for(let dt=0;dt<Qe;dt+=8)Rr(this,dt,dt+7),Rr(this,dt+1,dt+6),Rr(this,dt+2,dt+5),Rr(this,dt+3,dt+4);return this},Je.prototype.toString=function(){const Qe=this.length;return Qe===0?"":arguments.length===0?Dt(this,0,Qe):Ir.apply(this,arguments)},Je.prototype.toLocaleString=Je.prototype.toString,Je.prototype.equals=function(Qe){if(!Je.isBuffer(Qe))throw new TypeError("Argument must be a Buffer");return this===Qe?!0:Je.compare(this,Qe)===0},Je.prototype.inspect=function(){let Qe="";const dt=Ke.INSPECT_MAX_BYTES;return Qe=this.toString("hex",0,dt).replace(/(.{2})/g,"$1 ").trim(),this.length>dt&&(Qe+=" ... "),"<Buffer "+Qe+">"},We&&(Je.prototype[We]=Je.prototype.inspect),Je.prototype.compare=function(Qe,dt,or,dr,gr){if(Cn(Qe,Uint8Array)&&(Qe=Je.from(Qe,Qe.offset,Qe.byteLength)),!Je.isBuffer(Qe))throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type '+typeof Qe);if(dt===void 0&&(dt=0),or===void 0&&(or=Qe?Qe.length:0),dr===void 0&&(dr=0),gr===void 0&&(gr=this.length),dt<0||or>Qe.length||dr<0||gr>this.length)throw new RangeError("out of range index");if(dr>=gr&&dt>=or)return 0;if(dr>=gr)return-1;if(dt>=or)return 1;if(dt>>>=0,or>>>=0,dr>>>=0,gr>>>=0,this===Qe)return 0;let vr=gr-dr,Dr=or-dt;const Vr=Math.min(vr,Dr),Kr=this.slice(dr,gr),jr=Qe.slice(dt,or);for(let Hr=0;Hr<Vr;++Hr)if(Kr[Hr]!==jr[Hr]){vr=Kr[Hr],Dr=jr[Hr];break}return vr<Dr?-1:Dr<vr?1:0};function Pr(nr,Qe,dt,or,dr){if(nr.length===0)return-1;if(typeof dt=="string"?(or=dt,dt=0):dt>2147483647?dt=2147483647:dt<-2147483648&&(dt=-2147483648),dt=+dt,Fn(dt)&&(dt=dr?0:nr.length-1),dt<0&&(dt=nr.length+dt),dt>=nr.length){if(dr)return-1;dt=nr.length-1}else if(dt<0)if(dr)dt=0;else return-1;if(typeof Qe=="string"&&(Qe=Je.from(Qe,or)),Je.isBuffer(Qe))return Qe.length===0?-1:Br(nr,Qe,dt,or,dr);if(typeof Qe=="number")return Qe=Qe&255,typeof Uint8Array.prototype.indexOf=="function"?dr?Uint8Array.prototype.indexOf.call(nr,Qe,dt):Uint8Array.prototype.lastIndexOf.call(nr,Qe,dt):Br(nr,[Qe],dt,or,dr);throw new TypeError("val must be string, number or Buffer")}function Br(nr,Qe,dt,or,dr){let gr=1,vr=nr.length,Dr=Qe.length;if(or!==void 0&&(or=String(or).toLowerCase(),or==="ucs2"||or==="ucs-2"||or==="utf16le"||or==="utf-16le")){if(nr.length<2||Qe.length<2)return-1;gr=2,vr/=2,Dr/=2,dt/=2}function Vr(jr,Hr){return gr===1?jr[Hr]:jr.readUInt16BE(Hr*gr)}let Kr;if(dr){let jr=-1;for(Kr=dt;Kr<vr;Kr++)if(Vr(nr,Kr)===Vr(Qe,jr===-1?0:Kr-jr)){if(jr===-1&&(jr=Kr),Kr-jr+1===Dr)return jr*gr}else jr!==-1&&(Kr-=Kr-jr),jr=-1}else for(dt+Dr>vr&&(dt=vr-Dr),Kr=dt;Kr>=0;Kr--){let jr=!0;for(let Hr=0;Hr<Dr;Hr++)if(Vr(nr,Kr+Hr)!==Vr(Qe,Hr)){jr=!1;break}if(jr)return Kr}return-1}Je.prototype.includes=function(Qe,dt,or){return this.indexOf(Qe,dt,or)!==-1},Je.prototype.indexOf=function(Qe,dt,or){return Pr(this,Qe,dt,or,!0)},Je.prototype.lastIndexOf=function(Qe,dt,or){return Pr(this,Qe,dt,or,!1)};function Or(nr,Qe,dt,or){dt=Number(dt)||0;const dr=nr.length-dt;or?(or=Number(or),or>dr&&(or=dr)):or=dr;const gr=Qe.length;or>gr/2&&(or=gr/2);let vr;for(vr=0;vr<or;++vr){const Dr=parseInt(Qe.substr(vr*2,2),16);if(Fn(Dr))return vr;nr[dt+vr]=Dr}return vr}function Nr(nr,Qe,dt,or){return Jr(Qr(Qe,nr.length-dt),nr,dt,or)}function Cr(nr,Qe,dt,or){return Jr(jn(Qe),nr,dt,or)}function Tr(nr,Qe,dt,or){return Jr($n(Qe),nr,dt,or)}function Mr(nr,Qe,dt,or){return Jr(fi(Qe,nr.length-dt),nr,dt,or)}Je.prototype.write=function(Qe,dt,or,dr){if(dt===void 0)dr="utf8",or=this.length,dt=0;else if(or===void 0&&typeof dt=="string")dr=dt,or=this.length,dt=0;else if(isFinite(dt))dt=dt>>>0,isFinite(or)?(or=or>>>0,dr===void 0&&(dr="utf8")):(dr=or,or=void 0);else throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");const gr=this.length-dt;if((or===void 0||or>gr)&&(or=gr),Qe.length>0&&(or<0||dt<0)||dt>this.length)throw new RangeError("Attempt to write outside buffer bounds");dr||(dr="utf8");let vr=!1;for(;;)switch(dr){case"hex":return Or(this,Qe,dt,or);case"utf8":case"utf-8":return Nr(this,Qe,dt,or);case"ascii":case"latin1":case"binary":return Cr(this,Qe,dt,or);case"base64":return Tr(this,Qe,dt,or);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return Mr(this,Qe,dt,or);default:if(vr)throw new TypeError("Unknown encoding: "+dr);dr=(""+dr).toLowerCase(),vr=!0}},Je.prototype.toJSON=function(){return{type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}};function ar(nr,Qe,dt){return Qe===0&&dt===nr.length?Re.fromByteArray(nr):Re.fromByteArray(nr.slice(Qe,dt))}function Dt(nr,Qe,dt){dt=Math.min(nr.length,dt);const or=[];let dr=Qe;for(;dr<dt;){const gr=nr[dr];let vr=null,Dr=gr>239?4:gr>223?3:gr>191?2:1;if(dr+Dr<=dt){let Vr,Kr,jr,Hr;switch(Dr){case 1:gr<128&&(vr=gr);break;case 2:Vr=nr[dr+1],(Vr&192)===128&&(Hr=(gr&31)<<6|Vr&63,Hr>127&&(vr=Hr));break;case 3:Vr=nr[dr+1],Kr=nr[dr+2],(Vr&192)===128&&(Kr&192)===128&&(Hr=(gr&15)<<12|(Vr&63)<<6|Kr&63,Hr>2047&&(Hr<55296||Hr>57343)&&(vr=Hr));break;case 4:Vr=nr[dr+1],Kr=nr[dr+2],jr=nr[dr+3],(Vr&192)===128&&(Kr&192)===128&&(jr&192)===128&&(Hr=(gr&15)<<18|(Vr&63)<<12|(Kr&63)<<6|jr&63,Hr>65535&&Hr<1114112&&(vr=Hr))}}vr===null?(vr=65533,Dr=1):vr>65535&&(vr-=65536,or.push(vr>>>10&1023|55296),vr=56320|vr&1023),or.push(vr),dr+=Dr}return cr(or)}const sr=4096;function cr(nr){const Qe=nr.length;if(Qe<=sr)return String.fromCharCode.apply(String,nr);let dt="",or=0;for(;or<Qe;)dt+=String.fromCharCode.apply(String,nr.slice(or,or+=sr));return dt}function yr(nr,Qe,dt){let or="";dt=Math.min(nr.length,dt);for(let dr=Qe;dr<dt;++dr)or+=String.fromCharCode(nr[dr]&127);return or}function _r(nr,Qe,dt){let or="";dt=Math.min(nr.length,dt);for(let dr=Qe;dr<dt;++dr)or+=String.fromCharCode(nr[dr]);return or}function xr(nr,Qe,dt){const or=nr.length;(!Qe||Qe<0)&&(Qe=0),(!dt||dt<0||dt>or)&&(dt=or);let dr="";for(let gr=Qe;gr<dt;++gr)dr+=Kn[nr[gr]];return dr}function Ar(nr,Qe,dt){const or=nr.slice(Qe,dt);let dr="";for(let gr=0;gr<or.length-1;gr+=2)dr+=String.fromCharCode(or[gr]+or[gr+1]*256);return dr}Je.prototype.slice=function(Qe,dt){const or=this.length;Qe=~~Qe,dt=dt===void 0?or:~~dt,Qe<0?(Qe+=or,Qe<0&&(Qe=0)):Qe>or&&(Qe=or),dt<0?(dt+=or,dt<0&&(dt=0)):dt>or&&(dt=or),dt<Qe&&(dt=Qe);const dr=this.subarray(Qe,dt);return Object.setPrototypeOf(dr,Je.prototype),dr};function pr(nr,Qe,dt){if(nr%1!==0||nr<0)throw new RangeError("offset is not uint");if(nr+Qe>dt)throw new RangeError("Trying to access beyond buffer length")}Je.prototype.readUintLE=Je.prototype.readUIntLE=function(Qe,dt,or){Qe=Qe>>>0,dt=dt>>>0,or||pr(Qe,dt,this.length);let dr=this[Qe],gr=1,vr=0;for(;++vr<dt&&(gr*=256);)dr+=this[Qe+vr]*gr;return dr},Je.prototype.readUintBE=Je.prototype.readUIntBE=function(Qe,dt,or){Qe=Qe>>>0,dt=dt>>>0,or||pr(Qe,dt,this.length);let dr=this[Qe+--dt],gr=1;for(;dt>0&&(gr*=256);)dr+=this[Qe+--dt]*gr;return dr},Je.prototype.readUint8=Je.prototype.readUInt8=function(Qe,dt){return Qe=Qe>>>0,dt||pr(Qe,1,this.length),this[Qe]},Je.prototype.readUint16LE=Je.prototype.readUInt16LE=function(Qe,dt){return Qe=Qe>>>0,dt||pr(Qe,2,this.length),this[Qe]|this[Qe+1]<<8},Je.prototype.readUint16BE=Je.prototype.readUInt16BE=function(Qe,dt){return Qe=Qe>>>0,dt||pr(Qe,2,this.length),this[Qe]<<8|this[Qe+1]},Je.prototype.readUint32LE=Je.prototype.readUInt32LE=function(Qe,dt){return Qe=Qe>>>0,dt||pr(Qe,4,this.length),(this[Qe]|this[Qe+1]<<8|this[Qe+2]<<16)+this[Qe+3]*16777216},Je.prototype.readUint32BE=Je.prototype.readUInt32BE=function(Qe,dt){return Qe=Qe>>>0,dt||pr(Qe,4,this.length),this[Qe]*16777216+(this[Qe+1]<<16|this[Qe+2]<<8|this[Qe+3])},Je.prototype.readBigUInt64LE=Wn(function(Qe){Qe=Qe>>>0,Hn(Qe,"offset");const dt=this[Qe],or=this[Qe+7];(dt===void 0||or===void 0)&&Xr(Qe,this.length-8);const dr=dt+this[++Qe]*2**8+this[++Qe]*2**16+this[++Qe]*2**24,gr=this[++Qe]+this[++Qe]*2**8+this[++Qe]*2**16+or*2**24;return BigInt(dr)+(BigInt(gr)<<BigInt(32))}),Je.prototype.readBigUInt64BE=Wn(function(Qe){Qe=Qe>>>0,Hn(Qe,"offset");const dt=this[Qe],or=this[Qe+7];(dt===void 0||or===void 0)&&Xr(Qe,this.length-8);const dr=dt*2**24+this[++Qe]*2**16+this[++Qe]*2**8+this[++Qe],gr=this[++Qe]*2**24+this[++Qe]*2**16+this[++Qe]*2**8+or;return(BigInt(dr)<<BigInt(32))+BigInt(gr)}),Je.prototype.readIntLE=function(Qe,dt,or){Qe=Qe>>>0,dt=dt>>>0,or||pr(Qe,dt,this.length);let dr=this[Qe],gr=1,vr=0;for(;++vr<dt&&(gr*=256);)dr+=this[Qe+vr]*gr;return gr*=128,dr>=gr&&(dr-=Math.pow(2,8*dt)),dr},Je.prototype.readIntBE=function(Qe,dt,or){Qe=Qe>>>0,dt=dt>>>0,or||pr(Qe,dt,this.length);let dr=dt,gr=1,vr=this[Qe+--dr];for(;dr>0&&(gr*=256);)vr+=this[Qe+--dr]*gr;return gr*=128,vr>=gr&&(vr-=Math.pow(2,8*dt)),vr},Je.prototype.readInt8=function(Qe,dt){return Qe=Qe>>>0,dt||pr(Qe,1,this.length),this[Qe]&128?(255-this[Qe]+1)*-1:this[Qe]},Je.prototype.readInt16LE=function(Qe,dt){Qe=Qe>>>0,dt||pr(Qe,2,this.length);const or=this[Qe]|this[Qe+1]<<8;return or&32768?or|4294901760:or},Je.prototype.readInt16BE=function(Qe,dt){Qe=Qe>>>0,dt||pr(Qe,2,this.length);const or=this[Qe+1]|this[Qe]<<8;return or&32768?or|4294901760:or},Je.prototype.readInt32LE=function(Qe,dt){return Qe=Qe>>>0,dt||pr(Qe,4,this.length),this[Qe]|this[Qe+1]<<8|this[Qe+2]<<16|this[Qe+3]<<24},Je.prototype.readInt32BE=function(Qe,dt){return Qe=Qe>>>0,dt||pr(Qe,4,this.length),this[Qe]<<24|this[Qe+1]<<16|this[Qe+2]<<8|this[Qe+3]},Je.prototype.readBigInt64LE=Wn(function(Qe){Qe=Qe>>>0,Hn(Qe,"offset");const dt=this[Qe],or=this[Qe+7];(dt===void 0||or===void 0)&&Xr(Qe,this.length-8);const dr=this[Qe+4]+this[Qe+5]*2**8+this[Qe+6]*2**16+(or<<24);return(BigInt(dr)<<BigInt(32))+BigInt(dt+this[++Qe]*2**8+this[++Qe]*2**16+this[++Qe]*2**24)}),Je.prototype.readBigInt64BE=Wn(function(Qe){Qe=Qe>>>0,Hn(Qe,"offset");const dt=this[Qe],or=this[Qe+7];(dt===void 0||or===void 0)&&Xr(Qe,this.length-8);const dr=(dt<<24)+this[++Qe]*2**16+this[++Qe]*2**8+this[++Qe];return(BigInt(dr)<<BigInt(32))+BigInt(this[++Qe]*2**24+this[++Qe]*2**16+this[++Qe]*2**8+or)}),Je.prototype.readFloatLE=function(Qe,dt){return Qe=Qe>>>0,dt||pr(Qe,4,this.length),Fe.read(this,Qe,!0,23,4)},Je.prototype.readFloatBE=function(Qe,dt){return Qe=Qe>>>0,dt||pr(Qe,4,this.length),Fe.read(this,Qe,!1,23,4)},Je.prototype.readDoubleLE=function(Qe,dt){return Qe=Qe>>>0,dt||pr(Qe,8,this.length),Fe.read(this,Qe,!0,52,8)},Je.prototype.readDoubleBE=function(Qe,dt){return Qe=Qe>>>0,dt||pr(Qe,8,this.length),Fe.read(this,Qe,!1,52,8)};function rr(nr,Qe,dt,or,dr,gr){if(!Je.isBuffer(nr))throw new TypeError('"buffer" argument must be a Buffer instance');if(Qe>dr||Qe<gr)throw new RangeError('"value" argument is out of bounds');if(dt+or>nr.length)throw new RangeError("Index out of range")}Je.prototype.writeUintLE=Je.prototype.writeUIntLE=function(Qe,dt,or,dr){if(Qe=+Qe,dt=dt>>>0,or=or>>>0,!dr){const Dr=Math.pow(2,8*or)-1;rr(this,Qe,dt,or,Dr,0)}let gr=1,vr=0;for(this[dt]=Qe&255;++vr<or&&(gr*=256);)this[dt+vr]=Qe/gr&255;return dt+or},Je.prototype.writeUintBE=Je.prototype.writeUIntBE=function(Qe,dt,or,dr){if(Qe=+Qe,dt=dt>>>0,or=or>>>0,!dr){const Dr=Math.pow(2,8*or)-1;rr(this,Qe,dt,or,Dr,0)}let gr=or-1,vr=1;for(this[dt+gr]=Qe&255;--gr>=0&&(vr*=256);)this[dt+gr]=Qe/vr&255;return dt+or},Je.prototype.writeUint8=Je.prototype.writeUInt8=function(Qe,dt,or){return Qe=+Qe,dt=dt>>>0,or||rr(this,Qe,dt,1,255,0),this[dt]=Qe&255,dt+1},Je.prototype.writeUint16LE=Je.prototype.writeUInt16LE=function(Qe,dt,or){return Qe=+Qe,dt=dt>>>0,or||rr(this,Qe,dt,2,65535,0),this[dt]=Qe&255,this[dt+1]=Qe>>>8,dt+2},Je.prototype.writeUint16BE=Je.prototype.writeUInt16BE=function(Qe,dt,or){return Qe=+Qe,dt=dt>>>0,or||rr(this,Qe,dt,2,65535,0),this[dt]=Qe>>>8,this[dt+1]=Qe&255,dt+2},Je.prototype.writeUint32LE=Je.prototype.writeUInt32LE=function(Qe,dt,or){return Qe=+Qe,dt=dt>>>0,or||rr(this,Qe,dt,4,4294967295,0),this[dt+3]=Qe>>>24,this[dt+2]=Qe>>>16,this[dt+1]=Qe>>>8,this[dt]=Qe&255,dt+4},Je.prototype.writeUint32BE=Je.prototype.writeUInt32BE=function(Qe,dt,or){return Qe=+Qe,dt=dt>>>0,or||rr(this,Qe,dt,4,4294967295,0),this[dt]=Qe>>>24,this[dt+1]=Qe>>>16,this[dt+2]=Qe>>>8,this[dt+3]=Qe&255,dt+4};function hr(nr,Qe,dt,or,dr){Gr(Qe,or,dr,nr,dt,7);let gr=Number(Qe&BigInt(4294967295));nr[dt++]=gr,gr=gr>>8,nr[dt++]=gr,gr=gr>>8,nr[dt++]=gr,gr=gr>>8,nr[dt++]=gr;let vr=Number(Qe>>BigInt(32)&BigInt(4294967295));return nr[dt++]=vr,vr=vr>>8,nr[dt++]=vr,vr=vr>>8,nr[dt++]=vr,vr=vr>>8,nr[dt++]=vr,dt}function $r(nr,Qe,dt,or,dr){Gr(Qe,or,dr,nr,dt,7);let gr=Number(Qe&BigInt(4294967295));nr[dt+7]=gr,gr=gr>>8,nr[dt+6]=gr,gr=gr>>8,nr[dt+5]=gr,gr=gr>>8,nr[dt+4]=gr;let vr=Number(Qe>>BigInt(32)&BigInt(4294967295));return nr[dt+3]=vr,vr=vr>>8,nr[dt+2]=vr,vr=vr>>8,nr[dt+1]=vr,vr=vr>>8,nr[dt]=vr,dt+8}Je.prototype.writeBigUInt64LE=Wn(function(Qe,dt=0){return hr(this,Qe,dt,BigInt(0),BigInt("0xffffffffffffffff"))}),Je.prototype.writeBigUInt64BE=Wn(function(Qe,dt=0){return $r(this,Qe,dt,BigInt(0),BigInt("0xffffffffffffffff"))}),Je.prototype.writeIntLE=function(Qe,dt,or,dr){if(Qe=+Qe,dt=dt>>>0,!dr){const Vr=Math.pow(2,8*or-1);rr(this,Qe,dt,or,Vr-1,-Vr)}let gr=0,vr=1,Dr=0;for(this[dt]=Qe&255;++gr<or&&(vr*=256);)Qe<0&&Dr===0&&this[dt+gr-1]!==0&&(Dr=1),this[dt+gr]=(Qe/vr>>0)-Dr&255;return dt+or},Je.prototype.writeIntBE=function(Qe,dt,or,dr){if(Qe=+Qe,dt=dt>>>0,!dr){const Vr=Math.pow(2,8*or-1);rr(this,Qe,dt,or,Vr-1,-Vr)}let gr=or-1,vr=1,Dr=0;for(this[dt+gr]=Qe&255;--gr>=0&&(vr*=256);)Qe<0&&Dr===0&&this[dt+gr+1]!==0&&(Dr=1),this[dt+gr]=(Qe/vr>>0)-Dr&255;return dt+or},Je.prototype.writeInt8=function(Qe,dt,or){return Qe=+Qe,dt=dt>>>0,or||rr(this,Qe,dt,1,127,-128),Qe<0&&(Qe=255+Qe+1),this[dt]=Qe&255,dt+1},Je.prototype.writeInt16LE=function(Qe,dt,or){return Qe=+Qe,dt=dt>>>0,or||rr(this,Qe,dt,2,32767,-32768),this[dt]=Qe&255,this[dt+1]=Qe>>>8,dt+2},Je.prototype.writeInt16BE=function(Qe,dt,or){return Qe=+Qe,dt=dt>>>0,or||rr(this,Qe,dt,2,32767,-32768),this[dt]=Qe>>>8,this[dt+1]=Qe&255,dt+2},Je.prototype.writeInt32LE=function(Qe,dt,or){return Qe=+Qe,dt=dt>>>0,or||rr(this,Qe,dt,4,2147483647,-2147483648),this[dt]=Qe&255,this[dt+1]=Qe>>>8,this[dt+2]=Qe>>>16,this[dt+3]=Qe>>>24,dt+4},Je.prototype.writeInt32BE=function(Qe,dt,or){return Qe=+Qe,dt=dt>>>0,or||rr(this,Qe,dt,4,2147483647,-2147483648),Qe<0&&(Qe=4294967295+Qe+1),this[dt]=Qe>>>24,this[dt+1]=Qe>>>16,this[dt+2]=Qe>>>8,this[dt+3]=Qe&255,dt+4},Je.prototype.writeBigInt64LE=Wn(function(Qe,dt=0){return hr(this,Qe,dt,-BigInt("0x8000000000000000"),BigInt("0x7fffffffffffffff"))}),Je.prototype.writeBigInt64BE=Wn(function(Qe,dt=0){return $r(this,Qe,dt,-BigInt("0x8000000000000000"),BigInt("0x7fffffffffffffff"))});function Lr(nr,Qe,dt,or,dr,gr){if(dt+or>nr.length)throw new RangeError("Index out of range");if(dt<0)throw new RangeError("Index out of range")}function Ur(nr,Qe,dt,or,dr){return Qe=+Qe,dt=dt>>>0,dr||Lr(nr,Qe,dt,4),Fe.write(nr,Qe,dt,or,23,4),dt+4}Je.prototype.writeFloatLE=function(Qe,dt,or){return Ur(this,Qe,dt,!0,or)},Je.prototype.writeFloatBE=function(Qe,dt,or){return Ur(this,Qe,dt,!1,or)};function Wr(nr,Qe,dt,or,dr){return Qe=+Qe,dt=dt>>>0,dr||Lr(nr,Qe,dt,8),Fe.write(nr,Qe,dt,or,52,8),dt+8}Je.prototype.writeDoubleLE=function(Qe,dt,or){return Wr(this,Qe,dt,!0,or)},Je.prototype.writeDoubleBE=function(Qe,dt,or){return Wr(this,Qe,dt,!1,or)},Je.prototype.copy=function(Qe,dt,or,dr){if(!Je.isBuffer(Qe))throw new TypeError("argument should be a Buffer");if(or||(or=0),!dr&&dr!==0&&(dr=this.length),dt>=Qe.length&&(dt=Qe.length),dt||(dt=0),dr>0&&dr<or&&(dr=or),dr===or||Qe.length===0||this.length===0)return 0;if(dt<0)throw new RangeError("targetStart out of bounds");if(or<0||or>=this.length)throw new RangeError("Index out of range");if(dr<0)throw new RangeError("sourceEnd out of bounds");dr>this.length&&(dr=this.length),Qe.length-dt<dr-or&&(dr=Qe.length-dt+or);const gr=dr-or;return this===Qe&&typeof Uint8Array.prototype.copyWithin=="function"?this.copyWithin(dt,or,dr):Uint8Array.prototype.set.call(Qe,this.subarray(or,dr),dt),gr},Je.prototype.fill=function(Qe,dt,or,dr){if(typeof Qe=="string"){if(typeof dt=="string"?(dr=dt,dt=0,or=this.length):typeof or=="string"&&(dr=or,or=this.length),dr!==void 0&&typeof dr!="string")throw new TypeError("encoding must be a string");if(typeof dr=="string"&&!Je.isEncoding(dr))throw new TypeError("Unknown encoding: "+dr);if(Qe.length===1){const vr=Qe.charCodeAt(0);(dr==="utf8"&&vr<128||dr==="latin1")&&(Qe=vr)}}else typeof Qe=="number"?Qe=Qe&255:typeof Qe=="boolean"&&(Qe=Number(Qe));if(dt<0||this.length<dt||this.length<or)throw new RangeError("Out of range index");if(or<=dt)return this;dt=dt>>>0,or=or===void 0?this.length:or>>>0,Qe||(Qe=0);let gr;if(typeof Qe=="number")for(gr=dt;gr<or;++gr)this[gr]=Qe;else{const vr=Je.isBuffer(Qe)?Qe:Je.from(Qe,dr),Dr=vr.length;if(Dr===0)throw new TypeError('The value "'+Qe+'" is invalid for argument "value"');for(gr=0;gr<or-dt;++gr)this[gr+dt]=vr[gr%Dr]}return this};const Fr={};function zr(nr,Qe,dt){Fr[nr]=class extends dt{constructor(){super(),Object.defineProperty(this,"message",{value:Qe.apply(this,arguments),writable:!0,configurable:!0}),this.name=`${this.name} [${nr}]`,this.stack,delete this.name}get code(){return nr}set code(dr){Object.defineProperty(this,"code",{configurable:!0,enumerable:!0,value:dr,writable:!0})}toString(){return`${this.name} [${nr}]: ${this.message}`}}}zr("ERR_BUFFER_OUT_OF_BOUNDS",function(nr){return nr?`${nr} is outside of buffer bounds`:"Attempt to access memory outside buffer bounds"},RangeError),zr("ERR_INVALID_ARG_TYPE",function(nr,Qe){return`The "${nr}" argument must be of type number. Received type ${typeof Qe}`},TypeError),zr("ERR_OUT_OF_RANGE",function(nr,Qe,dt){let or=`The value of "${nr}" is out of range.`,dr=dt;return Number.isInteger(dt)&&Math.abs(dt)>2**32?dr=Yr(String(dt)):typeof dt=="bigint"&&(dr=String(dt),(dt>BigInt(2)**BigInt(32)||dt<-(BigInt(2)**BigInt(32)))&&(dr=Yr(dr)),dr+="n"),or+=` It must be ${Qe}. Received ${dr}`,or},RangeError);function Yr(nr){let Qe="",dt=nr.length;const or=nr[0]==="-"?1:0;for(;dt>=or+4;dt-=3)Qe=`_${nr.slice(dt-3,dt)}${Qe}`;return`${nr.slice(0,dt)}${Qe}`}function qr(nr,Qe,dt){Hn(Qe,"offset"),(nr[Qe]===void 0||nr[Qe+dt]===void 0)&&Xr(Qe,nr.length-(dt+1))}function Gr(nr,Qe,dt,or,dr,gr){if(nr>dt||nr<Qe){const vr=typeof Qe=="bigint"?"n":"";let Dr;throw gr>3?Qe===0||Qe===BigInt(0)?Dr=`>= 0${vr} and < 2${vr} ** ${(gr+1)*8}${vr}`:Dr=`>= -(2${vr} ** ${(gr+1)*8-1}${vr}) and < 2 ** ${(gr+1)*8-1}${vr}`:Dr=`>= ${Qe}${vr} and <= ${dt}${vr}`,new Fr.ERR_OUT_OF_RANGE("value",Dr,nr)}qr(or,dr,gr)}function Hn(nr,Qe){if(typeof nr!="number")throw new Fr.ERR_INVALID_ARG_TYPE(Qe,"number",nr)}function Xr(nr,Qe,dt){throw Math.floor(nr)!==nr?(Hn(nr,dt),new Fr.ERR_OUT_OF_RANGE(dt||"offset","an integer",nr)):Qe<0?new Fr.ERR_BUFFER_OUT_OF_BOUNDS:new Fr.ERR_OUT_OF_RANGE(dt||"offset",`>= ${dt?1:0} and <= ${Qe}`,nr)}const Zr=/[^+/0-9A-Za-z-_]/g;function qn(nr){if(nr=nr.split("=")[0],nr=nr.trim().replace(Zr,""),nr.length<2)return"";for(;nr.length%4!==0;)nr=nr+"=";return nr}function Qr(nr,Qe){Qe=Qe||1/0;let dt;const or=nr.length;let dr=null;const gr=[];for(let vr=0;vr<or;++vr){if(dt=nr.charCodeAt(vr),dt>55295&&dt<57344){if(!dr){if(dt>56319){(Qe-=3)>-1&&gr.push(239,191,189);continue}else if(vr+1===or){(Qe-=3)>-1&&gr.push(239,191,189);continue}dr=dt;continue}if(dt<56320){(Qe-=3)>-1&&gr.push(239,191,189),dr=dt;continue}dt=(dr-55296<<10|dt-56320)+65536}else dr&&(Qe-=3)>-1&&gr.push(239,191,189);if(dr=null,dt<128){if((Qe-=1)<0)break;gr.push(dt)}else if(dt<2048){if((Qe-=2)<0)break;gr.push(dt>>6|192,dt&63|128)}else if(dt<65536){if((Qe-=3)<0)break;gr.push(dt>>12|224,dt>>6&63|128,dt&63|128)}else if(dt<1114112){if((Qe-=4)<0)break;gr.push(dt>>18|240,dt>>12&63|128,dt>>6&63|128,dt&63|128)}else throw new Error("Invalid code point")}return gr}function jn(nr){const Qe=[];for(let dt=0;dt<nr.length;++dt)Qe.push(nr.charCodeAt(dt)&255);return Qe}function fi(nr,Qe){let dt,or,dr;const gr=[];for(let vr=0;vr<nr.length&&!((Qe-=2)<0);++vr)dt=nr.charCodeAt(vr),or=dt>>8,dr=dt%256,gr.push(dr),gr.push(or);return gr}function $n(nr){return Re.toByteArray(qn(nr))}function Jr(nr,Qe,dt,or){let dr;for(dr=0;dr<or&&!(dr+dt>=Qe.length||dr>=nr.length);++dr)Qe[dr+dt]=nr[dr];return dr}function Cn(nr,Qe){return nr instanceof Qe||nr!=null&&nr.constructor!=null&&nr.constructor.name!=null&&nr.constructor.name===Qe.name}function Fn(nr){return nr!==nr}const Kn=function(){const nr="0123456789abcdef",Qe=new Array(256);for(let dt=0;dt<16;++dt){const or=dt*16;for(let dr=0;dr<16;++dr)Qe[or+dr]=nr[dt]+nr[dr]}return Qe}();function Wn(nr){return typeof BigInt>"u"?Un:nr}function Un(){throw new Error("BigInt not supported")}})(buffer);function number$1(Ke){if(!Number.isSafeInteger(Ke)||Ke<0)throw new Error(`Wrong positive integer: ${Ke}`)}function bool(Ke){if(typeof Ke!="boolean")throw new Error(`Expected boolean, not ${Ke}`)}function bytes(Ke,...Re){if(!(Ke instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(Re.length>0&&!Re.includes(Ke.length))throw new TypeError(`Expected Uint8Array of length ${Re}, not of length=${Ke.length}`)}function hash(Ke){if(typeof Ke!="function"||typeof Ke.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");number$1(Ke.outputLen),number$1(Ke.blockLen)}function exists(Ke,Re=!0){if(Ke.destroyed)throw new Error("Hash instance has been destroyed");if(Re&&Ke.finished)throw new Error("Hash#digest() has already been called")}function output(Ke,Re){bytes(Ke);const Fe=Re.outputLen;if(Ke.length<Fe)throw new Error(`digestInto() expects output buffer of length at least ${Fe}`)}const assert$2={number:number$1,bool,bytes,hash,exists,output};/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */const u32$1=Ke=>new Uint32Array(Ke.buffer,Ke.byteOffset,Math.floor(Ke.byteLength/4)),createView=Ke=>new DataView(Ke.buffer,Ke.byteOffset,Ke.byteLength),rotr=(Ke,Re)=>Ke<<32-Re|Ke>>>Re,isLE=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;if(!isLE)throw new Error("Non little-endian hardware is not supported");Array.from({length:256},(Ke,Re)=>Re.toString(16).padStart(2,"0"));function utf8ToBytes(Ke){if(typeof Ke!="string")throw new TypeError(`utf8ToBytes expected string, got ${typeof Ke}`);return new TextEncoder().encode(Ke)}function toBytes(Ke){if(typeof Ke=="string"&&(Ke=utf8ToBytes(Ke)),!(Ke instanceof Uint8Array))throw new TypeError(`Expected input type is Uint8Array (got ${typeof Ke})`);return Ke}class Hash{clone(){return this._cloneInto()}}function wrapConstructor(Ke){const Re=We=>Ke().update(toBytes(We)).digest(),Fe=Ke();return Re.outputLen=Fe.outputLen,Re.blockLen=Fe.blockLen,Re.create=()=>Ke(),Re}function wrapConstructorWithOpts(Ke){const Re=(We,qe)=>Ke(qe).update(toBytes(We)).digest(),Fe=Ke({});return Re.outputLen=Fe.outputLen,Re.blockLen=Fe.blockLen,Re.create=We=>Ke(We),Re}function setBigUint64(Ke,Re,Fe,We){if(typeof Ke.setBigUint64=="function")return Ke.setBigUint64(Re,Fe,We);const qe=BigInt(32),Ze=BigInt(4294967295),Xe=Number(Fe>>qe&Ze),Je=Number(Fe&Ze),tr=We?4:0,er=We?0:4;Ke.setUint32(Re+tr,Xe,We),Ke.setUint32(Re+er,Je,We)}class SHA2 extends Hash{constructor(Re,Fe,We,qe){super(),this.blockLen=Re,this.outputLen=Fe,this.padOffset=We,this.isLE=qe,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(Re),this.view=createView(this.buffer)}update(Re){assert$2.exists(this);const{view:Fe,buffer:We,blockLen:qe}=this;Re=toBytes(Re);const Ze=Re.length;for(let Xe=0;Xe<Ze;){const Je=Math.min(qe-this.pos,Ze-Xe);if(Je===qe){const tr=createView(Re);for(;qe<=Ze-Xe;Xe+=qe)this.process(tr,Xe);continue}We.set(Re.subarray(Xe,Xe+Je),this.pos),this.pos+=Je,Xe+=Je,this.pos===qe&&(this.process(Fe,0),this.pos=0)}return this.length+=Re.length,this.roundClean(),this}digestInto(Re){assert$2.exists(this),assert$2.output(Re,this),this.finished=!0;const{buffer:Fe,view:We,blockLen:qe,isLE:Ze}=this;let{pos:Xe}=this;Fe[Xe++]=128,this.buffer.subarray(Xe).fill(0),this.padOffset>qe-Xe&&(this.process(We,0),Xe=0);for(let tr=Xe;tr<qe;tr++)Fe[tr]=0;setBigUint64(We,qe-8,BigInt(this.length*8),Ze),this.process(We,0);const Je=createView(Re);this.get().forEach((tr,er)=>Je.setUint32(4*er,tr,Ze))}digest(){const{buffer:Re,outputLen:Fe}=this;this.digestInto(Re);const We=Re.slice(0,Fe);return this.destroy(),We}_cloneInto(Re){Re||(Re=new this.constructor),Re.set(...this.get());const{blockLen:Fe,buffer:We,length:qe,finished:Ze,destroyed:Xe,pos:Je}=this;return Re.length=qe,Re.pos=Je,Re.finished=Ze,Re.destroyed=Xe,qe%Fe&&Re.buffer.set(We),Re}}const U32_MASK64=BigInt(2**32-1),_32n=BigInt(32);function fromBig(Ke,Re=!1){return Re?{h:Number(Ke&U32_MASK64),l:Number(Ke>>_32n&U32_MASK64)}:{h:Number(Ke>>_32n&U32_MASK64)|0,l:Number(Ke&U32_MASK64)|0}}function split(Ke,Re=!1){let Fe=new Uint32Array(Ke.length),We=new Uint32Array(Ke.length);for(let qe=0;qe<Ke.length;qe++){const{h:Ze,l:Xe}=fromBig(Ke[qe],Re);[Fe[qe],We[qe]]=[Ze,Xe]}return[Fe,We]}const toBig=(Ke,Re)=>BigInt(Ke>>>0)<<_32n|BigInt(Re>>>0),shrSH=(Ke,Re,Fe)=>Ke>>>Fe,shrSL=(Ke,Re,Fe)=>Ke<<32-Fe|Re>>>Fe,rotrSH=(Ke,Re,Fe)=>Ke>>>Fe|Re<<32-Fe,rotrSL=(Ke,Re,Fe)=>Ke<<32-Fe|Re>>>Fe,rotrBH=(Ke,Re,Fe)=>Ke<<64-Fe|Re>>>Fe-32,rotrBL=(Ke,Re,Fe)=>Ke>>>Fe-32|Re<<64-Fe,rotr32H=(Ke,Re)=>Re,rotr32L=(Ke,Re)=>Ke,rotlSH=(Ke,Re,Fe)=>Ke<<Fe|Re>>>32-Fe,rotlSL=(Ke,Re,Fe)=>Re<<Fe|Ke>>>32-Fe,rotlBH=(Ke,Re,Fe)=>Re<<Fe-32|Ke>>>64-Fe,rotlBL=(Ke,Re,Fe)=>Ke<<Fe-32|Re>>>64-Fe;function add(Ke,Re,Fe,We){const qe=(Re>>>0)+(We>>>0);return{h:Ke+Fe+(qe/2**32|0)|0,l:qe|0}}const add3L=(Ke,Re,Fe)=>(Ke>>>0)+(Re>>>0)+(Fe>>>0),add3H=(Ke,Re,Fe,We)=>Re+Fe+We+(Ke/2**32|0)|0,add4L=(Ke,Re,Fe,We)=>(Ke>>>0)+(Re>>>0)+(Fe>>>0)+(We>>>0),add4H=(Ke,Re,Fe,We,qe)=>Re+Fe+We+qe+(Ke/2**32|0)|0,add5L=(Ke,Re,Fe,We,qe)=>(Ke>>>0)+(Re>>>0)+(Fe>>>0)+(We>>>0)+(qe>>>0),add5H=(Ke,Re,Fe,We,qe,Ze)=>Re+Fe+We+qe+Ze+(Ke/2**32|0)|0,u64$1={fromBig,split,toBig,shrSH,shrSL,rotrSH,rotrSL,rotrBH,rotrBL,rotr32H,rotr32L,rotlSH,rotlSL,rotlBH,rotlBL,add,add3L,add3H,add4L,add4H,add5H,add5L},[SHA512_Kh,SHA512_Kl]=u64$1.split(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(Ke=>BigInt(Ke))),SHA512_W_H=new Uint32Array(80),SHA512_W_L=new Uint32Array(80);class SHA512 extends SHA2{constructor(){super(128,64,16,!1),this.Ah=1779033703,this.Al=-205731576,this.Bh=-1150833019,this.Bl=-2067093701,this.Ch=1013904242,this.Cl=-23791573,this.Dh=-1521486534,this.Dl=1595750129,this.Eh=1359893119,this.El=-1377402159,this.Fh=-1694144372,this.Fl=725511199,this.Gh=528734635,this.Gl=-79577749,this.Hh=1541459225,this.Hl=327033209}get(){const{Ah:Re,Al:Fe,Bh:We,Bl:qe,Ch:Ze,Cl:Xe,Dh:Je,Dl:tr,Eh:er,El:ir,Fh:lr,Fl:fr,Gh:ur,Gl:mr,Hh:br,Hl:wr}=this;return[Re,Fe,We,qe,Ze,Xe,Je,tr,er,ir,lr,fr,ur,mr,br,wr]}set(Re,Fe,We,qe,Ze,Xe,Je,tr,er,ir,lr,fr,ur,mr,br,wr){this.Ah=Re|0,this.Al=Fe|0,this.Bh=We|0,this.Bl=qe|0,this.Ch=Ze|0,this.Cl=Xe|0,this.Dh=Je|0,this.Dl=tr|0,this.Eh=er|0,this.El=ir|0,this.Fh=lr|0,this.Fl=fr|0,this.Gh=ur|0,this.Gl=mr|0,this.Hh=br|0,this.Hl=wr|0}process(Re,Fe){for(let Er=0;Er<16;Er++,Fe+=4)SHA512_W_H[Er]=Re.getUint32(Fe),SHA512_W_L[Er]=Re.getUint32(Fe+=4);for(let Er=16;Er<80;Er++){const Ir=SHA512_W_H[Er-15]|0,Rr=SHA512_W_L[Er-15]|0,Pr=u64$1.rotrSH(Ir,Rr,1)^u64$1.rotrSH(Ir,Rr,8)^u64$1.shrSH(Ir,Rr,7),Br=u64$1.rotrSL(Ir,Rr,1)^u64$1.rotrSL(Ir,Rr,8)^u64$1.shrSL(Ir,Rr,7),Or=SHA512_W_H[Er-2]|0,Nr=SHA512_W_L[Er-2]|0,Cr=u64$1.rotrSH(Or,Nr,19)^u64$1.rotrBH(Or,Nr,61)^u64$1.shrSH(Or,Nr,6),Tr=u64$1.rotrSL(Or,Nr,19)^u64$1.rotrBL(Or,Nr,61)^u64$1.shrSL(Or,Nr,6),Mr=u64$1.add4L(Br,Tr,SHA512_W_L[Er-7],SHA512_W_L[Er-16]),ar=u64$1.add4H(Mr,Pr,Cr,SHA512_W_H[Er-7],SHA512_W_H[Er-16]);SHA512_W_H[Er]=ar|0,SHA512_W_L[Er]=Mr|0}let{Ah:We,Al:qe,Bh:Ze,Bl:Xe,Ch:Je,Cl:tr,Dh:er,Dl:ir,Eh:lr,El:fr,Fh:ur,Fl:mr,Gh:br,Gl:wr,Hh:Sr,Hl:kr}=this;for(let Er=0;Er<80;Er++){const Ir=u64$1.rotrSH(lr,fr,14)^u64$1.rotrSH(lr,fr,18)^u64$1.rotrBH(lr,fr,41),Rr=u64$1.rotrSL(lr,fr,14)^u64$1.rotrSL(lr,fr,18)^u64$1.rotrBL(lr,fr,41),Pr=lr&ur^~lr&br,Br=fr&mr^~fr&wr,Or=u64$1.add5L(kr,Rr,Br,SHA512_Kl[Er],SHA512_W_L[Er]),Nr=u64$1.add5H(Or,Sr,Ir,Pr,SHA512_Kh[Er],SHA512_W_H[Er]),Cr=Or|0,Tr=u64$1.rotrSH(We,qe,28)^u64$1.rotrBH(We,qe,34)^u64$1.rotrBH(We,qe,39),Mr=u64$1.rotrSL(We,qe,28)^u64$1.rotrBL(We,qe,34)^u64$1.rotrBL(We,qe,39),ar=We&Ze^We&Je^Ze&Je,Dt=qe&Xe^qe&tr^Xe&tr;Sr=br|0,kr=wr|0,br=ur|0,wr=mr|0,ur=lr|0,mr=fr|0,{h:lr,l:fr}=u64$1.add(er|0,ir|0,Nr|0,Cr|0),er=Je|0,ir=tr|0,Je=Ze|0,tr=Xe|0,Ze=We|0,Xe=qe|0;const sr=u64$1.add3L(Cr,Mr,Dt);We=u64$1.add3H(sr,Nr,Tr,ar),qe=sr|0}({h:We,l:qe}=u64$1.add(this.Ah|0,this.Al|0,We|0,qe|0)),{h:Ze,l:Xe}=u64$1.add(this.Bh|0,this.Bl|0,Ze|0,Xe|0),{h:Je,l:tr}=u64$1.add(this.Ch|0,this.Cl|0,Je|0,tr|0),{h:er,l:ir}=u64$1.add(this.Dh|0,this.Dl|0,er|0,ir|0),{h:lr,l:fr}=u64$1.add(this.Eh|0,this.El|0,lr|0,fr|0),{h:ur,l:mr}=u64$1.add(this.Fh|0,this.Fl|0,ur|0,mr|0),{h:br,l:wr}=u64$1.add(this.Gh|0,this.Gl|0,br|0,wr|0),{h:Sr,l:kr}=u64$1.add(this.Hh|0,this.Hl|0,Sr|0,kr|0),this.set(We,qe,Ze,Xe,Je,tr,er,ir,lr,fr,ur,mr,br,wr,Sr,kr)}roundClean(){SHA512_W_H.fill(0),SHA512_W_L.fill(0)}destroy(){this.buffer.fill(0),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}class SHA512_256 extends SHA512{constructor(){super(),this.Ah=573645204,this.Al=-64227540,this.Bh=-1621794909,this.Bl=-934517566,this.Ch=596883563,this.Cl=1867755857,this.Dh=-1774684391,this.Dl=1497426621,this.Eh=-1775747358,this.El=-1467023389,this.Fh=-1101128155,this.Fl=1401305490,this.Gh=721525244,this.Gl=746961066,this.Hh=246885852,this.Hl=-2117784414,this.outputLen=32}}class SHA384 extends SHA512{constructor(){super(),this.Ah=-876896931,this.Al=-1056596264,this.Bh=1654270250,this.Bl=914150663,this.Ch=-1856437926,this.Cl=812702999,this.Dh=355462360,this.Dl=-150054599,this.Eh=1731405415,this.El=-4191439,this.Fh=-1900787065,this.Fl=1750603025,this.Gh=-619958771,this.Gl=1694076839,this.Hh=1203062813,this.Hl=-1090891868,this.outputLen=48}}const sha512=wrapConstructor(()=>new SHA512);wrapConstructor(()=>new SHA512_256);wrapConstructor(()=>new SHA384);const __viteBrowserExternal={},nodeCrypto=Object.freeze(Object.defineProperty({__proto__:null,default:__viteBrowserExternal},Symbol.toStringTag,{value:"Module"}));/*! noble-ed25519 - MIT License (c) 2019 Paul Miller (paulmillr.com) */const _0n$2=BigInt(0),_1n$2=BigInt(1),_2n$2=BigInt(2),CU_O=BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),CURVE$1=Object.freeze({a:BigInt(-1),d:BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),P:BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949"),l:CU_O,n:CU_O,h:BigInt(8),Gx:BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),Gy:BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960")}),POW_2_256$1=BigInt("0x10000000000000000000000000000000000000000000000000000000000000000"),SQRT_M1=BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");BigInt("6853475219497561581579357271197624642482790079785650197046958215289687604742");const SQRT_AD_MINUS_ONE=BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235"),INVSQRT_A_MINUS_D=BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578"),ONE_MINUS_D_SQ=BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838"),D_MINUS_ONE_SQ=BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952");class ExtendedPoint{constructor(Re,Fe,We,qe){this.x=Re,this.y=Fe,this.z=We,this.t=qe}static fromAffine(Re){if(!(Re instanceof Point$1))throw new TypeError("ExtendedPoint#fromAffine: expected Point");return Re.equals(Point$1.ZERO)?ExtendedPoint.ZERO:new ExtendedPoint(Re.x,Re.y,_1n$2,mod$1(Re.x*Re.y))}static toAffineBatch(Re){const Fe=invertBatch$1(Re.map(We=>We.z));return Re.map((We,qe)=>We.toAffine(Fe[qe]))}static normalizeZ(Re){return this.toAffineBatch(Re).map(this.fromAffine)}equals(Re){assertExtPoint(Re);const{x:Fe,y:We,z:qe}=this,{x:Ze,y:Xe,z:Je}=Re,tr=mod$1(Fe*Je),er=mod$1(Ze*qe),ir=mod$1(We*Je),lr=mod$1(Xe*qe);return tr===er&&ir===lr}negate(){return new ExtendedPoint(mod$1(-this.x),this.y,this.z,mod$1(-this.t))}double(){const{x:Re,y:Fe,z:We}=this,{a:qe}=CURVE$1,Ze=mod$1(Re*Re),Xe=mod$1(Fe*Fe),Je=mod$1(_2n$2*mod$1(We*We)),tr=mod$1(qe*Ze),er=Re+Fe,ir=mod$1(mod$1(er*er)-Ze-Xe),lr=tr+Xe,fr=lr-Je,ur=tr-Xe,mr=mod$1(ir*fr),br=mod$1(lr*ur),wr=mod$1(ir*ur),Sr=mod$1(fr*lr);return new ExtendedPoint(mr,br,Sr,wr)}add(Re){assertExtPoint(Re);const{x:Fe,y:We,z:qe,t:Ze}=this,{x:Xe,y:Je,z:tr,t:er}=Re,ir=mod$1((We-Fe)*(Je+Xe)),lr=mod$1((We+Fe)*(Je-Xe)),fr=mod$1(lr-ir);if(fr===_0n$2)return this.double();const ur=mod$1(qe*_2n$2*er),mr=mod$1(Ze*_2n$2*tr),br=mr+ur,wr=lr+ir,Sr=mr-ur,kr=mod$1(br*fr),Er=mod$1(wr*Sr),Ir=mod$1(br*Sr),Rr=mod$1(fr*wr);return new ExtendedPoint(kr,Er,Rr,Ir)}subtract(Re){return this.add(Re.negate())}precomputeWindow(Re){const Fe=1+256/Re,We=[];let qe=this,Ze=qe;for(let Xe=0;Xe<Fe;Xe++){Ze=qe,We.push(Ze);for(let Je=1;Je<2**(Re-1);Je++)Ze=Ze.add(qe),We.push(Ze);qe=Ze.double()}return We}wNAF(Re,Fe){!Fe&&this.equals(ExtendedPoint.BASE)&&(Fe=Point$1.BASE);const We=Fe&&Fe._WINDOW_SIZE||1;if(256%We)throw new Error("Point#wNAF: Invalid precomputation window, must be power of 2");let qe=Fe&&pointPrecomputes$1.get(Fe);qe||(qe=this.precomputeWindow(We),Fe&&We!==1&&(qe=ExtendedPoint.normalizeZ(qe),pointPrecomputes$1.set(Fe,qe)));let Ze=ExtendedPoint.ZERO,Xe=ExtendedPoint.ZERO;const Je=1+256/We,tr=2**(We-1),er=BigInt(2**We-1),ir=2**We,lr=BigInt(We);for(let fr=0;fr<Je;fr++){const ur=fr*tr;let mr=Number(Re&er);if(Re>>=lr,mr>tr&&(mr-=ir,Re+=_1n$2),mr===0){let br=qe[ur];fr%2&&(br=br.negate()),Xe=Xe.add(br)}else{let br=qe[ur+Math.abs(mr)-1];mr<0&&(br=br.negate()),Ze=Ze.add(br)}}return ExtendedPoint.normalizeZ([Ze,Xe])[0]}multiply(Re,Fe){return this.wNAF(normalizeScalar$1(Re,CURVE$1.l),Fe)}multiplyUnsafe(Re){let Fe=normalizeScalar$1(Re,CURVE$1.l,!1);const We=ExtendedPoint.BASE,qe=ExtendedPoint.ZERO;if(Fe===_0n$2)return qe;if(this.equals(qe)||Fe===_1n$2)return this;if(this.equals(We))return this.wNAF(Fe);let Ze=qe,Xe=this;for(;Fe>_0n$2;)Fe&_1n$2&&(Ze=Ze.add(Xe)),Xe=Xe.double(),Fe>>=_1n$2;return Ze}isSmallOrder(){return this.multiplyUnsafe(CURVE$1.h).equals(ExtendedPoint.ZERO)}isTorsionFree(){return this.multiplyUnsafe(CURVE$1.l).equals(ExtendedPoint.ZERO)}toAffine(Re=invert$1(this.z)){const{x:Fe,y:We,z:qe}=this,Ze=mod$1(Fe*Re),Xe=mod$1(We*Re);if(mod$1(qe*Re)!==_1n$2)throw new Error("invZ was invalid");return new Point$1(Ze,Xe)}fromRistrettoBytes(){legacyRist()}toRistrettoBytes(){legacyRist()}fromRistrettoHash(){legacyRist()}}ExtendedPoint.BASE=new ExtendedPoint(CURVE$1.Gx,CURVE$1.Gy,_1n$2,mod$1(CURVE$1.Gx*CURVE$1.Gy));ExtendedPoint.ZERO=new ExtendedPoint(_0n$2,_1n$2,_1n$2,_0n$2);function assertExtPoint(Ke){if(!(Ke instanceof ExtendedPoint))throw new TypeError("ExtendedPoint expected")}function assertRstPoint(Ke){if(!(Ke instanceof RistrettoPoint))throw new TypeError("RistrettoPoint expected")}function legacyRist(){throw new Error("Legacy method: switch to RistrettoPoint")}class RistrettoPoint{constructor(Re){this.ep=Re}static calcElligatorRistrettoMap(Re){const{d:Fe}=CURVE$1,We=mod$1(SQRT_M1*Re*Re),qe=mod$1((We+_1n$2)*ONE_MINUS_D_SQ);let Ze=BigInt(-1);const Xe=mod$1((Ze-Fe*We)*mod$1(We+Fe));let{isValid:Je,value:tr}=uvRatio(qe,Xe),er=mod$1(tr*Re);edIsNegative(er)||(er=mod$1(-er)),Je||(tr=er),Je||(Ze=We);const ir=mod$1(Ze*(We-_1n$2)*D_MINUS_ONE_SQ-Xe),lr=tr*tr,fr=mod$1((tr+tr)*Xe),ur=mod$1(ir*SQRT_AD_MINUS_ONE),mr=mod$1(_1n$2-lr),br=mod$1(_1n$2+lr);return new ExtendedPoint(mod$1(fr*br),mod$1(mr*ur),mod$1(ur*br),mod$1(fr*mr))}static hashToCurve(Re){Re=ensureBytes$1(Re,64);const Fe=bytes255ToNumberLE(Re.slice(0,32)),We=this.calcElligatorRistrettoMap(Fe),qe=bytes255ToNumberLE(Re.slice(32,64)),Ze=this.calcElligatorRistrettoMap(qe);return new RistrettoPoint(We.add(Ze))}static fromHex(Re){Re=ensureBytes$1(Re,32);const{a:Fe,d:We}=CURVE$1,qe="RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint",Ze=bytes255ToNumberLE(Re);if(!equalBytes(numberTo32BytesLE(Ze),Re)||edIsNegative(Ze))throw new Error(qe);const Xe=mod$1(Ze*Ze),Je=mod$1(_1n$2+Fe*Xe),tr=mod$1(_1n$2-Fe*Xe),er=mod$1(Je*Je),ir=mod$1(tr*tr),lr=mod$1(Fe*We*er-ir),{isValid:fr,value:ur}=invertSqrt(mod$1(lr*ir)),mr=mod$1(ur*tr),br=mod$1(ur*mr*lr);let wr=mod$1((Ze+Ze)*mr);edIsNegative(wr)&&(wr=mod$1(-wr));const Sr=mod$1(Je*br),kr=mod$1(wr*Sr);if(!fr||edIsNegative(kr)||Sr===_0n$2)throw new Error(qe);return new RistrettoPoint(new ExtendedPoint(wr,Sr,_1n$2,kr))}toRawBytes(){let{x:Re,y:Fe,z:We,t:qe}=this.ep;const Ze=mod$1(mod$1(We+Fe)*mod$1(We-Fe)),Xe=mod$1(Re*Fe),Je=mod$1(Xe*Xe),{value:tr}=invertSqrt(mod$1(Ze*Je)),er=mod$1(tr*Ze),ir=mod$1(tr*Xe),lr=mod$1(er*ir*qe);let fr;if(edIsNegative(qe*lr)){let mr=mod$1(Fe*SQRT_M1),br=mod$1(Re*SQRT_M1);Re=mr,Fe=br,fr=mod$1(er*INVSQRT_A_MINUS_D)}else fr=ir;edIsNegative(Re*lr)&&(Fe=mod$1(-Fe));let ur=mod$1((We-Fe)*fr);return edIsNegative(ur)&&(ur=mod$1(-ur)),numberTo32BytesLE(ur)}toHex(){return bytesToHex$1(this.toRawBytes())}toString(){return this.toHex()}equals(Re){assertRstPoint(Re);const Fe=this.ep,We=Re.ep,qe=mod$1(Fe.x*We.y)===mod$1(Fe.y*We.x),Ze=mod$1(Fe.y*We.y)===mod$1(Fe.x*We.x);return qe||Ze}add(Re){return assertRstPoint(Re),new RistrettoPoint(this.ep.add(Re.ep))}subtract(Re){return assertRstPoint(Re),new RistrettoPoint(this.ep.subtract(Re.ep))}multiply(Re){return new RistrettoPoint(this.ep.multiply(Re))}multiplyUnsafe(Re){return new RistrettoPoint(this.ep.multiplyUnsafe(Re))}}RistrettoPoint.BASE=new RistrettoPoint(ExtendedPoint.BASE);RistrettoPoint.ZERO=new RistrettoPoint(ExtendedPoint.ZERO);const pointPrecomputes$1=new WeakMap;class Point$1{constructor(Re,Fe){this.x=Re,this.y=Fe}_setWindowSize(Re){this._WINDOW_SIZE=Re,pointPrecomputes$1.delete(this)}static fromHex(Re,Fe=!0){const{d:We,P:qe}=CURVE$1;Re=ensureBytes$1(Re,32);const Ze=Re.slice();Ze[31]=Re[31]&-129;const Xe=bytesToNumberLE(Ze);if(Fe&&Xe>=qe)throw new Error("Expected 0 < hex < P");if(!Fe&&Xe>=POW_2_256$1)throw new Error("Expected 0 < hex < 2**256");const Je=mod$1(Xe*Xe),tr=mod$1(Je-_1n$2),er=mod$1(We*Je+_1n$2);let{isValid:ir,value:lr}=uvRatio(tr,er);if(!ir)throw new Error("Point.fromHex: invalid y coordinate");const fr=(lr&_1n$2)===_1n$2;return(Re[31]&128)!==0!==fr&&(lr=mod$1(-lr)),new Point$1(lr,Xe)}static async fromPrivateKey(Re){return(await getExtendedPublicKey(Re)).point}toRawBytes(){const Re=numberTo32BytesLE(this.y);return Re[31]|=this.x&_1n$2?128:0,Re}toHex(){return bytesToHex$1(this.toRawBytes())}toX25519(){const{y:Re}=this,Fe=mod$1((_1n$2+Re)*invert$1(_1n$2-Re));return numberTo32BytesLE(Fe)}isTorsionFree(){return ExtendedPoint.fromAffine(this).isTorsionFree()}equals(Re){return this.x===Re.x&&this.y===Re.y}negate(){return new Point$1(mod$1(-this.x),this.y)}add(Re){return ExtendedPoint.fromAffine(this).add(ExtendedPoint.fromAffine(Re)).toAffine()}subtract(Re){return this.add(Re.negate())}multiply(Re){return ExtendedPoint.fromAffine(this).multiply(Re,this).toAffine()}}Point$1.BASE=new Point$1(CURVE$1.Gx,CURVE$1.Gy);Point$1.ZERO=new Point$1(_0n$2,_1n$2);class Signature$1{constructor(Re,Fe){this.r=Re,this.s=Fe,this.assertValidity()}static fromHex(Re){const Fe=ensureBytes$1(Re,64),We=Point$1.fromHex(Fe.slice(0,32),!1),qe=bytesToNumberLE(Fe.slice(32,64));return new Signature$1(We,qe)}assertValidity(){const{r:Re,s:Fe}=this;if(!(Re instanceof Point$1))throw new Error("Expected Point instance");return normalizeScalar$1(Fe,CURVE$1.l,!1),this}toRawBytes(){const Re=new Uint8Array(64);return Re.set(this.r.toRawBytes()),Re.set(numberTo32BytesLE(this.s),32),Re}toHex(){return bytesToHex$1(this.toRawBytes())}}function concatBytes$1(...Ke){if(!Ke.every(We=>We instanceof Uint8Array))throw new Error("Expected Uint8Array list");if(Ke.length===1)return Ke[0];const Re=Ke.reduce((We,qe)=>We+qe.length,0),Fe=new Uint8Array(Re);for(let We=0,qe=0;We<Ke.length;We++){const Ze=Ke[We];Fe.set(Ze,qe),qe+=Ze.length}return Fe}const hexes$1=Array.from({length:256},(Ke,Re)=>Re.toString(16).padStart(2,"0"));function bytesToHex$1(Ke){if(!(Ke instanceof Uint8Array))throw new Error("Uint8Array expected");let Re="";for(let Fe=0;Fe<Ke.length;Fe++)Re+=hexes$1[Ke[Fe]];return Re}function hexToBytes$1(Ke){if(typeof Ke!="string")throw new TypeError("hexToBytes: expected string, got "+typeof Ke);if(Ke.length%2)throw new Error("hexToBytes: received invalid unpadded hex");const Re=new Uint8Array(Ke.length/2);for(let Fe=0;Fe<Re.length;Fe++){const We=Fe*2,qe=Ke.slice(We,We+2),Ze=Number.parseInt(qe,16);if(Number.isNaN(Ze)||Ze<0)throw new Error("Invalid byte sequence");Re[Fe]=Ze}return Re}function numberTo32BytesBE(Ke){const Fe=Ke.toString(16).padStart(64,"0");return hexToBytes$1(Fe)}function numberTo32BytesLE(Ke){return numberTo32BytesBE(Ke).reverse()}function edIsNegative(Ke){return(mod$1(Ke)&_1n$2)===_1n$2}function bytesToNumberLE(Ke){if(!(Ke instanceof Uint8Array))throw new Error("Expected Uint8Array");return BigInt("0x"+bytesToHex$1(Uint8Array.from(Ke).reverse()))}const MAX_255B=BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");function bytes255ToNumberLE(Ke){return mod$1(bytesToNumberLE(Ke)&MAX_255B)}function mod$1(Ke,Re=CURVE$1.P){const Fe=Ke%Re;return Fe>=_0n$2?Fe:Re+Fe}function invert$1(Ke,Re=CURVE$1.P){if(Ke===_0n$2||Re<=_0n$2)throw new Error(`invert: expected positive integers, got n=${Ke} mod=${Re}`);let Fe=mod$1(Ke,Re),We=Re,qe=_0n$2,Ze=_1n$2;for(;Fe!==_0n$2;){const Je=We/Fe,tr=We%Fe,er=qe-Ze*Je;We=Fe,Fe=tr,qe=Ze,Ze=er}if(We!==_1n$2)throw new Error("invert: does not exist");return mod$1(qe,Re)}function invertBatch$1(Ke,Re=CURVE$1.P){const Fe=new Array(Ke.length),We=Ke.reduce((Ze,Xe,Je)=>Xe===_0n$2?Ze:(Fe[Je]=Ze,mod$1(Ze*Xe,Re)),_1n$2),qe=invert$1(We,Re);return Ke.reduceRight((Ze,Xe,Je)=>Xe===_0n$2?Ze:(Fe[Je]=mod$1(Ze*Fe[Je],Re),mod$1(Ze*Xe,Re)),qe),Fe}function pow2$1(Ke,Re){const{P:Fe}=CURVE$1;let We=Ke;for(;Re-- >_0n$2;)We*=We,We%=Fe;return We}function pow_2_252_3(Ke){const{P:Re}=CURVE$1,Fe=BigInt(5),We=BigInt(10),qe=BigInt(20),Ze=BigInt(40),Xe=BigInt(80),tr=Ke*Ke%Re*Ke%Re,er=pow2$1(tr,_2n$2)*tr%Re,ir=pow2$1(er,_1n$2)*Ke%Re,lr=pow2$1(ir,Fe)*ir%Re,fr=pow2$1(lr,We)*lr%Re,ur=pow2$1(fr,qe)*fr%Re,mr=pow2$1(ur,Ze)*ur%Re,br=pow2$1(mr,Xe)*mr%Re,wr=pow2$1(br,Xe)*mr%Re,Sr=pow2$1(wr,We)*lr%Re;return{pow_p_5_8:pow2$1(Sr,_2n$2)*Ke%Re,b2:tr}}function uvRatio(Ke,Re){const Fe=mod$1(Re*Re*Re),We=mod$1(Fe*Fe*Re),qe=pow_2_252_3(Ke*We).pow_p_5_8;let Ze=mod$1(Ke*Fe*qe);const Xe=mod$1(Re*Ze*Ze),Je=Ze,tr=mod$1(Ze*SQRT_M1),er=Xe===Ke,ir=Xe===mod$1(-Ke),lr=Xe===mod$1(-Ke*SQRT_M1);return er&&(Ze=Je),(ir||lr)&&(Ze=tr),edIsNegative(Ze)&&(Ze=mod$1(-Ze)),{isValid:er||ir,value:Ze}}function invertSqrt(Ke){return uvRatio(_1n$2,Ke)}function modlLE(Ke){return mod$1(bytesToNumberLE(Ke),CURVE$1.l)}function equalBytes(Ke,Re){if(Ke.length!==Re.length)return!1;for(let Fe=0;Fe<Ke.length;Fe++)if(Ke[Fe]!==Re[Fe])return!1;return!0}function ensureBytes$1(Ke,Re){const Fe=Ke instanceof Uint8Array?Uint8Array.from(Ke):hexToBytes$1(Ke);if(typeof Re=="number"&&Fe.length!==Re)throw new Error(`Expected ${Re} bytes`);return Fe}function normalizeScalar$1(Ke,Re,Fe=!0){if(!Re)throw new TypeError("Specify max value");if(typeof Ke=="number"&&Number.isSafeInteger(Ke)&&(Ke=BigInt(Ke)),typeof Ke=="bigint"&&Ke<Re){if(Fe){if(_0n$2<Ke)return Ke}else if(_0n$2<=Ke)return Ke}throw new TypeError("Expected valid scalar: 0 < scalar < max")}function adjustBytes25519(Ke){return Ke[0]&=248,Ke[31]&=127,Ke[31]|=64,Ke}function checkPrivateKey(Ke){if(Ke=typeof Ke=="bigint"||typeof Ke=="number"?numberTo32BytesBE(normalizeScalar$1(Ke,POW_2_256$1)):ensureBytes$1(Ke),Ke.length!==32)throw new Error("Expected 32 bytes");return Ke}function getKeyFromHash(Ke){const Re=adjustBytes25519(Ke.slice(0,32)),Fe=Ke.slice(32,64),We=modlLE(Re),qe=Point$1.BASE.multiply(We),Ze=qe.toRawBytes();return{head:Re,prefix:Fe,scalar:We,point:qe,pointBytes:Ze}}let _sha512Sync;function sha512s(...Ke){if(typeof _sha512Sync!="function")throw new Error("utils.sha512Sync must be set to use sync methods");return _sha512Sync(...Ke)}async function getExtendedPublicKey(Ke){return getKeyFromHash(await utils$1.sha512(checkPrivateKey(Ke)))}function getExtendedPublicKeySync(Ke){return getKeyFromHash(sha512s(checkPrivateKey(Ke)))}function getPublicKeySync(Ke){return getExtendedPublicKeySync(Ke).pointBytes}function signSync$1(Ke,Re){Ke=ensureBytes$1(Ke);const{prefix:Fe,scalar:We,pointBytes:qe}=getExtendedPublicKeySync(Re),Ze=modlLE(sha512s(Fe,Ke)),Xe=Point$1.BASE.multiply(Ze),Je=modlLE(sha512s(Xe.toRawBytes(),qe,Ke)),tr=mod$1(Ze+Je*We,CURVE$1.l);return new Signature$1(Xe,tr).toRawBytes()}function prepareVerification(Ke,Re,Fe){Re=ensureBytes$1(Re),Fe instanceof Point$1||(Fe=Point$1.fromHex(Fe,!1));const{r:We,s:qe}=Ke instanceof Signature$1?Ke.assertValidity():Signature$1.fromHex(Ke),Ze=ExtendedPoint.BASE.multiplyUnsafe(qe);return{r:We,s:qe,SB:Ze,pub:Fe,msg:Re}}function finishVerification(Ke,Re,Fe,We){const qe=modlLE(We),Ze=ExtendedPoint.fromAffine(Ke).multiplyUnsafe(qe);return ExtendedPoint.fromAffine(Re).add(Ze).subtract(Fe).multiplyUnsafe(CURVE$1.h).equals(ExtendedPoint.ZERO)}function verifySync(Ke,Re,Fe){const{r:We,SB:qe,msg:Ze,pub:Xe}=prepareVerification(Ke,Re,Fe),Je=sha512s(We.toRawBytes(),Xe.toRawBytes(),Ze);return finishVerification(Xe,We,qe,Je)}const sync={getExtendedPublicKey:getExtendedPublicKeySync,getPublicKey:getPublicKeySync,sign:signSync$1,verify:verifySync};Point$1.BASE._setWindowSize(8);const crypto$2={node:nodeCrypto,web:typeof self=="object"&&"crypto"in self?self.crypto:void 0},utils$1={bytesToHex:bytesToHex$1,hexToBytes:hexToBytes$1,concatBytes:concatBytes$1,getExtendedPublicKey,mod:mod$1,invert:invert$1,TORSION_SUBGROUP:["0100000000000000000000000000000000000000000000000000000000000000","c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a","0000000000000000000000000000000000000000000000000000000000000080","26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05","ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f","26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85","0000000000000000000000000000000000000000000000000000000000000000","c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa"],hashToPrivateScalar:Ke=>{if(Ke=ensureBytes$1(Ke),Ke.length<40||Ke.length>1024)throw new Error("Expected 40-1024 bytes of private key as per FIPS 186");return mod$1(bytesToNumberLE(Ke),CURVE$1.l-_1n$2)+_1n$2},randomBytes:(Ke=32)=>{if(crypto$2.web)return crypto$2.web.getRandomValues(new Uint8Array(Ke));if(crypto$2.node){const{randomBytes:Re}=crypto$2.node;return new Uint8Array(Re(Ke).buffer)}else throw new Error("The environment doesn't have randomBytes function")},randomPrivateKey:()=>utils$1.randomBytes(32),sha512:async(...Ke)=>{const Re=concatBytes$1(...Ke);if(crypto$2.web){const Fe=await crypto$2.web.subtle.digest("SHA-512",Re.buffer);return new Uint8Array(Fe)}else{if(crypto$2.node)return Uint8Array.from(crypto$2.node.createHash("sha512").update(Re).digest());throw new Error("The environment doesn't have sha512 function")}},precompute(Ke=8,Re=Point$1.BASE){const Fe=Re.equals(Point$1.BASE)?Re:new Point$1(Re.x,Re.y);return Fe._setWindowSize(Ke),Fe.multiply(_2n$2),Fe},sha512Sync:void 0};Object.defineProperties(utils$1,{sha512Sync:{configurable:!1,get(){return _sha512Sync},set(Ke){_sha512Sync||(_sha512Sync=Ke)}}});var bn$1={exports:{}};const require$$0$1=getAugmentedNamespace(nodeCrypto);(function(Ke){(function(Re,Fe){function We(ar,Dt){if(!ar)throw new Error(Dt||"Assertion failed")}function qe(ar,Dt){ar.super_=Dt;var sr=function(){};sr.prototype=Dt.prototype,ar.prototype=new sr,ar.prototype.constructor=ar}function Ze(ar,Dt,sr){if(Ze.isBN(ar))return ar;this.negative=0,this.words=null,this.length=0,this.red=null,ar!==null&&((Dt==="le"||Dt==="be")&&(sr=Dt,Dt=10),this._init(ar||0,Dt||10,sr||"be"))}typeof Re=="object"?Re.exports=Ze:Fe.BN=Ze,Ze.BN=Ze,Ze.wordSize=26;var Xe;try{typeof window<"u"&&typeof window.Buffer<"u"?Xe=window.Buffer:Xe=require$$0$1.Buffer}catch{}Ze.isBN=function(Dt){return Dt instanceof Ze?!0:Dt!==null&&typeof Dt=="object"&&Dt.constructor.wordSize===Ze.wordSize&&Array.isArray(Dt.words)},Ze.max=function(Dt,sr){return Dt.cmp(sr)>0?Dt:sr},Ze.min=function(Dt,sr){return Dt.cmp(sr)<0?Dt:sr},Ze.prototype._init=function(Dt,sr,cr){if(typeof Dt=="number")return this._initNumber(Dt,sr,cr);if(typeof Dt=="object")return this._initArray(Dt,sr,cr);sr==="hex"&&(sr=16),We(sr===(sr|0)&&sr>=2&&sr<=36),Dt=Dt.toString().replace(/\s+/g,"");var yr=0;Dt[0]==="-"&&(yr++,this.negative=1),yr<Dt.length&&(sr===16?this._parseHex(Dt,yr,cr):(this._parseBase(Dt,sr,yr),cr==="le"&&this._initArray(this.toArray(),sr,cr)))},Ze.prototype._initNumber=function(Dt,sr,cr){Dt<0&&(this.negative=1,Dt=-Dt),Dt<67108864?(this.words=[Dt&67108863],this.length=1):Dt<4503599627370496?(this.words=[Dt&67108863,Dt/67108864&67108863],this.length=2):(We(Dt<9007199254740992),this.words=[Dt&67108863,Dt/67108864&67108863,1],this.length=3),cr==="le"&&this._initArray(this.toArray(),sr,cr)},Ze.prototype._initArray=function(Dt,sr,cr){if(We(typeof Dt.length=="number"),Dt.length<=0)return this.words=[0],this.length=1,this;this.length=Math.ceil(Dt.length/3),this.words=new Array(this.length);for(var yr=0;yr<this.length;yr++)this.words[yr]=0;var _r,xr,Ar=0;if(cr==="be")for(yr=Dt.length-1,_r=0;yr>=0;yr-=3)xr=Dt[yr]|Dt[yr-1]<<8|Dt[yr-2]<<16,this.words[_r]|=xr<<Ar&67108863,this.words[_r+1]=xr>>>26-Ar&67108863,Ar+=24,Ar>=26&&(Ar-=26,_r++);else if(cr==="le")for(yr=0,_r=0;yr<Dt.length;yr+=3)xr=Dt[yr]|Dt[yr+1]<<8|Dt[yr+2]<<16,this.words[_r]|=xr<<Ar&67108863,this.words[_r+1]=xr>>>26-Ar&67108863,Ar+=24,Ar>=26&&(Ar-=26,_r++);return this._strip()};function Je(ar,Dt){var sr=ar.charCodeAt(Dt);if(sr>=48&&sr<=57)return sr-48;if(sr>=65&&sr<=70)return sr-55;if(sr>=97&&sr<=102)return sr-87;We(!1,"Invalid character in "+ar)}function tr(ar,Dt,sr){var cr=Je(ar,sr);return sr-1>=Dt&&(cr|=Je(ar,sr-1)<<4),cr}Ze.prototype._parseHex=function(Dt,sr,cr){this.length=Math.ceil((Dt.length-sr)/6),this.words=new Array(this.length);for(var yr=0;yr<this.length;yr++)this.words[yr]=0;var _r=0,xr=0,Ar;if(cr==="be")for(yr=Dt.length-1;yr>=sr;yr-=2)Ar=tr(Dt,sr,yr)<<_r,this.words[xr]|=Ar&67108863,_r>=18?(_r-=18,xr+=1,this.words[xr]|=Ar>>>26):_r+=8;else{var pr=Dt.length-sr;for(yr=pr%2===0?sr+1:sr;yr<Dt.length;yr+=2)Ar=tr(Dt,sr,yr)<<_r,this.words[xr]|=Ar&67108863,_r>=18?(_r-=18,xr+=1,this.words[xr]|=Ar>>>26):_r+=8}this._strip()};function er(ar,Dt,sr,cr){for(var yr=0,_r=0,xr=Math.min(ar.length,sr),Ar=Dt;Ar<xr;Ar++){var pr=ar.charCodeAt(Ar)-48;yr*=cr,pr>=49?_r=pr-49+10:pr>=17?_r=pr-17+10:_r=pr,We(pr>=0&&_r<cr,"Invalid character"),yr+=_r}return yr}Ze.prototype._parseBase=function(Dt,sr,cr){this.words=[0],this.length=1;for(var yr=0,_r=1;_r<=67108863;_r*=sr)yr++;yr--,_r=_r/sr|0;for(var xr=Dt.length-cr,Ar=xr%yr,pr=Math.min(xr,xr-Ar)+cr,rr=0,hr=cr;hr<pr;hr+=yr)rr=er(Dt,hr,hr+yr,sr),this.imuln(_r),this.words[0]+rr<67108864?this.words[0]+=rr:this._iaddn(rr);if(Ar!==0){var $r=1;for(rr=er(Dt,hr,Dt.length,sr),hr=0;hr<Ar;hr++)$r*=sr;this.imuln($r),this.words[0]+rr<67108864?this.words[0]+=rr:this._iaddn(rr)}this._strip()},Ze.prototype.copy=function(Dt){Dt.words=new Array(this.length);for(var sr=0;sr<this.length;sr++)Dt.words[sr]=this.words[sr];Dt.length=this.length,Dt.negative=this.negative,Dt.red=this.red};function ir(ar,Dt){ar.words=Dt.words,ar.length=Dt.length,ar.negative=Dt.negative,ar.red=Dt.red}if(Ze.prototype._move=function(Dt){ir(Dt,this)},Ze.prototype.clone=function(){var Dt=new Ze(null);return this.copy(Dt),Dt},Ze.prototype._expand=function(Dt){for(;this.length<Dt;)this.words[this.length++]=0;return this},Ze.prototype._strip=function(){for(;this.length>1&&this.words[this.length-1]===0;)this.length--;return this._normSign()},Ze.prototype._normSign=function(){return this.length===1&&this.words[0]===0&&(this.negative=0),this},typeof Symbol<"u"&&typeof Symbol.for=="function")try{Ze.prototype[Symbol.for("nodejs.util.inspect.custom")]=lr}catch{Ze.prototype.inspect=lr}else Ze.prototype.inspect=lr;function lr(){return(this.red?"<BN-R: ":"<BN: ")+this.toString(16)+">"}var fr=["","0","00","000","0000","00000","000000","0000000","00000000","000000000","0000000000","00000000000","000000000000","0000000000000","00000000000000","000000000000000","0000000000000000","00000000000000000","000000000000000000","0000000000000000000","00000000000000000000","000000000000000000000","0000000000000000000000","00000000000000000000000","000000000000000000000000","0000000000000000000000000"],ur=[0,0,25,16,12,11,10,9,8,8,7,7,7,7,6,6,6,6,6,6,6,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5],mr=[0,0,33554432,43046721,16777216,48828125,60466176,40353607,16777216,43046721,1e7,19487171,35831808,62748517,7529536,11390625,16777216,24137569,34012224,47045881,64e6,4084101,5153632,6436343,7962624,9765625,11881376,14348907,17210368,20511149,243e5,28629151,33554432,39135393,45435424,52521875,60466176];Ze.prototype.toString=function(Dt,sr){Dt=Dt||10,sr=sr|0||1;var cr;if(Dt===16||Dt==="hex"){cr="";for(var yr=0,_r=0,xr=0;xr<this.length;xr++){var Ar=this.words[xr],pr=((Ar<<yr|_r)&16777215).toString(16);_r=Ar>>>24-yr&16777215,yr+=2,yr>=26&&(yr-=26,xr--),_r!==0||xr!==this.length-1?cr=fr[6-pr.length]+pr+cr:cr=pr+cr}for(_r!==0&&(cr=_r.toString(16)+cr);cr.length%sr!==0;)cr="0"+cr;return this.negative!==0&&(cr="-"+cr),cr}if(Dt===(Dt|0)&&Dt>=2&&Dt<=36){var rr=ur[Dt],hr=mr[Dt];cr="";var $r=this.clone();for($r.negative=0;!$r.isZero();){var Lr=$r.modrn(hr).toString(Dt);$r=$r.idivn(hr),$r.isZero()?cr=Lr+cr:cr=fr[rr-Lr.length]+Lr+cr}for(this.isZero()&&(cr="0"+cr);cr.length%sr!==0;)cr="0"+cr;return this.negative!==0&&(cr="-"+cr),cr}We(!1,"Base should be between 2 and 36")},Ze.prototype.toNumber=function(){var Dt=this.words[0];return this.length===2?Dt+=this.words[1]*67108864:this.length===3&&this.words[2]===1?Dt+=4503599627370496+this.words[1]*67108864:this.length>2&&We(!1,"Number can only safely store up to 53 bits"),this.negative!==0?-Dt:Dt},Ze.prototype.toJSON=function(){return this.toString(16,2)},Xe&&(Ze.prototype.toBuffer=function(Dt,sr){return this.toArrayLike(Xe,Dt,sr)}),Ze.prototype.toArray=function(Dt,sr){return this.toArrayLike(Array,Dt,sr)};var br=function(Dt,sr){return Dt.allocUnsafe?Dt.allocUnsafe(sr):new Dt(sr)};Ze.prototype.toArrayLike=function(Dt,sr,cr){this._strip();var yr=this.byteLength(),_r=cr||Math.max(1,yr);We(yr<=_r,"byte array longer than desired length"),We(_r>0,"Requested array length <= 0");var xr=br(Dt,_r),Ar=sr==="le"?"LE":"BE";return this["_toArrayLike"+Ar](xr,yr),xr},Ze.prototype._toArrayLikeLE=function(Dt,sr){for(var cr=0,yr=0,_r=0,xr=0;_r<this.length;_r++){var Ar=this.words[_r]<<xr|yr;Dt[cr++]=Ar&255,cr<Dt.length&&(Dt[cr++]=Ar>>8&255),cr<Dt.length&&(Dt[cr++]=Ar>>16&255),xr===6?(cr<Dt.length&&(Dt[cr++]=Ar>>24&255),yr=0,xr=0):(yr=Ar>>>24,xr+=2)}if(cr<Dt.length)for(Dt[cr++]=yr;cr<Dt.length;)Dt[cr++]=0},Ze.prototype._toArrayLikeBE=function(Dt,sr){for(var cr=Dt.length-1,yr=0,_r=0,xr=0;_r<this.length;_r++){var Ar=this.words[_r]<<xr|yr;Dt[cr--]=Ar&255,cr>=0&&(Dt[cr--]=Ar>>8&255),cr>=0&&(Dt[cr--]=Ar>>16&255),xr===6?(cr>=0&&(Dt[cr--]=Ar>>24&255),yr=0,xr=0):(yr=Ar>>>24,xr+=2)}if(cr>=0)for(Dt[cr--]=yr;cr>=0;)Dt[cr--]=0},Math.clz32?Ze.prototype._countBits=function(Dt){return 32-Math.clz32(Dt)}:Ze.prototype._countBits=function(Dt){var sr=Dt,cr=0;return sr>=4096&&(cr+=13,sr>>>=13),sr>=64&&(cr+=7,sr>>>=7),sr>=8&&(cr+=4,sr>>>=4),sr>=2&&(cr+=2,sr>>>=2),cr+sr},Ze.prototype._zeroBits=function(Dt){if(Dt===0)return 26;var sr=Dt,cr=0;return(sr&8191)===0&&(cr+=13,sr>>>=13),(sr&127)===0&&(cr+=7,sr>>>=7),(sr&15)===0&&(cr+=4,sr>>>=4),(sr&3)===0&&(cr+=2,sr>>>=2),(sr&1)===0&&cr++,cr},Ze.prototype.bitLength=function(){var Dt=this.words[this.length-1],sr=this._countBits(Dt);return(this.length-1)*26+sr};function wr(ar){for(var Dt=new Array(ar.bitLength()),sr=0;sr<Dt.length;sr++){var cr=sr/26|0,yr=sr%26;Dt[sr]=ar.words[cr]>>>yr&1}return Dt}Ze.prototype.zeroBits=function(){if(this.isZero())return 0;for(var Dt=0,sr=0;sr<this.length;sr++){var cr=this._zeroBits(this.words[sr]);if(Dt+=cr,cr!==26)break}return Dt},Ze.prototype.byteLength=function(){return Math.ceil(this.bitLength()/8)},Ze.prototype.toTwos=function(Dt){return this.negative!==0?this.abs().inotn(Dt).iaddn(1):this.clone()},Ze.prototype.fromTwos=function(Dt){return this.testn(Dt-1)?this.notn(Dt).iaddn(1).ineg():this.clone()},Ze.prototype.isNeg=function(){return this.negative!==0},Ze.prototype.neg=function(){return this.clone().ineg()},Ze.prototype.ineg=function(){return this.isZero()||(this.negative^=1),this},Ze.prototype.iuor=function(Dt){for(;this.length<Dt.length;)this.words[this.length++]=0;for(var sr=0;sr<Dt.length;sr++)this.words[sr]=this.words[sr]|Dt.words[sr];return this._strip()},Ze.prototype.ior=function(Dt){return We((this.negative|Dt.negative)===0),this.iuor(Dt)},Ze.prototype.or=function(Dt){return this.length>Dt.length?this.clone().ior(Dt):Dt.clone().ior(this)},Ze.prototype.uor=function(Dt){return this.length>Dt.length?this.clone().iuor(Dt):Dt.clone().iuor(this)},Ze.prototype.iuand=function(Dt){var sr;this.length>Dt.length?sr=Dt:sr=this;for(var cr=0;cr<sr.length;cr++)this.words[cr]=this.words[cr]&Dt.words[cr];return this.length=sr.length,this._strip()},Ze.prototype.iand=function(Dt){return We((this.negative|Dt.negative)===0),this.iuand(Dt)},Ze.prototype.and=function(Dt){return this.length>Dt.length?this.clone().iand(Dt):Dt.clone().iand(this)},Ze.prototype.uand=function(Dt){return this.length>Dt.length?this.clone().iuand(Dt):Dt.clone().iuand(this)},Ze.prototype.iuxor=function(Dt){var sr,cr;this.length>Dt.length?(sr=this,cr=Dt):(sr=Dt,cr=this);for(var yr=0;yr<cr.length;yr++)this.words[yr]=sr.words[yr]^cr.words[yr];if(this!==sr)for(;yr<sr.length;yr++)this.words[yr]=sr.words[yr];return this.length=sr.length,this._strip()},Ze.prototype.ixor=function(Dt){return We((this.negative|Dt.negative)===0),this.iuxor(Dt)},Ze.prototype.xor=function(Dt){return this.length>Dt.length?this.clone().ixor(Dt):Dt.clone().ixor(this)},Ze.prototype.uxor=function(Dt){return this.length>Dt.length?this.clone().iuxor(Dt):Dt.clone().iuxor(this)},Ze.prototype.inotn=function(Dt){We(typeof Dt=="number"&&Dt>=0);var sr=Math.ceil(Dt/26)|0,cr=Dt%26;this._expand(sr),cr>0&&sr--;for(var yr=0;yr<sr;yr++)this.words[yr]=~this.words[yr]&67108863;return cr>0&&(this.words[yr]=~this.words[yr]&67108863>>26-cr),this._strip()},Ze.prototype.notn=function(Dt){return this.clone().inotn(Dt)},Ze.prototype.setn=function(Dt,sr){We(typeof Dt=="number"&&Dt>=0);var cr=Dt/26|0,yr=Dt%26;return this._expand(cr+1),sr?this.words[cr]=this.words[cr]|1<<yr:this.words[cr]=this.words[cr]&~(1<<yr),this._strip()},Ze.prototype.iadd=function(Dt){var sr;if(this.negative!==0&&Dt.negative===0)return this.negative=0,sr=this.isub(Dt),this.negative^=1,this._normSign();if(this.negative===0&&Dt.negative!==0)return Dt.negative=0,sr=this.isub(Dt),Dt.negative=1,sr._normSign();var cr,yr;this.length>Dt.length?(cr=this,yr=Dt):(cr=Dt,yr=this);for(var _r=0,xr=0;xr<yr.length;xr++)sr=(cr.words[xr]|0)+(yr.words[xr]|0)+_r,this.words[xr]=sr&67108863,_r=sr>>>26;for(;_r!==0&&xr<cr.length;xr++)sr=(cr.words[xr]|0)+_r,this.words[xr]=sr&67108863,_r=sr>>>26;if(this.length=cr.length,_r!==0)this.words[this.length]=_r,this.length++;else if(cr!==this)for(;xr<cr.length;xr++)this.words[xr]=cr.words[xr];return this},Ze.prototype.add=function(Dt){var sr;return Dt.negative!==0&&this.negative===0?(Dt.negative=0,sr=this.sub(Dt),Dt.negative^=1,sr):Dt.negative===0&&this.negative!==0?(this.negative=0,sr=Dt.sub(this),this.negative=1,sr):this.length>Dt.length?this.clone().iadd(Dt):Dt.clone().iadd(this)},Ze.prototype.isub=function(Dt){if(Dt.negative!==0){Dt.negative=0;var sr=this.iadd(Dt);return Dt.negative=1,sr._normSign()}else if(this.negative!==0)return this.negative=0,this.iadd(Dt),this.negative=1,this._normSign();var cr=this.cmp(Dt);if(cr===0)return this.negative=0,this.length=1,this.words[0]=0,this;var yr,_r;cr>0?(yr=this,_r=Dt):(yr=Dt,_r=this);for(var xr=0,Ar=0;Ar<_r.length;Ar++)sr=(yr.words[Ar]|0)-(_r.words[Ar]|0)+xr,xr=sr>>26,this.words[Ar]=sr&67108863;for(;xr!==0&&Ar<yr.length;Ar++)sr=(yr.words[Ar]|0)+xr,xr=sr>>26,this.words[Ar]=sr&67108863;if(xr===0&&Ar<yr.length&&yr!==this)for(;Ar<yr.length;Ar++)this.words[Ar]=yr.words[Ar];return this.length=Math.max(this.length,Ar),yr!==this&&(this.negative=1),this._strip()},Ze.prototype.sub=function(Dt){return this.clone().isub(Dt)};function Sr(ar,Dt,sr){sr.negative=Dt.negative^ar.negative;var cr=ar.length+Dt.length|0;sr.length=cr,cr=cr-1|0;var yr=ar.words[0]|0,_r=Dt.words[0]|0,xr=yr*_r,Ar=xr&67108863,pr=xr/67108864|0;sr.words[0]=Ar;for(var rr=1;rr<cr;rr++){for(var hr=pr>>>26,$r=pr&67108863,Lr=Math.min(rr,Dt.length-1),Ur=Math.max(0,rr-ar.length+1);Ur<=Lr;Ur++){var Wr=rr-Ur|0;yr=ar.words[Wr]|0,_r=Dt.words[Ur]|0,xr=yr*_r+$r,hr+=xr/67108864|0,$r=xr&67108863}sr.words[rr]=$r|0,pr=hr|0}return pr!==0?sr.words[rr]=pr|0:sr.length--,sr._strip()}var kr=function(Dt,sr,cr){var yr=Dt.words,_r=sr.words,xr=cr.words,Ar=0,pr,rr,hr,$r=yr[0]|0,Lr=$r&8191,Ur=$r>>>13,Wr=yr[1]|0,Fr=Wr&8191,zr=Wr>>>13,Yr=yr[2]|0,qr=Yr&8191,Gr=Yr>>>13,Hn=yr[3]|0,Xr=Hn&8191,Zr=Hn>>>13,qn=yr[4]|0,Qr=qn&8191,jn=qn>>>13,fi=yr[5]|0,$n=fi&8191,Jr=fi>>>13,Cn=yr[6]|0,Fn=Cn&8191,Kn=Cn>>>13,Wn=yr[7]|0,Un=Wn&8191,nr=Wn>>>13,Qe=yr[8]|0,dt=Qe&8191,or=Qe>>>13,dr=yr[9]|0,gr=dr&8191,vr=dr>>>13,Dr=_r[0]|0,Vr=Dr&8191,Kr=Dr>>>13,jr=_r[1]|0,Hr=jr&8191,Gn=jr>>>13,$i=_r[2]|0,Yn=$i&8191,Zn=$i>>>13,Li=_r[3]|0,Xn=Li&8191,Jn=Li>>>13,Ci=_r[4]|0,Qn=Ci&8191,ei=Ci>>>13,Oi=_r[5]|0,ti=Oi&8191,ri=Oi>>>13,Pi=_r[6]|0,ni=Pi&8191,ii=Pi>>>13,Ni=_r[7]|0,oi=Ni&8191,si=Ni>>>13,Mi=_r[8]|0,ai=Mi&8191,ui=Mi>>>13,Ui=_r[9]|0,ci=Ui&8191,li=Ui>>>13;cr.negative=Dt.negative^sr.negative,cr.length=19,pr=Math.imul(Lr,Vr),rr=Math.imul(Lr,Kr),rr=rr+Math.imul(Ur,Vr)|0,hr=Math.imul(Ur,Kr);var di=(Ar+pr|0)+((rr&8191)<<13)|0;Ar=(hr+(rr>>>13)|0)+(di>>>26)|0,di&=67108863,pr=Math.imul(Fr,Vr),rr=Math.imul(Fr,Kr),rr=rr+Math.imul(zr,Vr)|0,hr=Math.imul(zr,Kr),pr=pr+Math.imul(Lr,Hr)|0,rr=rr+Math.imul(Lr,Gn)|0,rr=rr+Math.imul(Ur,Hr)|0,hr=hr+Math.imul(Ur,Gn)|0;var hi=(Ar+pr|0)+((rr&8191)<<13)|0;Ar=(hr+(rr>>>13)|0)+(hi>>>26)|0,hi&=67108863,pr=Math.imul(qr,Vr),rr=Math.imul(qr,Kr),rr=rr+Math.imul(Gr,Vr)|0,hr=Math.imul(Gr,Kr),pr=pr+Math.imul(Fr,Hr)|0,rr=rr+Math.imul(Fr,Gn)|0,rr=rr+Math.imul(zr,Hr)|0,hr=hr+Math.imul(zr,Gn)|0,pr=pr+Math.imul(Lr,Yn)|0,rr=rr+Math.imul(Lr,Zn)|0,rr=rr+Math.imul(Ur,Yn)|0,hr=hr+Math.imul(Ur,Zn)|0;var pi=(Ar+pr|0)+((rr&8191)<<13)|0;Ar=(hr+(rr>>>13)|0)+(pi>>>26)|0,pi&=67108863,pr=Math.imul(Xr,Vr),rr=Math.imul(Xr,Kr),rr=rr+Math.imul(Zr,Vr)|0,hr=Math.imul(Zr,Kr),pr=pr+Math.imul(qr,Hr)|0,rr=rr+Math.imul(qr,Gn)|0,rr=rr+Math.imul(Gr,Hr)|0,hr=hr+Math.imul(Gr,Gn)|0,pr=pr+Math.imul(Fr,Yn)|0,rr=rr+Math.imul(Fr,Zn)|0,rr=rr+Math.imul(zr,Yn)|0,hr=hr+Math.imul(zr,Zn)|0,pr=pr+Math.imul(Lr,Xn)|0,rr=rr+Math.imul(Lr,Jn)|0,rr=rr+Math.imul(Ur,Xn)|0,hr=hr+Math.imul(Ur,Jn)|0;var yi=(Ar+pr|0)+((rr&8191)<<13)|0;Ar=(hr+(rr>>>13)|0)+(yi>>>26)|0,yi&=67108863,pr=Math.imul(Qr,Vr),rr=Math.imul(Qr,Kr),rr=rr+Math.imul(jn,Vr)|0,hr=Math.imul(jn,Kr),pr=pr+Math.imul(Xr,Hr)|0,rr=rr+Math.imul(Xr,Gn)|0,rr=rr+Math.imul(Zr,Hr)|0,hr=hr+Math.imul(Zr,Gn)|0,pr=pr+Math.imul(qr,Yn)|0,rr=rr+Math.imul(qr,Zn)|0,rr=rr+Math.imul(Gr,Yn)|0,hr=hr+Math.imul(Gr,Zn)|0,pr=pr+Math.imul(Fr,Xn)|0,rr=rr+Math.imul(Fr,Jn)|0,rr=rr+Math.imul(zr,Xn)|0,hr=hr+Math.imul(zr,Jn)|0,pr=pr+Math.imul(Lr,Qn)|0,rr=rr+Math.imul(Lr,ei)|0,rr=rr+Math.imul(Ur,Qn)|0,hr=hr+Math.imul(Ur,ei)|0;var mi=(Ar+pr|0)+((rr&8191)<<13)|0;Ar=(hr+(rr>>>13)|0)+(mi>>>26)|0,mi&=67108863,pr=Math.imul($n,Vr),rr=Math.imul($n,Kr),rr=rr+Math.imul(Jr,Vr)|0,hr=Math.imul(Jr,Kr),pr=pr+Math.imul(Qr,Hr)|0,rr=rr+Math.imul(Qr,Gn)|0,rr=rr+Math.imul(jn,Hr)|0,hr=hr+Math.imul(jn,Gn)|0,pr=pr+Math.imul(Xr,Yn)|0,rr=rr+Math.imul(Xr,Zn)|0,rr=rr+Math.imul(Zr,Yn)|0,hr=hr+Math.imul(Zr,Zn)|0,pr=pr+Math.imul(qr,Xn)|0,rr=rr+Math.imul(qr,Jn)|0,rr=rr+Math.imul(Gr,Xn)|0,hr=hr+Math.imul(Gr,Jn)|0,pr=pr+Math.imul(Fr,Qn)|0,rr=rr+Math.imul(Fr,ei)|0,rr=rr+Math.imul(zr,Qn)|0,hr=hr+Math.imul(zr,ei)|0,pr=pr+Math.imul(Lr,ti)|0,rr=rr+Math.imul(Lr,ri)|0,rr=rr+Math.imul(Ur,ti)|0,hr=hr+Math.imul(Ur,ri)|0;var gi=(Ar+pr|0)+((rr&8191)<<13)|0;Ar=(hr+(rr>>>13)|0)+(gi>>>26)|0,gi&=67108863,pr=Math.imul(Fn,Vr),rr=Math.imul(Fn,Kr),rr=rr+Math.imul(Kn,Vr)|0,hr=Math.imul(Kn,Kr),pr=pr+Math.imul($n,Hr)|0,rr=rr+Math.imul($n,Gn)|0,rr=rr+Math.imul(Jr,Hr)|0,hr=hr+Math.imul(Jr,Gn)|0,pr=pr+Math.imul(Qr,Yn)|0,rr=rr+Math.imul(Qr,Zn)|0,rr=rr+Math.imul(jn,Yn)|0,hr=hr+Math.imul(jn,Zn)|0,pr=pr+Math.imul(Xr,Xn)|0,rr=rr+Math.imul(Xr,Jn)|0,rr=rr+Math.imul(Zr,Xn)|0,hr=hr+Math.imul(Zr,Jn)|0,pr=pr+Math.imul(qr,Qn)|0,rr=rr+Math.imul(qr,ei)|0,rr=rr+Math.imul(Gr,Qn)|0,hr=hr+Math.imul(Gr,ei)|0,pr=pr+Math.imul(Fr,ti)|0,rr=rr+Math.imul(Fr,ri)|0,rr=rr+Math.imul(zr,ti)|0,hr=hr+Math.imul(zr,ri)|0,pr=pr+Math.imul(Lr,ni)|0,rr=rr+Math.imul(Lr,ii)|0,rr=rr+Math.imul(Ur,ni)|0,hr=hr+Math.imul(Ur,ii)|0;var _i=(Ar+pr|0)+((rr&8191)<<13)|0;Ar=(hr+(rr>>>13)|0)+(_i>>>26)|0,_i&=67108863,pr=Math.imul(Un,Vr),rr=Math.imul(Un,Kr),rr=rr+Math.imul(nr,Vr)|0,hr=Math.imul(nr,Kr),pr=pr+Math.imul(Fn,Hr)|0,rr=rr+Math.imul(Fn,Gn)|0,rr=rr+Math.imul(Kn,Hr)|0,hr=hr+Math.imul(Kn,Gn)|0,pr=pr+Math.imul($n,Yn)|0,rr=rr+Math.imul($n,Zn)|0,rr=rr+Math.imul(Jr,Yn)|0,hr=hr+Math.imul(Jr,Zn)|0,pr=pr+Math.imul(Qr,Xn)|0,rr=rr+Math.imul(Qr,Jn)|0,rr=rr+Math.imul(jn,Xn)|0,hr=hr+Math.imul(jn,Jn)|0,pr=pr+Math.imul(Xr,Qn)|0,rr=rr+Math.imul(Xr,ei)|0,rr=rr+Math.imul(Zr,Qn)|0,hr=hr+Math.imul(Zr,ei)|0,pr=pr+Math.imul(qr,ti)|0,rr=rr+Math.imul(qr,ri)|0,rr=rr+Math.imul(Gr,ti)|0,hr=hr+Math.imul(Gr,ri)|0,pr=pr+Math.imul(Fr,ni)|0,rr=rr+Math.imul(Fr,ii)|0,rr=rr+Math.imul(zr,ni)|0,hr=hr+Math.imul(zr,ii)|0,pr=pr+Math.imul(Lr,oi)|0,rr=rr+Math.imul(Lr,si)|0,rr=rr+Math.imul(Ur,oi)|0,hr=hr+Math.imul(Ur,si)|0;var bi=(Ar+pr|0)+((rr&8191)<<13)|0;Ar=(hr+(rr>>>13)|0)+(bi>>>26)|0,bi&=67108863,pr=Math.imul(dt,Vr),rr=Math.imul(dt,Kr),rr=rr+Math.imul(or,Vr)|0,hr=Math.imul(or,Kr),pr=pr+Math.imul(Un,Hr)|0,rr=rr+Math.imul(Un,Gn)|0,rr=rr+Math.imul(nr,Hr)|0,hr=hr+Math.imul(nr,Gn)|0,pr=pr+Math.imul(Fn,Yn)|0,rr=rr+Math.imul(Fn,Zn)|0,rr=rr+Math.imul(Kn,Yn)|0,hr=hr+Math.imul(Kn,Zn)|0,pr=pr+Math.imul($n,Xn)|0,rr=rr+Math.imul($n,Jn)|0,rr=rr+Math.imul(Jr,Xn)|0,hr=hr+Math.imul(Jr,Jn)|0,pr=pr+Math.imul(Qr,Qn)|0,rr=rr+Math.imul(Qr,ei)|0,rr=rr+Math.imul(jn,Qn)|0,hr=hr+Math.imul(jn,ei)|0,pr=pr+Math.imul(Xr,ti)|0,rr=rr+Math.imul(Xr,ri)|0,rr=rr+Math.imul(Zr,ti)|0,hr=hr+Math.imul(Zr,ri)|0,pr=pr+Math.imul(qr,ni)|0,rr=rr+Math.imul(qr,ii)|0,rr=rr+Math.imul(Gr,ni)|0,hr=hr+Math.imul(Gr,ii)|0,pr=pr+Math.imul(Fr,oi)|0,rr=rr+Math.imul(Fr,si)|0,rr=rr+Math.imul(zr,oi)|0,hr=hr+Math.imul(zr,si)|0,pr=pr+Math.imul(Lr,ai)|0,rr=rr+Math.imul(Lr,ui)|0,rr=rr+Math.imul(Ur,ai)|0,hr=hr+Math.imul(Ur,ui)|0;var wi=(Ar+pr|0)+((rr&8191)<<13)|0;Ar=(hr+(rr>>>13)|0)+(wi>>>26)|0,wi&=67108863,pr=Math.imul(gr,Vr),rr=Math.imul(gr,Kr),rr=rr+Math.imul(vr,Vr)|0,hr=Math.imul(vr,Kr),pr=pr+Math.imul(dt,Hr)|0,rr=rr+Math.imul(dt,Gn)|0,rr=rr+Math.imul(or,Hr)|0,hr=hr+Math.imul(or,Gn)|0,pr=pr+Math.imul(Un,Yn)|0,rr=rr+Math.imul(Un,Zn)|0,rr=rr+Math.imul(nr,Yn)|0,hr=hr+Math.imul(nr,Zn)|0,pr=pr+Math.imul(Fn,Xn)|0,rr=rr+Math.imul(Fn,Jn)|0,rr=rr+Math.imul(Kn,Xn)|0,hr=hr+Math.imul(Kn,Jn)|0,pr=pr+Math.imul($n,Qn)|0,rr=rr+Math.imul($n,ei)|0,rr=rr+Math.imul(Jr,Qn)|0,hr=hr+Math.imul(Jr,ei)|0,pr=pr+Math.imul(Qr,ti)|0,rr=rr+Math.imul(Qr,ri)|0,rr=rr+Math.imul(jn,ti)|0,hr=hr+Math.imul(jn,ri)|0,pr=pr+Math.imul(Xr,ni)|0,rr=rr+Math.imul(Xr,ii)|0,rr=rr+Math.imul(Zr,ni)|0,hr=hr+Math.imul(Zr,ii)|0,pr=pr+Math.imul(qr,oi)|0,rr=rr+Math.imul(qr,si)|0,rr=rr+Math.imul(Gr,oi)|0,hr=hr+Math.imul(Gr,si)|0,pr=pr+Math.imul(Fr,ai)|0,rr=rr+Math.imul(Fr,ui)|0,rr=rr+Math.imul(zr,ai)|0,hr=hr+Math.imul(zr,ui)|0,pr=pr+Math.imul(Lr,ci)|0,rr=rr+Math.imul(Lr,li)|0,rr=rr+Math.imul(Ur,ci)|0,hr=hr+Math.imul(Ur,li)|0;var Si=(Ar+pr|0)+((rr&8191)<<13)|0;Ar=(hr+(rr>>>13)|0)+(Si>>>26)|0,Si&=67108863,pr=Math.imul(gr,Hr),rr=Math.imul(gr,Gn),rr=rr+Math.imul(vr,Hr)|0,hr=Math.imul(vr,Gn),pr=pr+Math.imul(dt,Yn)|0,rr=rr+Math.imul(dt,Zn)|0,rr=rr+Math.imul(or,Yn)|0,hr=hr+Math.imul(or,Zn)|0,pr=pr+Math.imul(Un,Xn)|0,rr=rr+Math.imul(Un,Jn)|0,rr=rr+Math.imul(nr,Xn)|0,hr=hr+Math.imul(nr,Jn)|0,pr=pr+Math.imul(Fn,Qn)|0,rr=rr+Math.imul(Fn,ei)|0,rr=rr+Math.imul(Kn,Qn)|0,hr=hr+Math.imul(Kn,ei)|0,pr=pr+Math.imul($n,ti)|0,rr=rr+Math.imul($n,ri)|0,rr=rr+Math.imul(Jr,ti)|0,hr=hr+Math.imul(Jr,ri)|0,pr=pr+Math.imul(Qr,ni)|0,rr=rr+Math.imul(Qr,ii)|0,rr=rr+Math.imul(jn,ni)|0,hr=hr+Math.imul(jn,ii)|0,pr=pr+Math.imul(Xr,oi)|0,rr=rr+Math.imul(Xr,si)|0,rr=rr+Math.imul(Zr,oi)|0,hr=hr+Math.imul(Zr,si)|0,pr=pr+Math.imul(qr,ai)|0,rr=rr+Math.imul(qr,ui)|0,rr=rr+Math.imul(Gr,ai)|0,hr=hr+Math.imul(Gr,ui)|0,pr=pr+Math.imul(Fr,ci)|0,rr=rr+Math.imul(Fr,li)|0,rr=rr+Math.imul(zr,ci)|0,hr=hr+Math.imul(zr,li)|0;var vi=(Ar+pr|0)+((rr&8191)<<13)|0;Ar=(hr+(rr>>>13)|0)+(vi>>>26)|0,vi&=67108863,pr=Math.imul(gr,Yn),rr=Math.imul(gr,Zn),rr=rr+Math.imul(vr,Yn)|0,hr=Math.imul(vr,Zn),pr=pr+Math.imul(dt,Xn)|0,rr=rr+Math.imul(dt,Jn)|0,rr=rr+Math.imul(or,Xn)|0,hr=hr+Math.imul(or,Jn)|0,pr=pr+Math.imul(Un,Qn)|0,rr=rr+Math.imul(Un,ei)|0,rr=rr+Math.imul(nr,Qn)|0,hr=hr+Math.imul(nr,ei)|0,pr=pr+Math.imul(Fn,ti)|0,rr=rr+Math.imul(Fn,ri)|0,rr=rr+Math.imul(Kn,ti)|0,hr=hr+Math.imul(Kn,ri)|0,pr=pr+Math.imul($n,ni)|0,rr=rr+Math.imul($n,ii)|0,rr=rr+Math.imul(Jr,ni)|0,hr=hr+Math.imul(Jr,ii)|0,pr=pr+Math.imul(Qr,oi)|0,rr=rr+Math.imul(Qr,si)|0,rr=rr+Math.imul(jn,oi)|0,hr=hr+Math.imul(jn,si)|0,pr=pr+Math.imul(Xr,ai)|0,rr=rr+Math.imul(Xr,ui)|0,rr=rr+Math.imul(Zr,ai)|0,hr=hr+Math.imul(Zr,ui)|0,pr=pr+Math.imul(qr,ci)|0,rr=rr+Math.imul(qr,li)|0,rr=rr+Math.imul(Gr,ci)|0,hr=hr+Math.imul(Gr,li)|0;var Ei=(Ar+pr|0)+((rr&8191)<<13)|0;Ar=(hr+(rr>>>13)|0)+(Ei>>>26)|0,Ei&=67108863,pr=Math.imul(gr,Xn),rr=Math.imul(gr,Jn),rr=rr+Math.imul(vr,Xn)|0,hr=Math.imul(vr,Jn),pr=pr+Math.imul(dt,Qn)|0,rr=rr+Math.imul(dt,ei)|0,rr=rr+Math.imul(or,Qn)|0,hr=hr+Math.imul(or,ei)|0,pr=pr+Math.imul(Un,ti)|0,rr=rr+Math.imul(Un,ri)|0,rr=rr+Math.imul(nr,ti)|0,hr=hr+Math.imul(nr,ri)|0,pr=pr+Math.imul(Fn,ni)|0,rr=rr+Math.imul(Fn,ii)|0,rr=rr+Math.imul(Kn,ni)|0,hr=hr+Math.imul(Kn,ii)|0,pr=pr+Math.imul($n,oi)|0,rr=rr+Math.imul($n,si)|0,rr=rr+Math.imul(Jr,oi)|0,hr=hr+Math.imul(Jr,si)|0,pr=pr+Math.imul(Qr,ai)|0,rr=rr+Math.imul(Qr,ui)|0,rr=rr+Math.imul(jn,ai)|0,hr=hr+Math.imul(jn,ui)|0,pr=pr+Math.imul(Xr,ci)|0,rr=rr+Math.imul(Xr,li)|0,rr=rr+Math.imul(Zr,ci)|0,hr=hr+Math.imul(Zr,li)|0;var xi=(Ar+pr|0)+((rr&8191)<<13)|0;Ar=(hr+(rr>>>13)|0)+(xi>>>26)|0,xi&=67108863,pr=Math.imul(gr,Qn),rr=Math.imul(gr,ei),rr=rr+Math.imul(vr,Qn)|0,hr=Math.imul(vr,ei),pr=pr+Math.imul(dt,ti)|0,rr=rr+Math.imul(dt,ri)|0,rr=rr+Math.imul(or,ti)|0,hr=hr+Math.imul(or,ri)|0,pr=pr+Math.imul(Un,ni)|0,rr=rr+Math.imul(Un,ii)|0,rr=rr+Math.imul(nr,ni)|0,hr=hr+Math.imul(nr,ii)|0,pr=pr+Math.imul(Fn,oi)|0,rr=rr+Math.imul(Fn,si)|0,rr=rr+Math.imul(Kn,oi)|0,hr=hr+Math.imul(Kn,si)|0,pr=pr+Math.imul($n,ai)|0,rr=rr+Math.imul($n,ui)|0,rr=rr+Math.imul(Jr,ai)|0,hr=hr+Math.imul(Jr,ui)|0,pr=pr+Math.imul(Qr,ci)|0,rr=rr+Math.imul(Qr,li)|0,rr=rr+Math.imul(jn,ci)|0,hr=hr+Math.imul(jn,li)|0;var Ai=(Ar+pr|0)+((rr&8191)<<13)|0;Ar=(hr+(rr>>>13)|0)+(Ai>>>26)|0,Ai&=67108863,pr=Math.imul(gr,ti),rr=Math.imul(gr,ri),rr=rr+Math.imul(vr,ti)|0,hr=Math.imul(vr,ri),pr=pr+Math.imul(dt,ni)|0,rr=rr+Math.imul(dt,ii)|0,rr=rr+Math.imul(or,ni)|0,hr=hr+Math.imul(or,ii)|0,pr=pr+Math.imul(Un,oi)|0,rr=rr+Math.imul(Un,si)|0,rr=rr+Math.imul(nr,oi)|0,hr=hr+Math.imul(nr,si)|0,pr=pr+Math.imul(Fn,ai)|0,rr=rr+Math.imul(Fn,ui)|0,rr=rr+Math.imul(Kn,ai)|0,hr=hr+Math.imul(Kn,ui)|0,pr=pr+Math.imul($n,ci)|0,rr=rr+Math.imul($n,li)|0,rr=rr+Math.imul(Jr,ci)|0,hr=hr+Math.imul(Jr,li)|0;var Ii=(Ar+pr|0)+((rr&8191)<<13)|0;Ar=(hr+(rr>>>13)|0)+(Ii>>>26)|0,Ii&=67108863,pr=Math.imul(gr,ni),rr=Math.imul(gr,ii),rr=rr+Math.imul(vr,ni)|0,hr=Math.imul(vr,ii),pr=pr+Math.imul(dt,oi)|0,rr=rr+Math.imul(dt,si)|0,rr=rr+Math.imul(or,oi)|0,hr=hr+Math.imul(or,si)|0,pr=pr+Math.imul(Un,ai)|0,rr=rr+Math.imul(Un,ui)|0,rr=rr+Math.imul(nr,ai)|0,hr=hr+Math.imul(nr,ui)|0,pr=pr+Math.imul(Fn,ci)|0,rr=rr+Math.imul(Fn,li)|0,rr=rr+Math.imul(Kn,ci)|0,hr=hr+Math.imul(Kn,li)|0;var ki=(Ar+pr|0)+((rr&8191)<<13)|0;Ar=(hr+(rr>>>13)|0)+(ki>>>26)|0,ki&=67108863,pr=Math.imul(gr,oi),rr=Math.imul(gr,si),rr=rr+Math.imul(vr,oi)|0,hr=Math.imul(vr,si),pr=pr+Math.imul(dt,ai)|0,rr=rr+Math.imul(dt,ui)|0,rr=rr+Math.imul(or,ai)|0,hr=hr+Math.imul(or,ui)|0,pr=pr+Math.imul(Un,ci)|0,rr=rr+Math.imul(Un,li)|0,rr=rr+Math.imul(nr,ci)|0,hr=hr+Math.imul(nr,li)|0;var Ri=(Ar+pr|0)+((rr&8191)<<13)|0;Ar=(hr+(rr>>>13)|0)+(Ri>>>26)|0,Ri&=67108863,pr=Math.imul(gr,ai),rr=Math.imul(gr,ui),rr=rr+Math.imul(vr,ai)|0,hr=Math.imul(vr,ui),pr=pr+Math.imul(dt,ci)|0,rr=rr+Math.imul(dt,li)|0,rr=rr+Math.imul(or,ci)|0,hr=hr+Math.imul(or,li)|0;var Ti=(Ar+pr|0)+((rr&8191)<<13)|0;Ar=(hr+(rr>>>13)|0)+(Ti>>>26)|0,Ti&=67108863,pr=Math.imul(gr,ci),rr=Math.imul(gr,li),rr=rr+Math.imul(vr,ci)|0,hr=Math.imul(vr,li);var Bi=(Ar+pr|0)+((rr&8191)<<13)|0;return Ar=(hr+(rr>>>13)|0)+(Bi>>>26)|0,Bi&=67108863,xr[0]=di,xr[1]=hi,xr[2]=pi,xr[3]=yi,xr[4]=mi,xr[5]=gi,xr[6]=_i,xr[7]=bi,xr[8]=wi,xr[9]=Si,xr[10]=vi,xr[11]=Ei,xr[12]=xi,xr[13]=Ai,xr[14]=Ii,xr[15]=ki,xr[16]=Ri,xr[17]=Ti,xr[18]=Bi,Ar!==0&&(xr[19]=Ar,cr.length++),cr};Math.imul||(kr=Sr);function Er(ar,Dt,sr){sr.negative=Dt.negative^ar.negative,sr.length=ar.length+Dt.length;for(var cr=0,yr=0,_r=0;_r<sr.length-1;_r++){var xr=yr;yr=0;for(var Ar=cr&67108863,pr=Math.min(_r,Dt.length-1),rr=Math.max(0,_r-ar.length+1);rr<=pr;rr++){var hr=_r-rr,$r=ar.words[hr]|0,Lr=Dt.words[rr]|0,Ur=$r*Lr,Wr=Ur&67108863;xr=xr+(Ur/67108864|0)|0,Wr=Wr+Ar|0,Ar=Wr&67108863,xr=xr+(Wr>>>26)|0,yr+=xr>>>26,xr&=67108863}sr.words[_r]=Ar,cr=xr,xr=yr}return cr!==0?sr.words[_r]=cr:sr.length--,sr._strip()}function Ir(ar,Dt,sr){return Er(ar,Dt,sr)}Ze.prototype.mulTo=function(Dt,sr){var cr,yr=this.length+Dt.length;return this.length===10&&Dt.length===10?cr=kr(this,Dt,sr):yr<63?cr=Sr(this,Dt,sr):yr<1024?cr=Er(this,Dt,sr):cr=Ir(this,Dt,sr),cr},Ze.prototype.mul=function(Dt){var sr=new Ze(null);return sr.words=new Array(this.length+Dt.length),this.mulTo(Dt,sr)},Ze.prototype.mulf=function(Dt){var sr=new Ze(null);return sr.words=new Array(this.length+Dt.length),Ir(this,Dt,sr)},Ze.prototype.imul=function(Dt){return this.clone().mulTo(Dt,this)},Ze.prototype.imuln=function(Dt){var sr=Dt<0;sr&&(Dt=-Dt),We(typeof Dt=="number"),We(Dt<67108864);for(var cr=0,yr=0;yr<this.length;yr++){var _r=(this.words[yr]|0)*Dt,xr=(_r&67108863)+(cr&67108863);cr>>=26,cr+=_r/67108864|0,cr+=xr>>>26,this.words[yr]=xr&67108863}return cr!==0&&(this.words[yr]=cr,this.length++),sr?this.ineg():this},Ze.prototype.muln=function(Dt){return this.clone().imuln(Dt)},Ze.prototype.sqr=function(){return this.mul(this)},Ze.prototype.isqr=function(){return this.imul(this.clone())},Ze.prototype.pow=function(Dt){var sr=wr(Dt);if(sr.length===0)return new Ze(1);for(var cr=this,yr=0;yr<sr.length&&sr[yr]===0;yr++,cr=cr.sqr());if(++yr<sr.length)for(var _r=cr.sqr();yr<sr.length;yr++,_r=_r.sqr())sr[yr]!==0&&(cr=cr.mul(_r));return cr},Ze.prototype.iushln=function(Dt){We(typeof Dt=="number"&&Dt>=0);var sr=Dt%26,cr=(Dt-sr)/26,yr=67108863>>>26-sr<<26-sr,_r;if(sr!==0){var xr=0;for(_r=0;_r<this.length;_r++){var Ar=this.words[_r]&yr,pr=(this.words[_r]|0)-Ar<<sr;this.words[_r]=pr|xr,xr=Ar>>>26-sr}xr&&(this.words[_r]=xr,this.length++)}if(cr!==0){for(_r=this.length-1;_r>=0;_r--)this.words[_r+cr]=this.words[_r];for(_r=0;_r<cr;_r++)this.words[_r]=0;this.length+=cr}return this._strip()},Ze.prototype.ishln=function(Dt){return We(this.negative===0),this.iushln(Dt)},Ze.prototype.iushrn=function(Dt,sr,cr){We(typeof Dt=="number"&&Dt>=0);var yr;sr?yr=(sr-sr%26)/26:yr=0;var _r=Dt%26,xr=Math.min((Dt-_r)/26,this.length),Ar=67108863^67108863>>>_r<<_r,pr=cr;if(yr-=xr,yr=Math.max(0,yr),pr){for(var rr=0;rr<xr;rr++)pr.words[rr]=this.words[rr];pr.length=xr}if(xr!==0)if(this.length>xr)for(this.length-=xr,rr=0;rr<this.length;rr++)this.words[rr]=this.words[rr+xr];else this.words[0]=0,this.length=1;var hr=0;for(rr=this.length-1;rr>=0&&(hr!==0||rr>=yr);rr--){var $r=this.words[rr]|0;this.words[rr]=hr<<26-_r|$r>>>_r,hr=$r&Ar}return pr&&hr!==0&&(pr.words[pr.length++]=hr),this.length===0&&(this.words[0]=0,this.length=1),this._strip()},Ze.prototype.ishrn=function(Dt,sr,cr){return We(this.negative===0),this.iushrn(Dt,sr,cr)},Ze.prototype.shln=function(Dt){return this.clone().ishln(Dt)},Ze.prototype.ushln=function(Dt){return this.clone().iushln(Dt)},Ze.prototype.shrn=function(Dt){return this.clone().ishrn(Dt)},Ze.prototype.ushrn=function(Dt){return this.clone().iushrn(Dt)},Ze.prototype.testn=function(Dt){We(typeof Dt=="number"&&Dt>=0);var sr=Dt%26,cr=(Dt-sr)/26,yr=1<<sr;if(this.length<=cr)return!1;var _r=this.words[cr];return!!(_r&yr)},Ze.prototype.imaskn=function(Dt){We(typeof Dt=="number"&&Dt>=0);var sr=Dt%26,cr=(Dt-sr)/26;if(We(this.negative===0,"imaskn works only with positive numbers"),this.length<=cr)return this;if(sr!==0&&cr++,this.length=Math.min(cr,this.length),sr!==0){var yr=67108863^67108863>>>sr<<sr;this.words[this.length-1]&=yr}return this._strip()},Ze.prototype.maskn=function(Dt){return this.clone().imaskn(Dt)},Ze.prototype.iaddn=function(Dt){return We(typeof Dt=="number"),We(Dt<67108864),Dt<0?this.isubn(-Dt):this.negative!==0?this.length===1&&(this.words[0]|0)<=Dt?(this.words[0]=Dt-(this.words[0]|0),this.negative=0,this):(this.negative=0,this.isubn(Dt),this.negative=1,this):this._iaddn(Dt)},Ze.prototype._iaddn=function(Dt){this.words[0]+=Dt;for(var sr=0;sr<this.length&&this.words[sr]>=67108864;sr++)this.words[sr]-=67108864,sr===this.length-1?this.words[sr+1]=1:this.words[sr+1]++;return this.length=Math.max(this.length,sr+1),this},Ze.prototype.isubn=function(Dt){if(We(typeof Dt=="number"),We(Dt<67108864),Dt<0)return this.iaddn(-Dt);if(this.negative!==0)return this.negative=0,this.iaddn(Dt),this.negative=1,this;if(this.words[0]-=Dt,this.length===1&&this.words[0]<0)this.words[0]=-this.words[0],this.negative=1;else for(var sr=0;sr<this.length&&this.words[sr]<0;sr++)this.words[sr]+=67108864,this.words[sr+1]-=1;return this._strip()},Ze.prototype.addn=function(Dt){return this.clone().iaddn(Dt)},Ze.prototype.subn=function(Dt){return this.clone().isubn(Dt)},Ze.prototype.iabs=function(){return this.negative=0,this},Ze.prototype.abs=function(){return this.clone().iabs()},Ze.prototype._ishlnsubmul=function(Dt,sr,cr){var yr=Dt.length+cr,_r;this._expand(yr);var xr,Ar=0;for(_r=0;_r<Dt.length;_r++){xr=(this.words[_r+cr]|0)+Ar;var pr=(Dt.words[_r]|0)*sr;xr-=pr&67108863,Ar=(xr>>26)-(pr/67108864|0),this.words[_r+cr]=xr&67108863}for(;_r<this.length-cr;_r++)xr=(this.words[_r+cr]|0)+Ar,Ar=xr>>26,this.words[_r+cr]=xr&67108863;if(Ar===0)return this._strip();for(We(Ar===-1),Ar=0,_r=0;_r<this.length;_r++)xr=-(this.words[_r]|0)+Ar,Ar=xr>>26,this.words[_r]=xr&67108863;return this.negative=1,this._strip()},Ze.prototype._wordDiv=function(Dt,sr){var cr=this.length-Dt.length,yr=this.clone(),_r=Dt,xr=_r.words[_r.length-1]|0,Ar=this._countBits(xr);cr=26-Ar,cr!==0&&(_r=_r.ushln(cr),yr.iushln(cr),xr=_r.words[_r.length-1]|0);var pr=yr.length-_r.length,rr;if(sr!=="mod"){rr=new Ze(null),rr.length=pr+1,rr.words=new Array(rr.length);for(var hr=0;hr<rr.length;hr++)rr.words[hr]=0}var $r=yr.clone()._ishlnsubmul(_r,1,pr);$r.negative===0&&(yr=$r,rr&&(rr.words[pr]=1));for(var Lr=pr-1;Lr>=0;Lr--){var Ur=(yr.words[_r.length+Lr]|0)*67108864+(yr.words[_r.length+Lr-1]|0);for(Ur=Math.min(Ur/xr|0,67108863),yr._ishlnsubmul(_r,Ur,Lr);yr.negative!==0;)Ur--,yr.negative=0,yr._ishlnsubmul(_r,1,Lr),yr.isZero()||(yr.negative^=1);rr&&(rr.words[Lr]=Ur)}return rr&&rr._strip(),yr._strip(),sr!=="div"&&cr!==0&&yr.iushrn(cr),{div:rr||null,mod:yr}},Ze.prototype.divmod=function(Dt,sr,cr){if(We(!Dt.isZero()),this.isZero())return{div:new Ze(0),mod:new Ze(0)};var yr,_r,xr;return this.negative!==0&&Dt.negative===0?(xr=this.neg().divmod(Dt,sr),sr!=="mod"&&(yr=xr.div.neg()),sr!=="div"&&(_r=xr.mod.neg(),cr&&_r.negative!==0&&_r.iadd(Dt)),{div:yr,mod:_r}):this.negative===0&&Dt.negative!==0?(xr=this.divmod(Dt.neg(),sr),sr!=="mod"&&(yr=xr.div.neg()),{div:yr,mod:xr.mod}):(this.negative&Dt.negative)!==0?(xr=this.neg().divmod(Dt.neg(),sr),sr!=="div"&&(_r=xr.mod.neg(),cr&&_r.negative!==0&&_r.isub(Dt)),{div:xr.div,mod:_r}):Dt.length>this.length||this.cmp(Dt)<0?{div:new Ze(0),mod:this}:Dt.length===1?sr==="div"?{div:this.divn(Dt.words[0]),mod:null}:sr==="mod"?{div:null,mod:new Ze(this.modrn(Dt.words[0]))}:{div:this.divn(Dt.words[0]),mod:new Ze(this.modrn(Dt.words[0]))}:this._wordDiv(Dt,sr)},Ze.prototype.div=function(Dt){return this.divmod(Dt,"div",!1).div},Ze.prototype.mod=function(Dt){return this.divmod(Dt,"mod",!1).mod},Ze.prototype.umod=function(Dt){return this.divmod(Dt,"mod",!0).mod},Ze.prototype.divRound=function(Dt){var sr=this.divmod(Dt);if(sr.mod.isZero())return sr.div;var cr=sr.div.negative!==0?sr.mod.isub(Dt):sr.mod,yr=Dt.ushrn(1),_r=Dt.andln(1),xr=cr.cmp(yr);return xr<0||_r===1&&xr===0?sr.div:sr.div.negative!==0?sr.div.isubn(1):sr.div.iaddn(1)},Ze.prototype.modrn=function(Dt){var sr=Dt<0;sr&&(Dt=-Dt),We(Dt<=67108863);for(var cr=(1<<26)%Dt,yr=0,_r=this.length-1;_r>=0;_r--)yr=(cr*yr+(this.words[_r]|0))%Dt;return sr?-yr:yr},Ze.prototype.modn=function(Dt){return this.modrn(Dt)},Ze.prototype.idivn=function(Dt){var sr=Dt<0;sr&&(Dt=-Dt),We(Dt<=67108863);for(var cr=0,yr=this.length-1;yr>=0;yr--){var _r=(this.words[yr]|0)+cr*67108864;this.words[yr]=_r/Dt|0,cr=_r%Dt}return this._strip(),sr?this.ineg():this},Ze.prototype.divn=function(Dt){return this.clone().idivn(Dt)},Ze.prototype.egcd=function(Dt){We(Dt.negative===0),We(!Dt.isZero());var sr=this,cr=Dt.clone();sr.negative!==0?sr=sr.umod(Dt):sr=sr.clone();for(var yr=new Ze(1),_r=new Ze(0),xr=new Ze(0),Ar=new Ze(1),pr=0;sr.isEven()&&cr.isEven();)sr.iushrn(1),cr.iushrn(1),++pr;for(var rr=cr.clone(),hr=sr.clone();!sr.isZero();){for(var $r=0,Lr=1;(sr.words[0]&Lr)===0&&$r<26;++$r,Lr<<=1);if($r>0)for(sr.iushrn($r);$r-- >0;)(yr.isOdd()||_r.isOdd())&&(yr.iadd(rr),_r.isub(hr)),yr.iushrn(1),_r.iushrn(1);for(var Ur=0,Wr=1;(cr.words[0]&Wr)===0&&Ur<26;++Ur,Wr<<=1);if(Ur>0)for(cr.iushrn(Ur);Ur-- >0;)(xr.isOdd()||Ar.isOdd())&&(xr.iadd(rr),Ar.isub(hr)),xr.iushrn(1),Ar.iushrn(1);sr.cmp(cr)>=0?(sr.isub(cr),yr.isub(xr),_r.isub(Ar)):(cr.isub(sr),xr.isub(yr),Ar.isub(_r))}return{a:xr,b:Ar,gcd:cr.iushln(pr)}},Ze.prototype._invmp=function(Dt){We(Dt.negative===0),We(!Dt.isZero());var sr=this,cr=Dt.clone();sr.negative!==0?sr=sr.umod(Dt):sr=sr.clone();for(var yr=new Ze(1),_r=new Ze(0),xr=cr.clone();sr.cmpn(1)>0&&cr.cmpn(1)>0;){for(var Ar=0,pr=1;(sr.words[0]&pr)===0&&Ar<26;++Ar,pr<<=1);if(Ar>0)for(sr.iushrn(Ar);Ar-- >0;)yr.isOdd()&&yr.iadd(xr),yr.iushrn(1);for(var rr=0,hr=1;(cr.words[0]&hr)===0&&rr<26;++rr,hr<<=1);if(rr>0)for(cr.iushrn(rr);rr-- >0;)_r.isOdd()&&_r.iadd(xr),_r.iushrn(1);sr.cmp(cr)>=0?(sr.isub(cr),yr.isub(_r)):(cr.isub(sr),_r.isub(yr))}var $r;return sr.cmpn(1)===0?$r=yr:$r=_r,$r.cmpn(0)<0&&$r.iadd(Dt),$r},Ze.prototype.gcd=function(Dt){if(this.isZero())return Dt.abs();if(Dt.isZero())return this.abs();var sr=this.clone(),cr=Dt.clone();sr.negative=0,cr.negative=0;for(var yr=0;sr.isEven()&&cr.isEven();yr++)sr.iushrn(1),cr.iushrn(1);do{for(;sr.isEven();)sr.iushrn(1);for(;cr.isEven();)cr.iushrn(1);var _r=sr.cmp(cr);if(_r<0){var xr=sr;sr=cr,cr=xr}else if(_r===0||cr.cmpn(1)===0)break;sr.isub(cr)}while(!0);return cr.iushln(yr)},Ze.prototype.invm=function(Dt){return this.egcd(Dt).a.umod(Dt)},Ze.prototype.isEven=function(){return(this.words[0]&1)===0},Ze.prototype.isOdd=function(){return(this.words[0]&1)===1},Ze.prototype.andln=function(Dt){return this.words[0]&Dt},Ze.prototype.bincn=function(Dt){We(typeof Dt=="number");var sr=Dt%26,cr=(Dt-sr)/26,yr=1<<sr;if(this.length<=cr)return this._expand(cr+1),this.words[cr]|=yr,this;for(var _r=yr,xr=cr;_r!==0&&xr<this.length;xr++){var Ar=this.words[xr]|0;Ar+=_r,_r=Ar>>>26,Ar&=67108863,this.words[xr]=Ar}return _r!==0&&(this.words[xr]=_r,this.length++),this},Ze.prototype.isZero=function(){return this.length===1&&this.words[0]===0},Ze.prototype.cmpn=function(Dt){var sr=Dt<0;if(this.negative!==0&&!sr)return-1;if(this.negative===0&&sr)return 1;this._strip();var cr;if(this.length>1)cr=1;else{sr&&(Dt=-Dt),We(Dt<=67108863,"Number is too big");var yr=this.words[0]|0;cr=yr===Dt?0:yr<Dt?-1:1}return this.negative!==0?-cr|0:cr},Ze.prototype.cmp=function(Dt){if(this.negative!==0&&Dt.negative===0)return-1;if(this.negative===0&&Dt.negative!==0)return 1;var sr=this.ucmp(Dt);return this.negative!==0?-sr|0:sr},Ze.prototype.ucmp=function(Dt){if(this.length>Dt.length)return 1;if(this.length<Dt.length)return-1;for(var sr=0,cr=this.length-1;cr>=0;cr--){var yr=this.words[cr]|0,_r=Dt.words[cr]|0;if(yr!==_r){yr<_r?sr=-1:yr>_r&&(sr=1);break}}return sr},Ze.prototype.gtn=function(Dt){return this.cmpn(Dt)===1},Ze.prototype.gt=function(Dt){return this.cmp(Dt)===1},Ze.prototype.gten=function(Dt){return this.cmpn(Dt)>=0},Ze.prototype.gte=function(Dt){return this.cmp(Dt)>=0},Ze.prototype.ltn=function(Dt){return this.cmpn(Dt)===-1},Ze.prototype.lt=function(Dt){return this.cmp(Dt)===-1},Ze.prototype.lten=function(Dt){return this.cmpn(Dt)<=0},Ze.prototype.lte=function(Dt){return this.cmp(Dt)<=0},Ze.prototype.eqn=function(Dt){return this.cmpn(Dt)===0},Ze.prototype.eq=function(Dt){return this.cmp(Dt)===0},Ze.red=function(Dt){return new Tr(Dt)},Ze.prototype.toRed=function(Dt){return We(!this.red,"Already a number in reduction context"),We(this.negative===0,"red works only with positives"),Dt.convertTo(this)._forceRed(Dt)},Ze.prototype.fromRed=function(){return We(this.red,"fromRed works only with numbers in reduction context"),this.red.convertFrom(this)},Ze.prototype._forceRed=function(Dt){return this.red=Dt,this},Ze.prototype.forceRed=function(Dt){return We(!this.red,"Already a number in reduction context"),this._forceRed(Dt)},Ze.prototype.redAdd=function(Dt){return We(this.red,"redAdd works only with red numbers"),this.red.add(this,Dt)},Ze.prototype.redIAdd=function(Dt){return We(this.red,"redIAdd works only with red numbers"),this.red.iadd(this,Dt)},Ze.prototype.redSub=function(Dt){return We(this.red,"redSub works only with red numbers"),this.red.sub(this,Dt)},Ze.prototype.redISub=function(Dt){return We(this.red,"redISub works only with red numbers"),this.red.isub(this,Dt)},Ze.prototype.redShl=function(Dt){return We(this.red,"redShl works only with red numbers"),this.red.shl(this,Dt)},Ze.prototype.redMul=function(Dt){return We(this.red,"redMul works only with red numbers"),this.red._verify2(this,Dt),this.red.mul(this,Dt)},Ze.prototype.redIMul=function(Dt){return We(this.red,"redMul works only with red numbers"),this.red._verify2(this,Dt),this.red.imul(this,Dt)},Ze.prototype.redSqr=function(){return We(this.red,"redSqr works only with red numbers"),this.red._verify1(this),this.red.sqr(this)},Ze.prototype.redISqr=function(){return We(this.red,"redISqr works only with red numbers"),this.red._verify1(this),this.red.isqr(this)},Ze.prototype.redSqrt=function(){return We(this.red,"redSqrt works only with red numbers"),this.red._verify1(this),this.red.sqrt(this)},Ze.prototype.redInvm=function(){return We(this.red,"redInvm works only with red numbers"),this.red._verify1(this),this.red.invm(this)},Ze.prototype.redNeg=function(){return We(this.red,"redNeg works only with red numbers"),this.red._verify1(this),this.red.neg(this)},Ze.prototype.redPow=function(Dt){return We(this.red&&!Dt.red,"redPow(normalNum)"),this.red._verify1(this),this.red.pow(this,Dt)};var Rr={k256:null,p224:null,p192:null,p25519:null};function Pr(ar,Dt){this.name=ar,this.p=new Ze(Dt,16),this.n=this.p.bitLength(),this.k=new Ze(1).iushln(this.n).isub(this.p),this.tmp=this._tmp()}Pr.prototype._tmp=function(){var Dt=new Ze(null);return Dt.words=new Array(Math.ceil(this.n/13)),Dt},Pr.prototype.ireduce=function(Dt){var sr=Dt,cr;do this.split(sr,this.tmp),sr=this.imulK(sr),sr=sr.iadd(this.tmp),cr=sr.bitLength();while(cr>this.n);var yr=cr<this.n?-1:sr.ucmp(this.p);return yr===0?(sr.words[0]=0,sr.length=1):yr>0?sr.isub(this.p):sr.strip!==void 0?sr.strip():sr._strip(),sr},Pr.prototype.split=function(Dt,sr){Dt.iushrn(this.n,0,sr)},Pr.prototype.imulK=function(Dt){return Dt.imul(this.k)};function Br(){Pr.call(this,"k256","ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f")}qe(Br,Pr),Br.prototype.split=function(Dt,sr){for(var cr=4194303,yr=Math.min(Dt.length,9),_r=0;_r<yr;_r++)sr.words[_r]=Dt.words[_r];if(sr.length=yr,Dt.length<=9){Dt.words[0]=0,Dt.length=1;return}var xr=Dt.words[9];for(sr.words[sr.length++]=xr&cr,_r=10;_r<Dt.length;_r++){var Ar=Dt.words[_r]|0;Dt.words[_r-10]=(Ar&cr)<<4|xr>>>22,xr=Ar}xr>>>=22,Dt.words[_r-10]=xr,xr===0&&Dt.length>10?Dt.length-=10:Dt.length-=9},Br.prototype.imulK=function(Dt){Dt.words[Dt.length]=0,Dt.words[Dt.length+1]=0,Dt.length+=2;for(var sr=0,cr=0;cr<Dt.length;cr++){var yr=Dt.words[cr]|0;sr+=yr*977,Dt.words[cr]=sr&67108863,sr=yr*64+(sr/67108864|0)}return Dt.words[Dt.length-1]===0&&(Dt.length--,Dt.words[Dt.length-1]===0&&Dt.length--),Dt};function Or(){Pr.call(this,"p224","ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001")}qe(Or,Pr);function Nr(){Pr.call(this,"p192","ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff")}qe(Nr,Pr);function Cr(){Pr.call(this,"25519","7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed")}qe(Cr,Pr),Cr.prototype.imulK=function(Dt){for(var sr=0,cr=0;cr<Dt.length;cr++){var yr=(Dt.words[cr]|0)*19+sr,_r=yr&67108863;yr>>>=26,Dt.words[cr]=_r,sr=yr}return sr!==0&&(Dt.words[Dt.length++]=sr),Dt},Ze._prime=function(Dt){if(Rr[Dt])return Rr[Dt];var sr;if(Dt==="k256")sr=new Br;else if(Dt==="p224")sr=new Or;else if(Dt==="p192")sr=new Nr;else if(Dt==="p25519")sr=new Cr;else throw new Error("Unknown prime "+Dt);return Rr[Dt]=sr,sr};function Tr(ar){if(typeof ar=="string"){var Dt=Ze._prime(ar);this.m=Dt.p,this.prime=Dt}else We(ar.gtn(1),"modulus must be greater than 1"),this.m=ar,this.prime=null}Tr.prototype._verify1=function(Dt){We(Dt.negative===0,"red works only with positives"),We(Dt.red,"red works only with red numbers")},Tr.prototype._verify2=function(Dt,sr){We((Dt.negative|sr.negative)===0,"red works only with positives"),We(Dt.red&&Dt.red===sr.red,"red works only with red numbers")},Tr.prototype.imod=function(Dt){return this.prime?this.prime.ireduce(Dt)._forceRed(this):(ir(Dt,Dt.umod(this.m)._forceRed(this)),Dt)},Tr.prototype.neg=function(Dt){return Dt.isZero()?Dt.clone():this.m.sub(Dt)._forceRed(this)},Tr.prototype.add=function(Dt,sr){this._verify2(Dt,sr);var cr=Dt.add(sr);return cr.cmp(this.m)>=0&&cr.isub(this.m),cr._forceRed(this)},Tr.prototype.iadd=function(Dt,sr){this._verify2(Dt,sr);var cr=Dt.iadd(sr);return cr.cmp(this.m)>=0&&cr.isub(this.m),cr},Tr.prototype.sub=function(Dt,sr){this._verify2(Dt,sr);var cr=Dt.sub(sr);return cr.cmpn(0)<0&&cr.iadd(this.m),cr._forceRed(this)},Tr.prototype.isub=function(Dt,sr){this._verify2(Dt,sr);var cr=Dt.isub(sr);return cr.cmpn(0)<0&&cr.iadd(this.m),cr},Tr.prototype.shl=function(Dt,sr){return this._verify1(Dt),this.imod(Dt.ushln(sr))},Tr.prototype.imul=function(Dt,sr){return this._verify2(Dt,sr),this.imod(Dt.imul(sr))},Tr.prototype.mul=function(Dt,sr){return this._verify2(Dt,sr),this.imod(Dt.mul(sr))},Tr.prototype.isqr=function(Dt){return this.imul(Dt,Dt.clone())},Tr.prototype.sqr=function(Dt){return this.mul(Dt,Dt)},Tr.prototype.sqrt=function(Dt){if(Dt.isZero())return Dt.clone();var sr=this.m.andln(3);if(We(sr%2===1),sr===3){var cr=this.m.add(new Ze(1)).iushrn(2);return this.pow(Dt,cr)}for(var yr=this.m.subn(1),_r=0;!yr.isZero()&&yr.andln(1)===0;)_r++,yr.iushrn(1);We(!yr.isZero());var xr=new Ze(1).toRed(this),Ar=xr.redNeg(),pr=this.m.subn(1).iushrn(1),rr=this.m.bitLength();for(rr=new Ze(2*rr*rr).toRed(this);this.pow(rr,pr).cmp(Ar)!==0;)rr.redIAdd(Ar);for(var hr=this.pow(rr,yr),$r=this.pow(Dt,yr.addn(1).iushrn(1)),Lr=this.pow(Dt,yr),Ur=_r;Lr.cmp(xr)!==0;){for(var Wr=Lr,Fr=0;Wr.cmp(xr)!==0;Fr++)Wr=Wr.redSqr();We(Fr<Ur);var zr=this.pow(hr,new Ze(1).iushln(Ur-Fr-1));$r=$r.redMul(zr),hr=zr.redSqr(),Lr=Lr.redMul(hr),Ur=Fr}return $r},Tr.prototype.invm=function(Dt){var sr=Dt._invmp(this.m);return sr.negative!==0?(sr.negative=0,this.imod(sr).redNeg()):this.imod(sr)},Tr.prototype.pow=function(Dt,sr){if(sr.isZero())return new Ze(1).toRed(this);if(sr.cmpn(1)===0)return Dt.clone();var cr=4,yr=new Array(1<<cr);yr[0]=new Ze(1).toRed(this),yr[1]=Dt;for(var _r=2;_r<yr.length;_r++)yr[_r]=this.mul(yr[_r-1],Dt);var xr=yr[0],Ar=0,pr=0,rr=sr.bitLength()%26;for(rr===0&&(rr=26),_r=sr.length-1;_r>=0;_r--){for(var hr=sr.words[_r],$r=rr-1;$r>=0;$r--){var Lr=hr>>$r&1;if(xr!==yr[0]&&(xr=this.sqr(xr)),Lr===0&&Ar===0){pr=0;continue}Ar<<=1,Ar|=Lr,pr++,!(pr!==cr&&(_r!==0||$r!==0))&&(xr=this.mul(xr,yr[Ar]),pr=0,Ar=0)}rr=26}return xr},Tr.prototype.convertTo=function(Dt){var sr=Dt.umod(this.m);return sr===Dt?sr.clone():sr},Tr.prototype.convertFrom=function(Dt){var sr=Dt.clone();return sr.red=null,sr},Ze.mont=function(Dt){return new Mr(Dt)};function Mr(ar){Tr.call(this,ar),this.shift=this.m.bitLength(),this.shift%26!==0&&(this.shift+=26-this.shift%26),this.r=new Ze(1).iushln(this.shift),this.r2=this.imod(this.r.sqr()),this.rinv=this.r._invmp(this.m),this.minv=this.rinv.mul(this.r).isubn(1).div(this.m),this.minv=this.minv.umod(this.r),this.minv=this.r.sub(this.minv)}qe(Mr,Tr),Mr.prototype.convertTo=function(Dt){return this.imod(Dt.ushln(this.shift))},Mr.prototype.convertFrom=function(Dt){var sr=this.imod(Dt.mul(this.rinv));return sr.red=null,sr},Mr.prototype.imul=function(Dt,sr){if(Dt.isZero()||sr.isZero())return Dt.words[0]=0,Dt.length=1,Dt;var cr=Dt.imul(sr),yr=cr.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),_r=cr.isub(yr).iushrn(this.shift),xr=_r;return _r.cmp(this.m)>=0?xr=_r.isub(this.m):_r.cmpn(0)<0&&(xr=_r.iadd(this.m)),xr._forceRed(this)},Mr.prototype.mul=function(Dt,sr){if(Dt.isZero()||sr.isZero())return new Ze(0)._forceRed(this);var cr=Dt.mul(sr),yr=cr.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),_r=cr.isub(yr).iushrn(this.shift),xr=_r;return _r.cmp(this.m)>=0?xr=_r.isub(this.m):_r.cmpn(0)<0&&(xr=_r.iadd(this.m)),xr._forceRed(this)},Mr.prototype.invm=function(Dt){var sr=this.imod(Dt._invmp(this.m).mul(this.r2));return sr._forceRed(this)}})(Ke,commonjsGlobal)})(bn$1);const u=bn$1.exports;var safeBuffer={exports:{}};/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */(function(Ke,Re){var Fe=buffer,We=Fe.Buffer;function qe(Xe,Je){for(var tr in Xe)Je[tr]=Xe[tr]}We.from&&We.alloc&&We.allocUnsafe&&We.allocUnsafeSlow?Ke.exports=Fe:(qe(Fe,Re),Re.Buffer=Ze);function Ze(Xe,Je,tr){return We(Xe,Je,tr)}Ze.prototype=Object.create(We.prototype),qe(We,Ze),Ze.from=function(Xe,Je,tr){if(typeof Xe=="number")throw new TypeError("Argument must not be a number");return We(Xe,Je,tr)},Ze.alloc=function(Xe,Je,tr){if(typeof Xe!="number")throw new TypeError("Argument must be a number");var er=We(Xe);return Je!==void 0?typeof tr=="string"?er.fill(Je,tr):er.fill(Je):er.fill(0),er},Ze.allocUnsafe=function(Xe){if(typeof Xe!="number")throw new TypeError("Argument must be a number");return We(Xe)},Ze.allocUnsafeSlow=function(Xe){if(typeof Xe!="number")throw new TypeError("Argument must be a number");return Fe.SlowBuffer(Xe)}})(safeBuffer,safeBuffer.exports);var _Buffer=safeBuffer.exports.Buffer;function base$1(Ke){if(Ke.length>=255)throw new TypeError("Alphabet too long");for(var Re=new Uint8Array(256),Fe=0;Fe<Re.length;Fe++)Re[Fe]=255;for(var We=0;We<Ke.length;We++){var qe=Ke.charAt(We),Ze=qe.charCodeAt(0);if(Re[Ze]!==255)throw new TypeError(qe+" is ambiguous");Re[Ze]=We}var Xe=Ke.length,Je=Ke.charAt(0),tr=Math.log(Xe)/Math.log(256),er=Math.log(256)/Math.log(Xe);function ir(ur){if((Array.isArray(ur)||ur instanceof Uint8Array)&&(ur=_Buffer.from(ur)),!_Buffer.isBuffer(ur))throw new TypeError("Expected Buffer");if(ur.length===0)return"";for(var mr=0,br=0,wr=0,Sr=ur.length;wr!==Sr&&ur[wr]===0;)wr++,mr++;for(var kr=(Sr-wr)*er+1>>>0,Er=new Uint8Array(kr);wr!==Sr;){for(var Ir=ur[wr],Rr=0,Pr=kr-1;(Ir!==0||Rr<br)&&Pr!==-1;Pr--,Rr++)Ir+=256*Er[Pr]>>>0,Er[Pr]=Ir%Xe>>>0,Ir=Ir/Xe>>>0;if(Ir!==0)throw new Error("Non-zero carry");br=Rr,wr++}for(var Br=kr-br;Br!==kr&&Er[Br]===0;)Br++;for(var Or=Je.repeat(mr);Br<kr;++Br)Or+=Ke.charAt(Er[Br]);return Or}function lr(ur){if(typeof ur!="string")throw new TypeError("Expected String");if(ur.length===0)return _Buffer.alloc(0);for(var mr=0,br=0,wr=0;ur[mr]===Je;)br++,mr++;for(var Sr=(ur.length-mr)*tr+1>>>0,kr=new Uint8Array(Sr);ur[mr];){var Er=Re[ur.charCodeAt(mr)];if(Er===255)return;for(var Ir=0,Rr=Sr-1;(Er!==0||Ir<wr)&&Rr!==-1;Rr--,Ir++)Er+=Xe*kr[Rr]>>>0,kr[Rr]=Er%256>>>0,Er=Er/256>>>0;if(Er!==0)throw new Error("Non-zero carry");wr=Ir,mr++}for(var Pr=Sr-wr;Pr!==Sr&&kr[Pr]===0;)Pr++;var Br=_Buffer.allocUnsafe(br+(Sr-Pr));Br.fill(0,0,br);for(var Or=br;Pr!==Sr;)Br[Or++]=kr[Pr++];return Br}function fr(ur){var mr=lr(ur);if(mr)return mr;throw new Error("Non-base"+Xe+" character")}return{encode:ir,decodeUnsafe:lr,decode:fr}}var src=base$1,basex=src,ALPHABET="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz",bs58=basex(ALPHABET);const Chi=(Ke,Re,Fe)=>Ke&Re^~Ke&Fe,Maj=(Ke,Re,Fe)=>Ke&Re^Ke&Fe^Re&Fe,SHA256_K=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),IV=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),SHA256_W=new Uint32Array(64);class SHA256 extends SHA2{constructor(){super(64,32,8,!1),this.A=IV[0]|0,this.B=IV[1]|0,this.C=IV[2]|0,this.D=IV[3]|0,this.E=IV[4]|0,this.F=IV[5]|0,this.G=IV[6]|0,this.H=IV[7]|0}get(){const{A:Re,B:Fe,C:We,D:qe,E:Ze,F:Xe,G:Je,H:tr}=this;return[Re,Fe,We,qe,Ze,Xe,Je,tr]}set(Re,Fe,We,qe,Ze,Xe,Je,tr){this.A=Re|0,this.B=Fe|0,this.C=We|0,this.D=qe|0,this.E=Ze|0,this.F=Xe|0,this.G=Je|0,this.H=tr|0}process(Re,Fe){for(let lr=0;lr<16;lr++,Fe+=4)SHA256_W[lr]=Re.getUint32(Fe,!1);for(let lr=16;lr<64;lr++){const fr=SHA256_W[lr-15],ur=SHA256_W[lr-2],mr=rotr(fr,7)^rotr(fr,18)^fr>>>3,br=rotr(ur,17)^rotr(ur,19)^ur>>>10;SHA256_W[lr]=br+SHA256_W[lr-7]+mr+SHA256_W[lr-16]|0}let{A:We,B:qe,C:Ze,D:Xe,E:Je,F:tr,G:er,H:ir}=this;for(let lr=0;lr<64;lr++){const fr=rotr(Je,6)^rotr(Je,11)^rotr(Je,25),ur=ir+fr+Chi(Je,tr,er)+SHA256_K[lr]+SHA256_W[lr]|0,br=(rotr(We,2)^rotr(We,13)^rotr(We,22))+Maj(We,qe,Ze)|0;ir=er,er=tr,tr=Je,Je=Xe+ur|0,Xe=Ze,Ze=qe,qe=We,We=ur+br|0}We=We+this.A|0,qe=qe+this.B|0,Ze=Ze+this.C|0,Xe=Xe+this.D|0,Je=Je+this.E|0,tr=tr+this.F|0,er=er+this.G|0,ir=ir+this.H|0,this.set(We,qe,Ze,Xe,Je,tr,er,ir)}roundClean(){SHA256_W.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}const sha256$1=wrapConstructor(()=>new SHA256);var lib$1={};function inRange(Ke,Re,Fe){return Re<=Ke&&Ke<=Fe}function ToDictionary(Ke){if(Ke===void 0)return{};if(Ke===Object(Ke))return Ke;throw TypeError("Could not convert argument to dictionary")}function stringToCodePoints(Ke){for(var Re=String(Ke),Fe=Re.length,We=0,qe=[];We<Fe;){var Ze=Re.charCodeAt(We);if(Ze<55296||Ze>57343)qe.push(Ze);else if(56320<=Ze&&Ze<=57343)qe.push(65533);else if(55296<=Ze&&Ze<=56319)if(We===Fe-1)qe.push(65533);else{var Xe=Ke.charCodeAt(We+1);if(56320<=Xe&&Xe<=57343){var Je=Ze&1023,tr=Xe&1023;qe.push(65536+(Je<<10)+tr),We+=1}else qe.push(65533)}We+=1}return qe}function codePointsToString(Ke){for(var Re="",Fe=0;Fe<Ke.length;++Fe){var We=Ke[Fe];We<=65535?Re+=String.fromCharCode(We):(We-=65536,Re+=String.fromCharCode((We>>10)+55296,(We&1023)+56320))}return Re}var end_of_stream=-1;function Stream(Ke){this.tokens=[].slice.call(Ke)}Stream.prototype={endOfStream:function(){return!this.tokens.length},read:function(){return this.tokens.length?this.tokens.shift():end_of_stream},prepend:function(Ke){if(Array.isArray(Ke))for(var Re=Ke;Re.length;)this.tokens.unshift(Re.pop());else this.tokens.unshift(Ke)},push:function(Ke){if(Array.isArray(Ke))for(var Re=Ke;Re.length;)this.tokens.push(Re.shift());else this.tokens.push(Ke)}};var finished=-1;function decoderError(Ke,Re){if(Ke)throw TypeError("Decoder error");return Re||65533}var DEFAULT_ENCODING="utf-8";function TextDecoder$1(Ke,Re){if(!(this instanceof TextDecoder$1))return new TextDecoder$1(Ke,Re);if(Ke=Ke!==void 0?String(Ke).toLowerCase():DEFAULT_ENCODING,Ke!==DEFAULT_ENCODING)throw new Error("Encoding not supported. Only utf-8 is supported");Re=ToDictionary(Re),this._streaming=!1,this._BOMseen=!1,this._decoder=null,this._fatal=Boolean(Re.fatal),this._ignoreBOM=Boolean(Re.ignoreBOM),Object.defineProperty(this,"encoding",{value:"utf-8"}),Object.defineProperty(this,"fatal",{value:this._fatal}),Object.defineProperty(this,"ignoreBOM",{value:this._ignoreBOM})}TextDecoder$1.prototype={decode:function(Re,Fe){var We;typeof Re=="object"&&Re instanceof ArrayBuffer?We=new Uint8Array(Re):typeof Re=="object"&&"buffer"in Re&&Re.buffer instanceof ArrayBuffer?We=new Uint8Array(Re.buffer,Re.byteOffset,Re.byteLength):We=new Uint8Array(0),Fe=ToDictionary(Fe),this._streaming||(this._decoder=new UTF8Decoder({fatal:this._fatal}),this._BOMseen=!1),this._streaming=Boolean(Fe.stream);for(var qe=new Stream(We),Ze=[],Xe;!qe.endOfStream()&&(Xe=this._decoder.handler(qe,qe.read()),Xe!==finished);)Xe!==null&&(Array.isArray(Xe)?Ze.push.apply(Ze,Xe):Ze.push(Xe));if(!this._streaming){do{if(Xe=this._decoder.handler(qe,qe.read()),Xe===finished)break;Xe!==null&&(Array.isArray(Xe)?Ze.push.apply(Ze,Xe):Ze.push(Xe))}while(!qe.endOfStream());this._decoder=null}return Ze.length&&["utf-8"].indexOf(this.encoding)!==-1&&!this._ignoreBOM&&!this._BOMseen&&(Ze[0]===65279?(this._BOMseen=!0,Ze.shift()):this._BOMseen=!0),codePointsToString(Ze)}};function TextEncoder$1(Ke,Re){if(!(this instanceof TextEncoder$1))return new TextEncoder$1(Ke,Re);if(Ke=Ke!==void 0?String(Ke).toLowerCase():DEFAULT_ENCODING,Ke!==DEFAULT_ENCODING)throw new Error("Encoding not supported. Only utf-8 is supported");Re=ToDictionary(Re),this._streaming=!1,this._encoder=null,this._options={fatal:Boolean(Re.fatal)},Object.defineProperty(this,"encoding",{value:"utf-8"})}TextEncoder$1.prototype={encode:function(Re,Fe){Re=Re?String(Re):"",Fe=ToDictionary(Fe),this._streaming||(this._encoder=new UTF8Encoder(this._options)),this._streaming=Boolean(Fe.stream);for(var We=[],qe=new Stream(stringToCodePoints(Re)),Ze;!qe.endOfStream()&&(Ze=this._encoder.handler(qe,qe.read()),Ze!==finished);)Array.isArray(Ze)?We.push.apply(We,Ze):We.push(Ze);if(!this._streaming){for(;Ze=this._encoder.handler(qe,qe.read()),Ze!==finished;)Array.isArray(Ze)?We.push.apply(We,Ze):We.push(Ze);this._encoder=null}return new Uint8Array(We)}};function UTF8Decoder(Ke){var Re=Ke.fatal,Fe=0,We=0,qe=0,Ze=128,Xe=191;this.handler=function(Je,tr){if(tr===end_of_stream&&qe!==0)return qe=0,decoderError(Re);if(tr===end_of_stream)return finished;if(qe===0){if(inRange(tr,0,127))return tr;if(inRange(tr,194,223))qe=1,Fe=tr-192;else if(inRange(tr,224,239))tr===224&&(Ze=160),tr===237&&(Xe=159),qe=2,Fe=tr-224;else if(inRange(tr,240,244))tr===240&&(Ze=144),tr===244&&(Xe=143),qe=3,Fe=tr-240;else return decoderError(Re);return Fe=Fe<<6*qe,null}if(!inRange(tr,Ze,Xe))return Fe=qe=We=0,Ze=128,Xe=191,Je.prepend(tr),decoderError(Re);if(Ze=128,Xe=191,We+=1,Fe+=tr-128<<6*(qe-We),We!==qe)return null;var er=Fe;return Fe=qe=We=0,er}}function UTF8Encoder(Ke){Ke.fatal,this.handler=function(Re,Fe){if(Fe===end_of_stream)return finished;if(inRange(Fe,0,127))return Fe;var We,qe;inRange(Fe,128,2047)?(We=1,qe=192):inRange(Fe,2048,65535)?(We=2,qe=224):inRange(Fe,65536,1114111)&&(We=3,qe=240);for(var Ze=[(Fe>>6*We)+qe];We>0;){var Xe=Fe>>6*(We-1);Ze.push(128|Xe&63),We-=1}return Ze}}const encoding$1=Object.freeze(Object.defineProperty({__proto__:null,TextEncoder:TextEncoder$1,TextDecoder:TextDecoder$1},Symbol.toStringTag,{value:"Module"})),require$$2=getAugmentedNamespace(encoding$1);var __createBinding=commonjsGlobal&&commonjsGlobal.__createBinding||(Object.create?function(Ke,Re,Fe,We){We===void 0&&(We=Fe),Object.defineProperty(Ke,We,{enumerable:!0,get:function(){return Re[Fe]}})}:function(Ke,Re,Fe,We){We===void 0&&(We=Fe),Ke[We]=Re[Fe]}),__setModuleDefault=commonjsGlobal&&commonjsGlobal.__setModuleDefault||(Object.create?function(Ke,Re){Object.defineProperty(Ke,"default",{enumerable:!0,value:Re})}:function(Ke,Re){Ke.default=Re}),__decorate=commonjsGlobal&&commonjsGlobal.__decorate||function(Ke,Re,Fe,We){var qe=arguments.length,Ze=qe<3?Re:We===null?We=Object.getOwnPropertyDescriptor(Re,Fe):We,Xe;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")Ze=Reflect.decorate(Ke,Re,Fe,We);else for(var Je=Ke.length-1;Je>=0;Je--)(Xe=Ke[Je])&&(Ze=(qe<3?Xe(Ze):qe>3?Xe(Re,Fe,Ze):Xe(Re,Fe))||Ze);return qe>3&&Ze&&Object.defineProperty(Re,Fe,Ze),Ze},__importStar=commonjsGlobal&&commonjsGlobal.__importStar||function(Ke){if(Ke&&Ke.__esModule)return Ke;var Re={};if(Ke!=null)for(var Fe in Ke)Fe!=="default"&&Object.hasOwnProperty.call(Ke,Fe)&&__createBinding(Re,Ke,Fe);return __setModuleDefault(Re,Ke),Re},__importDefault=commonjsGlobal&&commonjsGlobal.__importDefault||function(Ke){return Ke&&Ke.__esModule?Ke:{default:Ke}};Object.defineProperty(lib$1,"__esModule",{value:!0});var deserializeUnchecked_1=lib$1.deserializeUnchecked=deserialize_1=lib$1.deserialize=serialize_1=lib$1.serialize=lib$1.BinaryReader=lib$1.BinaryWriter=lib$1.BorshError=lib$1.baseDecode=lib$1.baseEncode=void 0;const bn_js_1=__importDefault(bn$1.exports),bs58_1=__importDefault(bs58),encoding=__importStar(require$$2),ResolvedTextDecoder=typeof TextDecoder!="function"?encoding.TextDecoder:TextDecoder,textDecoder=new ResolvedTextDecoder("utf-8",{fatal:!0});function baseEncode(Ke){return typeof Ke=="string"&&(Ke=Buffer.from(Ke,"utf8")),bs58_1.default.encode(Buffer.from(Ke))}lib$1.baseEncode=baseEncode;function baseDecode(Ke){return Buffer.from(bs58_1.default.decode(Ke))}lib$1.baseDecode=baseDecode;const INITIAL_LENGTH=1024;class BorshError extends Error{constructor(Re){super(Re),this.fieldPath=[],this.originalMessage=Re}addToFieldPath(Re){this.fieldPath.splice(0,0,Re),this.message=this.originalMessage+": "+this.fieldPath.join(".")}}lib$1.BorshError=BorshError;class BinaryWriter{constructor(){this.buf=Buffer.alloc(INITIAL_LENGTH),this.length=0}maybeResize(){this.buf.length<16+this.length&&(this.buf=Buffer.concat([this.buf,Buffer.alloc(INITIAL_LENGTH)]))}writeU8(Re){this.maybeResize(),this.buf.writeUInt8(Re,this.length),this.length+=1}writeU16(Re){this.maybeResize(),this.buf.writeUInt16LE(Re,this.length),this.length+=2}writeU32(Re){this.maybeResize(),this.buf.writeUInt32LE(Re,this.length),this.length+=4}writeU64(Re){this.maybeResize(),this.writeBuffer(Buffer.from(new bn_js_1.default(Re).toArray("le",8)))}writeU128(Re){this.maybeResize(),this.writeBuffer(Buffer.from(new bn_js_1.default(Re).toArray("le",16)))}writeU256(Re){this.maybeResize(),this.writeBuffer(Buffer.from(new bn_js_1.default(Re).toArray("le",32)))}writeU512(Re){this.maybeResize(),this.writeBuffer(Buffer.from(new bn_js_1.default(Re).toArray("le",64)))}writeBuffer(Re){this.buf=Buffer.concat([Buffer.from(this.buf.subarray(0,this.length)),Re,Buffer.alloc(INITIAL_LENGTH)]),this.length+=Re.length}writeString(Re){this.maybeResize();const Fe=Buffer.from(Re,"utf8");this.writeU32(Fe.length),this.writeBuffer(Fe)}writeFixedArray(Re){this.writeBuffer(Buffer.from(Re))}writeArray(Re,Fe){this.maybeResize(),this.writeU32(Re.length);for(const We of Re)this.maybeResize(),Fe(We)}toArray(){return this.buf.subarray(0,this.length)}}lib$1.BinaryWriter=BinaryWriter;function handlingRangeError(Ke,Re,Fe){const We=Fe.value;Fe.value=function(...qe){try{return We.apply(this,qe)}catch(Ze){if(Ze instanceof RangeError){const Xe=Ze.code;if(["ERR_BUFFER_OUT_OF_BOUNDS","ERR_OUT_OF_RANGE"].indexOf(Xe)>=0)throw new BorshError("Reached the end of buffer when deserializing")}throw Ze}}}class BinaryReader{constructor(Re){this.buf=Re,this.offset=0}readU8(){const Re=this.buf.readUInt8(this.offset);return this.offset+=1,Re}readU16(){const Re=this.buf.readUInt16LE(this.offset);return this.offset+=2,Re}readU32(){const Re=this.buf.readUInt32LE(this.offset);return this.offset+=4,Re}readU64(){const Re=this.readBuffer(8);return new bn_js_1.default(Re,"le")}readU128(){const Re=this.readBuffer(16);return new bn_js_1.default(Re,"le")}readU256(){const Re=this.readBuffer(32);return new bn_js_1.default(Re,"le")}readU512(){const Re=this.readBuffer(64);return new bn_js_1.default(Re,"le")}readBuffer(Re){if(this.offset+Re>this.buf.length)throw new BorshError(`Expected buffer length ${Re} isn't within bounds`);const Fe=this.buf.slice(this.offset,this.offset+Re);return this.offset+=Re,Fe}readString(){const Re=this.readU32(),Fe=this.readBuffer(Re);try{return textDecoder.decode(Fe)}catch(We){throw new BorshError(`Error decoding UTF-8 string: ${We}`)}}readFixedArray(Re){return new Uint8Array(this.readBuffer(Re))}readArray(Re){const Fe=this.readU32(),We=Array();for(let qe=0;qe<Fe;++qe)We.push(Re());return We}}__decorate([handlingRangeError],BinaryReader.prototype,"readU8",null);__decorate([handlingRangeError],BinaryReader.prototype,"readU16",null);__decorate([handlingRangeError],BinaryReader.prototype,"readU32",null);__decorate([handlingRangeError],BinaryReader.prototype,"readU64",null);__decorate([handlingRangeError],BinaryReader.prototype,"readU128",null);__decorate([handlingRangeError],BinaryReader.prototype,"readU256",null);__decorate([handlingRangeError],BinaryReader.prototype,"readU512",null);__decorate([handlingRangeError],BinaryReader.prototype,"readString",null);__decorate([handlingRangeError],BinaryReader.prototype,"readFixedArray",null);__decorate([handlingRangeError],BinaryReader.prototype,"readArray",null);lib$1.BinaryReader=BinaryReader;function capitalizeFirstLetter(Ke){return Ke.charAt(0).toUpperCase()+Ke.slice(1)}function serializeField(Ke,Re,Fe,We,qe){try{if(typeof We=="string")qe[`write${capitalizeFirstLetter(We)}`](Fe);else if(We instanceof Array)if(typeof We[0]=="number"){if(Fe.length!==We[0])throw new BorshError(`Expecting byte array of length ${We[0]}, but got ${Fe.length} bytes`);qe.writeFixedArray(Fe)}else if(We.length===2&&typeof We[1]=="number"){if(Fe.length!==We[1])throw new BorshError(`Expecting byte array of length ${We[1]}, but got ${Fe.length} bytes`);for(let Ze=0;Ze<We[1];Ze++)serializeField(Ke,null,Fe[Ze],We[0],qe)}else qe.writeArray(Fe,Ze=>{serializeField(Ke,Re,Ze,We[0],qe)});else if(We.kind!==void 0)switch(We.kind){case"option":{Fe==null?qe.writeU8(0):(qe.writeU8(1),serializeField(Ke,Re,Fe,We.type,qe));break}case"map":{qe.writeU32(Fe.size),Fe.forEach((Ze,Xe)=>{serializeField(Ke,Re,Xe,We.key,qe),serializeField(Ke,Re,Ze,We.value,qe)});break}default:throw new BorshError(`FieldType ${We} unrecognized`)}else serializeStruct(Ke,Fe,qe)}catch(Ze){throw Ze instanceof BorshError&&Ze.addToFieldPath(Re),Ze}}function serializeStruct(Ke,Re,Fe){if(typeof Re.borshSerialize=="function"){Re.borshSerialize(Fe);return}const We=Ke.get(Re.constructor);if(!We)throw new BorshError(`Class ${Re.constructor.name} is missing in schema`);if(We.kind==="struct")We.fields.map(([qe,Ze])=>{serializeField(Ke,qe,Re[qe],Ze,Fe)});else if(We.kind==="enum"){const qe=Re[We.field];for(let Ze=0;Ze<We.values.length;++Ze){const[Xe,Je]=We.values[Ze];if(Xe===qe){Fe.writeU8(Ze),serializeField(Ke,Xe,Re[Xe],Je,Fe);break}}}else throw new BorshError(`Unexpected schema kind: ${We.kind} for ${Re.constructor.name}`)}function serialize(Ke,Re,Fe=BinaryWriter){const We=new Fe;return serializeStruct(Ke,Re,We),We.toArray()}var serialize_1=lib$1.serialize=serialize;function deserializeField(Ke,Re,Fe,We){try{if(typeof Fe=="string")return We[`read${capitalizeFirstLetter(Fe)}`]();if(Fe instanceof Array){if(typeof Fe[0]=="number")return We.readFixedArray(Fe[0]);if(typeof Fe[1]=="number"){const qe=[];for(let Ze=0;Ze<Fe[1];Ze++)qe.push(deserializeField(Ke,null,Fe[0],We));return qe}else return We.readArray(()=>deserializeField(Ke,Re,Fe[0],We))}if(Fe.kind==="option")return We.readU8()?deserializeField(Ke,Re,Fe.type,We):void 0;if(Fe.kind==="map"){let qe=new Map;const Ze=We.readU32();for(let Xe=0;Xe<Ze;Xe++){const Je=deserializeField(Ke,Re,Fe.key,We),tr=deserializeField(Ke,Re,Fe.value,We);qe.set(Je,tr)}return qe}return deserializeStruct(Ke,Fe,We)}catch(qe){throw qe instanceof BorshError&&qe.addToFieldPath(Re),qe}}function deserializeStruct(Ke,Re,Fe){if(typeof Re.borshDeserialize=="function")return Re.borshDeserialize(Fe);const We=Ke.get(Re);if(!We)throw new BorshError(`Class ${Re.name} is missing in schema`);if(We.kind==="struct"){const qe={};for(const[Ze,Xe]of Ke.get(Re).fields)qe[Ze]=deserializeField(Ke,Ze,Xe,Fe);return new Re(qe)}if(We.kind==="enum"){const qe=Fe.readU8();if(qe>=We.values.length)throw new BorshError(`Enum index: ${qe} is out of range`);const[Ze,Xe]=We.values[qe],Je=deserializeField(Ke,Ze,Xe,Fe);return new Re({[Ze]:Je})}throw new BorshError(`Unexpected schema kind: ${We.kind} for ${Re.constructor.name}`)}function deserialize(Ke,Re,Fe,We=BinaryReader){const qe=new We(Fe),Ze=deserializeStruct(Ke,Re,qe);if(qe.offset<Fe.length)throw new BorshError(`Unexpected ${Fe.length-qe.offset} bytes after deserialized data`);return Ze}var deserialize_1=lib$1.deserialize=deserialize;function deserializeUnchecked(Ke,Re,Fe,We=BinaryReader){const qe=new We(Fe);return deserializeStruct(Ke,Re,qe)}deserializeUnchecked_1=lib$1.deserializeUnchecked=deserializeUnchecked;var Layout$3={};Object.defineProperty(Layout$3,"__esModule",{value:!0});Layout$3.s16=Layout$3.s8=Layout$3.nu64be=Layout$3.u48be=Layout$3.u40be=Layout$3.u32be=Layout$3.u24be=Layout$3.u16be=nu64=Layout$3.nu64=Layout$3.u48=Layout$3.u40=u32=Layout$3.u32=Layout$3.u24=u16=Layout$3.u16=u8=Layout$3.u8=offset=Layout$3.offset=Layout$3.greedy=Layout$3.Constant=Layout$3.UTF8=Layout$3.CString=Layout$3.Blob=Layout$3.Boolean=Layout$3.BitField=Layout$3.BitStructure=Layout$3.VariantLayout=Layout$3.Union=Layout$3.UnionLayoutDiscriminator=Layout$3.UnionDiscriminator=Layout$3.Structure=Layout$3.Sequence=Layout$3.DoubleBE=Layout$3.Double=Layout$3.FloatBE=Layout$3.Float=Layout$3.NearInt64BE=Layout$3.NearInt64=Layout$3.NearUInt64BE=Layout$3.NearUInt64=Layout$3.IntBE=Layout$3.Int=Layout$3.UIntBE=Layout$3.UInt=Layout$3.OffsetLayout=Layout$3.GreedyCount=Layout$3.ExternalLayout=Layout$3.bindConstructorLayout=Layout$3.nameWithProperty=Layout$3.Layout=Layout$3.uint8ArrayToBuffer=Layout$3.checkUint8Array=void 0;Layout$3.constant=Layout$3.utf8=Layout$3.cstr=blob=Layout$3.blob=Layout$3.unionLayoutDiscriminator=Layout$3.union=seq=Layout$3.seq=Layout$3.bits=struct=Layout$3.struct=Layout$3.f64be=Layout$3.f64=Layout$3.f32be=Layout$3.f32=Layout$3.ns64be=Layout$3.s48be=Layout$3.s40be=Layout$3.s32be=Layout$3.s24be=Layout$3.s16be=ns64=Layout$3.ns64=Layout$3.s48=Layout$3.s40=Layout$3.s32=Layout$3.s24=void 0;const buffer_1=buffer$1;function checkUint8Array(Ke){if(!(Ke instanceof Uint8Array))throw new TypeError("b must be a Uint8Array")}Layout$3.checkUint8Array=checkUint8Array;function uint8ArrayToBuffer(Ke){return checkUint8Array(Ke),buffer_1.Buffer.from(Ke.buffer,Ke.byteOffset,Ke.length)}Layout$3.uint8ArrayToBuffer=uint8ArrayToBuffer;class Layout$2{constructor(Re,Fe){if(!Number.isInteger(Re))throw new TypeError("span must be an integer");this.span=Re,this.property=Fe}makeDestinationObject(){return{}}getSpan(Re,Fe){if(0>this.span)throw new RangeError("indeterminate span");return this.span}replicate(Re){const Fe=Object.create(this.constructor.prototype);return Object.assign(Fe,this),Fe.property=Re,Fe}fromArray(Re){}}Layout$3.Layout=Layout$2;function nameWithProperty$1(Ke,Re){return Re.property?Ke+"["+Re.property+"]":Ke}Layout$3.nameWithProperty=nameWithProperty$1;function bindConstructorLayout$1(Ke,Re){if(typeof Ke!="function")throw new TypeError("Class must be constructor");if(Object.prototype.hasOwnProperty.call(Ke,"layout_"))throw new Error("Class is already bound to a layout");if(!(Re&&Re instanceof Layout$2))throw new TypeError("layout must be a Layout");if(Object.prototype.hasOwnProperty.call(Re,"boundConstructor_"))throw new Error("layout is already bound to a constructor");Ke.layout_=Re,Re.boundConstructor_=Ke,Re.makeDestinationObject=()=>new Ke,Object.defineProperty(Ke.prototype,"encode",{value(Fe,We){return Re.encode(this,Fe,We)},writable:!0}),Object.defineProperty(Ke,"decode",{value(Fe,We){return Re.decode(Fe,We)},writable:!0})}Layout$3.bindConstructorLayout=bindConstructorLayout$1;class ExternalLayout$1 extends Layout$2{isCount(){throw new Error("ExternalLayout is abstract")}}Layout$3.ExternalLayout=ExternalLayout$1;class GreedyCount$1 extends ExternalLayout$1{constructor(Re=1,Fe){if(!Number.isInteger(Re)||0>=Re)throw new TypeError("elementSpan must be a (positive) integer");super(-1,Fe),this.elementSpan=Re}isCount(){return!0}decode(Re,Fe=0){checkUint8Array(Re);const We=Re.length-Fe;return Math.floor(We/this.elementSpan)}encode(Re,Fe,We){return 0}}Layout$3.GreedyCount=GreedyCount$1;class OffsetLayout$1 extends ExternalLayout$1{constructor(Re,Fe=0,We){if(!(Re instanceof Layout$2))throw new TypeError("layout must be a Layout");if(!Number.isInteger(Fe))throw new TypeError("offset must be integer or undefined");super(Re.span,We||Re.property),this.layout=Re,this.offset=Fe}isCount(){return this.layout instanceof UInt$1||this.layout instanceof UIntBE$1}decode(Re,Fe=0){return this.layout.decode(Re,Fe+this.offset)}encode(Re,Fe,We=0){return this.layout.encode(Re,Fe,We+this.offset)}}Layout$3.OffsetLayout=OffsetLayout$1;class UInt$1 extends Layout$2{constructor(Re,Fe){if(super(Re,Fe),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(Re,Fe=0){return uint8ArrayToBuffer(Re).readUIntLE(Fe,this.span)}encode(Re,Fe,We=0){return uint8ArrayToBuffer(Fe).writeUIntLE(Re,We,this.span),this.span}}Layout$3.UInt=UInt$1;class UIntBE$1 extends Layout$2{constructor(Re,Fe){if(super(Re,Fe),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(Re,Fe=0){return uint8ArrayToBuffer(Re).readUIntBE(Fe,this.span)}encode(Re,Fe,We=0){return uint8ArrayToBuffer(Fe).writeUIntBE(Re,We,this.span),this.span}}Layout$3.UIntBE=UIntBE$1;class Int$1 extends Layout$2{constructor(Re,Fe){if(super(Re,Fe),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(Re,Fe=0){return uint8ArrayToBuffer(Re).readIntLE(Fe,this.span)}encode(Re,Fe,We=0){return uint8ArrayToBuffer(Fe).writeIntLE(Re,We,this.span),this.span}}Layout$3.Int=Int$1;class IntBE$1 extends Layout$2{constructor(Re,Fe){if(super(Re,Fe),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(Re,Fe=0){return uint8ArrayToBuffer(Re).readIntBE(Fe,this.span)}encode(Re,Fe,We=0){return uint8ArrayToBuffer(Fe).writeIntBE(Re,We,this.span),this.span}}Layout$3.IntBE=IntBE$1;const V2E32$1=Math.pow(2,32);function divmodInt64$1(Ke){const Re=Math.floor(Ke/V2E32$1),Fe=Ke-Re*V2E32$1;return{hi32:Re,lo32:Fe}}function roundedInt64$1(Ke,Re){return Ke*V2E32$1+Re}class NearUInt64$1 extends Layout$2{constructor(Re){super(8,Re)}decode(Re,Fe=0){const We=uint8ArrayToBuffer(Re),qe=We.readUInt32LE(Fe),Ze=We.readUInt32LE(Fe+4);return roundedInt64$1(Ze,qe)}encode(Re,Fe,We=0){const qe=divmodInt64$1(Re),Ze=uint8ArrayToBuffer(Fe);return Ze.writeUInt32LE(qe.lo32,We),Ze.writeUInt32LE(qe.hi32,We+4),8}}Layout$3.NearUInt64=NearUInt64$1;class NearUInt64BE$1 extends Layout$2{constructor(Re){super(8,Re)}decode(Re,Fe=0){const We=uint8ArrayToBuffer(Re),qe=We.readUInt32BE(Fe),Ze=We.readUInt32BE(Fe+4);return roundedInt64$1(qe,Ze)}encode(Re,Fe,We=0){const qe=divmodInt64$1(Re),Ze=uint8ArrayToBuffer(Fe);return Ze.writeUInt32BE(qe.hi32,We),Ze.writeUInt32BE(qe.lo32,We+4),8}}Layout$3.NearUInt64BE=NearUInt64BE$1;class NearInt64$1 extends Layout$2{constructor(Re){super(8,Re)}decode(Re,Fe=0){const We=uint8ArrayToBuffer(Re),qe=We.readUInt32LE(Fe),Ze=We.readInt32LE(Fe+4);return roundedInt64$1(Ze,qe)}encode(Re,Fe,We=0){const qe=divmodInt64$1(Re),Ze=uint8ArrayToBuffer(Fe);return Ze.writeUInt32LE(qe.lo32,We),Ze.writeInt32LE(qe.hi32,We+4),8}}Layout$3.NearInt64=NearInt64$1;class NearInt64BE$1 extends Layout$2{constructor(Re){super(8,Re)}decode(Re,Fe=0){const We=uint8ArrayToBuffer(Re),qe=We.readInt32BE(Fe),Ze=We.readUInt32BE(Fe+4);return roundedInt64$1(qe,Ze)}encode(Re,Fe,We=0){const qe=divmodInt64$1(Re),Ze=uint8ArrayToBuffer(Fe);return Ze.writeInt32BE(qe.hi32,We),Ze.writeUInt32BE(qe.lo32,We+4),8}}Layout$3.NearInt64BE=NearInt64BE$1;class Float$1 extends Layout$2{constructor(Re){super(4,Re)}decode(Re,Fe=0){return uint8ArrayToBuffer(Re).readFloatLE(Fe)}encode(Re,Fe,We=0){return uint8ArrayToBuffer(Fe).writeFloatLE(Re,We),4}}Layout$3.Float=Float$1;class FloatBE$1 extends Layout$2{constructor(Re){super(4,Re)}decode(Re,Fe=0){return uint8ArrayToBuffer(Re).readFloatBE(Fe)}encode(Re,Fe,We=0){return uint8ArrayToBuffer(Fe).writeFloatBE(Re,We),4}}Layout$3.FloatBE=FloatBE$1;class Double$1 extends Layout$2{constructor(Re){super(8,Re)}decode(Re,Fe=0){return uint8ArrayToBuffer(Re).readDoubleLE(Fe)}encode(Re,Fe,We=0){return uint8ArrayToBuffer(Fe).writeDoubleLE(Re,We),8}}Layout$3.Double=Double$1;class DoubleBE$1 extends Layout$2{constructor(Re){super(8,Re)}decode(Re,Fe=0){return uint8ArrayToBuffer(Re).readDoubleBE(Fe)}encode(Re,Fe,We=0){return uint8ArrayToBuffer(Fe).writeDoubleBE(Re,We),8}}Layout$3.DoubleBE=DoubleBE$1;class Sequence$1 extends Layout$2{constructor(Re,Fe,We){if(!(Re instanceof Layout$2))throw new TypeError("elementLayout must be a Layout");if(!(Fe instanceof ExternalLayout$1&&Fe.isCount()||Number.isInteger(Fe)&&0<=Fe))throw new TypeError("count must be non-negative integer or an unsigned integer ExternalLayout");let qe=-1;!(Fe instanceof ExternalLayout$1)&&0<Re.span&&(qe=Fe*Re.span),super(qe,We),this.elementLayout=Re,this.count=Fe}getSpan(Re,Fe=0){if(0<=this.span)return this.span;let We=0,qe=this.count;if(qe instanceof ExternalLayout$1&&(qe=qe.decode(Re,Fe)),0<this.elementLayout.span)We=qe*this.elementLayout.span;else{let Ze=0;for(;Ze<qe;)We+=this.elementLayout.getSpan(Re,Fe+We),++Ze}return We}decode(Re,Fe=0){const We=[];let qe=0,Ze=this.count;for(Ze instanceof ExternalLayout$1&&(Ze=Ze.decode(Re,Fe));qe<Ze;)We.push(this.elementLayout.decode(Re,Fe)),Fe+=this.elementLayout.getSpan(Re,Fe),qe+=1;return We}encode(Re,Fe,We=0){const qe=this.elementLayout,Ze=Re.reduce((Xe,Je)=>Xe+qe.encode(Je,Fe,We+Xe),0);return this.count instanceof ExternalLayout$1&&this.count.encode(Re.length,Fe,We),Ze}}Layout$3.Sequence=Sequence$1;class Structure$1 extends Layout$2{constructor(Re,Fe,We){if(!(Array.isArray(Re)&&Re.reduce((Ze,Xe)=>Ze&&Xe instanceof Layout$2,!0)))throw new TypeError("fields must be array of Layout instances");typeof Fe=="boolean"&&We===void 0&&(We=Fe,Fe=void 0);for(const Ze of Re)if(0>Ze.span&&Ze.property===void 0)throw new Error("fields cannot contain unnamed variable-length layout");let qe=-1;try{qe=Re.reduce((Ze,Xe)=>Ze+Xe.getSpan(),0)}catch{}super(qe,Fe),this.fields=Re,this.decodePrefixes=!!We}getSpan(Re,Fe=0){if(0<=this.span)return this.span;let We=0;try{We=this.fields.reduce((qe,Ze)=>{const Xe=Ze.getSpan(Re,Fe);return Fe+=Xe,qe+Xe},0)}catch{throw new RangeError("indeterminate span")}return We}decode(Re,Fe=0){checkUint8Array(Re);const We=this.makeDestinationObject();for(const qe of this.fields)if(qe.property!==void 0&&(We[qe.property]=qe.decode(Re,Fe)),Fe+=qe.getSpan(Re,Fe),this.decodePrefixes&&Re.length===Fe)break;return We}encode(Re,Fe,We=0){const qe=We;let Ze=0,Xe=0;for(const Je of this.fields){let tr=Je.span;if(Xe=0<tr?tr:0,Je.property!==void 0){const er=Re[Je.property];er!==void 0&&(Xe=Je.encode(er,Fe,We),0>tr&&(tr=Je.getSpan(Fe,We)))}Ze=We,We+=tr}return Ze+Xe-qe}fromArray(Re){const Fe=this.makeDestinationObject();for(const We of this.fields)We.property!==void 0&&0<Re.length&&(Fe[We.property]=Re.shift());return Fe}layoutFor(Re){if(typeof Re!="string")throw new TypeError("property must be string");for(const Fe of this.fields)if(Fe.property===Re)return Fe}offsetOf(Re){if(typeof Re!="string")throw new TypeError("property must be string");let Fe=0;for(const We of this.fields){if(We.property===Re)return Fe;0>We.span?Fe=-1:0<=Fe&&(Fe+=We.span)}}}Layout$3.Structure=Structure$1;class UnionDiscriminator$1{constructor(Re){this.property=Re}decode(Re,Fe){throw new Error("UnionDiscriminator is abstract")}encode(Re,Fe,We){throw new Error("UnionDiscriminator is abstract")}}Layout$3.UnionDiscriminator=UnionDiscriminator$1;class UnionLayoutDiscriminator$1 extends UnionDiscriminator$1{constructor(Re,Fe){if(!(Re instanceof ExternalLayout$1&&Re.isCount()))throw new TypeError("layout must be an unsigned integer ExternalLayout");super(Fe||Re.property||"variant"),this.layout=Re}decode(Re,Fe){return this.layout.decode(Re,Fe)}encode(Re,Fe,We){return this.layout.encode(Re,Fe,We)}}Layout$3.UnionLayoutDiscriminator=UnionLayoutDiscriminator$1;class Union$1 extends Layout$2{constructor(Re,Fe,We){let qe;if(Re instanceof UInt$1||Re instanceof UIntBE$1)qe=new UnionLayoutDiscriminator$1(new OffsetLayout$1(Re));else if(Re instanceof ExternalLayout$1&&Re.isCount())qe=new UnionLayoutDiscriminator$1(Re);else if(Re instanceof UnionDiscriminator$1)qe=Re;else throw new TypeError("discr must be a UnionDiscriminator or an unsigned integer layout");if(Fe===void 0&&(Fe=null),!(Fe===null||Fe instanceof Layout$2))throw new TypeError("defaultLayout must be null or a Layout");if(Fe!==null){if(0>Fe.span)throw new Error("defaultLayout must have constant span");Fe.property===void 0&&(Fe=Fe.replicate("content"))}let Ze=-1;Fe&&(Ze=Fe.span,0<=Ze&&(Re instanceof UInt$1||Re instanceof UIntBE$1)&&(Ze+=qe.layout.span)),super(Ze,We),this.discriminator=qe,this.usesPrefixDiscriminator=Re instanceof UInt$1||Re instanceof UIntBE$1,this.defaultLayout=Fe,this.registry={};let Xe=this.defaultGetSourceVariant.bind(this);this.getSourceVariant=function(Je){return Xe(Je)},this.configGetSourceVariant=function(Je){Xe=Je.bind(this)}}getSpan(Re,Fe=0){if(0<=this.span)return this.span;const We=this.getVariant(Re,Fe);if(!We)throw new Error("unable to determine span for unrecognized variant");return We.getSpan(Re,Fe)}defaultGetSourceVariant(Re){if(Object.prototype.hasOwnProperty.call(Re,this.discriminator.property)){if(this.defaultLayout&&this.defaultLayout.property&&Object.prototype.hasOwnProperty.call(Re,this.defaultLayout.property))return;const Fe=this.registry[Re[this.discriminator.property]];if(Fe&&(!Fe.layout||Fe.property&&Object.prototype.hasOwnProperty.call(Re,Fe.property)))return Fe}else for(const Fe in this.registry){const We=this.registry[Fe];if(We.property&&Object.prototype.hasOwnProperty.call(Re,We.property))return We}throw new Error("unable to infer src variant")}decode(Re,Fe=0){let We;const qe=this.discriminator,Ze=qe.decode(Re,Fe),Xe=this.registry[Ze];if(Xe===void 0){const Je=this.defaultLayout;let tr=0;this.usesPrefixDiscriminator&&(tr=qe.layout.span),We=this.makeDestinationObject(),We[qe.property]=Ze,We[Je.property]=Je.decode(Re,Fe+tr)}else We=Xe.decode(Re,Fe);return We}encode(Re,Fe,We=0){const qe=this.getSourceVariant(Re);if(qe===void 0){const Ze=this.discriminator,Xe=this.defaultLayout;let Je=0;return this.usesPrefixDiscriminator&&(Je=Ze.layout.span),Ze.encode(Re[Ze.property],Fe,We),Je+Xe.encode(Re[Xe.property],Fe,We+Je)}return qe.encode(Re,Fe,We)}addVariant(Re,Fe,We){const qe=new VariantLayout$1(this,Re,Fe,We);return this.registry[Re]=qe,qe}getVariant(Re,Fe=0){let We;return Re instanceof Uint8Array?We=this.discriminator.decode(Re,Fe):We=Re,this.registry[We]}}Layout$3.Union=Union$1;class VariantLayout$1 extends Layout$2{constructor(Re,Fe,We,qe){if(!(Re instanceof Union$1))throw new TypeError("union must be a Union");if(!Number.isInteger(Fe)||0>Fe)throw new TypeError("variant must be a (non-negative) integer");if(typeof We=="string"&&qe===void 0&&(qe=We,We=null),We){if(!(We instanceof Layout$2))throw new TypeError("layout must be a Layout");if(Re.defaultLayout!==null&&0<=We.span&&We.span>Re.defaultLayout.span)throw new Error("variant span exceeds span of containing union");if(typeof qe!="string")throw new TypeError("variant must have a String property")}let Ze=Re.span;0>Re.span&&(Ze=We?We.span:0,0<=Ze&&Re.usesPrefixDiscriminator&&(Ze+=Re.discriminator.layout.span)),super(Ze,qe),this.union=Re,this.variant=Fe,this.layout=We||null}getSpan(Re,Fe=0){if(0<=this.span)return this.span;let We=0;this.union.usesPrefixDiscriminator&&(We=this.union.discriminator.layout.span);let qe=0;return this.layout&&(qe=this.layout.getSpan(Re,Fe+We)),We+qe}decode(Re,Fe=0){const We=this.makeDestinationObject();if(this!==this.union.getVariant(Re,Fe))throw new Error("variant mismatch");let qe=0;return this.union.usesPrefixDiscriminator&&(qe=this.union.discriminator.layout.span),this.layout?We[this.property]=this.layout.decode(Re,Fe+qe):this.property?We[this.property]=!0:this.union.usesPrefixDiscriminator&&(We[this.union.discriminator.property]=this.variant),We}encode(Re,Fe,We=0){let qe=0;if(this.union.usesPrefixDiscriminator&&(qe=this.union.discriminator.layout.span),this.layout&&!Object.prototype.hasOwnProperty.call(Re,this.property))throw new TypeError("variant lacks property "+this.property);this.union.discriminator.encode(this.variant,Fe,We);let Ze=qe;if(this.layout&&(this.layout.encode(Re[this.property],Fe,We+qe),Ze+=this.layout.getSpan(Fe,We+qe),0<=this.union.span&&Ze>this.union.span))throw new Error("encoded variant overruns containing union");return Ze}fromArray(Re){if(this.layout)return this.layout.fromArray(Re)}}Layout$3.VariantLayout=VariantLayout$1;function fixBitwiseResult$1(Ke){return 0>Ke&&(Ke+=4294967296),Ke}class BitStructure$1 extends Layout$2{constructor(Re,Fe,We){if(!(Re instanceof UInt$1||Re instanceof UIntBE$1))throw new TypeError("word must be a UInt or UIntBE layout");if(typeof Fe=="string"&&We===void 0&&(We=Fe,Fe=!1),4<Re.span)throw new RangeError("word cannot exceed 32 bits");super(Re.span,We),this.word=Re,this.msb=!!Fe,this.fields=[];let qe=0;this._packedSetValue=function(Ze){return qe=fixBitwiseResult$1(Ze),this},this._packedGetValue=function(){return qe}}decode(Re,Fe=0){const We=this.makeDestinationObject(),qe=this.word.decode(Re,Fe);this._packedSetValue(qe);for(const Ze of this.fields)Ze.property!==void 0&&(We[Ze.property]=Ze.decode(Re));return We}encode(Re,Fe,We=0){const qe=this.word.decode(Fe,We);this._packedSetValue(qe);for(const Ze of this.fields)if(Ze.property!==void 0){const Xe=Re[Ze.property];Xe!==void 0&&Ze.encode(Xe)}return this.word.encode(this._packedGetValue(),Fe,We)}addField(Re,Fe){const We=new BitField$1(this,Re,Fe);return this.fields.push(We),We}addBoolean(Re){const Fe=new Boolean$2(this,Re);return this.fields.push(Fe),Fe}fieldFor(Re){if(typeof Re!="string")throw new TypeError("property must be string");for(const Fe of this.fields)if(Fe.property===Re)return Fe}}Layout$3.BitStructure=BitStructure$1;class BitField$1{constructor(Re,Fe,We){if(!(Re instanceof BitStructure$1))throw new TypeError("container must be a BitStructure");if(!Number.isInteger(Fe)||0>=Fe)throw new TypeError("bits must be positive integer");const qe=8*Re.span,Ze=Re.fields.reduce((Xe,Je)=>Xe+Je.bits,0);if(Fe+Ze>qe)throw new Error("bits too long for span remainder ("+(qe-Ze)+" of "+qe+" remain)");this.container=Re,this.bits=Fe,this.valueMask=(1<<Fe)-1,Fe===32&&(this.valueMask=4294967295),this.start=Ze,this.container.msb&&(this.start=qe-Ze-Fe),this.wordMask=fixBitwiseResult$1(this.valueMask<<this.start),this.property=We}decode(Re,Fe){const We=this.container._packedGetValue();return fixBitwiseResult$1(We&this.wordMask)>>>this.start}encode(Re){if(typeof Re!="number"||!Number.isInteger(Re)||Re!==fixBitwiseResult$1(Re&this.valueMask))throw new TypeError(nameWithProperty$1("BitField.encode",this)+" value must be integer not exceeding "+this.valueMask);const Fe=this.container._packedGetValue(),We=fixBitwiseResult$1(Re<<this.start);this.container._packedSetValue(fixBitwiseResult$1(Fe&~this.wordMask)|We)}}Layout$3.BitField=BitField$1;class Boolean$2 extends BitField$1{constructor(Re,Fe){super(Re,1,Fe)}decode(Re,Fe){return!!super.decode(Re,Fe)}encode(Re){typeof Re=="boolean"&&(Re=+Re),super.encode(Re)}}Layout$3.Boolean=Boolean$2;class Blob$2 extends Layout$2{constructor(Re,Fe){if(!(Re instanceof ExternalLayout$1&&Re.isCount()||Number.isInteger(Re)&&0<=Re))throw new TypeError("length must be positive integer or an unsigned integer ExternalLayout");let We=-1;Re instanceof ExternalLayout$1||(We=Re),super(We,Fe),this.length=Re}getSpan(Re,Fe){let We=this.span;return 0>We&&(We=this.length.decode(Re,Fe)),We}decode(Re,Fe=0){let We=this.span;return 0>We&&(We=this.length.decode(Re,Fe)),uint8ArrayToBuffer(Re).slice(Fe,Fe+We)}encode(Re,Fe,We){let qe=this.length;if(this.length instanceof ExternalLayout$1&&(qe=Re.length),!(Re instanceof Uint8Array&&qe===Re.length))throw new TypeError(nameWithProperty$1("Blob.encode",this)+" requires (length "+qe+") Uint8Array as src");if(We+qe>Fe.length)throw new RangeError("encoding overruns Uint8Array");const Ze=uint8ArrayToBuffer(Re);return uint8ArrayToBuffer(Fe).write(Ze.toString("hex"),We,qe,"hex"),this.length instanceof ExternalLayout$1&&this.length.encode(qe,Fe,We),qe}}Layout$3.Blob=Blob$2;class CString$1 extends Layout$2{constructor(Re){super(-1,Re)}getSpan(Re,Fe=0){checkUint8Array(Re);let We=Fe;for(;We<Re.length&&Re[We]!==0;)We+=1;return 1+We-Fe}decode(Re,Fe=0){const We=this.getSpan(Re,Fe);return uint8ArrayToBuffer(Re).slice(Fe,Fe+We-1).toString("utf-8")}encode(Re,Fe,We=0){typeof Re!="string"&&(Re=String(Re));const qe=buffer_1.Buffer.from(Re,"utf8"),Ze=qe.length;if(We+Ze>Fe.length)throw new RangeError("encoding overruns Buffer");const Xe=uint8ArrayToBuffer(Fe);return qe.copy(Xe,We),Xe[We+Ze]=0,Ze+1}}Layout$3.CString=CString$1;class UTF8$1 extends Layout$2{constructor(Re,Fe){if(typeof Re=="string"&&Fe===void 0&&(Fe=Re,Re=void 0),Re===void 0)Re=-1;else if(!Number.isInteger(Re))throw new TypeError("maxSpan must be an integer");super(-1,Fe),this.maxSpan=Re}getSpan(Re,Fe=0){return checkUint8Array(Re),Re.length-Fe}decode(Re,Fe=0){const We=this.getSpan(Re,Fe);if(0<=this.maxSpan&&this.maxSpan<We)throw new RangeError("text length exceeds maxSpan");return uint8ArrayToBuffer(Re).slice(Fe,Fe+We).toString("utf-8")}encode(Re,Fe,We=0){typeof Re!="string"&&(Re=String(Re));const qe=buffer_1.Buffer.from(Re,"utf8"),Ze=qe.length;if(0<=this.maxSpan&&this.maxSpan<Ze)throw new RangeError("text length exceeds maxSpan");if(We+Ze>Fe.length)throw new RangeError("encoding overruns Buffer");return qe.copy(uint8ArrayToBuffer(Fe),We),Ze}}Layout$3.UTF8=UTF8$1;class Constant$1 extends Layout$2{constructor(Re,Fe){super(0,Fe),this.value=Re}decode(Re,Fe){return this.value}encode(Re,Fe,We){return 0}}Layout$3.Constant=Constant$1;Layout$3.greedy=(Ke,Re)=>new GreedyCount$1(Ke,Re);var offset=Layout$3.offset=(Ke,Re,Fe)=>new OffsetLayout$1(Ke,Re,Fe),u8=Layout$3.u8=Ke=>new UInt$1(1,Ke),u16=Layout$3.u16=Ke=>new UInt$1(2,Ke);Layout$3.u24=Ke=>new UInt$1(3,Ke);var u32=Layout$3.u32=Ke=>new UInt$1(4,Ke);Layout$3.u40=Ke=>new UInt$1(5,Ke);Layout$3.u48=Ke=>new UInt$1(6,Ke);var nu64=Layout$3.nu64=Ke=>new NearUInt64$1(Ke);Layout$3.u16be=Ke=>new UIntBE$1(2,Ke);Layout$3.u24be=Ke=>new UIntBE$1(3,Ke);Layout$3.u32be=Ke=>new UIntBE$1(4,Ke);Layout$3.u40be=Ke=>new UIntBE$1(5,Ke);Layout$3.u48be=Ke=>new UIntBE$1(6,Ke);Layout$3.nu64be=Ke=>new NearUInt64BE$1(Ke);Layout$3.s8=Ke=>new Int$1(1,Ke);Layout$3.s16=Ke=>new Int$1(2,Ke);Layout$3.s24=Ke=>new Int$1(3,Ke);Layout$3.s32=Ke=>new Int$1(4,Ke);Layout$3.s40=Ke=>new Int$1(5,Ke);Layout$3.s48=Ke=>new Int$1(6,Ke);var ns64=Layout$3.ns64=Ke=>new NearInt64$1(Ke);Layout$3.s16be=Ke=>new IntBE$1(2,Ke);Layout$3.s24be=Ke=>new IntBE$1(3,Ke);Layout$3.s32be=Ke=>new IntBE$1(4,Ke);Layout$3.s40be=Ke=>new IntBE$1(5,Ke);Layout$3.s48be=Ke=>new IntBE$1(6,Ke);Layout$3.ns64be=Ke=>new NearInt64BE$1(Ke);Layout$3.f32=Ke=>new Float$1(Ke);Layout$3.f32be=Ke=>new FloatBE$1(Ke);Layout$3.f64=Ke=>new Double$1(Ke);Layout$3.f64be=Ke=>new DoubleBE$1(Ke);var struct=Layout$3.struct=(Ke,Re,Fe)=>new Structure$1(Ke,Re,Fe);Layout$3.bits=(Ke,Re,Fe)=>new BitStructure$1(Ke,Re,Fe);var seq=Layout$3.seq=(Ke,Re,Fe)=>new Sequence$1(Ke,Re,Fe);Layout$3.union=(Ke,Re,Fe)=>new Union$1(Ke,Re,Fe);Layout$3.unionLayoutDiscriminator=(Ke,Re)=>new UnionLayoutDiscriminator$1(Ke,Re);var blob=Layout$3.blob=(Ke,Re)=>new Blob$2(Ke,Re);Layout$3.cstr=Ke=>new CString$1(Ke);Layout$3.utf8=(Ke,Re)=>new UTF8$1(Ke,Re);Layout$3.constant=(Ke,Re)=>new Constant$1(Ke,Re);var browser$1={};Object.defineProperty(browser$1,"__esModule",{value:!0});function toBigIntLE(Ke){{const Re=Buffer.from(Ke);Re.reverse();const Fe=Re.toString("hex");return Fe.length===0?BigInt(0):BigInt(`0x${Fe}`)}}var toBigIntLE_1=browser$1.toBigIntLE=toBigIntLE;function toBigIntBE(Ke){{const Re=Ke.toString("hex");return Re.length===0?BigInt(0):BigInt(`0x${Re}`)}}browser$1.toBigIntBE=toBigIntBE;function toBufferLE(Ke,Re){{const Fe=Ke.toString(16),We=Buffer.from(Fe.padStart(Re*2,"0").slice(0,Re*2),"hex");return We.reverse(),We}}var toBufferLE_1=browser$1.toBufferLE=toBufferLE;function toBufferBE(Ke,Re){{const Fe=Ke.toString(16);return Buffer.from(Fe.padStart(Re*2,"0").slice(0,Re*2),"hex")}}browser$1.toBufferBE=toBufferBE;class StructError extends TypeError{constructor(Re,Fe){let We;const{message:qe,...Ze}=Re,{path:Xe}=Re,Je=Xe.length===0?qe:"At path: "+Xe.join(".")+" -- "+qe;super(Je),Object.assign(this,Ze),this.name=this.constructor.name,this.failures=()=>{var tr;return(tr=We)!=null?tr:We=[Re,...Fe()]}}}function isIterable(Ke){return isObject(Ke)&&typeof Ke[Symbol.iterator]=="function"}function isObject(Ke){return typeof Ke=="object"&&Ke!=null}function print(Ke){return typeof Ke=="string"?JSON.stringify(Ke):""+Ke}function shiftIterator(Ke){const{done:Re,value:Fe}=Ke.next();return Re?void 0:Fe}function toFailure(Ke,Re,Fe,We){if(Ke===!0)return;Ke===!1?Ke={}:typeof Ke=="string"&&(Ke={message:Ke});const{path:qe,branch:Ze}=Re,{type:Xe}=Fe,{refinement:Je,message:tr="Expected a value of type `"+Xe+"`"+(Je?" with refinement `"+Je+"`":"")+", but received: `"+print(We)+"`"}=Ke;return{value:We,type:Xe,refinement:Je,key:qe[qe.length-1],path:qe,branch:Ze,...Ke,message:tr}}function*toFailures(Ke,Re,Fe,We){isIterable(Ke)||(Ke=[Ke]);for(const qe of Ke){const Ze=toFailure(qe,Re,Fe,We);Ze&&(yield Ze)}}function*run(Ke,Re,Fe={}){const{path:We=[],branch:qe=[Ke],coerce:Ze=!1,mask:Xe=!1}=Fe,Je={path:We,branch:qe};if(Ze&&(Ke=Re.coercer(Ke,Je),Xe&&Re.type!=="type"&&isObject(Re.schema)&&isObject(Ke)&&!Array.isArray(Ke)))for(const er in Ke)Re.schema[er]===void 0&&delete Ke[er];let tr=!0;for(const er of Re.validator(Ke,Je))tr=!1,yield[er,void 0];for(let[er,ir,lr]of Re.entries(Ke,Je)){const fr=run(ir,lr,{path:er===void 0?We:[...We,er],branch:er===void 0?qe:[...qe,ir],coerce:Ze,mask:Xe});for(const ur of fr)ur[0]?(tr=!1,yield[ur[0],void 0]):Ze&&(ir=ur[1],er===void 0?Ke=ir:Ke instanceof Map?Ke.set(er,ir):Ke instanceof Set?Ke.add(ir):isObject(Ke)&&(Ke[er]=ir))}if(tr)for(const er of Re.refiner(Ke,Je))tr=!1,yield[er,void 0];tr&&(yield[void 0,Ke])}class Struct$1{constructor(Re){const{type:Fe,schema:We,validator:qe,refiner:Ze,coercer:Xe=tr=>tr,entries:Je=function*(){}}=Re;this.type=Fe,this.schema=We,this.entries=Je,this.coercer=Xe,qe?this.validator=(tr,er)=>{const ir=qe(tr,er);return toFailures(ir,er,this,tr)}:this.validator=()=>[],Ze?this.refiner=(tr,er)=>{const ir=Ze(tr,er);return toFailures(ir,er,this,tr)}:this.refiner=()=>[]}assert(Re){return assert$1(Re,this)}create(Re){return create(Re,this)}is(Re){return is(Re,this)}mask(Re){return mask(Re,this)}validate(Re,Fe={}){return validate$1(Re,this,Fe)}}function assert$1(Ke,Re){const Fe=validate$1(Ke,Re);if(Fe[0])throw Fe[0]}function create(Ke,Re){const Fe=validate$1(Ke,Re,{coerce:!0});if(Fe[0])throw Fe[0];return Fe[1]}function mask(Ke,Re){const Fe=validate$1(Ke,Re,{coerce:!0,mask:!0});if(Fe[0])throw Fe[0];return Fe[1]}function is(Ke,Re){return!validate$1(Ke,Re)[0]}function validate$1(Ke,Re,Fe={}){const We=run(Ke,Re,Fe),qe=shiftIterator(We);return qe[0]?[new StructError(qe[0],function*(){for(const Xe of We)Xe[0]&&(yield Xe[0])}),void 0]:[void 0,qe[1]]}function define(Ke,Re){return new Struct$1({type:Ke,schema:null,validator:Re})}function any(){return define("any",()=>!0)}function array(Ke){return new Struct$1({type:"array",schema:Ke,*entries(Re){if(Ke&&Array.isArray(Re))for(const[Fe,We]of Re.entries())yield[Fe,We,Ke]},coercer(Re){return Array.isArray(Re)?Re.slice():Re},validator(Re){return Array.isArray(Re)||"Expected an array value, but received: "+print(Re)}})}function boolean(){return define("boolean",Ke=>typeof Ke=="boolean")}function instance(Ke){return define("instance",Re=>Re instanceof Ke||"Expected a `"+Ke.name+"` instance, but received: "+print(Re))}function literal(Ke){const Re=print(Ke),Fe=typeof Ke;return new Struct$1({type:"literal",schema:Fe==="string"||Fe==="number"||Fe==="boolean"?Ke:null,validator(We){return We===Ke||"Expected the literal `"+Re+"`, but received: "+print(We)}})}function never(){return define("never",()=>!1)}function nullable(Ke){return new Struct$1({...Ke,validator:(Re,Fe)=>Re===null||Ke.validator(Re,Fe),refiner:(Re,Fe)=>Re===null||Ke.refiner(Re,Fe)})}function number(){return define("number",Ke=>typeof Ke=="number"&&!isNaN(Ke)||"Expected a number, but received: "+print(Ke))}function optional(Ke){return new Struct$1({...Ke,validator:(Re,Fe)=>Re===void 0||Ke.validator(Re,Fe),refiner:(Re,Fe)=>Re===void 0||Ke.refiner(Re,Fe)})}function record(Ke,Re){return new Struct$1({type:"record",schema:null,*entries(Fe){if(isObject(Fe))for(const We in Fe){const qe=Fe[We];yield[We,We,Ke],yield[We,qe,Re]}},validator(Fe){return isObject(Fe)||"Expected an object, but received: "+print(Fe)}})}function string(){return define("string",Ke=>typeof Ke=="string"||"Expected a string, but received: "+print(Ke))}function tuple(Ke){const Re=never();return new Struct$1({type:"tuple",schema:null,*entries(Fe){if(Array.isArray(Fe)){const We=Math.max(Ke.length,Fe.length);for(let qe=0;qe<We;qe++)yield[qe,Fe[qe],Ke[qe]||Re]}},validator(Fe){return Array.isArray(Fe)||"Expected an array, but received: "+print(Fe)}})}function type(Ke){const Re=Object.keys(Ke);return new Struct$1({type:"type",schema:Ke,*entries(Fe){if(isObject(Fe))for(const We of Re)yield[We,Fe[We],Ke[We]]},validator(Fe){return isObject(Fe)||"Expected an object, but received: "+print(Fe)}})}function union(Ke){const Re=Ke.map(Fe=>Fe.type).join(" | ");return new Struct$1({type:"union",schema:null,validator(Fe,We){const qe=[];for(const Ze of Ke){const[...Xe]=run(Fe,Ze,We),[Je]=Xe;if(Je[0])for(const[tr]of Xe)tr&&qe.push(tr);else return[]}return["Expected the value to satisfy a union of `"+Re+"`, but received: "+print(Fe),...qe]}})}function unknown(){return define("unknown",()=>!0)}function coerce(Ke,Re,Fe){return new Struct$1({...Ke,coercer:(We,qe)=>is(We,Re)?Ke.coercer(Fe(We,qe),qe):Ke.coercer(We,qe)})}var index_browser={},interopRequireDefault={exports:{}};(function(Ke){function Re(Fe){return Fe&&Fe.__esModule?Fe:{default:Fe}}Ke.exports=Re,Ke.exports.__esModule=!0,Ke.exports.default=Ke.exports})(interopRequireDefault);var createClass={exports:{}},hasRequiredCreateClass;function requireCreateClass(){return hasRequiredCreateClass||(hasRequiredCreateClass=1,function(Ke){function Re(We,qe){for(var Ze=0;Ze<qe.length;Ze++){var Xe=qe[Ze];Xe.enumerable=Xe.enumerable||!1,Xe.configurable=!0,"value"in Xe&&(Xe.writable=!0),Object.defineProperty(We,Xe.key,Xe)}}function Fe(We,qe,Ze){return qe&&Re(We.prototype,qe),Ze&&Re(We,Ze),Object.defineProperty(We,"prototype",{writable:!1}),We}Ke.exports=Fe,Ke.exports.__esModule=!0,Ke.exports.default=Ke.exports}(createClass)),createClass.exports}var classCallCheck={exports:{}},hasRequiredClassCallCheck;function requireClassCallCheck(){return hasRequiredClassCallCheck||(hasRequiredClassCallCheck=1,function(Ke){function Re(Fe,We){if(!(Fe instanceof We))throw new TypeError("Cannot call a class as a function")}Ke.exports=Re,Ke.exports.__esModule=!0,Ke.exports.default=Ke.exports}(classCallCheck)),classCallCheck.exports}var inherits={exports:{}},setPrototypeOf={exports:{}},hasRequiredSetPrototypeOf;function requireSetPrototypeOf(){return hasRequiredSetPrototypeOf||(hasRequiredSetPrototypeOf=1,function(Ke){function Re(Fe,We){return Ke.exports=Re=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(Ze,Xe){return Ze.__proto__=Xe,Ze},Ke.exports.__esModule=!0,Ke.exports.default=Ke.exports,Re(Fe,We)}Ke.exports=Re,Ke.exports.__esModule=!0,Ke.exports.default=Ke.exports}(setPrototypeOf)),setPrototypeOf.exports}var hasRequiredInherits;function requireInherits(){return hasRequiredInherits||(hasRequiredInherits=1,function(Ke){var Re=requireSetPrototypeOf();function Fe(We,qe){if(typeof qe!="function"&&qe!==null)throw new TypeError("Super expression must either be null or a function");We.prototype=Object.create(qe&&qe.prototype,{constructor:{value:We,writable:!0,configurable:!0}}),Object.defineProperty(We,"prototype",{writable:!1}),qe&&Re(We,qe)}Ke.exports=Fe,Ke.exports.__esModule=!0,Ke.exports.default=Ke.exports}(inherits)),inherits.exports}var possibleConstructorReturn={exports:{}},_typeof={exports:{}},hasRequired_typeof;function require_typeof(){return hasRequired_typeof||(hasRequired_typeof=1,function(Ke){function Re(Fe){return Ke.exports=Re=typeof Symbol=="function"&&typeof Symbol.iterator=="symbol"?function(We){return typeof We}:function(We){return We&&typeof Symbol=="function"&&We.constructor===Symbol&&We!==Symbol.prototype?"symbol":typeof We},Ke.exports.__esModule=!0,Ke.exports.default=Ke.exports,Re(Fe)}Ke.exports=Re,Ke.exports.__esModule=!0,Ke.exports.default=Ke.exports}(_typeof)),_typeof.exports}var assertThisInitialized={exports:{}},hasRequiredAssertThisInitialized;function requireAssertThisInitialized(){return hasRequiredAssertThisInitialized||(hasRequiredAssertThisInitialized=1,function(Ke){function Re(Fe){if(Fe===void 0)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return Fe}Ke.exports=Re,Ke.exports.__esModule=!0,Ke.exports.default=Ke.exports}(assertThisInitialized)),assertThisInitialized.exports}var hasRequiredPossibleConstructorReturn;function requirePossibleConstructorReturn(){return hasRequiredPossibleConstructorReturn||(hasRequiredPossibleConstructorReturn=1,function(Ke){var Re=require_typeof().default,Fe=requireAssertThisInitialized();function We(qe,Ze){if(Ze&&(Re(Ze)==="object"||typeof Ze=="function"))return Ze;if(Ze!==void 0)throw new TypeError("Derived constructors may only return object or undefined");return Fe(qe)}Ke.exports=We,Ke.exports.__esModule=!0,Ke.exports.default=Ke.exports}(possibleConstructorReturn)),possibleConstructorReturn.exports}var getPrototypeOf={exports:{}},hasRequiredGetPrototypeOf;function requireGetPrototypeOf(){return hasRequiredGetPrototypeOf||(hasRequiredGetPrototypeOf=1,function(Ke){function Re(Fe){return Ke.exports=Re=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(qe){return qe.__proto__||Object.getPrototypeOf(qe)},Ke.exports.__esModule=!0,Ke.exports.default=Ke.exports,Re(Fe)}Ke.exports=Re,Ke.exports.__esModule=!0,Ke.exports.default=Ke.exports}(getPrototypeOf)),getPrototypeOf.exports}var websocket_browser={},eventemitter3={exports:{}};(function(Ke){var Re=Object.prototype.hasOwnProperty,Fe="~";function We(){}Object.create&&(We.prototype=Object.create(null),new We().__proto__||(Fe=!1));function qe(tr,er,ir){this.fn=tr,this.context=er,this.once=ir||!1}function Ze(tr,er,ir,lr,fr){if(typeof ir!="function")throw new TypeError("The listener must be a function");var ur=new qe(ir,lr||tr,fr),mr=Fe?Fe+er:er;return tr._events[mr]?tr._events[mr].fn?tr._events[mr]=[tr._events[mr],ur]:tr._events[mr].push(ur):(tr._events[mr]=ur,tr._eventsCount++),tr}function Xe(tr,er){--tr._eventsCount===0?tr._events=new We:delete tr._events[er]}function Je(){this._events=new We,this._eventsCount=0}Je.prototype.eventNames=function(){var er=[],ir,lr;if(this._eventsCount===0)return er;for(lr in ir=this._events)Re.call(ir,lr)&&er.push(Fe?lr.slice(1):lr);return Object.getOwnPropertySymbols?er.concat(Object.getOwnPropertySymbols(ir)):er},Je.prototype.listeners=function(er){var ir=Fe?Fe+er:er,lr=this._events[ir];if(!lr)return[];if(lr.fn)return[lr.fn];for(var fr=0,ur=lr.length,mr=new Array(ur);fr<ur;fr++)mr[fr]=lr[fr].fn;return mr},Je.prototype.listenerCount=function(er){var ir=Fe?Fe+er:er,lr=this._events[ir];return lr?lr.fn?1:lr.length:0},Je.prototype.emit=function(er,ir,lr,fr,ur,mr){var br=Fe?Fe+er:er;if(!this._events[br])return!1;var wr=this._events[br],Sr=arguments.length,kr,Er;if(wr.fn){switch(wr.once&&this.removeListener(er,wr.fn,void 0,!0),Sr){case 1:return wr.fn.call(wr.context),!0;case 2:return wr.fn.call(wr.context,ir),!0;case 3:return wr.fn.call(wr.context,ir,lr),!0;case 4:return wr.fn.call(wr.context,ir,lr,fr),!0;case 5:return wr.fn.call(wr.context,ir,lr,fr,ur),!0;case 6:return wr.fn.call(wr.context,ir,lr,fr,ur,mr),!0}for(Er=1,kr=new Array(Sr-1);Er<Sr;Er++)kr[Er-1]=arguments[Er];wr.fn.apply(wr.context,kr)}else{var Ir=wr.length,Rr;for(Er=0;Er<Ir;Er++)switch(wr[Er].once&&this.removeListener(er,wr[Er].fn,void 0,!0),Sr){case 1:wr[Er].fn.call(wr[Er].context);break;case 2:wr[Er].fn.call(wr[Er].context,ir);break;case 3:wr[Er].fn.call(wr[Er].context,ir,lr);break;case 4:wr[Er].fn.call(wr[Er].context,ir,lr,fr);break;default:if(!kr)for(Rr=1,kr=new Array(Sr-1);Rr<Sr;Rr++)kr[Rr-1]=arguments[Rr];wr[Er].fn.apply(wr[Er].context,kr)}}return!0},Je.prototype.on=function(er,ir,lr){return Ze(this,er,ir,lr,!1)},Je.prototype.once=function(er,ir,lr){return Ze(this,er,ir,lr,!0)},Je.prototype.removeListener=function(er,ir,lr,fr){var ur=Fe?Fe+er:er;if(!this._events[ur])return this;if(!ir)return Xe(this,ur),this;var mr=this._events[ur];if(mr.fn)mr.fn===ir&&(!fr||mr.once)&&(!lr||mr.context===lr)&&Xe(this,ur);else{for(var br=0,wr=[],Sr=mr.length;br<Sr;br++)(mr[br].fn!==ir||fr&&!mr[br].once||lr&&mr[br].context!==lr)&&wr.push(mr[br]);wr.length?this._events[ur]=wr.length===1?wr[0]:wr:Xe(this,ur)}return this},Je.prototype.removeAllListeners=function(er){var ir;return er?(ir=Fe?Fe+er:er,this._events[ir]&&Xe(this,ir)):(this._events=new We,this._eventsCount=0),this},Je.prototype.off=Je.prototype.removeListener,Je.prototype.addListener=Je.prototype.on,Je.prefixed=Fe,Je.EventEmitter=Je,Ke.exports=Je})(eventemitter3);const y=eventemitter3.exports;var hasRequiredWebsocket_browser;function requireWebsocket_browser(){return hasRequiredWebsocket_browser||(hasRequiredWebsocket_browser=1,function(Ke){var Re=interopRequireDefault.exports;Object.defineProperty(Ke,"__esModule",{value:!0}),Ke.default=lr;var Fe=Re(requireClassCallCheck()),We=Re(requireCreateClass()),qe=Re(requireInherits()),Ze=Re(requirePossibleConstructorReturn()),Xe=Re(requireGetPrototypeOf()),Je=eventemitter3.exports;function tr(fr){var ur=er();return function(){var br=(0,Xe.default)(fr),wr;if(ur){var Sr=(0,Xe.default)(this).constructor;wr=Reflect.construct(br,arguments,Sr)}else wr=br.apply(this,arguments);return(0,Ze.default)(this,wr)}}function er(){if(typeof Reflect>"u"||!Reflect.construct||Reflect.construct.sham)return!1;if(typeof Proxy=="function")return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],function(){})),!0}catch{return!1}}var ir=function(fr){(0,qe.default)(mr,fr);var ur=tr(mr);function mr(br,wr,Sr){var kr;return(0,Fe.default)(this,mr),kr=ur.call(this),kr.socket=new window.WebSocket(br,Sr),kr.socket.onopen=function(){return kr.emit("open")},kr.socket.onmessage=function(Er){return kr.emit("message",Er.data)},kr.socket.onerror=function(Er){return kr.emit("error",Er)},kr.socket.onclose=function(Er){kr.emit("close",Er.code,Er.reason)},kr}return(0,We.default)(mr,[{key:"send",value:function(wr,Sr,kr){var Er=kr||Sr;try{this.socket.send(wr),Er()}catch(Ir){Er(Ir)}}},{key:"close",value:function(wr,Sr){this.socket.close(wr,Sr)}},{key:"addEventListener",value:function(wr,Sr,kr){this.socket.addEventListener(wr,Sr,kr)}}]),mr}(Je.EventEmitter);function lr(fr,ur){return new ir(fr,ur)}}(websocket_browser)),websocket_browser}var client={},regeneratorRuntime$1={exports:{}},hasRequiredRegeneratorRuntime;function requireRegeneratorRuntime(){return hasRequiredRegeneratorRuntime||(hasRequiredRegeneratorRuntime=1,function(Ke){var Re=require_typeof().default;function Fe(){Ke.exports=Fe=function(){return We},Ke.exports.__esModule=!0,Ke.exports.default=Ke.exports;var We={},qe=Object.prototype,Ze=qe.hasOwnProperty,Xe=typeof Symbol=="function"?Symbol:{},Je=Xe.iterator||"@@iterator",tr=Xe.asyncIterator||"@@asyncIterator",er=Xe.toStringTag||"@@toStringTag";function ir(ar,Dt,sr){return Object.defineProperty(ar,Dt,{value:sr,enumerable:!0,configurable:!0,writable:!0}),ar[Dt]}try{ir({},"")}catch{ir=function(sr,cr,yr){return sr[cr]=yr}}function lr(ar,Dt,sr,cr){var yr=Dt&&Dt.prototype instanceof mr?Dt:mr,_r=Object.create(yr.prototype),xr=new Cr(cr||[]);return _r._invoke=function(Ar,pr,rr){var hr="suspendedStart";return function($r,Lr){if(hr==="executing")throw new Error("Generator is already running");if(hr==="completed"){if($r==="throw")throw Lr;return Mr()}for(rr.method=$r,rr.arg=Lr;;){var Ur=rr.delegate;if(Ur){var Wr=Br(Ur,rr);if(Wr){if(Wr===ur)continue;return Wr}}if(rr.method==="next")rr.sent=rr._sent=rr.arg;else if(rr.method==="throw"){if(hr==="suspendedStart")throw hr="completed",rr.arg;rr.dispatchException(rr.arg)}else rr.method==="return"&&rr.abrupt("return",rr.arg);hr="executing";var Fr=fr(Ar,pr,rr);if(Fr.type==="normal"){if(hr=rr.done?"completed":"suspendedYield",Fr.arg===ur)continue;return{value:Fr.arg,done:rr.done}}Fr.type==="throw"&&(hr="completed",rr.method="throw",rr.arg=Fr.arg)}}}(ar,sr,xr),_r}function fr(ar,Dt,sr){try{return{type:"normal",arg:ar.call(Dt,sr)}}catch(cr){return{type:"throw",arg:cr}}}We.wrap=lr;var ur={};function mr(){}function br(){}function wr(){}var Sr={};ir(Sr,Je,function(){return this});var kr=Object.getPrototypeOf,Er=kr&&kr(kr(Tr([])));Er&&Er!==qe&&Ze.call(Er,Je)&&(Sr=Er);var Ir=wr.prototype=mr.prototype=Object.create(Sr);function Rr(ar){["next","throw","return"].forEach(function(Dt){ir(ar,Dt,function(sr){return this._invoke(Dt,sr)})})}function Pr(ar,Dt){function sr(yr,_r,xr,Ar){var pr=fr(ar[yr],ar,_r);if(pr.type!=="throw"){var rr=pr.arg,hr=rr.value;return hr&&Re(hr)=="object"&&Ze.call(hr,"__await")?Dt.resolve(hr.__await).then(function($r){sr("next",$r,xr,Ar)},function($r){sr("throw",$r,xr,Ar)}):Dt.resolve(hr).then(function($r){rr.value=$r,xr(rr)},function($r){return sr("throw",$r,xr,Ar)})}Ar(pr.arg)}var cr;this._invoke=function(yr,_r){function xr(){return new Dt(function(Ar,pr){sr(yr,_r,Ar,pr)})}return cr=cr?cr.then(xr,xr):xr()}}function Br(ar,Dt){var sr=ar.iterator[Dt.method];if(sr===void 0){if(Dt.delegate=null,Dt.method==="throw"){if(ar.iterator.return&&(Dt.method="return",Dt.arg=void 0,Br(ar,Dt),Dt.method==="throw"))return ur;Dt.method="throw",Dt.arg=new TypeError("The iterator does not provide a 'throw' method")}return ur}var cr=fr(sr,ar.iterator,Dt.arg);if(cr.type==="throw")return Dt.method="throw",Dt.arg=cr.arg,Dt.delegate=null,ur;var yr=cr.arg;return yr?yr.done?(Dt[ar.resultName]=yr.value,Dt.next=ar.nextLoc,Dt.method!=="return"&&(Dt.method="next",Dt.arg=void 0),Dt.delegate=null,ur):yr:(Dt.method="throw",Dt.arg=new TypeError("iterator result is not an object"),Dt.delegate=null,ur)}function Or(ar){var Dt={tryLoc:ar[0]};1 in ar&&(Dt.catchLoc=ar[1]),2 in ar&&(Dt.finallyLoc=ar[2],Dt.afterLoc=ar[3]),this.tryEntries.push(Dt)}function Nr(ar){var Dt=ar.completion||{};Dt.type="normal",delete Dt.arg,ar.completion=Dt}function Cr(ar){this.tryEntries=[{tryLoc:"root"}],ar.forEach(Or,this),this.reset(!0)}function Tr(ar){if(ar){var Dt=ar[Je];if(Dt)return Dt.call(ar);if(typeof ar.next=="function")return ar;if(!isNaN(ar.length)){var sr=-1,cr=function yr(){for(;++sr<ar.length;)if(Ze.call(ar,sr))return yr.value=ar[sr],yr.done=!1,yr;return yr.value=void 0,yr.done=!0,yr};return cr.next=cr}}return{next:Mr}}function Mr(){return{value:void 0,done:!0}}return br.prototype=wr,ir(Ir,"constructor",wr),ir(wr,"constructor",br),br.displayName=ir(wr,er,"GeneratorFunction"),We.isGeneratorFunction=function(ar){var Dt=typeof ar=="function"&&ar.constructor;return!!Dt&&(Dt===br||(Dt.displayName||Dt.name)==="GeneratorFunction")},We.mark=function(ar){return Object.setPrototypeOf?Object.setPrototypeOf(ar,wr):(ar.__proto__=wr,ir(ar,er,"GeneratorFunction")),ar.prototype=Object.create(Ir),ar},We.awrap=function(ar){return{__await:ar}},Rr(Pr.prototype),ir(Pr.prototype,tr,function(){return this}),We.AsyncIterator=Pr,We.async=function(ar,Dt,sr,cr,yr){yr===void 0&&(yr=Promise);var _r=new Pr(lr(ar,Dt,sr,cr),yr);return We.isGeneratorFunction(Dt)?_r:_r.next().then(function(xr){return xr.done?xr.value:_r.next()})},Rr(Ir),ir(Ir,er,"Generator"),ir(Ir,Je,function(){return this}),ir(Ir,"toString",function(){return"[object Generator]"}),We.keys=function(ar){var Dt=[];for(var sr in ar)Dt.push(sr);return Dt.reverse(),function cr(){for(;Dt.length;){var yr=Dt.pop();if(yr in ar)return cr.value=yr,cr.done=!1,cr}return cr.done=!0,cr}},We.values=Tr,Cr.prototype={constructor:Cr,reset:function(Dt){if(this.prev=0,this.next=0,this.sent=this._sent=void 0,this.done=!1,this.delegate=null,this.method="next",this.arg=void 0,this.tryEntries.forEach(Nr),!Dt)for(var sr in this)sr.charAt(0)==="t"&&Ze.call(this,sr)&&!isNaN(+sr.slice(1))&&(this[sr]=void 0)},stop:function(){this.done=!0;var Dt=this.tryEntries[0].completion;if(Dt.type==="throw")throw Dt.arg;return this.rval},dispatchException:function(Dt){if(this.done)throw Dt;var sr=this;function cr(rr,hr){return xr.type="throw",xr.arg=Dt,sr.next=rr,hr&&(sr.method="next",sr.arg=void 0),!!hr}for(var yr=this.tryEntries.length-1;yr>=0;--yr){var _r=this.tryEntries[yr],xr=_r.completion;if(_r.tryLoc==="root")return cr("end");if(_r.tryLoc<=this.prev){var Ar=Ze.call(_r,"catchLoc"),pr=Ze.call(_r,"finallyLoc");if(Ar&&pr){if(this.prev<_r.catchLoc)return cr(_r.catchLoc,!0);if(this.prev<_r.finallyLoc)return cr(_r.finallyLoc)}else if(Ar){if(this.prev<_r.catchLoc)return cr(_r.catchLoc,!0)}else{if(!pr)throw new Error("try statement without catch or finally");if(this.prev<_r.finallyLoc)return cr(_r.finallyLoc)}}}},abrupt:function(Dt,sr){for(var cr=this.tryEntries.length-1;cr>=0;--cr){var yr=this.tryEntries[cr];if(yr.tryLoc<=this.prev&&Ze.call(yr,"finallyLoc")&&this.prev<yr.finallyLoc){var _r=yr;break}}_r&&(Dt==="break"||Dt==="continue")&&_r.tryLoc<=sr&&sr<=_r.finallyLoc&&(_r=null);var xr=_r?_r.completion:{};return xr.type=Dt,xr.arg=sr,_r?(this.method="next",this.next=_r.finallyLoc,ur):this.complete(xr)},complete:function(Dt,sr){if(Dt.type==="throw")throw Dt.arg;return Dt.type==="break"||Dt.type==="continue"?this.next=Dt.arg:Dt.type==="return"?(this.rval=this.arg=Dt.arg,this.method="return",this.next="end"):Dt.type==="normal"&&sr&&(this.next=sr),ur},finish:function(Dt){for(var sr=this.tryEntries.length-1;sr>=0;--sr){var cr=this.tryEntries[sr];if(cr.finallyLoc===Dt)return this.complete(cr.completion,cr.afterLoc),Nr(cr),ur}},catch:function(Dt){for(var sr=this.tryEntries.length-1;sr>=0;--sr){var cr=this.tryEntries[sr];if(cr.tryLoc===Dt){var yr=cr.completion;if(yr.type==="throw"){var _r=yr.arg;Nr(cr)}return _r}}throw new Error("illegal catch attempt")},delegateYield:function(Dt,sr,cr){return this.delegate={iterator:Tr(Dt),resultName:sr,nextLoc:cr},this.method==="next"&&(this.arg=void 0),ur}},We}Ke.exports=Fe,Ke.exports.__esModule=!0,Ke.exports.default=Ke.exports}(regeneratorRuntime$1)),regeneratorRuntime$1.exports}var regenerator,hasRequiredRegenerator;function requireRegenerator(){if(hasRequiredRegenerator)return regenerator;hasRequiredRegenerator=1;var Ke=requireRegeneratorRuntime()();regenerator=Ke;try{regeneratorRuntime=Ke}catch{typeof globalThis=="object"?globalThis.regeneratorRuntime=Ke:Function("r","regeneratorRuntime = r")(Ke)}return regenerator}var asyncToGenerator={exports:{}},hasRequiredAsyncToGenerator;function requireAsyncToGenerator(){return hasRequiredAsyncToGenerator||(hasRequiredAsyncToGenerator=1,function(Ke){function Re(We,qe,Ze,Xe,Je,tr,er){try{var ir=We[tr](er),lr=ir.value}catch(fr){Ze(fr);return}ir.done?qe(lr):Promise.resolve(lr).then(Xe,Je)}function Fe(We){return function(){var qe=this,Ze=arguments;return new Promise(function(Xe,Je){var tr=We.apply(qe,Ze);function er(lr){Re(tr,Xe,Je,er,ir,"next",lr)}function ir(lr){Re(tr,Xe,Je,er,ir,"throw",lr)}er(void 0)})}}Ke.exports=Fe,Ke.exports.__esModule=!0,Ke.exports.default=Ke.exports}(asyncToGenerator)),asyncToGenerator.exports}var hasRequiredClient;function requireClient(){return hasRequiredClient||(hasRequiredClient=1,function(Ke){var Re=interopRequireDefault.exports;Object.defineProperty(Ke,"__esModule",{value:!0}),Ke.default=void 0;var Fe=Re(requireRegenerator()),We=Re(requireAsyncToGenerator()),qe=Re(require_typeof()),Ze=Re(requireClassCallCheck()),Xe=Re(requireCreateClass()),Je=Re(requireInherits()),tr=Re(requirePossibleConstructorReturn()),er=Re(requireGetPrototypeOf()),ir=eventemitter3.exports;function lr(br){var wr=fr();return function(){var kr=(0,er.default)(br),Er;if(wr){var Ir=(0,er.default)(this).constructor;Er=Reflect.construct(kr,arguments,Ir)}else Er=kr.apply(this,arguments);return(0,tr.default)(this,Er)}}function fr(){if(typeof Reflect>"u"||!Reflect.construct||Reflect.construct.sham)return!1;if(typeof Proxy=="function")return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],function(){})),!0}catch{return!1}}var ur=function(br,wr){var Sr={};for(var kr in br)Object.prototype.hasOwnProperty.call(br,kr)&&wr.indexOf(kr)<0&&(Sr[kr]=br[kr]);if(br!=null&&typeof Object.getOwnPropertySymbols=="function")for(var Er=0,kr=Object.getOwnPropertySymbols(br);Er<kr.length;Er++)wr.indexOf(kr[Er])<0&&Object.prototype.propertyIsEnumerable.call(br,kr[Er])&&(Sr[kr[Er]]=br[kr[Er]]);return Sr},mr=function(br){(0,Je.default)(Sr,br);var wr=lr(Sr);function Sr(kr){var Er,Ir=arguments.length>1&&arguments[1]!==void 0?arguments[1]:"ws://localhost:8080",Rr=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{},Pr=arguments.length>3?arguments[3]:void 0;(0,Ze.default)(this,Sr);var Br=Rr.autoconnect,Or=Br===void 0?!0:Br,Nr=Rr.reconnect,Cr=Nr===void 0?!0:Nr,Tr=Rr.reconnect_interval,Mr=Tr===void 0?1e3:Tr,ar=Rr.max_reconnects,Dt=ar===void 0?5:ar,sr=ur(Rr,["autoconnect","reconnect","reconnect_interval","max_reconnects"]);return Er=wr.call(this),Er.webSocketFactory=kr,Er.queue={},Er.rpc_id=0,Er.address=Ir,Er.autoconnect=Or,Er.ready=!1,Er.reconnect=Cr,Er.reconnect_interval=Mr,Er.max_reconnects=Dt,Er.rest_options=sr,Er.current_reconnects=0,Er.generate_request_id=Pr||function(){return++Er.rpc_id},Er.autoconnect&&Er._connect(Er.address,Object.assign({autoconnect:Er.autoconnect,reconnect:Er.reconnect,reconnect_interval:Er.reconnect_interval,max_reconnects:Er.max_reconnects},Er.rest_options)),Er}return(0,Xe.default)(Sr,[{key:"connect",value:function(){this.socket||this._connect(this.address,Object.assign({autoconnect:this.autoconnect,reconnect:this.reconnect,reconnect_interval:this.reconnect_interval,max_reconnects:this.max_reconnects},this.rest_options))}},{key:"call",value:function(Er,Ir,Rr,Pr){var Br=this;return!Pr&&(0,qe.default)(Rr)==="object"&&(Pr=Rr,Rr=null),new Promise(function(Or,Nr){if(!Br.ready)return Nr(new Error("socket not ready"));var Cr=Br.generate_request_id(Er,Ir),Tr={jsonrpc:"2.0",method:Er,params:Ir||null,id:Cr};Br.socket.send(JSON.stringify(Tr),Pr,function(Mr){if(Mr)return Nr(Mr);Br.queue[Cr]={promise:[Or,Nr]},Rr&&(Br.queue[Cr].timeout=setTimeout(function(){delete Br.queue[Cr],Nr(new Error("reply timeout"))},Rr))})})}},{key:"login",value:function(){var kr=(0,We.default)(Fe.default.mark(function Ir(Rr){var Pr;return Fe.default.wrap(function(Or){for(;;)switch(Or.prev=Or.next){case 0:return Or.next=2,this.call("rpc.login",Rr);case 2:if(Pr=Or.sent,Pr){Or.next=5;break}throw new Error("authentication failed");case 5:return Or.abrupt("return",Pr);case 6:case"end":return Or.stop()}},Ir,this)}));function Er(Ir){return kr.apply(this,arguments)}return Er}()},{key:"listMethods",value:function(){var kr=(0,We.default)(Fe.default.mark(function Ir(){return Fe.default.wrap(function(Pr){for(;;)switch(Pr.prev=Pr.next){case 0:return Pr.next=2,this.call("__listMethods");case 2:return Pr.abrupt("return",Pr.sent);case 3:case"end":return Pr.stop()}},Ir,this)}));function Er(){return kr.apply(this,arguments)}return Er}()},{key:"notify",value:function(Er,Ir){var Rr=this;return new Promise(function(Pr,Br){if(!Rr.ready)return Br(new Error("socket not ready"));var Or={jsonrpc:"2.0",method:Er,params:Ir||null};Rr.socket.send(JSON.stringify(Or),function(Nr){if(Nr)return Br(Nr);Pr()})})}},{key:"subscribe",value:function(){var kr=(0,We.default)(Fe.default.mark(function Ir(Rr){var Pr;return Fe.default.wrap(function(Or){for(;;)switch(Or.prev=Or.next){case 0:return typeof Rr=="string"&&(Rr=[Rr]),Or.next=3,this.call("rpc.on",Rr);case 3:if(Pr=Or.sent,!(typeof Rr=="string"&&Pr[Rr]!=="ok")){Or.next=6;break}throw new Error("Failed subscribing to an event '"+Rr+"' with: "+Pr[Rr]);case 6:return Or.abrupt("return",Pr);case 7:case"end":return Or.stop()}},Ir,this)}));function Er(Ir){return kr.apply(this,arguments)}return Er}()},{key:"unsubscribe",value:function(){var kr=(0,We.default)(Fe.default.mark(function Ir(Rr){var Pr;return Fe.default.wrap(function(Or){for(;;)switch(Or.prev=Or.next){case 0:return typeof Rr=="string"&&(Rr=[Rr]),Or.next=3,this.call("rpc.off",Rr);case 3:if(Pr=Or.sent,!(typeof Rr=="string"&&Pr[Rr]!=="ok")){Or.next=6;break}throw new Error("Failed unsubscribing from an event with: "+Pr);case 6:return Or.abrupt("return",Pr);case 7:case"end":return Or.stop()}},Ir,this)}));function Er(Ir){return kr.apply(this,arguments)}return Er}()},{key:"close",value:function(Er,Ir){this.socket.close(Er||1e3,Ir)}},{key:"_connect",value:function(Er,Ir){var Rr=this;this.socket=this.webSocketFactory(Er,Ir),this.socket.addEventListener("open",function(){Rr.ready=!0,Rr.emit("open"),Rr.current_reconnects=0}),this.socket.addEventListener("message",function(Pr){var Br=Pr.data;Br instanceof ArrayBuffer&&(Br=Buffer.from(Br).toString());try{Br=JSON.parse(Br)}catch{return}if(Br.notification&&Rr.listeners(Br.notification).length){if(!Object.keys(Br.params).length)return Rr.emit(Br.notification);var Or=[Br.notification];if(Br.params.constructor===Object)Or.push(Br.params);else for(var Nr=0;Nr<Br.params.length;Nr++)Or.push(Br.params[Nr]);return Promise.resolve().then(function(){Rr.emit.apply(Rr,Or)})}if(!Rr.queue[Br.id])return Br.method&&Br.params?Promise.resolve().then(function(){Rr.emit(Br.method,Br.params)}):void 0;"error"in Br=="result"in Br&&Rr.queue[Br.id].promise[1](new Error('Server response malformed. Response must include either "result" or "error", but not both.')),Rr.queue[Br.id].timeout&&clearTimeout(Rr.queue[Br.id].timeout),Br.error?Rr.queue[Br.id].promise[1](Br.error):Rr.queue[Br.id].promise[0](Br.result),delete Rr.queue[Br.id]}),this.socket.addEventListener("error",function(Pr){return Rr.emit("error",Pr)}),this.socket.addEventListener("close",function(Pr){var Br=Pr.code,Or=Pr.reason;Rr.ready&&setTimeout(function(){return Rr.emit("close",Br,Or)},0),Rr.ready=!1,Rr.socket=void 0,Br!==1e3&&(Rr.current_reconnects++,Rr.reconnect&&(Rr.max_reconnects>Rr.current_reconnects||Rr.max_reconnects===0)&&setTimeout(function(){return Rr._connect(Er,Ir)},Rr.reconnect_interval))})}}]),Sr}(ir.EventEmitter);Ke.default=mr}(client)),client}var _interopRequireDefault=interopRequireDefault.exports;Object.defineProperty(index_browser,"__esModule",{value:!0});var Client_1=index_browser.Client=void 0,_createClass2=_interopRequireDefault(requireCreateClass()),_classCallCheck2=_interopRequireDefault(requireClassCallCheck()),_inherits2=_interopRequireDefault(requireInherits()),_possibleConstructorReturn2=_interopRequireDefault(requirePossibleConstructorReturn()),_getPrototypeOf2=_interopRequireDefault(requireGetPrototypeOf()),_websocket=_interopRequireDefault(requireWebsocket_browser()),_client=_interopRequireDefault(requireClient());function _createSuper(Ke){var Re=_isNativeReflectConstruct();return function(){var We=(0,_getPrototypeOf2.default)(Ke),qe;if(Re){var Ze=(0,_getPrototypeOf2.default)(this).constructor;qe=Reflect.construct(We,arguments,Ze)}else qe=We.apply(this,arguments);return(0,_possibleConstructorReturn2.default)(this,qe)}}function _isNativeReflectConstruct(){if(typeof Reflect>"u"||!Reflect.construct||Reflect.construct.sham)return!1;if(typeof Proxy=="function")return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],function(){})),!0}catch{return!1}}var Client=function(Ke){(0,_inherits2.default)(Fe,Ke);var Re=_createSuper(Fe);function Fe(){var We=arguments.length>0&&arguments[0]!==void 0?arguments[0]:"ws://localhost:8080",qe=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{},Ze=qe.autoconnect,Xe=Ze===void 0?!0:Ze,Je=qe.reconnect,tr=Je===void 0?!0:Je,er=qe.reconnect_interval,ir=er===void 0?1e3:er,lr=qe.max_reconnects,fr=lr===void 0?5:lr,ur=arguments.length>2?arguments[2]:void 0;return(0,_classCallCheck2.default)(this,Fe),Re.call(this,_websocket.default,We,{autoconnect:Xe,reconnect:tr,reconnect_interval:ir,max_reconnects:fr},ur)}return(0,_createClass2.default)(Fe)}(_client.default);Client_1=index_browser.Client=Client;var getRandomValues,rnds8=new Uint8Array(16);function rng(){if(!getRandomValues&&(getRandomValues=typeof crypto<"u"&&crypto.getRandomValues&&crypto.getRandomValues.bind(crypto)||typeof msCrypto<"u"&&typeof msCrypto.getRandomValues=="function"&&msCrypto.getRandomValues.bind(msCrypto),!getRandomValues))throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");return getRandomValues(rnds8)}const REGEX=/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;function validate(Ke){return typeof Ke=="string"&&REGEX.test(Ke)}var byteToHex=[];for(var i=0;i<256;++i)byteToHex.push((i+256).toString(16).substr(1));function stringify$1(Ke){var Re=arguments.length>1&&arguments[1]!==void 0?arguments[1]:0,Fe=(byteToHex[Ke[Re+0]]+byteToHex[Ke[Re+1]]+byteToHex[Ke[Re+2]]+byteToHex[Ke[Re+3]]+"-"+byteToHex[Ke[Re+4]]+byteToHex[Ke[Re+5]]+"-"+byteToHex[Ke[Re+6]]+byteToHex[Ke[Re+7]]+"-"+byteToHex[Ke[Re+8]]+byteToHex[Ke[Re+9]]+"-"+byteToHex[Ke[Re+10]]+byteToHex[Ke[Re+11]]+byteToHex[Ke[Re+12]]+byteToHex[Ke[Re+13]]+byteToHex[Ke[Re+14]]+byteToHex[Ke[Re+15]]).toLowerCase();if(!validate(Fe))throw TypeError("Stringified UUID is invalid");return Fe}var _nodeId,_clockseq,_lastMSecs=0,_lastNSecs=0;function v1(Ke,Re,Fe){var We=Re&&Fe||0,qe=Re||new Array(16);Ke=Ke||{};var Ze=Ke.node||_nodeId,Xe=Ke.clockseq!==void 0?Ke.clockseq:_clockseq;if(Ze==null||Xe==null){var Je=Ke.random||(Ke.rng||rng)();Ze==null&&(Ze=_nodeId=[Je[0]|1,Je[1],Je[2],Je[3],Je[4],Je[5]]),Xe==null&&(Xe=_clockseq=(Je[6]<<8|Je[7])&16383)}var tr=Ke.msecs!==void 0?Ke.msecs:Date.now(),er=Ke.nsecs!==void 0?Ke.nsecs:_lastNSecs+1,ir=tr-_lastMSecs+(er-_lastNSecs)/1e4;if(ir<0&&Ke.clockseq===void 0&&(Xe=Xe+1&16383),(ir<0||tr>_lastMSecs)&&Ke.nsecs===void 0&&(er=0),er>=1e4)throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");_lastMSecs=tr,_lastNSecs=er,_clockseq=Xe,tr+=122192928e5;var lr=((tr&268435455)*1e4+er)%4294967296;qe[We++]=lr>>>24&255,qe[We++]=lr>>>16&255,qe[We++]=lr>>>8&255,qe[We++]=lr&255;var fr=tr/4294967296*1e4&268435455;qe[We++]=fr>>>8&255,qe[We++]=fr&255,qe[We++]=fr>>>24&15|16,qe[We++]=fr>>>16&255,qe[We++]=Xe>>>8|128,qe[We++]=Xe&255;for(var ur=0;ur<6;++ur)qe[We+ur]=Ze[ur];return Re||stringify$1(qe)}function parse(Ke){if(!validate(Ke))throw TypeError("Invalid UUID");var Re,Fe=new Uint8Array(16);return Fe[0]=(Re=parseInt(Ke.slice(0,8),16))>>>24,Fe[1]=Re>>>16&255,Fe[2]=Re>>>8&255,Fe[3]=Re&255,Fe[4]=(Re=parseInt(Ke.slice(9,13),16))>>>8,Fe[5]=Re&255,Fe[6]=(Re=parseInt(Ke.slice(14,18),16))>>>8,Fe[7]=Re&255,Fe[8]=(Re=parseInt(Ke.slice(19,23),16))>>>8,Fe[9]=Re&255,Fe[10]=(Re=parseInt(Ke.slice(24,36),16))/1099511627776&255,Fe[11]=Re/4294967296&255,Fe[12]=Re>>>24&255,Fe[13]=Re>>>16&255,Fe[14]=Re>>>8&255,Fe[15]=Re&255,Fe}function stringToBytes(Ke){Ke=unescape(encodeURIComponent(Ke));for(var Re=[],Fe=0;Fe<Ke.length;++Fe)Re.push(Ke.charCodeAt(Fe));return Re}var DNS="6ba7b810-9dad-11d1-80b4-00c04fd430c8",URL="6ba7b811-9dad-11d1-80b4-00c04fd430c8";function v35(Ke,Re,Fe){function We(qe,Ze,Xe,Je){if(typeof qe=="string"&&(qe=stringToBytes(qe)),typeof Ze=="string"&&(Ze=parse(Ze)),Ze.length!==16)throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");var tr=new Uint8Array(16+qe.length);if(tr.set(Ze),tr.set(qe,Ze.length),tr=Fe(tr),tr[6]=tr[6]&15|Re,tr[8]=tr[8]&63|128,Xe){Je=Je||0;for(var er=0;er<16;++er)Xe[Je+er]=tr[er];return Xe}return stringify$1(tr)}try{We.name=Ke}catch{}return We.DNS=DNS,We.URL=URL,We}function md5(Ke){if(typeof Ke=="string"){var Re=unescape(encodeURIComponent(Ke));Ke=new Uint8Array(Re.length);for(var Fe=0;Fe<Re.length;++Fe)Ke[Fe]=Re.charCodeAt(Fe)}return md5ToHexEncodedArray(wordsToMd5(bytesToWords(Ke),Ke.length*8))}function md5ToHexEncodedArray(Ke){for(var Re=[],Fe=Ke.length*32,We="0123456789abcdef",qe=0;qe<Fe;qe+=8){var Ze=Ke[qe>>5]>>>qe%32&255,Xe=parseInt(We.charAt(Ze>>>4&15)+We.charAt(Ze&15),16);Re.push(Xe)}return Re}function getOutputLength(Ke){return(Ke+64>>>9<<4)+14+1}function wordsToMd5(Ke,Re){Ke[Re>>5]|=128<<Re%32,Ke[getOutputLength(Re)-1]=Re;for(var Fe=1732584193,We=-271733879,qe=-1732584194,Ze=271733878,Xe=0;Xe<Ke.length;Xe+=16){var Je=Fe,tr=We,er=qe,ir=Ze;Fe=md5ff(Fe,We,qe,Ze,Ke[Xe],7,-680876936),Ze=md5ff(Ze,Fe,We,qe,Ke[Xe+1],12,-389564586),qe=md5ff(qe,Ze,Fe,We,Ke[Xe+2],17,606105819),We=md5ff(We,qe,Ze,Fe,Ke[Xe+3],22,-1044525330),Fe=md5ff(Fe,We,qe,Ze,Ke[Xe+4],7,-176418897),Ze=md5ff(Ze,Fe,We,qe,Ke[Xe+5],12,1200080426),qe=md5ff(qe,Ze,Fe,We,Ke[Xe+6],17,-1473231341),We=md5ff(We,qe,Ze,Fe,Ke[Xe+7],22,-45705983),Fe=md5ff(Fe,We,qe,Ze,Ke[Xe+8],7,1770035416),Ze=md5ff(Ze,Fe,We,qe,Ke[Xe+9],12,-1958414417),qe=md5ff(qe,Ze,Fe,We,Ke[Xe+10],17,-42063),We=md5ff(We,qe,Ze,Fe,Ke[Xe+11],22,-1990404162),Fe=md5ff(Fe,We,qe,Ze,Ke[Xe+12],7,1804603682),Ze=md5ff(Ze,Fe,We,qe,Ke[Xe+13],12,-40341101),qe=md5ff(qe,Ze,Fe,We,Ke[Xe+14],17,-1502002290),We=md5ff(We,qe,Ze,Fe,Ke[Xe+15],22,1236535329),Fe=md5gg(Fe,We,qe,Ze,Ke[Xe+1],5,-165796510),Ze=md5gg(Ze,Fe,We,qe,Ke[Xe+6],9,-1069501632),qe=md5gg(qe,Ze,Fe,We,Ke[Xe+11],14,643717713),We=md5gg(We,qe,Ze,Fe,Ke[Xe],20,-373897302),Fe=md5gg(Fe,We,qe,Ze,Ke[Xe+5],5,-701558691),Ze=md5gg(Ze,Fe,We,qe,Ke[Xe+10],9,38016083),qe=md5gg(qe,Ze,Fe,We,Ke[Xe+15],14,-660478335),We=md5gg(We,qe,Ze,Fe,Ke[Xe+4],20,-405537848),Fe=md5gg(Fe,We,qe,Ze,Ke[Xe+9],5,568446438),Ze=md5gg(Ze,Fe,We,qe,Ke[Xe+14],9,-1019803690),qe=md5gg(qe,Ze,Fe,We,Ke[Xe+3],14,-187363961),We=md5gg(We,qe,Ze,Fe,Ke[Xe+8],20,1163531501),Fe=md5gg(Fe,We,qe,Ze,Ke[Xe+13],5,-1444681467),Ze=md5gg(Ze,Fe,We,qe,Ke[Xe+2],9,-51403784),qe=md5gg(qe,Ze,Fe,We,Ke[Xe+7],14,1735328473),We=md5gg(We,qe,Ze,Fe,Ke[Xe+12],20,-1926607734),Fe=md5hh(Fe,We,qe,Ze,Ke[Xe+5],4,-378558),Ze=md5hh(Ze,Fe,We,qe,Ke[Xe+8],11,-2022574463),qe=md5hh(qe,Ze,Fe,We,Ke[Xe+11],16,1839030562),We=md5hh(We,qe,Ze,Fe,Ke[Xe+14],23,-35309556),Fe=md5hh(Fe,We,qe,Ze,Ke[Xe+1],4,-1530992060),Ze=md5hh(Ze,Fe,We,qe,Ke[Xe+4],11,1272893353),qe=md5hh(qe,Ze,Fe,We,Ke[Xe+7],16,-155497632),We=md5hh(We,qe,Ze,Fe,Ke[Xe+10],23,-1094730640),Fe=md5hh(Fe,We,qe,Ze,Ke[Xe+13],4,681279174),Ze=md5hh(Ze,Fe,We,qe,Ke[Xe],11,-358537222),qe=md5hh(qe,Ze,Fe,We,Ke[Xe+3],16,-722521979),We=md5hh(We,qe,Ze,Fe,Ke[Xe+6],23,76029189),Fe=md5hh(Fe,We,qe,Ze,Ke[Xe+9],4,-640364487),Ze=md5hh(Ze,Fe,We,qe,Ke[Xe+12],11,-421815835),qe=md5hh(qe,Ze,Fe,We,Ke[Xe+15],16,530742520),We=md5hh(We,qe,Ze,Fe,Ke[Xe+2],23,-995338651),Fe=md5ii(Fe,We,qe,Ze,Ke[Xe],6,-198630844),Ze=md5ii(Ze,Fe,We,qe,Ke[Xe+7],10,1126891415),qe=md5ii(qe,Ze,Fe,We,Ke[Xe+14],15,-1416354905),We=md5ii(We,qe,Ze,Fe,Ke[Xe+5],21,-57434055),Fe=md5ii(Fe,We,qe,Ze,Ke[Xe+12],6,1700485571),Ze=md5ii(Ze,Fe,We,qe,Ke[Xe+3],10,-1894986606),qe=md5ii(qe,Ze,Fe,We,Ke[Xe+10],15,-1051523),We=md5ii(We,qe,Ze,Fe,Ke[Xe+1],21,-2054922799),Fe=md5ii(Fe,We,qe,Ze,Ke[Xe+8],6,1873313359),Ze=md5ii(Ze,Fe,We,qe,Ke[Xe+15],10,-30611744),qe=md5ii(qe,Ze,Fe,We,Ke[Xe+6],15,-1560198380),We=md5ii(We,qe,Ze,Fe,Ke[Xe+13],21,1309151649),Fe=md5ii(Fe,We,qe,Ze,Ke[Xe+4],6,-145523070),Ze=md5ii(Ze,Fe,We,qe,Ke[Xe+11],10,-1120210379),qe=md5ii(qe,Ze,Fe,We,Ke[Xe+2],15,718787259),We=md5ii(We,qe,Ze,Fe,Ke[Xe+9],21,-343485551),Fe=safeAdd(Fe,Je),We=safeAdd(We,tr),qe=safeAdd(qe,er),Ze=safeAdd(Ze,ir)}return[Fe,We,qe,Ze]}function bytesToWords(Ke){if(Ke.length===0)return[];for(var Re=Ke.length*8,Fe=new Uint32Array(getOutputLength(Re)),We=0;We<Re;We+=8)Fe[We>>5]|=(Ke[We/8]&255)<<We%32;return Fe}function safeAdd(Ke,Re){var Fe=(Ke&65535)+(Re&65535),We=(Ke>>16)+(Re>>16)+(Fe>>16);return We<<16|Fe&65535}function bitRotateLeft(Ke,Re){return Ke<<Re|Ke>>>32-Re}function md5cmn(Ke,Re,Fe,We,qe,Ze){return safeAdd(bitRotateLeft(safeAdd(safeAdd(Re,Ke),safeAdd(We,Ze)),qe),Fe)}function md5ff(Ke,Re,Fe,We,qe,Ze,Xe){return md5cmn(Re&Fe|~Re&We,Ke,Re,qe,Ze,Xe)}function md5gg(Ke,Re,Fe,We,qe,Ze,Xe){return md5cmn(Re&We|Fe&~We,Ke,Re,qe,Ze,Xe)}function md5hh(Ke,Re,Fe,We,qe,Ze,Xe){return md5cmn(Re^Fe^We,Ke,Re,qe,Ze,Xe)}function md5ii(Ke,Re,Fe,We,qe,Ze,Xe){return md5cmn(Fe^(Re|~We),Ke,Re,qe,Ze,Xe)}var v3=v35("v3",48,md5);const v3$1=v3;function v4(Ke,Re,Fe){Ke=Ke||{};var We=Ke.random||(Ke.rng||rng)();if(We[6]=We[6]&15|64,We[8]=We[8]&63|128,Re){Fe=Fe||0;for(var qe=0;qe<16;++qe)Re[Fe+qe]=We[qe];return Re}return stringify$1(We)}function f(Ke,Re,Fe,We){switch(Ke){case 0:return Re&Fe^~Re&We;case 1:return Re^Fe^We;case 2:return Re&Fe^Re&We^Fe&We;case 3:return Re^Fe^We}}function ROTL(Ke,Re){return Ke<<Re|Ke>>>32-Re}function sha1(Ke){var Re=[1518500249,1859775393,2400959708,3395469782],Fe=[1732584193,4023233417,2562383102,271733878,3285377520];if(typeof Ke=="string"){var We=unescape(encodeURIComponent(Ke));Ke=[];for(var qe=0;qe<We.length;++qe)Ke.push(We.charCodeAt(qe))}else Array.isArray(Ke)||(Ke=Array.prototype.slice.call(Ke));Ke.push(128);for(var Ze=Ke.length/4+2,Xe=Math.ceil(Ze/16),Je=new Array(Xe),tr=0;tr<Xe;++tr){for(var er=new Uint32Array(16),ir=0;ir<16;++ir)er[ir]=Ke[tr*64+ir*4]<<24|Ke[tr*64+ir*4+1]<<16|Ke[tr*64+ir*4+2]<<8|Ke[tr*64+ir*4+3];Je[tr]=er}Je[Xe-1][14]=(Ke.length-1)*8/Math.pow(2,32),Je[Xe-1][14]=Math.floor(Je[Xe-1][14]),Je[Xe-1][15]=(Ke.length-1)*8&4294967295;for(var lr=0;lr<Xe;++lr){for(var fr=new Uint32Array(80),ur=0;ur<16;++ur)fr[ur]=Je[lr][ur];for(var mr=16;mr<80;++mr)fr[mr]=ROTL(fr[mr-3]^fr[mr-8]^fr[mr-14]^fr[mr-16],1);for(var br=Fe[0],wr=Fe[1],Sr=Fe[2],kr=Fe[3],Er=Fe[4],Ir=0;Ir<80;++Ir){var Rr=Math.floor(Ir/20),Pr=ROTL(br,5)+f(Rr,wr,Sr,kr)+Er+Re[Rr]+fr[Ir]>>>0;Er=kr,kr=Sr,Sr=ROTL(wr,30)>>>0,wr=br,br=Pr}Fe[0]=Fe[0]+br>>>0,Fe[1]=Fe[1]+wr>>>0,Fe[2]=Fe[2]+Sr>>>0,Fe[3]=Fe[3]+kr>>>0,Fe[4]=Fe[4]+Er>>>0}return[Fe[0]>>24&255,Fe[0]>>16&255,Fe[0]>>8&255,Fe[0]&255,Fe[1]>>24&255,Fe[1]>>16&255,Fe[1]>>8&255,Fe[1]&255,Fe[2]>>24&255,Fe[2]>>16&255,Fe[2]>>8&255,Fe[2]&255,Fe[3]>>24&255,Fe[3]>>16&255,Fe[3]>>8&255,Fe[3]&255,Fe[4]>>24&255,Fe[4]>>16&255,Fe[4]>>8&255,Fe[4]&255]}var v5=v35("v5",80,sha1);const v5$1=v5,nil="00000000-0000-0000-0000-000000000000";function version(Ke){if(!validate(Ke))throw TypeError("Invalid UUID");return parseInt(Ke.substr(14,1),16)}const esmBrowser=Object.freeze(Object.defineProperty({__proto__:null,v1,v3:v3$1,v4,v5:v5$1,NIL:nil,version,validate,stringify:stringify$1,parse},Symbol.toStringTag,{value:"Module"})),require$$0=getAugmentedNamespace(esmBrowser),uuid$1=require$$0.v4,generateRequest$1=function(Ke,Re,Fe,We){if(typeof Ke!="string")throw new TypeError(Ke+" must be a string");We=We||{};const qe=typeof We.version=="number"?We.version:2;if(qe!==1&&qe!==2)throw new TypeError(qe+" must be 1 or 2");const Ze={method:Ke};if(qe===2&&(Ze.jsonrpc="2.0"),Re){if(typeof Re!="object"&&!Array.isArray(Re))throw new TypeError(Re+" must be an object, array or omitted");Ze.params=Re}if(typeof Fe>"u"){const Xe=typeof We.generator=="function"?We.generator:function(){return uuid$1()};Ze.id=Xe(Ze,We)}else qe===2&&Fe===null?We.notificationIdNull&&(Ze.id=null):Ze.id=Fe;return Ze};var generateRequest_1=generateRequest$1;const uuid=require$$0.v4,generateRequest=generateRequest_1,ClientBrowser=function(Ke,Re){if(!(this instanceof ClientBrowser))return new ClientBrowser(Ke,Re);Re||(Re={}),this.options={reviver:typeof Re.reviver<"u"?Re.reviver:null,replacer:typeof Re.replacer<"u"?Re.replacer:null,generator:typeof Re.generator<"u"?Re.generator:function(){return uuid()},version:typeof Re.version<"u"?Re.version:2,notificationIdNull:typeof Re.notificationIdNull=="boolean"?Re.notificationIdNull:!1},this.callServer=Ke};var browser=ClientBrowser;ClientBrowser.prototype.request=function(Ke,Re,Fe,We){const qe=this;let Ze=null;const Xe=Array.isArray(Ke)&&typeof Re=="function";if(this.options.version===1&&Xe)throw new TypeError("JSON-RPC 1.0 does not support batching");if(Xe||!Xe&&Ke&&typeof Ke=="object"&&typeof Re=="function")We=Re,Ze=Ke;else{typeof Fe=="function"&&(We=Fe,Fe=void 0);const er=typeof We=="function";try{Ze=generateRequest(Ke,Re,Fe,{generator:this.options.generator,version:this.options.version,notificationIdNull:this.options.notificationIdNull})}catch(ir){if(er)return We(ir);throw ir}if(!er)return Ze}let tr;try{tr=JSON.stringify(Ze,this.options.replacer)}catch(er){return We(er)}return this.callServer(tr,function(er,ir){qe._parseResponse(er,ir,We)}),Ze};ClientBrowser.prototype._parseResponse=function(Ke,Re,Fe){if(Ke){Fe(Ke);return}if(!Re)return Fe();let We;try{We=JSON.parse(Re,this.options.reviver)}catch(qe){return Fe(qe)}if(Fe.length===3)if(Array.isArray(We)){const qe=function(Xe){return typeof Xe.error<"u"},Ze=function(Xe){return!qe(Xe)};return Fe(null,We.filter(qe),We.filter(Ze))}else return Fe(null,We.error,We.result);Fe(null,We)};const[SHA3_PI,SHA3_ROTL,_SHA3_IOTA]=[[],[],[]],_0n$1=BigInt(0),_1n$1=BigInt(1),_2n$1=BigInt(2),_7n=BigInt(7),_256n=BigInt(256),_0x71n=BigInt(113);for(let Ke=0,Re=_1n$1,Fe=1,We=0;Ke<24;Ke++){[Fe,We]=[We,(2*Fe+3*We)%5],SHA3_PI.push(2*(5*We+Fe)),SHA3_ROTL.push((Ke+1)*(Ke+2)/2%64);let qe=_0n$1;for(let Ze=0;Ze<7;Ze++)Re=(Re<<_1n$1^(Re>>_7n)*_0x71n)%_256n,Re&_2n$1&&(qe^=_1n$1<<(_1n$1<<BigInt(Ze))-_1n$1);_SHA3_IOTA.push(qe)}const[SHA3_IOTA_H,SHA3_IOTA_L]=u64$1.split(_SHA3_IOTA,!0),rotlH=(Ke,Re,Fe)=>Fe>32?u64$1.rotlBH(Ke,Re,Fe):u64$1.rotlSH(Ke,Re,Fe),rotlL=(Ke,Re,Fe)=>Fe>32?u64$1.rotlBL(Ke,Re,Fe):u64$1.rotlSL(Ke,Re,Fe);function keccakP(Ke,Re=24){const Fe=new Uint32Array(10);for(let We=24-Re;We<24;We++){for(let Xe=0;Xe<10;Xe++)Fe[Xe]=Ke[Xe]^Ke[Xe+10]^Ke[Xe+20]^Ke[Xe+30]^Ke[Xe+40];for(let Xe=0;Xe<10;Xe+=2){const Je=(Xe+8)%10,tr=(Xe+2)%10,er=Fe[tr],ir=Fe[tr+1],lr=rotlH(er,ir,1)^Fe[Je],fr=rotlL(er,ir,1)^Fe[Je+1];for(let ur=0;ur<50;ur+=10)Ke[Xe+ur]^=lr,Ke[Xe+ur+1]^=fr}let qe=Ke[2],Ze=Ke[3];for(let Xe=0;Xe<24;Xe++){const Je=SHA3_ROTL[Xe],tr=rotlH(qe,Ze,Je),er=rotlL(qe,Ze,Je),ir=SHA3_PI[Xe];qe=Ke[ir],Ze=Ke[ir+1],Ke[ir]=tr,Ke[ir+1]=er}for(let Xe=0;Xe<50;Xe+=10){for(let Je=0;Je<10;Je++)Fe[Je]=Ke[Xe+Je];for(let Je=0;Je<10;Je++)Ke[Xe+Je]^=~Fe[(Je+2)%10]&Fe[(Je+4)%10]}Ke[0]^=SHA3_IOTA_H[We],Ke[1]^=SHA3_IOTA_L[We]}Fe.fill(0)}class Keccak extends Hash{constructor(Re,Fe,We,qe=!1,Ze=24){if(super(),this.blockLen=Re,this.suffix=Fe,this.outputLen=We,this.enableXOF=qe,this.rounds=Ze,this.pos=0,this.posOut=0,this.finished=!1,this.destroyed=!1,assert$2.number(We),0>=this.blockLen||this.blockLen>=200)throw new Error("Sha3 supports only keccak-f1600 function");this.state=new Uint8Array(200),this.state32=u32$1(this.state)}keccak(){keccakP(this.state32,this.rounds),this.posOut=0,this.pos=0}update(Re){assert$2.exists(this);const{blockLen:Fe,state:We}=this;Re=toBytes(Re);const qe=Re.length;for(let Ze=0;Ze<qe;){const Xe=Math.min(Fe-this.pos,qe-Ze);for(let Je=0;Je<Xe;Je++)We[this.pos++]^=Re[Ze++];this.pos===Fe&&this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;const{state:Re,suffix:Fe,pos:We,blockLen:qe}=this;Re[We]^=Fe,(Fe&128)!==0&&We===qe-1&&this.keccak(),Re[qe-1]^=128,this.keccak()}writeInto(Re){assert$2.exists(this,!1),assert$2.bytes(Re),this.finish();const Fe=this.state,{blockLen:We}=this;for(let qe=0,Ze=Re.length;qe<Ze;){this.posOut>=We&&this.keccak();const Xe=Math.min(We-this.posOut,Ze-qe);Re.set(Fe.subarray(this.posOut,this.posOut+Xe),qe),this.posOut+=Xe,qe+=Xe}return Re}xofInto(Re){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto(Re)}xof(Re){return assert$2.number(Re),this.xofInto(new Uint8Array(Re))}digestInto(Re){if(assert$2.output(Re,this),this.finished)throw new Error("digest() was already called");return this.writeInto(Re),this.destroy(),Re}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,this.state.fill(0)}_cloneInto(Re){const{blockLen:Fe,suffix:We,outputLen:qe,rounds:Ze,enableXOF:Xe}=this;return Re||(Re=new Keccak(Fe,We,qe,Xe,Ze)),Re.state32.set(this.state32),Re.pos=this.pos,Re.posOut=this.posOut,Re.finished=this.finished,Re.rounds=Ze,Re.suffix=We,Re.outputLen=qe,Re.enableXOF=Xe,Re.destroyed=this.destroyed,Re}}const gen=(Ke,Re,Fe)=>wrapConstructor(()=>new Keccak(Re,Ke,Fe));gen(6,144,224/8);gen(6,136,256/8);gen(6,104,384/8);gen(6,72,512/8);gen(1,144,224/8);const keccak_256=gen(1,136,256/8);gen(1,104,384/8);gen(1,72,512/8);const genShake=(Ke,Re,Fe)=>wrapConstructorWithOpts((We={})=>new Keccak(Re,Ke,We.dkLen===void 0?Fe:We.dkLen,!0));genShake(31,168,128/8);genShake(31,136,256/8);class HMAC extends Hash{constructor(Re,Fe){super(),this.finished=!1,this.destroyed=!1,assert$2.hash(Re);const We=toBytes(Fe);if(this.iHash=Re.create(),typeof this.iHash.update!="function")throw new TypeError("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const qe=this.blockLen,Ze=new Uint8Array(qe);Ze.set(We.length>qe?Re.create().update(We).digest():We);for(let Xe=0;Xe<Ze.length;Xe++)Ze[Xe]^=54;this.iHash.update(Ze),this.oHash=Re.create();for(let Xe=0;Xe<Ze.length;Xe++)Ze[Xe]^=106;this.oHash.update(Ze),Ze.fill(0)}update(Re){return assert$2.exists(this),this.iHash.update(Re),this}digestInto(Re){assert$2.exists(this),assert$2.bytes(Re,this.outputLen),this.finished=!0,this.iHash.digestInto(Re),this.oHash.update(Re),this.oHash.digestInto(Re),this.destroy()}digest(){const Re=new Uint8Array(this.oHash.outputLen);return this.digestInto(Re),Re}_cloneInto(Re){Re||(Re=Object.create(Object.getPrototypeOf(this),{}));const{oHash:Fe,iHash:We,finished:qe,destroyed:Ze,blockLen:Xe,outputLen:Je}=this;return Re=Re,Re.finished=qe,Re.destroyed=Ze,Re.blockLen=Xe,Re.outputLen=Je,Re.oHash=Fe._cloneInto(Re.oHash),Re.iHash=We._cloneInto(Re.iHash),Re}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const hmac=(Ke,Re,Fe)=>new HMAC(Ke,Re).update(Fe).digest();hmac.create=(Ke,Re)=>new HMAC(Ke,Re);/*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */const _0n=BigInt(0),_1n=BigInt(1),_2n=BigInt(2),_3n=BigInt(3),_8n=BigInt(8),CURVE=Object.freeze({a:_0n,b:BigInt(7),P:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),n:BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),h:_1n,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee")});function weistrass(Ke){const{a:Re,b:Fe}=CURVE,We=mod(Ke*Ke),qe=mod(We*Ke);return mod(qe+Re*Ke+Fe)}const USE_ENDOMORPHISM=CURVE.a===_0n;class ShaError extends Error{constructor(Re){super(Re)}}class JacobianPoint{constructor(Re,Fe,We){this.x=Re,this.y=Fe,this.z=We}static fromAffine(Re){if(!(Re instanceof Point))throw new TypeError("JacobianPoint#fromAffine: expected Point");return new JacobianPoint(Re.x,Re.y,_1n)}static toAffineBatch(Re){const Fe=invertBatch(Re.map(We=>We.z));return Re.map((We,qe)=>We.toAffine(Fe[qe]))}static normalizeZ(Re){return JacobianPoint.toAffineBatch(Re).map(JacobianPoint.fromAffine)}equals(Re){if(!(Re instanceof JacobianPoint))throw new TypeError("JacobianPoint expected");const{x:Fe,y:We,z:qe}=this,{x:Ze,y:Xe,z:Je}=Re,tr=mod(qe*qe),er=mod(Je*Je),ir=mod(Fe*er),lr=mod(Ze*tr),fr=mod(mod(We*Je)*er),ur=mod(mod(Xe*qe)*tr);return ir===lr&&fr===ur}negate(){return new JacobianPoint(this.x,mod(-this.y),this.z)}double(){const{x:Re,y:Fe,z:We}=this,qe=mod(Re*Re),Ze=mod(Fe*Fe),Xe=mod(Ze*Ze),Je=Re+Ze,tr=mod(_2n*(mod(Je*Je)-qe-Xe)),er=mod(_3n*qe),ir=mod(er*er),lr=mod(ir-_2n*tr),fr=mod(er*(tr-lr)-_8n*Xe),ur=mod(_2n*Fe*We);return new JacobianPoint(lr,fr,ur)}add(Re){if(!(Re instanceof JacobianPoint))throw new TypeError("JacobianPoint expected");const{x:Fe,y:We,z:qe}=this,{x:Ze,y:Xe,z:Je}=Re;if(Ze===_0n||Xe===_0n)return this;if(Fe===_0n||We===_0n)return Re;const tr=mod(qe*qe),er=mod(Je*Je),ir=mod(Fe*er),lr=mod(Ze*tr),fr=mod(mod(We*Je)*er),ur=mod(mod(Xe*qe)*tr),mr=mod(lr-ir),br=mod(ur-fr);if(mr===_0n)return br===_0n?this.double():JacobianPoint.ZERO;const wr=mod(mr*mr),Sr=mod(mr*wr),kr=mod(ir*wr),Er=mod(br*br-Sr-_2n*kr),Ir=mod(br*(kr-Er)-fr*Sr),Rr=mod(qe*Je*mr);return new JacobianPoint(Er,Ir,Rr)}subtract(Re){return this.add(Re.negate())}multiplyUnsafe(Re){const Fe=JacobianPoint.ZERO;if(typeof Re=="bigint"&&Re===_0n)return Fe;let We=normalizeScalar(Re);if(We===_1n)return this;if(!USE_ENDOMORPHISM){let lr=Fe,fr=this;for(;We>_0n;)We&_1n&&(lr=lr.add(fr)),fr=fr.double(),We>>=_1n;return lr}let{k1neg:qe,k1:Ze,k2neg:Xe,k2:Je}=splitScalarEndo(We),tr=Fe,er=Fe,ir=this;for(;Ze>_0n||Je>_0n;)Ze&_1n&&(tr=tr.add(ir)),Je&_1n&&(er=er.add(ir)),ir=ir.double(),Ze>>=_1n,Je>>=_1n;return qe&&(tr=tr.negate()),Xe&&(er=er.negate()),er=new JacobianPoint(mod(er.x*CURVE.beta),er.y,er.z),tr.add(er)}precomputeWindow(Re){const Fe=USE_ENDOMORPHISM?128/Re+1:256/Re+1,We=[];let qe=this,Ze=qe;for(let Xe=0;Xe<Fe;Xe++){Ze=qe,We.push(Ze);for(let Je=1;Je<2**(Re-1);Je++)Ze=Ze.add(qe),We.push(Ze);qe=Ze.double()}return We}wNAF(Re,Fe){!Fe&&this.equals(JacobianPoint.BASE)&&(Fe=Point.BASE);const We=Fe&&Fe._WINDOW_SIZE||1;if(256%We)throw new Error("Point#wNAF: Invalid precomputation window, must be power of 2");let qe=Fe&&pointPrecomputes.get(Fe);qe||(qe=this.precomputeWindow(We),Fe&&We!==1&&(qe=JacobianPoint.normalizeZ(qe),pointPrecomputes.set(Fe,qe)));let Ze=JacobianPoint.ZERO,Xe=JacobianPoint.ZERO;const Je=1+(USE_ENDOMORPHISM?128/We:256/We),tr=2**(We-1),er=BigInt(2**We-1),ir=2**We,lr=BigInt(We);for(let fr=0;fr<Je;fr++){const ur=fr*tr;let mr=Number(Re&er);if(Re>>=lr,mr>tr&&(mr-=ir,Re+=_1n),mr===0){let br=qe[ur];fr%2&&(br=br.negate()),Xe=Xe.add(br)}else{let br=qe[ur+Math.abs(mr)-1];mr<0&&(br=br.negate()),Ze=Ze.add(br)}}return{p:Ze,f:Xe}}multiply(Re,Fe){let We=normalizeScalar(Re),qe,Ze;if(USE_ENDOMORPHISM){const{k1neg:Xe,k1:Je,k2neg:tr,k2:er}=splitScalarEndo(We);let{p:ir,f:lr}=this.wNAF(Je,Fe),{p:fr,f:ur}=this.wNAF(er,Fe);Xe&&(ir=ir.negate()),tr&&(fr=fr.negate()),fr=new JacobianPoint(mod(fr.x*CURVE.beta),fr.y,fr.z),qe=ir.add(fr),Ze=lr.add(ur)}else{const{p:Xe,f:Je}=this.wNAF(We,Fe);qe=Xe,Ze=Je}return JacobianPoint.normalizeZ([qe,Ze])[0]}toAffine(Re=invert(this.z)){const{x:Fe,y:We,z:qe}=this,Ze=Re,Xe=mod(Ze*Ze),Je=mod(Xe*Ze),tr=mod(Fe*Xe),er=mod(We*Je);if(mod(qe*Ze)!==_1n)throw new Error("invZ was invalid");return new Point(tr,er)}}JacobianPoint.BASE=new JacobianPoint(CURVE.Gx,CURVE.Gy,_1n);JacobianPoint.ZERO=new JacobianPoint(_0n,_1n,_0n);const pointPrecomputes=new WeakMap;class Point{constructor(Re,Fe){this.x=Re,this.y=Fe}_setWindowSize(Re){this._WINDOW_SIZE=Re,pointPrecomputes.delete(this)}hasEvenY(){return this.y%_2n===_0n}static fromCompressedHex(Re){const Fe=Re.length===32,We=bytesToNumber(Fe?Re:Re.subarray(1));if(!isValidFieldElement(We))throw new Error("Point is not on curve");const qe=weistrass(We);let Ze=sqrtMod(qe);const Xe=(Ze&_1n)===_1n;Fe?Xe&&(Ze=mod(-Ze)):(Re[0]&1)===1!==Xe&&(Ze=mod(-Ze));const Je=new Point(We,Ze);return Je.assertValidity(),Je}static fromUncompressedHex(Re){const Fe=bytesToNumber(Re.subarray(1,33)),We=bytesToNumber(Re.subarray(33,65)),qe=new Point(Fe,We);return qe.assertValidity(),qe}static fromHex(Re){const Fe=ensureBytes(Re),We=Fe.length,qe=Fe[0];if(We===32||We===33&&(qe===2||qe===3))return this.fromCompressedHex(Fe);if(We===65&&qe===4)return this.fromUncompressedHex(Fe);throw new Error(`Point.fromHex: received invalid point. Expected 32-33 compressed bytes or 65 uncompressed bytes, not ${We}`)}static fromPrivateKey(Re){return Point.BASE.multiply(normalizePrivateKey(Re))}static fromSignature(Re,Fe,We){Re=ensureBytes(Re);const qe=truncateHash(Re),{r:Ze,s:Xe}=normalizeSignature(Fe);if(We!==0&&We!==1)throw new Error("Cannot recover signature: invalid recovery bit");const Je=We&1?"03":"02",tr=Point.fromHex(Je+numTo32bStr(Ze)),{n:er}=CURVE,ir=invert(Ze,er),lr=mod(-qe*ir,er),fr=mod(Xe*ir,er),ur=Point.BASE.multiplyAndAddUnsafe(tr,lr,fr);if(!ur)throw new Error("Cannot recover signature: point at infinify");return ur.assertValidity(),ur}toRawBytes(Re=!1){return hexToBytes(this.toHex(Re))}toHex(Re=!1){const Fe=numTo32bStr(this.x);return Re?`${this.hasEvenY()?"02":"03"}${Fe}`:`04${Fe}${numTo32bStr(this.y)}`}toHexX(){return this.toHex(!0).slice(2)}toRawX(){return this.toRawBytes(!0).slice(1)}assertValidity(){const Re="Point is not on elliptic curve",{x:Fe,y:We}=this;if(!isValidFieldElement(Fe)||!isValidFieldElement(We))throw new Error(Re);const qe=mod(We*We),Ze=weistrass(Fe);if(mod(qe-Ze)!==_0n)throw new Error(Re)}equals(Re){return this.x===Re.x&&this.y===Re.y}negate(){return new Point(this.x,mod(-this.y))}double(){return JacobianPoint.fromAffine(this).double().toAffine()}add(Re){return JacobianPoint.fromAffine(this).add(JacobianPoint.fromAffine(Re)).toAffine()}subtract(Re){return this.add(Re.negate())}multiply(Re){return JacobianPoint.fromAffine(this).multiply(Re,this).toAffine()}multiplyAndAddUnsafe(Re,Fe,We){const qe=JacobianPoint.fromAffine(this),Ze=Fe===_0n||Fe===_1n||this!==Point.BASE?qe.multiplyUnsafe(Fe):qe.multiply(Fe),Xe=JacobianPoint.fromAffine(Re).multiplyUnsafe(We),Je=Ze.add(Xe);return Je.equals(JacobianPoint.ZERO)?void 0:Je.toAffine()}}Point.BASE=new Point(CURVE.Gx,CURVE.Gy);Point.ZERO=new Point(_0n,_0n);function sliceDER(Ke){return Number.parseInt(Ke[0],16)>=8?"00"+Ke:Ke}function parseDERInt(Ke){if(Ke.length<2||Ke[0]!==2)throw new Error(`Invalid signature integer tag: ${bytesToHex(Ke)}`);const Re=Ke[1],Fe=Ke.subarray(2,Re+2);if(!Re||Fe.length!==Re)throw new Error("Invalid signature integer: wrong length");if(Fe[0]===0&&Fe[1]<=127)throw new Error("Invalid signature integer: trailing length");return{data:bytesToNumber(Fe),left:Ke.subarray(Re+2)}}function parseDERSignature(Ke){if(Ke.length<2||Ke[0]!=48)throw new Error(`Invalid signature tag: ${bytesToHex(Ke)}`);if(Ke[1]!==Ke.length-2)throw new Error("Invalid signature: incorrect length");const{data:Re,left:Fe}=parseDERInt(Ke.subarray(2)),{data:We,left:qe}=parseDERInt(Fe);if(qe.length)throw new Error(`Invalid signature: left bytes after parsing: ${bytesToHex(qe)}`);return{r:Re,s:We}}class Signature{constructor(Re,Fe){this.r=Re,this.s=Fe,this.assertValidity()}static fromCompact(Re){const Fe=Re instanceof Uint8Array,We="Signature.fromCompact";if(typeof Re!="string"&&!Fe)throw new TypeError(`${We}: Expected string or Uint8Array`);const qe=Fe?bytesToHex(Re):Re;if(qe.length!==128)throw new Error(`${We}: Expected 64-byte hex`);return new Signature(hexToNumber(qe.slice(0,64)),hexToNumber(qe.slice(64,128)))}static fromDER(Re){const Fe=Re instanceof Uint8Array;if(typeof Re!="string"&&!Fe)throw new TypeError("Signature.fromDER: Expected string or Uint8Array");const{r:We,s:qe}=parseDERSignature(Fe?Re:hexToBytes(Re));return new Signature(We,qe)}static fromHex(Re){return this.fromDER(Re)}assertValidity(){const{r:Re,s:Fe}=this;if(!isWithinCurveOrder(Re))throw new Error("Invalid Signature: r must be 0 < r < n");if(!isWithinCurveOrder(Fe))throw new Error("Invalid Signature: s must be 0 < s < n")}hasHighS(){const Re=CURVE.n>>_1n;return this.s>Re}normalizeS(){return this.hasHighS()?new Signature(this.r,CURVE.n-this.s):this}toDERRawBytes(Re=!1){return hexToBytes(this.toDERHex(Re))}toDERHex(Re=!1){const Fe=sliceDER(numberToHexUnpadded(this.s));if(Re)return Fe;const We=sliceDER(numberToHexUnpadded(this.r)),qe=numberToHexUnpadded(We.length/2),Ze=numberToHexUnpadded(Fe.length/2);return`30${numberToHexUnpadded(We.length/2+Fe.length/2+4)}02${qe}${We}02${Ze}${Fe}`}toRawBytes(){return this.toDERRawBytes()}toHex(){return this.toDERHex()}toCompactRawBytes(){return hexToBytes(this.toCompactHex())}toCompactHex(){return numTo32bStr(this.r)+numTo32bStr(this.s)}}function concatBytes(...Ke){if(!Ke.every(We=>We instanceof Uint8Array))throw new Error("Uint8Array list expected");if(Ke.length===1)return Ke[0];const Re=Ke.reduce((We,qe)=>We+qe.length,0),Fe=new Uint8Array(Re);for(let We=0,qe=0;We<Ke.length;We++){const Ze=Ke[We];Fe.set(Ze,qe),qe+=Ze.length}return Fe}const hexes=Array.from({length:256},(Ke,Re)=>Re.toString(16).padStart(2,"0"));function bytesToHex(Ke){if(!(Ke instanceof Uint8Array))throw new Error("Expected Uint8Array");let Re="";for(let Fe=0;Fe<Ke.length;Fe++)Re+=hexes[Ke[Fe]];return Re}const POW_2_256=BigInt("0x10000000000000000000000000000000000000000000000000000000000000000");function numTo32bStr(Ke){if(typeof Ke!="bigint")throw new Error("Expected bigint");if(!(_0n<=Ke&&Ke<POW_2_256))throw new Error("Expected number < 2^256");return Ke.toString(16).padStart(64,"0")}function numTo32b(Ke){const Re=hexToBytes(numTo32bStr(Ke));if(Re.length!==32)throw new Error("Error: expected 32 bytes");return Re}function numberToHexUnpadded(Ke){const Re=Ke.toString(16);return Re.length&1?`0${Re}`:Re}function hexToNumber(Ke){if(typeof Ke!="string")throw new TypeError("hexToNumber: expected string, got "+typeof Ke);return BigInt(`0x${Ke}`)}function hexToBytes(Ke){if(typeof Ke!="string")throw new TypeError("hexToBytes: expected string, got "+typeof Ke);if(Ke.length%2)throw new Error("hexToBytes: received invalid unpadded hex"+Ke.length);const Re=new Uint8Array(Ke.length/2);for(let Fe=0;Fe<Re.length;Fe++){const We=Fe*2,qe=Ke.slice(We,We+2),Ze=Number.parseInt(qe,16);if(Number.isNaN(Ze)||Ze<0)throw new Error("Invalid byte sequence");Re[Fe]=Ze}return Re}function bytesToNumber(Ke){return hexToNumber(bytesToHex(Ke))}function ensureBytes(Ke){return Ke instanceof Uint8Array?Uint8Array.from(Ke):hexToBytes(Ke)}function normalizeScalar(Ke){if(typeof Ke=="number"&&Number.isSafeInteger(Ke)&&Ke>0)return BigInt(Ke);if(typeof Ke=="bigint"&&isWithinCurveOrder(Ke))return Ke;throw new TypeError("Expected valid private scalar: 0 < scalar < curve.n")}function mod(Ke,Re=CURVE.P){const Fe=Ke%Re;return Fe>=_0n?Fe:Re+Fe}function pow2(Ke,Re){const{P:Fe}=CURVE;let We=Ke;for(;Re-- >_0n;)We*=We,We%=Fe;return We}function sqrtMod(Ke){const{P:Re}=CURVE,Fe=BigInt(6),We=BigInt(11),qe=BigInt(22),Ze=BigInt(23),Xe=BigInt(44),Je=BigInt(88),tr=Ke*Ke*Ke%Re,er=tr*tr*Ke%Re,ir=pow2(er,_3n)*er%Re,lr=pow2(ir,_3n)*er%Re,fr=pow2(lr,_2n)*tr%Re,ur=pow2(fr,We)*fr%Re,mr=pow2(ur,qe)*ur%Re,br=pow2(mr,Xe)*mr%Re,wr=pow2(br,Je)*br%Re,Sr=pow2(wr,Xe)*mr%Re,kr=pow2(Sr,_3n)*er%Re,Er=pow2(kr,Ze)*ur%Re,Ir=pow2(Er,Fe)*tr%Re;return pow2(Ir,_2n)}function invert(Ke,Re=CURVE.P){if(Ke===_0n||Re<=_0n)throw new Error(`invert: expected positive integers, got n=${Ke} mod=${Re}`);let Fe=mod(Ke,Re),We=Re,qe=_0n,Ze=_1n;for(;Fe!==_0n;){const Je=We/Fe,tr=We%Fe,er=qe-Ze*Je;We=Fe,Fe=tr,qe=Ze,Ze=er}if(We!==_1n)throw new Error("invert: does not exist");return mod(qe,Re)}function invertBatch(Ke,Re=CURVE.P){const Fe=new Array(Ke.length),We=Ke.reduce((Ze,Xe,Je)=>Xe===_0n?Ze:(Fe[Je]=Ze,mod(Ze*Xe,Re)),_1n),qe=invert(We,Re);return Ke.reduceRight((Ze,Xe,Je)=>Xe===_0n?Ze:(Fe[Je]=mod(Ze*Fe[Je],Re),mod(Ze*Xe,Re)),qe),Fe}const divNearest=(Ke,Re)=>(Ke+Re/_2n)/Re,ENDO={a1:BigInt("0x3086d221a7d46bcde86c90e49284eb15"),b1:-_1n*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),a2:BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),b2:BigInt("0x3086d221a7d46bcde86c90e49284eb15"),POW_2_128:BigInt("0x100000000000000000000000000000000")};function splitScalarEndo(Ke){const{n:Re}=CURVE,{a1:Fe,b1:We,a2:qe,b2:Ze,POW_2_128:Xe}=ENDO,Je=divNearest(Ze*Ke,Re),tr=divNearest(-We*Ke,Re);let er=mod(Ke-Je*Fe-tr*qe,Re),ir=mod(-Je*We-tr*Ze,Re);const lr=er>Xe,fr=ir>Xe;if(lr&&(er=Re-er),fr&&(ir=Re-ir),er>Xe||ir>Xe)throw new Error("splitScalarEndo: Endomorphism failed, k="+Ke);return{k1neg:lr,k1:er,k2neg:fr,k2:ir}}function truncateHash(Ke){const{n:Re}=CURVE,We=Ke.length*8-256;let qe=bytesToNumber(Ke);return We>0&&(qe=qe>>BigInt(We)),qe>=Re&&(qe-=Re),qe}let _sha256Sync,_hmacSha256Sync;class HmacDrbg{constructor(){this.v=new Uint8Array(32).fill(1),this.k=new Uint8Array(32).fill(0),this.counter=0}hmac(...Re){return utils.hmacSha256(this.k,...Re)}hmacSync(...Re){return _hmacSha256Sync(this.k,...Re)}checkSync(){if(typeof _hmacSha256Sync!="function")throw new ShaError("hmacSha256Sync needs to be set")}incr(){if(this.counter>=1e3)throw new Error("Tried 1,000 k values for sign(), all were invalid");this.counter+=1}async reseed(Re=new Uint8Array){this.k=await this.hmac(this.v,Uint8Array.from([0]),Re),this.v=await this.hmac(this.v),Re.length!==0&&(this.k=await this.hmac(this.v,Uint8Array.from([1]),Re),this.v=await this.hmac(this.v))}reseedSync(Re=new Uint8Array){this.checkSync(),this.k=this.hmacSync(this.v,Uint8Array.from([0]),Re),this.v=this.hmacSync(this.v),Re.length!==0&&(this.k=this.hmacSync(this.v,Uint8Array.from([1]),Re),this.v=this.hmacSync(this.v))}async generate(){return this.incr(),this.v=await this.hmac(this.v),this.v}generateSync(){return this.checkSync(),this.incr(),this.v=this.hmacSync(this.v),this.v}}function isWithinCurveOrder(Ke){return _0n<Ke&&Ke<CURVE.n}function isValidFieldElement(Ke){return _0n<Ke&&Ke<CURVE.P}function kmdToSig(Ke,Re,Fe){const We=bytesToNumber(Ke);if(!isWithinCurveOrder(We))return;const{n:qe}=CURVE,Ze=Point.BASE.multiply(We),Xe=mod(Ze.x,qe);if(Xe===_0n)return;const Je=mod(invert(We,qe)*mod(Re+Fe*Xe,qe),qe);if(Je===_0n)return;const tr=new Signature(Xe,Je),er=(Ze.x===tr.r?0:2)|Number(Ze.y&_1n);return{sig:tr,recovery:er}}function normalizePrivateKey(Ke){let Re;if(typeof Ke=="bigint")Re=Ke;else if(typeof Ke=="number"&&Number.isSafeInteger(Ke)&&Ke>0)Re=BigInt(Ke);else if(typeof Ke=="string"){if(Ke.length!==64)throw new Error("Expected 32 bytes of private key");Re=hexToNumber(Ke)}else if(Ke instanceof Uint8Array){if(Ke.length!==32)throw new Error("Expected 32 bytes of private key");Re=bytesToNumber(Ke)}else throw new TypeError("Expected valid private key");if(!isWithinCurveOrder(Re))throw new Error("Expected private key: 0 < key < n");return Re}function normalizeSignature(Ke){if(Ke instanceof Signature)return Ke.assertValidity(),Ke;try{return Signature.fromDER(Ke)}catch{return Signature.fromCompact(Ke)}}function getPublicKey$1(Ke,Re=!1){return Point.fromPrivateKey(Ke).toRawBytes(Re)}function bits2int(Ke){const Re=Ke.length>32?Ke.slice(0,32):Ke;return bytesToNumber(Re)}function bits2octets(Ke){const Re=bits2int(Ke),Fe=mod(Re,CURVE.n);return int2octets(Fe<_0n?Re:Fe)}function int2octets(Ke){return numTo32b(Ke)}function initSigArgs(Ke,Re,Fe){if(Ke==null)throw new Error(`sign: expected valid message hash, not "${Ke}"`);const We=ensureBytes(Ke),qe=normalizePrivateKey(Re),Ze=[int2octets(qe),bits2octets(We)];if(Fe!=null){Fe===!0&&(Fe=utils.randomBytes(32));const tr=ensureBytes(Fe);if(tr.length!==32)throw new Error("sign: Expected 32 bytes of extra data");Ze.push(tr)}const Xe=concatBytes(...Ze),Je=bits2int(We);return{seed:Xe,m:Je,d:qe}}function finalizeSig(Ke,Re){let{sig:Fe,recovery:We}=Ke;const{canonical:qe,der:Ze,recovered:Xe}=Object.assign({canonical:!0,der:!0},Re);qe&&Fe.hasHighS()&&(Fe=Fe.normalizeS(),We^=1);const Je=Ze?Fe.toDERRawBytes():Fe.toCompactRawBytes();return Xe?[Je,We]:Je}function signSync(Ke,Re,Fe={}){const{seed:We,m:qe,d:Ze}=initSigArgs(Ke,Re,Fe.extraEntropy);let Xe;const Je=new HmacDrbg;for(Je.reseedSync(We);!(Xe=kmdToSig(Je.generateSync(),qe,Ze));)Je.reseedSync();return finalizeSig(Xe,Fe)}Point.BASE._setWindowSize(8);const crypto$1={node:nodeCrypto,web:typeof self=="object"&&"crypto"in self?self.crypto:void 0},TAGGED_HASH_PREFIXES={},utils={bytesToHex,hexToBytes,concatBytes,mod,invert,isValidPrivateKey(Ke){try{return normalizePrivateKey(Ke),!0}catch{return!1}},_bigintTo32Bytes:numTo32b,_normalizePrivateKey:normalizePrivateKey,hashToPrivateKey:Ke=>{if(Ke=ensureBytes(Ke),Ke.length<40||Ke.length>1024)throw new Error("Expected 40-1024 bytes of private key as per FIPS 186");const Re=mod(bytesToNumber(Ke),CURVE.n-_1n)+_1n;return numTo32b(Re)},randomBytes:(Ke=32)=>{if(crypto$1.web)return crypto$1.web.getRandomValues(new Uint8Array(Ke));if(crypto$1.node){const{randomBytes:Re}=crypto$1.node;return Uint8Array.from(Re(Ke))}else throw new Error("The environment doesn't have randomBytes function")},randomPrivateKey:()=>utils.hashToPrivateKey(utils.randomBytes(40)),sha256:async(...Ke)=>{if(crypto$1.web){const Re=await crypto$1.web.subtle.digest("SHA-256",concatBytes(...Ke));return new Uint8Array(Re)}else if(crypto$1.node){const{createHash:Re}=crypto$1.node,Fe=Re("sha256");return Ke.forEach(We=>Fe.update(We)),Uint8Array.from(Fe.digest())}else throw new Error("The environment doesn't have sha256 function")},hmacSha256:async(Ke,...Re)=>{if(crypto$1.web){const Fe=await crypto$1.web.subtle.importKey("raw",Ke,{name:"HMAC",hash:{name:"SHA-256"}},!1,["sign"]),We=concatBytes(...Re),qe=await crypto$1.web.subtle.sign("HMAC",Fe,We);return new Uint8Array(qe)}else if(crypto$1.node){const{createHmac:Fe}=crypto$1.node,We=Fe("sha256",Ke);return Re.forEach(qe=>We.update(qe)),Uint8Array.from(We.digest())}else throw new Error("The environment doesn't have hmac-sha256 function")},sha256Sync:void 0,hmacSha256Sync:void 0,taggedHash:async(Ke,...Re)=>{let Fe=TAGGED_HASH_PREFIXES[Ke];if(Fe===void 0){const We=await utils.sha256(Uint8Array.from(Ke,qe=>qe.charCodeAt(0)));Fe=concatBytes(We,We),TAGGED_HASH_PREFIXES[Ke]=Fe}return utils.sha256(Fe,...Re)},taggedHashSync:(Ke,...Re)=>{if(typeof _sha256Sync!="function")throw new ShaError("sha256Sync is undefined, you need to set it");let Fe=TAGGED_HASH_PREFIXES[Ke];if(Fe===void 0){const We=_sha256Sync(Uint8Array.from(Ke,qe=>qe.charCodeAt(0)));Fe=concatBytes(We,We),TAGGED_HASH_PREFIXES[Ke]=Fe}return _sha256Sync(Fe,...Re)},precompute(Ke=8,Re=Point.BASE){const Fe=Re===Point.BASE?Re:new Point(Re.x,Re.y);return Fe._setWindowSize(Ke),Fe.multiply(_3n),Fe}};Object.defineProperties(utils,{sha256Sync:{configurable:!1,get(){return _sha256Sync},set(Ke){_sha256Sync||(_sha256Sync=Ke)}},hmacSha256Sync:{configurable:!1,get(){return _hmacSha256Sync},set(Ke){_hmacSha256Sync||(_hmacSha256Sync=Ke)}}});utils$1.sha512Sync=(...Ke)=>sha512(utils$1.concatBytes(...Ke));const generatePrivateKey=utils$1.randomPrivateKey,generateKeypair=()=>{const Ke=utils$1.randomPrivateKey(),Re=getPublicKey(Ke),Fe=new Uint8Array(64);return Fe.set(Ke),Fe.set(Re,32),{publicKey:Re,secretKey:Fe}},getPublicKey=sync.getPublicKey;function isOnCurve(Ke){try{return Point$1.fromHex(Ke,!0),!0}catch{return!1}}const sign=(Ke,Re)=>sync.sign(Ke,Re.slice(0,32)),verify=sync.verify,toBuffer=Ke=>buffer.Buffer.isBuffer(Ke)?Ke:Ke instanceof Uint8Array?buffer.Buffer.from(Ke.buffer,Ke.byteOffset,Ke.byteLength):buffer.Buffer.from(Ke);class Struct{constructor(Re){Object.assign(this,Re)}encode(){return buffer.Buffer.from(serialize_1(SOLANA_SCHEMA,this))}static decode(Re){return deserialize_1(SOLANA_SCHEMA,this,Re)}static decodeUnchecked(Re){return deserializeUnchecked_1(SOLANA_SCHEMA,this,Re)}}class Enum extends Struct{constructor(Re){if(super(Re),this.enum="",Object.keys(Re).length!==1)throw new Error("Enum can only take single value");Object.keys(Re).map(Fe=>{this.enum=Fe})}}const SOLANA_SCHEMA=new Map,MAX_SEED_LENGTH=32,PUBLIC_KEY_LENGTH=32;function isPublicKeyData(Ke){return Ke._bn!==void 0}let uniquePublicKeyCounter=1;class PublicKey extends Struct{constructor(Re){if(super({}),this._bn=void 0,isPublicKeyData(Re))this._bn=Re._bn;else{if(typeof Re=="string"){const Fe=bs58.decode(Re);if(Fe.length!=PUBLIC_KEY_LENGTH)throw new Error("Invalid public key input");this._bn=new u(Fe)}else this._bn=new u(Re);if(this._bn.byteLength()>32)throw new Error("Invalid public key input")}}static unique(){const Re=new PublicKey(uniquePublicKeyCounter);return uniquePublicKeyCounter+=1,new PublicKey(Re.toBuffer())}equals(Re){return this._bn.eq(Re._bn)}toBase58(){return bs58.encode(this.toBytes())}toJSON(){return this.toBase58()}toBytes(){return this.toBuffer()}toBuffer(){const Re=this._bn.toArrayLike(buffer.Buffer);if(Re.length===PUBLIC_KEY_LENGTH)return Re;const Fe=buffer.Buffer.alloc(32);return Re.copy(Fe,32-Re.length),Fe}toString(){return this.toBase58()}static async createWithSeed(Re,Fe,We){const qe=buffer.Buffer.concat([Re.toBuffer(),buffer.Buffer.from(Fe),We.toBuffer()]),Ze=sha256$1(qe);return new PublicKey(Ze)}static createProgramAddressSync(Re,Fe){let We=buffer.Buffer.alloc(0);Re.forEach(function(Ze){if(Ze.length>MAX_SEED_LENGTH)throw new TypeError("Max seed length exceeded");We=buffer.Buffer.concat([We,toBuffer(Ze)])}),We=buffer.Buffer.concat([We,Fe.toBuffer(),buffer.Buffer.from("ProgramDerivedAddress")]);const qe=sha256$1(We);if(isOnCurve(qe))throw new Error("Invalid seeds, address must fall off the curve");return new PublicKey(qe)}static async createProgramAddress(Re,Fe){return this.createProgramAddressSync(Re,Fe)}static findProgramAddressSync(Re,Fe){let We=255,qe;for(;We!=0;){try{const Ze=Re.concat(buffer.Buffer.from([We]));qe=this.createProgramAddressSync(Ze,Fe)}catch(Ze){if(Ze instanceof TypeError)throw Ze;We--;continue}return[qe,We]}throw new Error("Unable to find a viable program address nonce")}static async findProgramAddress(Re,Fe){return this.findProgramAddressSync(Re,Fe)}static isOnCurve(Re){const Fe=new PublicKey(Re);return isOnCurve(Fe.toBytes())}}PublicKey.default=new PublicKey("11111111111111111111111111111111");SOLANA_SCHEMA.set(PublicKey,{kind:"struct",fields:[["_bn","u256"]]});class Account{constructor(Re){if(this._publicKey=void 0,this._secretKey=void 0,Re){const Fe=toBuffer(Re);if(Re.length!==64)throw new Error("bad secret key size");this._publicKey=Fe.slice(32,64),this._secretKey=Fe.slice(0,32)}else this._secretKey=toBuffer(generatePrivateKey()),this._publicKey=toBuffer(getPublicKey(this._secretKey))}get publicKey(){return new PublicKey(this._publicKey)}get secretKey(){return buffer.Buffer.concat([this._secretKey,this._publicKey],64)}}const BPF_LOADER_DEPRECATED_PROGRAM_ID=new PublicKey("BPFLoader1111111111111111111111111111111111"),PACKET_DATA_SIZE=1280-40-8,VERSION_PREFIX_MASK=127,SIGNATURE_LENGTH_IN_BYTES=64;class TransactionExpiredBlockheightExceededError extends Error{constructor(Re){super(`Signature ${Re} has expired: block height exceeded.`),this.signature=void 0,this.signature=Re}}Object.defineProperty(TransactionExpiredBlockheightExceededError.prototype,"name",{value:"TransactionExpiredBlockheightExceededError"});class TransactionExpiredTimeoutError extends Error{constructor(Re,Fe){super(`Transaction was not confirmed in ${Fe.toFixed(2)} seconds. It is unknown if it succeeded or failed. Check signature ${Re} using the Solana Explorer or CLI tools.`),this.signature=void 0,this.signature=Re}}Object.defineProperty(TransactionExpiredTimeoutError.prototype,"name",{value:"TransactionExpiredTimeoutError"});class MessageAccountKeys{constructor(Re,Fe){this.staticAccountKeys=void 0,this.accountKeysFromLookups=void 0,this.staticAccountKeys=Re,this.accountKeysFromLookups=Fe}keySegments(){const Re=[this.staticAccountKeys];return this.accountKeysFromLookups&&(Re.push(this.accountKeysFromLookups.writable),Re.push(this.accountKeysFromLookups.readonly)),Re}get(Re){for(const Fe of this.keySegments()){if(Re<Fe.length)return Fe[Re];Re-=Fe.length}}get length(){return this.keySegments().flat().length}compileInstructions(Re){if(this.length>255+1)throw new Error("Account index overflow encountered during compilation");const We=new Map;this.keySegments().flat().forEach((Ze,Xe)=>{We.set(Ze.toBase58(),Xe)});const qe=Ze=>{const Xe=We.get(Ze.toBase58());if(Xe===void 0)throw new Error("Encountered an unknown instruction account key during compilation");return Xe};return Re.map(Ze=>({programIdIndex:qe(Ze.programId),accountKeyIndexes:Ze.keys.map(Xe=>qe(Xe.pubkey)),data:Ze.data}))}}const publicKey=(Ke="publicKey")=>blob(32,Ke),signature=(Ke="signature")=>blob(64,Ke),rustString=(Ke="string")=>{const Re=struct([u32("length"),u32("lengthPadding"),blob(offset(u32(),-8),"chars")],Ke),Fe=Re.decode.bind(Re),We=Re.encode.bind(Re),qe=Re;return qe.decode=(Ze,Xe)=>Fe(Ze,Xe).chars.toString(),qe.encode=(Ze,Xe,Je)=>{const tr={chars:buffer.Buffer.from(Ze,"utf8")};return We(tr,Xe,Je)},qe.alloc=Ze=>u32().span+u32().span+buffer.Buffer.from(Ze,"utf8").length,qe},authorized=(Ke="authorized")=>struct([publicKey("staker"),publicKey("withdrawer")],Ke),lockup=(Ke="lockup")=>struct([ns64("unixTimestamp"),ns64("epoch"),publicKey("custodian")],Ke),voteInit=(Ke="voteInit")=>struct([publicKey("nodePubkey"),publicKey("authorizedVoter"),publicKey("authorizedWithdrawer"),u8("commission")],Ke),voteAuthorizeWithSeedArgs=(Ke="voteAuthorizeWithSeedArgs")=>struct([u32("voteAuthorizationType"),publicKey("currentAuthorityDerivedKeyOwnerPubkey"),rustString("currentAuthorityDerivedKeySeed"),publicKey("newAuthorized")],Ke);function getAlloc(Ke,Re){const Fe=qe=>{if(qe.span>=0)return qe.span;if(typeof qe.alloc=="function")return qe.alloc(Re[qe.property]);if("count"in qe&&"elementLayout"in qe){const Ze=Re[qe.property];if(Array.isArray(Ze))return Ze.length*Fe(qe.elementLayout)}else if("fields"in qe)return getAlloc({layout:qe},Re[qe.property]);return 0};let We=0;return Ke.layout.fields.forEach(qe=>{We+=Fe(qe)}),We}function decodeLength(Ke){let Re=0,Fe=0;for(;;){let We=Ke.shift();if(Re|=(We&127)<<Fe*7,Fe+=1,(We&128)===0)break}return Re}function encodeLength(Ke,Re){let Fe=Re;for(;;){let We=Fe&127;if(Fe>>=7,Fe==0){Ke.push(We);break}else We|=128,Ke.push(We)}}function assert(Ke,Re){if(!Ke)throw new Error(Re||"Assertion failed")}class CompiledKeys{constructor(Re,Fe){this.payer=void 0,this.keyMetaMap=void 0,this.payer=Re,this.keyMetaMap=Fe}static compile(Re,Fe){const We=new Map,qe=Xe=>{const Je=Xe.toBase58();let tr=We.get(Je);return tr===void 0&&(tr={isSigner:!1,isWritable:!1,isInvoked:!1},We.set(Je,tr)),tr},Ze=qe(Fe);Ze.isSigner=!0,Ze.isWritable=!0;for(const Xe of Re){qe(Xe.programId).isInvoked=!0;for(const Je of Xe.keys){const tr=qe(Je.pubkey);tr.isSigner||(tr.isSigner=Je.isSigner),tr.isWritable||(tr.isWritable=Je.isWritable)}}return new CompiledKeys(Fe,We)}getMessageComponents(){const Re=[...this.keyMetaMap.entries()];assert(Re.length<=256,"Max static account keys length exceeded");const Fe=Re.filter(([,tr])=>tr.isSigner&&tr.isWritable),We=Re.filter(([,tr])=>tr.isSigner&&!tr.isWritable),qe=Re.filter(([,tr])=>!tr.isSigner&&tr.isWritable),Ze=Re.filter(([,tr])=>!tr.isSigner&&!tr.isWritable),Xe={numRequiredSignatures:Fe.length+We.length,numReadonlySignedAccounts:We.length,numReadonlyUnsignedAccounts:Ze.length};{assert(Fe.length>0,"Expected at least one writable signer key");const[tr]=Fe[0];assert(tr===this.payer.toBase58(),"Expected first writable signer key to be the fee payer")}const Je=[...Fe.map(([tr])=>new PublicKey(tr)),...We.map(([tr])=>new PublicKey(tr)),...qe.map(([tr])=>new PublicKey(tr)),...Ze.map(([tr])=>new PublicKey(tr))];return[Xe,Je]}extractTableLookup(Re){const[Fe,We]=this.drainKeysFoundInLookupTable(Re.state.addresses,Xe=>!Xe.isSigner&&!Xe.isInvoked&&Xe.isWritable),[qe,Ze]=this.drainKeysFoundInLookupTable(Re.state.addresses,Xe=>!Xe.isSigner&&!Xe.isInvoked&&!Xe.isWritable);if(!(Fe.length===0&&qe.length===0))return[{accountKey:Re.key,writableIndexes:Fe,readonlyIndexes:qe},{writable:We,readonly:Ze}]}drainKeysFoundInLookupTable(Re,Fe){const We=new Array,qe=new Array;for(const[Ze,Xe]of this.keyMetaMap.entries())if(Fe(Xe)){const Je=new PublicKey(Ze),tr=Re.findIndex(er=>er.equals(Je));tr>=0&&(assert(tr<256,"Max lookup table index exceeded"),We.push(tr),qe.push(Je),this.keyMetaMap.delete(Ze))}return[We,qe]}}class Message{constructor(Re){this.header=void 0,this.accountKeys=void 0,this.recentBlockhash=void 0,this.instructions=void 0,this.indexToProgramIds=new Map,this.header=Re.header,this.accountKeys=Re.accountKeys.map(Fe=>new PublicKey(Fe)),this.recentBlockhash=Re.recentBlockhash,this.instructions=Re.instructions,this.instructions.forEach(Fe=>this.indexToProgramIds.set(Fe.programIdIndex,this.accountKeys[Fe.programIdIndex]))}get version(){return"legacy"}get staticAccountKeys(){return this.accountKeys}get compiledInstructions(){return this.instructions.map(Re=>({programIdIndex:Re.programIdIndex,accountKeyIndexes:Re.accounts,data:bs58.decode(Re.data)}))}get addressTableLookups(){return[]}getAccountKeys(){return new MessageAccountKeys(this.staticAccountKeys)}static compile(Re){const Fe=CompiledKeys.compile(Re.instructions,Re.payerKey),[We,qe]=Fe.getMessageComponents(),Xe=new MessageAccountKeys(qe).compileInstructions(Re.instructions).map(Je=>({programIdIndex:Je.programIdIndex,accounts:Je.accountKeyIndexes,data:bs58.encode(Je.data)}));return new Message({header:We,accountKeys:qe,recentBlockhash:Re.recentBlockhash,instructions:Xe})}isAccountSigner(Re){return Re<this.header.numRequiredSignatures}isAccountWritable(Re){const Fe=this.header.numRequiredSignatures;if(Re>=this.header.numRequiredSignatures){const We=Re-Fe,Ze=this.accountKeys.length-Fe-this.header.numReadonlyUnsignedAccounts;return We<Ze}else{const We=Fe-this.header.numReadonlySignedAccounts;return Re<We}}isProgramId(Re){return this.indexToProgramIds.has(Re)}programIds(){return[...this.indexToProgramIds.values()]}nonProgramIds(){return this.accountKeys.filter((Re,Fe)=>!this.isProgramId(Fe))}serialize(){const Re=this.accountKeys.length;let Fe=[];encodeLength(Fe,Re);const We=this.instructions.map(lr=>{const{accounts:fr,programIdIndex:ur}=lr,mr=Array.from(bs58.decode(lr.data));let br=[];encodeLength(br,fr.length);let wr=[];return encodeLength(wr,mr.length),{programIdIndex:ur,keyIndicesCount:buffer.Buffer.from(br),keyIndices:fr,dataLength:buffer.Buffer.from(wr),data:mr}});let qe=[];encodeLength(qe,We.length);let Ze=buffer.Buffer.alloc(PACKET_DATA_SIZE);buffer.Buffer.from(qe).copy(Ze);let Xe=qe.length;We.forEach(lr=>{const ur=struct([u8("programIdIndex"),blob(lr.keyIndicesCount.length,"keyIndicesCount"),seq(u8("keyIndex"),lr.keyIndices.length,"keyIndices"),blob(lr.dataLength.length,"dataLength"),seq(u8("userdatum"),lr.data.length,"data")]).encode(lr,Ze,Xe);Xe+=ur}),Ze=Ze.slice(0,Xe);const Je=struct([blob(1,"numRequiredSignatures"),blob(1,"numReadonlySignedAccounts"),blob(1,"numReadonlyUnsignedAccounts"),blob(Fe.length,"keyCount"),seq(publicKey("key"),Re,"keys"),publicKey("recentBlockhash")]),tr={numRequiredSignatures:buffer.Buffer.from([this.header.numRequiredSignatures]),numReadonlySignedAccounts:buffer.Buffer.from([this.header.numReadonlySignedAccounts]),numReadonlyUnsignedAccounts:buffer.Buffer.from([this.header.numReadonlyUnsignedAccounts]),keyCount:buffer.Buffer.from(Fe),keys:this.accountKeys.map(lr=>toBuffer(lr.toBytes())),recentBlockhash:bs58.decode(this.recentBlockhash)};let er=buffer.Buffer.alloc(2048);const ir=Je.encode(tr,er);return Ze.copy(er,ir),er.slice(0,ir+Ze.length)}static from(Re){let Fe=[...Re];const We=Fe.shift();if(We!==(We&VERSION_PREFIX_MASK))throw new Error("Versioned messages must be deserialized with VersionedMessage.deserialize()");const qe=Fe.shift(),Ze=Fe.shift(),Xe=decodeLength(Fe);let Je=[];for(let fr=0;fr<Xe;fr++){const ur=Fe.slice(0,PUBLIC_KEY_LENGTH);Fe=Fe.slice(PUBLIC_KEY_LENGTH),Je.push(new PublicKey(buffer.Buffer.from(ur)))}const tr=Fe.slice(0,PUBLIC_KEY_LENGTH);Fe=Fe.slice(PUBLIC_KEY_LENGTH);const er=decodeLength(Fe);let ir=[];for(let fr=0;fr<er;fr++){const ur=Fe.shift(),mr=decodeLength(Fe),br=Fe.slice(0,mr);Fe=Fe.slice(mr);const wr=decodeLength(Fe),Sr=Fe.slice(0,wr),kr=bs58.encode(buffer.Buffer.from(Sr));Fe=Fe.slice(wr),ir.push({programIdIndex:ur,accounts:br,data:kr})}const lr={header:{numRequiredSignatures:We,numReadonlySignedAccounts:qe,numReadonlyUnsignedAccounts:Ze},recentBlockhash:bs58.encode(buffer.Buffer.from(tr)),accountKeys:Je,instructions:ir};return new Message(lr)}}class MessageV0{constructor(Re){this.header=void 0,this.staticAccountKeys=void 0,this.recentBlockhash=void 0,this.compiledInstructions=void 0,this.addressTableLookups=void 0,this.header=Re.header,this.staticAccountKeys=Re.staticAccountKeys,this.recentBlockhash=Re.recentBlockhash,this.compiledInstructions=Re.compiledInstructions,this.addressTableLookups=Re.addressTableLookups}get version(){return 0}get numAccountKeysFromLookups(){let Re=0;for(const Fe of this.addressTableLookups)Re+=Fe.readonlyIndexes.length+Fe.writableIndexes.length;return Re}getAccountKeys(Re){let Fe;if(Re&&"accountKeysFromLookups"in Re&&Re.accountKeysFromLookups){if(this.numAccountKeysFromLookups!=Re.accountKeysFromLookups.writable.length+Re.accountKeysFromLookups.readonly.length)throw new Error("Failed to get account keys because of a mismatch in the number of account keys from lookups");Fe=Re.accountKeysFromLookups}else if(Re&&"addressLookupTableAccounts"in Re&&Re.addressLookupTableAccounts)Fe=this.resolveAddressTableLookups(Re.addressLookupTableAccounts);else if(this.addressTableLookups.length>0)throw new Error("Failed to get account keys because address table lookups were not resolved");return new MessageAccountKeys(this.staticAccountKeys,Fe)}isAccountSigner(Re){return Re<this.header.numRequiredSignatures}isAccountWritable(Re){const Fe=this.header.numRequiredSignatures,We=this.staticAccountKeys.length;if(Re>=We){const qe=Re-We,Ze=this.addressTableLookups.reduce((Xe,Je)=>Xe+Je.writableIndexes.length,0);return qe<Ze}else if(Re>=this.header.numRequiredSignatures){const qe=Re-Fe,Xe=We-Fe-this.header.numReadonlyUnsignedAccounts;return qe<Xe}else{const qe=Fe-this.header.numReadonlySignedAccounts;return Re<qe}}resolveAddressTableLookups(Re){const Fe={writable:[],readonly:[]};for(const We of this.addressTableLookups){const qe=Re.find(Ze=>Ze.key.equals(We.accountKey));if(!qe)throw new Error(`Failed to find address lookup table account for table key ${We.accountKey.toBase58()}`);for(const Ze of We.writableIndexes)if(Ze<qe.state.addresses.length)Fe.writable.push(qe.state.addresses[Ze]);else throw new Error(`Failed to find address for index ${Ze} in address lookup table ${We.accountKey.toBase58()}`);for(const Ze of We.readonlyIndexes)if(Ze<qe.state.addresses.length)Fe.readonly.push(qe.state.addresses[Ze]);else throw new Error(`Failed to find address for index ${Ze} in address lookup table ${We.accountKey.toBase58()}`)}return Fe}static compile(Re){const Fe=CompiledKeys.compile(Re.instructions,Re.payerKey),We=new Array,qe={writable:new Array,readonly:new Array},Ze=Re.addressLookupTableAccounts||[];for(const ir of Ze){const lr=Fe.extractTableLookup(ir);if(lr!==void 0){const[fr,{writable:ur,readonly:mr}]=lr;We.push(fr),qe.writable.push(...ur),qe.readonly.push(...mr)}}const[Xe,Je]=Fe.getMessageComponents(),er=new MessageAccountKeys(Je,qe).compileInstructions(Re.instructions);return new MessageV0({header:Xe,staticAccountKeys:Je,recentBlockhash:Re.recentBlockhash,compiledInstructions:er,addressTableLookups:We})}serialize(){const Re=Array();encodeLength(Re,this.staticAccountKeys.length);const Fe=this.serializeInstructions(),We=Array();encodeLength(We,this.compiledInstructions.length);const qe=this.serializeAddressTableLookups(),Ze=Array();encodeLength(Ze,this.addressTableLookups.length);const Xe=struct([u8("prefix"),struct([u8("numRequiredSignatures"),u8("numReadonlySignedAccounts"),u8("numReadonlyUnsignedAccounts")],"header"),blob(Re.length,"staticAccountKeysLength"),seq(publicKey(),this.staticAccountKeys.length,"staticAccountKeys"),publicKey("recentBlockhash"),blob(We.length,"instructionsLength"),blob(Fe.length,"serializedInstructions"),blob(Ze.length,"addressTableLookupsLength"),blob(qe.length,"serializedAddressTableLookups")]),Je=new Uint8Array(PACKET_DATA_SIZE),tr=1<<7,er=Xe.encode({prefix:tr,header:this.header,staticAccountKeysLength:new Uint8Array(Re),staticAccountKeys:this.staticAccountKeys.map(ir=>ir.toBytes()),recentBlockhash:bs58.decode(this.recentBlockhash),instructionsLength:new Uint8Array(We),serializedInstructions:Fe,addressTableLookupsLength:new Uint8Array(Ze),serializedAddressTableLookups:qe},Je);return Je.slice(0,er)}serializeInstructions(){let Re=0;const Fe=new Uint8Array(PACKET_DATA_SIZE);for(const We of this.compiledInstructions){const qe=Array();encodeLength(qe,We.accountKeyIndexes.length);const Ze=Array();encodeLength(Ze,We.data.length);const Xe=struct([u8("programIdIndex"),blob(qe.length,"encodedAccountKeyIndexesLength"),seq(u8(),We.accountKeyIndexes.length,"accountKeyIndexes"),blob(Ze.length,"encodedDataLength"),blob(We.data.length,"data")]);Re+=Xe.encode({programIdIndex:We.programIdIndex,encodedAccountKeyIndexesLength:new Uint8Array(qe),accountKeyIndexes:We.accountKeyIndexes,encodedDataLength:new Uint8Array(Ze),data:We.data},Fe,Re)}return Fe.slice(0,Re)}serializeAddressTableLookups(){let Re=0;const Fe=new Uint8Array(PACKET_DATA_SIZE);for(const We of this.addressTableLookups){const qe=Array();encodeLength(qe,We.writableIndexes.length);const Ze=Array();encodeLength(Ze,We.readonlyIndexes.length);const Xe=struct([publicKey("accountKey"),blob(qe.length,"encodedWritableIndexesLength"),seq(u8(),We.writableIndexes.length,"writableIndexes"),blob(Ze.length,"encodedReadonlyIndexesLength"),seq(u8(),We.readonlyIndexes.length,"readonlyIndexes")]);Re+=Xe.encode({accountKey:We.accountKey.toBytes(),encodedWritableIndexesLength:new Uint8Array(qe),writableIndexes:We.writableIndexes,encodedReadonlyIndexesLength:new Uint8Array(Ze),readonlyIndexes:We.readonlyIndexes},Fe,Re)}return Fe.slice(0,Re)}static deserialize(Re){let Fe=[...Re];const We=Fe.shift(),qe=We&VERSION_PREFIX_MASK;assert(We!==qe,"Expected versioned message but received legacy message");const Ze=qe;assert(Ze===0,`Expected versioned message with version 0 but found version ${Ze}`);const Xe={numRequiredSignatures:Fe.shift(),numReadonlySignedAccounts:Fe.shift(),numReadonlyUnsignedAccounts:Fe.shift()},Je=[],tr=decodeLength(Fe);for(let mr=0;mr<tr;mr++)Je.push(new PublicKey(Fe.splice(0,PUBLIC_KEY_LENGTH)));const er=bs58.encode(Fe.splice(0,PUBLIC_KEY_LENGTH)),ir=decodeLength(Fe),lr=[];for(let mr=0;mr<ir;mr++){const br=Fe.shift(),wr=decodeLength(Fe),Sr=Fe.splice(0,wr),kr=decodeLength(Fe),Er=new Uint8Array(Fe.splice(0,kr));lr.push({programIdIndex:br,accountKeyIndexes:Sr,data:Er})}const fr=decodeLength(Fe),ur=[];for(let mr=0;mr<fr;mr++){const br=new PublicKey(Fe.splice(0,PUBLIC_KEY_LENGTH)),wr=decodeLength(Fe),Sr=Fe.splice(0,wr),kr=decodeLength(Fe),Er=Fe.splice(0,kr);ur.push({accountKey:br,writableIndexes:Sr,readonlyIndexes:Er})}return new MessageV0({header:Xe,staticAccountKeys:Je,recentBlockhash:er,compiledInstructions:lr,addressTableLookups:ur})}}const VersionedMessage={deserializeMessageVersion(Ke){const Re=Ke[0],Fe=Re&VERSION_PREFIX_MASK;return Fe===Re?"legacy":Fe},deserialize:Ke=>{const Re=VersionedMessage.deserializeMessageVersion(Ke);if(Re==="legacy")return Message.from(Ke);if(Re===0)return MessageV0.deserialize(Ke);throw new Error(`Transaction message version ${Re} deserialization is not supported`)}};let TransactionStatus;(function(Ke){Ke[Ke.BLOCKHEIGHT_EXCEEDED=0]="BLOCKHEIGHT_EXCEEDED",Ke[Ke.PROCESSED=1]="PROCESSED",Ke[Ke.TIMED_OUT=2]="TIMED_OUT"})(TransactionStatus||(TransactionStatus={}));const DEFAULT_SIGNATURE=buffer.Buffer.alloc(SIGNATURE_LENGTH_IN_BYTES).fill(0);class TransactionInstruction{constructor(Re){this.keys=void 0,this.programId=void 0,this.data=buffer.Buffer.alloc(0),this.programId=Re.programId,this.keys=Re.keys,Re.data&&(this.data=Re.data)}toJSON(){return{keys:this.keys.map(({pubkey:Re,isSigner:Fe,isWritable:We})=>({pubkey:Re.toJSON(),isSigner:Fe,isWritable:We})),programId:this.programId.toJSON(),data:[...this.data]}}}class Transaction{get signature(){return this.signatures.length>0?this.signatures[0].signature:null}constructor(Re){if(this.signatures=[],this.feePayer=void 0,this.instructions=[],this.recentBlockhash=void 0,this.lastValidBlockHeight=void 0,this.nonceInfo=void 0,this._message=void 0,this._json=void 0,!!Re)if(Re.feePayer&&(this.feePayer=Re.feePayer),Re.signatures&&(this.signatures=Re.signatures),Object.prototype.hasOwnProperty.call(Re,"lastValidBlockHeight")){const{blockhash:Fe,lastValidBlockHeight:We}=Re;this.recentBlockhash=Fe,this.lastValidBlockHeight=We}else{const{recentBlockhash:Fe,nonceInfo:We}=Re;We&&(this.nonceInfo=We),this.recentBlockhash=Fe}}toJSON(){return{recentBlockhash:this.recentBlockhash||null,feePayer:this.feePayer?this.feePayer.toJSON():null,nonceInfo:this.nonceInfo?{nonce:this.nonceInfo.nonce,nonceInstruction:this.nonceInfo.nonceInstruction.toJSON()}:null,instructions:this.instructions.map(Re=>Re.toJSON()),signers:this.signatures.map(({publicKey:Re})=>Re.toJSON())}}add(...Re){if(Re.length===0)throw new Error("No instructions");return Re.forEach(Fe=>{"instructions"in Fe?this.instructions=this.instructions.concat(Fe.instructions):"data"in Fe&&"programId"in Fe&&"keys"in Fe?this.instructions.push(Fe):this.instructions.push(new TransactionInstruction(Fe))}),this}compileMessage(){if(this._message&&JSON.stringify(this.toJSON())===JSON.stringify(this._json))return this._message;let Re,Fe;if(this.nonceInfo?(Re=this.nonceInfo.nonce,this.instructions[0]!=this.nonceInfo.nonceInstruction?Fe=[this.nonceInfo.nonceInstruction,...this.instructions]:Fe=this.instructions):(Re=this.recentBlockhash,Fe=this.instructions),!Re)throw new Error("Transaction recentBlockhash required");Fe.length<1&&console.warn("No instructions provided");let We;if(this.feePayer)We=this.feePayer;else if(this.signatures.length>0&&this.signatures[0].publicKey)We=this.signatures[0].publicKey;else throw new Error("Transaction fee payer required");for(let br=0;br<Fe.length;br++)if(Fe[br].programId===void 0)throw new Error(`Transaction instruction index ${br} has undefined program id`);const qe=[],Ze=[];Fe.forEach(br=>{br.keys.forEach(Sr=>{Ze.push({...Sr})});const wr=br.programId.toString();qe.includes(wr)||qe.push(wr)}),qe.forEach(br=>{Ze.push({pubkey:new PublicKey(br),isSigner:!1,isWritable:!1})});const Xe=[];Ze.forEach(br=>{const wr=br.pubkey.toString(),Sr=Xe.findIndex(kr=>kr.pubkey.toString()===wr);Sr>-1?(Xe[Sr].isWritable=Xe[Sr].isWritable||br.isWritable,Xe[Sr].isSigner=Xe[Sr].isSigner||br.isSigner):Xe.push(br)}),Xe.sort(function(br,wr){return br.isSigner!==wr.isSigner?br.isSigner?-1:1:br.isWritable!==wr.isWritable?br.isWritable?-1:1:br.pubkey.toBase58().localeCompare(wr.pubkey.toBase58())});const Je=Xe.findIndex(br=>br.pubkey.equals(We));if(Je>-1){const[br]=Xe.splice(Je,1);br.isSigner=!0,br.isWritable=!0,Xe.unshift(br)}else Xe.unshift({pubkey:We,isSigner:!0,isWritable:!0});for(const br of this.signatures){const wr=Xe.findIndex(Sr=>Sr.pubkey.equals(br.publicKey));if(wr>-1)Xe[wr].isSigner||(Xe[wr].isSigner=!0,console.warn("Transaction references a signature that is unnecessary, only the fee payer and instruction signer accounts should sign a transaction. This behavior is deprecated and will throw an error in the next major version release."));else throw new Error(`unknown signer: ${br.publicKey.toString()}`)}let tr=0,er=0,ir=0;const lr=[],fr=[];Xe.forEach(({pubkey:br,isSigner:wr,isWritable:Sr})=>{wr?(lr.push(br.toString()),tr+=1,Sr||(er+=1)):(fr.push(br.toString()),Sr||(ir+=1))});const ur=lr.concat(fr),mr=Fe.map(br=>{const{data:wr,programId:Sr}=br;return{programIdIndex:ur.indexOf(Sr.toString()),accounts:br.keys.map(kr=>ur.indexOf(kr.pubkey.toString())),data:bs58.encode(wr)}});return mr.forEach(br=>{assert(br.programIdIndex>=0),br.accounts.forEach(wr=>assert(wr>=0))}),new Message({header:{numRequiredSignatures:tr,numReadonlySignedAccounts:er,numReadonlyUnsignedAccounts:ir},accountKeys:ur,recentBlockhash:Re,instructions:mr})}_compile(){const Re=this.compileMessage(),Fe=Re.accountKeys.slice(0,Re.header.numRequiredSignatures);return this.signatures.length===Fe.length&&this.signatures.every((qe,Ze)=>Fe[Ze].equals(qe.publicKey))||(this.signatures=Fe.map(We=>({signature:null,publicKey:We}))),Re}serializeMessage(){return this._compile().serialize()}async getEstimatedFee(Re){return(await Re.getFeeForMessage(this.compileMessage())).value}setSigners(...Re){if(Re.length===0)throw new Error("No signers");const Fe=new Set;this.signatures=Re.filter(We=>{const qe=We.toString();return Fe.has(qe)?!1:(Fe.add(qe),!0)}).map(We=>({signature:null,publicKey:We}))}sign(...Re){if(Re.length===0)throw new Error("No signers");const Fe=new Set,We=[];for(const Ze of Re){const Xe=Ze.publicKey.toString();Fe.has(Xe)||(Fe.add(Xe),We.push(Ze))}this.signatures=We.map(Ze=>({signature:null,publicKey:Ze.publicKey}));const qe=this._compile();this._partialSign(qe,...We)}partialSign(...Re){if(Re.length===0)throw new Error("No signers");const Fe=new Set,We=[];for(const Ze of Re){const Xe=Ze.publicKey.toString();Fe.has(Xe)||(Fe.add(Xe),We.push(Ze))}const qe=this._compile();this._partialSign(qe,...We)}_partialSign(Re,...Fe){const We=Re.serialize();Fe.forEach(qe=>{const Ze=sign(We,qe.secretKey);this._addSignature(qe.publicKey,toBuffer(Ze))})}addSignature(Re,Fe){this._compile(),this._addSignature(Re,Fe)}_addSignature(Re,Fe){assert(Fe.length===64);const We=this.signatures.findIndex(qe=>Re.equals(qe.publicKey));if(We<0)throw new Error(`unknown signer: ${Re.toString()}`);this.signatures[We].signature=buffer.Buffer.from(Fe)}verifySignatures(){return this._verifySignatures(this.serializeMessage(),!0)}_verifySignatures(Re,Fe){for(const{signature:We,publicKey:qe}of this.signatures)if(We===null){if(Fe)return!1}else if(!verify(We,Re,qe.toBuffer()))return!1;return!0}serialize(Re){const{requireAllSignatures:Fe,verifySignatures:We}=Object.assign({requireAllSignatures:!0,verifySignatures:!0},Re),qe=this.serializeMessage();if(We&&!this._verifySignatures(qe,Fe))throw new Error("Signature verification failed");return this._serialize(qe)}_serialize(Re){const{signatures:Fe}=this,We=[];encodeLength(We,Fe.length);const qe=We.length+Fe.length*64+Re.length,Ze=buffer.Buffer.alloc(qe);return assert(Fe.length<256),buffer.Buffer.from(We).copy(Ze,0),Fe.forEach(({signature:Xe},Je)=>{Xe!==null&&(assert(Xe.length===64,"signature has invalid length"),buffer.Buffer.from(Xe).copy(Ze,We.length+Je*64))}),Re.copy(Ze,We.length+Fe.length*64),assert(Ze.length<=PACKET_DATA_SIZE,`Transaction too large: ${Ze.length} > ${PACKET_DATA_SIZE}`),Ze}get keys(){return assert(this.instructions.length===1),this.instructions[0].keys.map(Re=>Re.pubkey)}get programId(){return assert(this.instructions.length===1),this.instructions[0].programId}get data(){return assert(this.instructions.length===1),this.instructions[0].data}static from(Re){let Fe=[...Re];const We=decodeLength(Fe);let qe=[];for(let Ze=0;Ze<We;Ze++){const Xe=Fe.slice(0,SIGNATURE_LENGTH_IN_BYTES);Fe=Fe.slice(SIGNATURE_LENGTH_IN_BYTES),qe.push(bs58.encode(buffer.Buffer.from(Xe)))}return Transaction.populate(Message.from(Fe),qe)}static populate(Re,Fe=[]){const We=new Transaction;return We.recentBlockhash=Re.recentBlockhash,Re.header.numRequiredSignatures>0&&(We.feePayer=Re.accountKeys[0]),Fe.forEach((qe,Ze)=>{const Xe={signature:qe==bs58.encode(DEFAULT_SIGNATURE)?null:bs58.decode(qe),publicKey:Re.accountKeys[Ze]};We.signatures.push(Xe)}),Re.instructions.forEach(qe=>{const Ze=qe.accounts.map(Xe=>{const Je=Re.accountKeys[Xe];return{pubkey:Je,isSigner:We.signatures.some(tr=>tr.publicKey.toString()===Je.toString())||Re.isAccountSigner(Xe),isWritable:Re.isAccountWritable(Xe)}});We.instructions.push(new TransactionInstruction({keys:Ze,programId:Re.accountKeys[qe.programIdIndex],data:bs58.decode(qe.data)}))}),We._message=Re,We._json=We.toJSON(),We}}class TransactionMessage{constructor(Re){this.payerKey=void 0,this.instructions=void 0,this.recentBlockhash=void 0,this.payerKey=Re.payerKey,this.instructions=Re.instructions,this.recentBlockhash=Re.recentBlockhash}static decompile(Re,Fe){const{header:We,compiledInstructions:qe,recentBlockhash:Ze}=Re,{numRequiredSignatures:Xe,numReadonlySignedAccounts:Je,numReadonlyUnsignedAccounts:tr}=We,er=Xe-Je;assert(er>0,"Message header is invalid");const ir=Re.staticAccountKeys.length-tr;assert(ir>=0,"Message header is invalid");const lr=Re.getAccountKeys(Fe),fr=lr.get(0);if(fr===void 0)throw new Error("Failed to decompile message because no account keys were found");const ur=[];for(const mr of qe){const br=[];for(const Sr of mr.accountKeyIndexes){const kr=lr.get(Sr);if(kr===void 0)throw new Error(`Failed to find key for account key index ${Sr}`);const Er=Sr<Xe;let Ir;Er?Ir=Sr<er:Sr<lr.staticAccountKeys.length?Ir=Sr-Xe<ir:Ir=Sr-lr.staticAccountKeys.length<lr.accountKeysFromLookups.writable.length,br.push({pubkey:kr,isSigner:Sr<We.numRequiredSignatures,isWritable:Ir})}const wr=lr.get(mr.programIdIndex);if(wr===void 0)throw new Error(`Failed to find program id for program id index ${mr.programIdIndex}`);ur.push(new TransactionInstruction({programId:wr,data:toBuffer(mr.data),keys:br}))}return new TransactionMessage({payerKey:fr,instructions:ur,recentBlockhash:Ze})}compileToLegacyMessage(){return Message.compile({payerKey:this.payerKey,recentBlockhash:this.recentBlockhash,instructions:this.instructions})}compileToV0Message(Re){return MessageV0.compile({payerKey:this.payerKey,recentBlockhash:this.recentBlockhash,instructions:this.instructions,addressLookupTableAccounts:Re})}}class VersionedTransaction{get version(){return this.message.version}constructor(Re,Fe){if(this.signatures=void 0,this.message=void 0,Fe!==void 0)assert(Fe.length===Re.header.numRequiredSignatures,"Expected signatures length to be equal to the number of required signatures"),this.signatures=Fe;else{const We=[];for(let qe=0;qe<Re.header.numRequiredSignatures;qe++)We.push(new Uint8Array(SIGNATURE_LENGTH_IN_BYTES));this.signatures=We}this.message=Re}serialize(){const Re=this.message.serialize(),Fe=Array();encodeLength(Fe,this.signatures.length);const We=struct([blob(Fe.length,"encodedSignaturesLength"),seq(signature(),this.signatures.length,"signatures"),blob(Re.length,"serializedMessage")]),qe=new Uint8Array(2048),Ze=We.encode({encodedSignaturesLength:new Uint8Array(Fe),signatures:this.signatures,serializedMessage:Re},qe);return qe.slice(0,Ze)}static deserialize(Re){let Fe=[...Re];const We=[],qe=decodeLength(Fe);for(let Xe=0;Xe<qe;Xe++)We.push(new Uint8Array(Fe.splice(0,SIGNATURE_LENGTH_IN_BYTES)));const Ze=VersionedMessage.deserialize(new Uint8Array(Fe));return new VersionedTransaction(Ze,We)}sign(Re){const Fe=this.message.serialize(),We=this.message.staticAccountKeys.slice(0,this.message.header.numRequiredSignatures);for(const qe of Re){const Ze=We.findIndex(Xe=>Xe.equals(qe.publicKey));assert(Ze>=0,`Cannot sign with non signer key ${qe.publicKey.toBase58()}`),this.signatures[Ze]=sign(Fe,qe.secretKey)}}addSignature(Re,Fe){assert(Fe.byteLength===64,"Signature must be 64 bytes long");const qe=this.message.staticAccountKeys.slice(0,this.message.header.numRequiredSignatures).findIndex(Ze=>Ze.equals(Re));assert(qe>=0,`Can not add signature; \`${Re.toBase58()}\` is not required to sign this transaction`),this.signatures[qe]=Fe}}const SYSVAR_CLOCK_PUBKEY=new PublicKey("SysvarC1ock11111111111111111111111111111111"),SYSVAR_EPOCH_SCHEDULE_PUBKEY=new PublicKey("SysvarEpochSchedu1e111111111111111111111111"),SYSVAR_INSTRUCTIONS_PUBKEY=new PublicKey("Sysvar1nstructions1111111111111111111111111"),SYSVAR_RECENT_BLOCKHASHES_PUBKEY=new PublicKey("SysvarRecentB1ockHashes11111111111111111111"),SYSVAR_RENT_PUBKEY=new PublicKey("SysvarRent111111111111111111111111111111111"),SYSVAR_REWARDS_PUBKEY=new PublicKey("SysvarRewards111111111111111111111111111111"),SYSVAR_SLOT_HASHES_PUBKEY=new PublicKey("SysvarS1otHashes111111111111111111111111111"),SYSVAR_SLOT_HISTORY_PUBKEY=new PublicKey("SysvarS1otHistory11111111111111111111111111"),SYSVAR_STAKE_HISTORY_PUBKEY=new PublicKey("SysvarStakeHistory1111111111111111111111111");async function sendAndConfirmTransaction(Ke,Re,Fe,We){const qe=We&&{skipPreflight:We.skipPreflight,preflightCommitment:We.preflightCommitment||We.commitment,maxRetries:We.maxRetries,minContextSlot:We.minContextSlot},Ze=await Ke.sendTransaction(Re,Fe,qe),Xe=Re.recentBlockhash!=null&&Re.lastValidBlockHeight!=null?(await Ke.confirmTransaction({signature:Ze,blockhash:Re.recentBlockhash,lastValidBlockHeight:Re.lastValidBlockHeight},We&&We.commitment)).value:(await Ke.confirmTransaction(Ze,We&&We.commitment)).value;if(Xe.err)throw new Error(`Transaction ${Ze} failed (${JSON.stringify(Xe)})`);return Ze}function sleep(Ke){return new Promise(Re=>setTimeout(Re,Ke))}function encodeData(Ke,Re){const Fe=Ke.layout.span>=0?Ke.layout.span:getAlloc(Ke,Re),We=buffer.Buffer.alloc(Fe),qe=Object.assign({instruction:Ke.index},Re);return Ke.layout.encode(qe,We),We}function decodeData$1(Ke,Re){let Fe;try{Fe=Ke.layout.decode(Re)}catch(We){throw new Error("invalid instruction; "+We)}if(Fe.instruction!==Ke.index)throw new Error(`invalid instruction; instruction index mismatch ${Fe.instruction} != ${Ke.index}`);return Fe}const FeeCalculatorLayout=nu64("lamportsPerSignature"),NonceAccountLayout=struct([u32("version"),u32("state"),publicKey("authorizedPubkey"),publicKey("nonce"),struct([FeeCalculatorLayout],"feeCalculator")]),NONCE_ACCOUNT_LENGTH=NonceAccountLayout.span;class NonceAccount{constructor(Re){this.authorizedPubkey=void 0,this.nonce=void 0,this.feeCalculator=void 0,this.authorizedPubkey=Re.authorizedPubkey,this.nonce=Re.nonce,this.feeCalculator=Re.feeCalculator}static fromAccountData(Re){const Fe=NonceAccountLayout.decode(toBuffer(Re),0);return new NonceAccount({authorizedPubkey:new PublicKey(Fe.authorizedPubkey),nonce:new PublicKey(Fe.nonce).toString(),feeCalculator:Fe.feeCalculator})}}const encodeDecode=Ke=>{const Re=Ke.decode.bind(Ke),Fe=Ke.encode.bind(Ke);return{decode:Re,encode:Fe}},bigInt=Ke=>Re=>{const Fe=blob(Ke,Re),{encode:We,decode:qe}=encodeDecode(Fe),Ze=Fe;return Ze.decode=(Xe,Je)=>{const tr=qe(Xe,Je);return toBigIntLE_1(buffer.Buffer.from(tr))},Ze.encode=(Xe,Je,tr)=>{const er=toBufferLE_1(Xe,Ke);return We(er,Je,tr)},Ze},u64=bigInt(8);class SystemInstruction{constructor(){}static decodeInstructionType(Re){this.checkProgramId(Re.programId);const We=u32("instruction").decode(Re.data);let qe;for(const[Ze,Xe]of Object.entries(SYSTEM_INSTRUCTION_LAYOUTS))if(Xe.index==We){qe=Ze;break}if(!qe)throw new Error("Instruction type incorrect; not a SystemInstruction");return qe}static decodeCreateAccount(Re){this.checkProgramId(Re.programId),this.checkKeyLength(Re.keys,2);const{lamports:Fe,space:We,programId:qe}=decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Create,Re.data);return{fromPubkey:Re.keys[0].pubkey,newAccountPubkey:Re.keys[1].pubkey,lamports:Fe,space:We,programId:new PublicKey(qe)}}static decodeTransfer(Re){this.checkProgramId(Re.programId),this.checkKeyLength(Re.keys,2);const{lamports:Fe}=decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Transfer,Re.data);return{fromPubkey:Re.keys[0].pubkey,toPubkey:Re.keys[1].pubkey,lamports:Fe}}static decodeTransferWithSeed(Re){this.checkProgramId(Re.programId),this.checkKeyLength(Re.keys,3);const{lamports:Fe,seed:We,programId:qe}=decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.TransferWithSeed,Re.data);return{fromPubkey:Re.keys[0].pubkey,basePubkey:Re.keys[1].pubkey,toPubkey:Re.keys[2].pubkey,lamports:Fe,seed:We,programId:new PublicKey(qe)}}static decodeAllocate(Re){this.checkProgramId(Re.programId),this.checkKeyLength(Re.keys,1);const{space:Fe}=decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Allocate,Re.data);return{accountPubkey:Re.keys[0].pubkey,space:Fe}}static decodeAllocateWithSeed(Re){this.checkProgramId(Re.programId),this.checkKeyLength(Re.keys,1);const{base:Fe,seed:We,space:qe,programId:Ze}=decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AllocateWithSeed,Re.data);return{accountPubkey:Re.keys[0].pubkey,basePubkey:new PublicKey(Fe),seed:We,space:qe,programId:new PublicKey(Ze)}}static decodeAssign(Re){this.checkProgramId(Re.programId),this.checkKeyLength(Re.keys,1);const{programId:Fe}=decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Assign,Re.data);return{accountPubkey:Re.keys[0].pubkey,programId:new PublicKey(Fe)}}static decodeAssignWithSeed(Re){this.checkProgramId(Re.programId),this.checkKeyLength(Re.keys,1);const{base:Fe,seed:We,programId:qe}=decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AssignWithSeed,Re.data);return{accountPubkey:Re.keys[0].pubkey,basePubkey:new PublicKey(Fe),seed:We,programId:new PublicKey(qe)}}static decodeCreateWithSeed(Re){this.checkProgramId(Re.programId),this.checkKeyLength(Re.keys,2);const{base:Fe,seed:We,lamports:qe,space:Ze,programId:Xe}=decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.CreateWithSeed,Re.data);return{fromPubkey:Re.keys[0].pubkey,newAccountPubkey:Re.keys[1].pubkey,basePubkey:new PublicKey(Fe),seed:We,lamports:qe,space:Ze,programId:new PublicKey(Xe)}}static decodeNonceInitialize(Re){this.checkProgramId(Re.programId),this.checkKeyLength(Re.keys,3);const{authorized:Fe}=decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.InitializeNonceAccount,Re.data);return{noncePubkey:Re.keys[0].pubkey,authorizedPubkey:new PublicKey(Fe)}}static decodeNonceAdvance(Re){return this.checkProgramId(Re.programId),this.checkKeyLength(Re.keys,3),decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AdvanceNonceAccount,Re.data),{noncePubkey:Re.keys[0].pubkey,authorizedPubkey:Re.keys[2].pubkey}}static decodeNonceWithdraw(Re){this.checkProgramId(Re.programId),this.checkKeyLength(Re.keys,5);const{lamports:Fe}=decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.WithdrawNonceAccount,Re.data);return{noncePubkey:Re.keys[0].pubkey,toPubkey:Re.keys[1].pubkey,authorizedPubkey:Re.keys[4].pubkey,lamports:Fe}}static decodeNonceAuthorize(Re){this.checkProgramId(Re.programId),this.checkKeyLength(Re.keys,2);const{authorized:Fe}=decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AuthorizeNonceAccount,Re.data);return{noncePubkey:Re.keys[0].pubkey,authorizedPubkey:Re.keys[1].pubkey,newAuthorizedPubkey:new PublicKey(Fe)}}static checkProgramId(Re){if(!Re.equals(SystemProgram.programId))throw new Error("invalid instruction; programId is not SystemProgram")}static checkKeyLength(Re,Fe){if(Re.length<Fe)throw new Error(`invalid instruction; found ${Re.length} keys, expected at least ${Fe}`)}}const SYSTEM_INSTRUCTION_LAYOUTS=Object.freeze({Create:{index:0,layout:struct([u32("instruction"),ns64("lamports"),ns64("space"),publicKey("programId")])},Assign:{index:1,layout:struct([u32("instruction"),publicKey("programId")])},Transfer:{index:2,layout:struct([u32("instruction"),u64("lamports")])},CreateWithSeed:{index:3,layout:struct([u32("instruction"),publicKey("base"),rustString("seed"),ns64("lamports"),ns64("space"),publicKey("programId")])},AdvanceNonceAccount:{index:4,layout:struct([u32("instruction")])},WithdrawNonceAccount:{index:5,layout:struct([u32("instruction"),ns64("lamports")])},InitializeNonceAccount:{index:6,layout:struct([u32("instruction"),publicKey("authorized")])},AuthorizeNonceAccount:{index:7,layout:struct([u32("instruction"),publicKey("authorized")])},Allocate:{index:8,layout:struct([u32("instruction"),ns64("space")])},AllocateWithSeed:{index:9,layout:struct([u32("instruction"),publicKey("base"),rustString("seed"),ns64("space"),publicKey("programId")])},AssignWithSeed:{index:10,layout:struct([u32("instruction"),publicKey("base"),rustString("seed"),publicKey("programId")])},TransferWithSeed:{index:11,layout:struct([u32("instruction"),u64("lamports"),rustString("seed"),publicKey("programId")])},UpgradeNonceAccount:{index:12,layout:struct([u32("instruction")])}});class SystemProgram{constructor(){}static createAccount(Re){const Fe=SYSTEM_INSTRUCTION_LAYOUTS.Create,We=encodeData(Fe,{lamports:Re.lamports,space:Re.space,programId:toBuffer(Re.programId.toBuffer())});return new TransactionInstruction({keys:[{pubkey:Re.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:Re.newAccountPubkey,isSigner:!0,isWritable:!0}],programId:this.programId,data:We})}static transfer(Re){let Fe,We;if("basePubkey"in Re){const qe=SYSTEM_INSTRUCTION_LAYOUTS.TransferWithSeed;Fe=encodeData(qe,{lamports:BigInt(Re.lamports),seed:Re.seed,programId:toBuffer(Re.programId.toBuffer())}),We=[{pubkey:Re.fromPubkey,isSigner:!1,isWritable:!0},{pubkey:Re.basePubkey,isSigner:!0,isWritable:!1},{pubkey:Re.toPubkey,isSigner:!1,isWritable:!0}]}else{const qe=SYSTEM_INSTRUCTION_LAYOUTS.Transfer;Fe=encodeData(qe,{lamports:BigInt(Re.lamports)}),We=[{pubkey:Re.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:Re.toPubkey,isSigner:!1,isWritable:!0}]}return new TransactionInstruction({keys:We,programId:this.programId,data:Fe})}static assign(Re){let Fe,We;if("basePubkey"in Re){const qe=SYSTEM_INSTRUCTION_LAYOUTS.AssignWithSeed;Fe=encodeData(qe,{base:toBuffer(Re.basePubkey.toBuffer()),seed:Re.seed,programId:toBuffer(Re.programId.toBuffer())}),We=[{pubkey:Re.accountPubkey,isSigner:!1,isWritable:!0},{pubkey:Re.basePubkey,isSigner:!0,isWritable:!1}]}else{const qe=SYSTEM_INSTRUCTION_LAYOUTS.Assign;Fe=encodeData(qe,{programId:toBuffer(Re.programId.toBuffer())}),We=[{pubkey:Re.accountPubkey,isSigner:!0,isWritable:!0}]}return new TransactionInstruction({keys:We,programId:this.programId,data:Fe})}static createAccountWithSeed(Re){const Fe=SYSTEM_INSTRUCTION_LAYOUTS.CreateWithSeed,We=encodeData(Fe,{base:toBuffer(Re.basePubkey.toBuffer()),seed:Re.seed,lamports:Re.lamports,space:Re.space,programId:toBuffer(Re.programId.toBuffer())});let qe=[{pubkey:Re.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:Re.newAccountPubkey,isSigner:!1,isWritable:!0}];return Re.basePubkey!=Re.fromPubkey&&qe.push({pubkey:Re.basePubkey,isSigner:!0,isWritable:!1}),new TransactionInstruction({keys:qe,programId:this.programId,data:We})}static createNonceAccount(Re){const Fe=new Transaction;"basePubkey"in Re&&"seed"in Re?Fe.add(SystemProgram.createAccountWithSeed({fromPubkey:Re.fromPubkey,newAccountPubkey:Re.noncePubkey,basePubkey:Re.basePubkey,seed:Re.seed,lamports:Re.lamports,space:NONCE_ACCOUNT_LENGTH,programId:this.programId})):Fe.add(SystemProgram.createAccount({fromPubkey:Re.fromPubkey,newAccountPubkey:Re.noncePubkey,lamports:Re.lamports,space:NONCE_ACCOUNT_LENGTH,programId:this.programId}));const We={noncePubkey:Re.noncePubkey,authorizedPubkey:Re.authorizedPubkey};return Fe.add(this.nonceInitialize(We)),Fe}static nonceInitialize(Re){const Fe=SYSTEM_INSTRUCTION_LAYOUTS.InitializeNonceAccount,We=encodeData(Fe,{authorized:toBuffer(Re.authorizedPubkey.toBuffer())}),qe={keys:[{pubkey:Re.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:SYSVAR_RECENT_BLOCKHASHES_PUBKEY,isSigner:!1,isWritable:!1},{pubkey:SYSVAR_RENT_PUBKEY,isSigner:!1,isWritable:!1}],programId:this.programId,data:We};return new TransactionInstruction(qe)}static nonceAdvance(Re){const Fe=SYSTEM_INSTRUCTION_LAYOUTS.AdvanceNonceAccount,We=encodeData(Fe),qe={keys:[{pubkey:Re.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:SYSVAR_RECENT_BLOCKHASHES_PUBKEY,isSigner:!1,isWritable:!1},{pubkey:Re.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:We};return new TransactionInstruction(qe)}static nonceWithdraw(Re){const Fe=SYSTEM_INSTRUCTION_LAYOUTS.WithdrawNonceAccount,We=encodeData(Fe,{lamports:Re.lamports});return new TransactionInstruction({keys:[{pubkey:Re.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:Re.toPubkey,isSigner:!1,isWritable:!0},{pubkey:SYSVAR_RECENT_BLOCKHASHES_PUBKEY,isSigner:!1,isWritable:!1},{pubkey:SYSVAR_RENT_PUBKEY,isSigner:!1,isWritable:!1},{pubkey:Re.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:We})}static nonceAuthorize(Re){const Fe=SYSTEM_INSTRUCTION_LAYOUTS.AuthorizeNonceAccount,We=encodeData(Fe,{authorized:toBuffer(Re.newAuthorizedPubkey.toBuffer())});return new TransactionInstruction({keys:[{pubkey:Re.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:Re.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:We})}static allocate(Re){let Fe,We;if("basePubkey"in Re){const qe=SYSTEM_INSTRUCTION_LAYOUTS.AllocateWithSeed;Fe=encodeData(qe,{base:toBuffer(Re.basePubkey.toBuffer()),seed:Re.seed,space:Re.space,programId:toBuffer(Re.programId.toBuffer())}),We=[{pubkey:Re.accountPubkey,isSigner:!1,isWritable:!0},{pubkey:Re.basePubkey,isSigner:!0,isWritable:!1}]}else{const qe=SYSTEM_INSTRUCTION_LAYOUTS.Allocate;Fe=encodeData(qe,{space:Re.space}),We=[{pubkey:Re.accountPubkey,isSigner:!0,isWritable:!0}]}return new TransactionInstruction({keys:We,programId:this.programId,data:Fe})}}SystemProgram.programId=new PublicKey("11111111111111111111111111111111");const CHUNK_SIZE=PACKET_DATA_SIZE-300;class Loader{constructor(){}static getMinNumSignatures(Re){return 2*(Math.ceil(Re/Loader.chunkSize)+1+1)}static async load(Re,Fe,We,qe,Ze){{const lr=await Re.getMinimumBalanceForRentExemption(Ze.length),fr=await Re.getAccountInfo(We.publicKey,"confirmed");let ur=null;if(fr!==null){if(fr.executable)return console.error("Program load failed, account is already executable"),!1;fr.data.length!==Ze.length&&(ur=ur||new Transaction,ur.add(SystemProgram.allocate({accountPubkey:We.publicKey,space:Ze.length}))),fr.owner.equals(qe)||(ur=ur||new Transaction,ur.add(SystemProgram.assign({accountPubkey:We.publicKey,programId:qe}))),fr.lamports<lr&&(ur=ur||new Transaction,ur.add(SystemProgram.transfer({fromPubkey:Fe.publicKey,toPubkey:We.publicKey,lamports:lr-fr.lamports})))}else ur=new Transaction().add(SystemProgram.createAccount({fromPubkey:Fe.publicKey,newAccountPubkey:We.publicKey,lamports:lr>0?lr:1,space:Ze.length,programId:qe}));ur!==null&&await sendAndConfirmTransaction(Re,ur,[Fe,We],{commitment:"confirmed"})}const Xe=struct([u32("instruction"),u32("offset"),u32("bytesLength"),u32("bytesLengthPadding"),seq(u8("byte"),offset(u32(),-8),"bytes")]),Je=Loader.chunkSize;let tr=0,er=Ze,ir=[];for(;er.length>0;){const lr=er.slice(0,Je),fr=buffer.Buffer.alloc(Je+16);Xe.encode({instruction:0,offset:tr,bytes:lr,bytesLength:0,bytesLengthPadding:0},fr);const ur=new Transaction().add({keys:[{pubkey:We.publicKey,isSigner:!0,isWritable:!0}],programId:qe,data:fr});ir.push(sendAndConfirmTransaction(Re,ur,[Fe,We],{commitment:"confirmed"})),Re._rpcEndpoint.includes("solana.com")&&await sleep(1e3/4),tr+=Je,er=er.slice(Je)}await Promise.all(ir);{const lr=struct([u32("instruction")]),fr=buffer.Buffer.alloc(lr.span);lr.encode({instruction:1},fr);const ur=new Transaction().add({keys:[{pubkey:We.publicKey,isSigner:!0,isWritable:!0},{pubkey:SYSVAR_RENT_PUBKEY,isSigner:!1,isWritable:!1}],programId:qe,data:fr});await sendAndConfirmTransaction(Re,ur,[Fe,We],{commitment:"confirmed"})}return!0}}Loader.chunkSize=CHUNK_SIZE;const BPF_LOADER_PROGRAM_ID=new PublicKey("BPFLoader2111111111111111111111111111111111");class BpfLoader{static getMinNumSignatures(Re){return Loader.getMinNumSignatures(Re)}static load(Re,Fe,We,qe,Ze){return Loader.load(Re,Fe,We,Ze,qe)}}var objToString=Object.prototype.toString,objKeys=Object.keys||function(Ke){var Re=[];for(var Fe in Ke)Re.push(Fe);return Re};function stringify(Ke,Re){var Fe,We,qe,Ze,Xe,Je,tr;if(Ke===!0)return"true";if(Ke===!1)return"false";switch(typeof Ke){case"object":if(Ke===null)return null;if(Ke.toJSON&&typeof Ke.toJSON=="function")return stringify(Ke.toJSON(),Re);if(tr=objToString.call(Ke),tr==="[object Array]"){for(qe="[",We=Ke.length-1,Fe=0;Fe<We;Fe++)qe+=stringify(Ke[Fe],!0)+",";return We>-1&&(qe+=stringify(Ke[Fe],!0)),qe+"]"}else if(tr==="[object Object]"){for(Ze=objKeys(Ke).sort(),We=Ze.length,qe="",Fe=0;Fe<We;)Xe=Ze[Fe],Je=stringify(Ke[Xe],!1),Je!==void 0&&(qe&&(qe+=","),qe+=JSON.stringify(Xe)+":"+Je),Fe++;return"{"+qe+"}"}else return JSON.stringify(Ke);case"function":case"undefined":return Re?null:void 0;case"string":return JSON.stringify(Ke);default:return isFinite(Ke)?Ke:null}}var fastStableStringify=function(Ke){var Re=stringify(Ke,!1);if(Re!==void 0)return""+Re},fastStableStringify$1=fastStableStringify;const MINIMUM_SLOT_PER_EPOCH=32;function trailingZeros(Ke){let Re=0;for(;Ke>1;)Ke/=2,Re++;return Re}function nextPowerOfTwo(Ke){return Ke===0?1:(Ke--,Ke|=Ke>>1,Ke|=Ke>>2,Ke|=Ke>>4,Ke|=Ke>>8,Ke|=Ke>>16,Ke|=Ke>>32,Ke+1)}class EpochSchedule{constructor(Re,Fe,We,qe,Ze){this.slotsPerEpoch=void 0,this.leaderScheduleSlotOffset=void 0,this.warmup=void 0,this.firstNormalEpoch=void 0,this.firstNormalSlot=void 0,this.slotsPerEpoch=Re,this.leaderScheduleSlotOffset=Fe,this.warmup=We,this.firstNormalEpoch=qe,this.firstNormalSlot=Ze}getEpoch(Re){return this.getEpochAndSlotIndex(Re)[0]}getEpochAndSlotIndex(Re){if(Re<this.firstNormalSlot){const Fe=trailingZeros(nextPowerOfTwo(Re+MINIMUM_SLOT_PER_EPOCH+1))-trailingZeros(MINIMUM_SLOT_PER_EPOCH)-1,We=this.getSlotsInEpoch(Fe),qe=Re-(We-MINIMUM_SLOT_PER_EPOCH);return[Fe,qe]}else{const Fe=Re-this.firstNormalSlot,We=Math.floor(Fe/this.slotsPerEpoch),qe=this.firstNormalEpoch+We,Ze=Fe%this.slotsPerEpoch;return[qe,Ze]}}getFirstSlotInEpoch(Re){return Re<=this.firstNormalEpoch?(Math.pow(2,Re)-1)*MINIMUM_SLOT_PER_EPOCH:(Re-this.firstNormalEpoch)*this.slotsPerEpoch+this.firstNormalSlot}getLastSlotInEpoch(Re){return this.getFirstSlotInEpoch(Re)+this.getSlotsInEpoch(Re)-1}getSlotsInEpoch(Re){return Re<this.firstNormalEpoch?Math.pow(2,Re+trailingZeros(MINIMUM_SLOT_PER_EPOCH)):this.slotsPerEpoch}}class SendTransactionError extends Error{constructor(Re,Fe){super(Re),this.logs=void 0,this.logs=Fe}}const SolanaJSONRPCErrorCode={JSON_RPC_SERVER_ERROR_BLOCK_CLEANED_UP:-32001,JSON_RPC_SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE:-32002,JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE:-32003,JSON_RPC_SERVER_ERROR_BLOCK_NOT_AVAILABLE:-32004,JSON_RPC_SERVER_ERROR_NODE_UNHEALTHY:-32005,JSON_RPC_SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE:-32006,JSON_RPC_SERVER_ERROR_SLOT_SKIPPED:-32007,JSON_RPC_SERVER_ERROR_NO_SNAPSHOT:-32008,JSON_RPC_SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED:-32009,JSON_RPC_SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX:-32010,JSON_RPC_SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE:-32011,JSON_RPC_SCAN_ERROR:-32012,JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH:-32013,JSON_RPC_SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET:-32014,JSON_RPC_SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION:-32015,JSON_RPC_SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED:-32016};class SolanaJSONRPCError extends Error{constructor({code:Re,message:Fe,data:We},qe){super(qe!=null?`${qe}: ${Fe}`:Fe),this.code=void 0,this.data=void 0,this.code=Re,this.data=We,this.name="SolanaJSONRPCError"}}var fetchImpl=globalThis.fetch;const NUM_TICKS_PER_SECOND=160,DEFAULT_TICKS_PER_SLOT=64,NUM_SLOTS_PER_SECOND=NUM_TICKS_PER_SECOND/DEFAULT_TICKS_PER_SLOT,MS_PER_SLOT=1e3/NUM_SLOTS_PER_SECOND;function decodeData(Ke,Re){let Fe;try{Fe=Ke.layout.decode(Re)}catch(We){throw new Error("invalid instruction; "+We)}if(Fe.typeIndex!==Ke.index)throw new Error(`invalid account data; account type mismatch ${Fe.typeIndex} != ${Ke.index}`);return Fe}const LOOKUP_TABLE_META_SIZE=56;class AddressLookupTableAccount{constructor(Re){this.key=void 0,this.state=void 0,this.key=Re.key,this.state=Re.state}isActive(){const Re=BigInt("0xffffffffffffffff");return this.state.deactivationSlot===Re}static deserialize(Re){const Fe=decodeData(LookupTableMetaLayout,Re),We=Re.length-LOOKUP_TABLE_META_SIZE;assert(We>=0,"lookup table is invalid"),assert(We%32===0,"lookup table is invalid");const qe=We/32,{addresses:Ze}=struct([seq(publicKey(),qe,"addresses")]).decode(Re.slice(LOOKUP_TABLE_META_SIZE));return{deactivationSlot:Fe.deactivationSlot,lastExtendedSlot:Fe.lastExtendedSlot,lastExtendedSlotStartIndex:Fe.lastExtendedStartIndex,authority:Fe.authority.length!==0?new PublicKey(Fe.authority[0]):void 0,addresses:Ze.map(Xe=>new PublicKey(Xe))}}}const LookupTableMetaLayout={index:1,layout:struct([u32("typeIndex"),u64("deactivationSlot"),nu64("lastExtendedSlot"),u8("lastExtendedStartIndex"),u8(),seq(publicKey(),offset(u8(),-1),"authority")])},URL_RE=/^[^:]+:\/\/([^:[]+|\[[^\]]+\])(:\d+)?(.*)/i;function makeWebsocketUrl(Ke){const Re=Ke.match(URL_RE);if(Re==null)throw TypeError(`Failed to validate endpoint URL \`${Ke}\``);const[Fe,We,qe,Ze]=Re,Xe=Ke.startsWith("https:")?"wss:":"ws:",Je=qe==null?null:parseInt(qe.slice(1),10),tr=Je==null?"":`:${Je+1}`;return`${Xe}//${We}${tr}${Ze}`}var _process$env$npm_pack;const PublicKeyFromString=coerce(instance(PublicKey),string(),Ke=>new PublicKey(Ke)),RawAccountDataResult=tuple([string(),literal("base64")]),BufferFromRawAccountData=coerce(instance(buffer.Buffer),RawAccountDataResult,Ke=>buffer.Buffer.from(Ke[0],"base64")),BLOCKHASH_CACHE_TIMEOUT_MS=30*1e3;function assertEndpointUrl(Ke){if(/^https?:/.test(Ke)===!1)throw new TypeError("Endpoint URL must start with `http:` or `https:`.");return Ke}function extractCommitmentFromConfig(Ke){let Re,Fe;if(typeof Ke=="string")Re=Ke;else if(Ke){const{commitment:We,...qe}=Ke;Re=We,Fe=qe}return{commitment:Re,config:Fe}}function createRpcResult(Ke){return union([type({jsonrpc:literal("2.0"),id:string(),result:Ke}),type({jsonrpc:literal("2.0"),id:string(),error:type({code:unknown(),message:string(),data:optional(any())})})])}const UnknownRpcResult=createRpcResult(unknown());function jsonRpcResult(Ke){return coerce(createRpcResult(Ke),UnknownRpcResult,Re=>"error"in Re?Re:{...Re,result:create(Re.result,Ke)})}function jsonRpcResultAndContext(Ke){return jsonRpcResult(type({context:type({slot:number()}),value:Ke}))}function notificationResultAndContext(Ke){return type({context:type({slot:number()}),value:Ke})}function versionedMessageFromResponse(Ke,Re){return Ke===0?new MessageV0({header:Re.header,staticAccountKeys:Re.accountKeys.map(Fe=>new PublicKey(Fe)),recentBlockhash:Re.recentBlockhash,compiledInstructions:Re.instructions.map(Fe=>({programIdIndex:Fe.programIdIndex,accountKeyIndexes:Fe.accounts,data:bs58.decode(Fe.data)})),addressTableLookups:Re.addressTableLookups}):new Message(Re)}const GetInflationGovernorResult=type({foundation:number(),foundationTerm:number(),initial:number(),taper:number(),terminal:number()}),GetInflationRewardResult=jsonRpcResult(array(nullable(type({epoch:number(),effectiveSlot:number(),amount:number(),postBalance:number()})))),GetEpochInfoResult=type({epoch:number(),slotIndex:number(),slotsInEpoch:number(),absoluteSlot:number(),blockHeight:optional(number()),transactionCount:optional(number())}),GetEpochScheduleResult=type({slotsPerEpoch:number(),leaderScheduleSlotOffset:number(),warmup:boolean(),firstNormalEpoch:number(),firstNormalSlot:number()}),GetLeaderScheduleResult=record(string(),array(number())),TransactionErrorResult=nullable(union([type({}),string()])),SignatureStatusResult=type({err:TransactionErrorResult}),SignatureReceivedResult=literal("receivedSignature"),VersionResult=type({"solana-core":string(),"feature-set":optional(number())}),SimulatedTransactionResponseStruct=jsonRpcResultAndContext(type({err:nullable(union([type({}),string()])),logs:nullable(array(string())),accounts:optional(nullable(array(nullable(type({executable:boolean(),owner:string(),lamports:number(),data:array(string()),rentEpoch:optional(number())}))))),unitsConsumed:optional(number()),returnData:optional(nullable(type({programId:string(),data:tuple([string(),literal("base64")])})))})),BlockProductionResponseStruct=jsonRpcResultAndContext(type({byIdentity:record(string(),array(number())),range:type({firstSlot:number(),lastSlot:number()})}));function createRpcClient(Ke,Re,Fe,We,qe){const Ze=Fe||fetchImpl;let Xe;return We&&(Xe=async(tr,er)=>{const ir=await new Promise((lr,fr)=>{try{We(tr,er,(ur,mr)=>lr([ur,mr]))}catch(ur){fr(ur)}});return await Ze(...ir)}),new browser(async(tr,er)=>{const lr={method:"POST",body:tr,agent:void 0,headers:Object.assign({"Content-Type":"application/json"},Re||{},COMMON_HTTP_HEADERS)};try{let fr=5,ur,mr=500;for(;Xe?ur=await Xe(Ke,lr):ur=await Ze(Ke,lr),!(ur.status!==429||qe===!0||(fr-=1,fr===0));)console.log(`Server responded with ${ur.status} ${ur.statusText}.  Retrying after ${mr}ms delay...`),await sleep(mr),mr*=2;const br=await ur.text();ur.ok?er(null,br):er(new Error(`${ur.status} ${ur.statusText}: ${br}`))}catch(fr){fr instanceof Error&&er(fr)}finally{}},{})}function createRpcRequest(Ke){return(Re,Fe)=>new Promise((We,qe)=>{Ke.request(Re,Fe,(Ze,Xe)=>{if(Ze){qe(Ze);return}We(Xe)})})}function createRpcBatchRequest(Ke){return Re=>new Promise((Fe,We)=>{Re.length===0&&Fe([]);const qe=Re.map(Ze=>Ke.request(Ze.methodName,Ze.args));Ke.request(qe,(Ze,Xe)=>{if(Ze){We(Ze);return}Fe(Xe)})})}const GetInflationGovernorRpcResult=jsonRpcResult(GetInflationGovernorResult),GetEpochInfoRpcResult=jsonRpcResult(GetEpochInfoResult),GetEpochScheduleRpcResult=jsonRpcResult(GetEpochScheduleResult),GetLeaderScheduleRpcResult=jsonRpcResult(GetLeaderScheduleResult),SlotRpcResult=jsonRpcResult(number()),GetSupplyRpcResult=jsonRpcResultAndContext(type({total:number(),circulating:number(),nonCirculating:number(),nonCirculatingAccounts:array(PublicKeyFromString)})),TokenAmountResult=type({amount:string(),uiAmount:nullable(number()),decimals:number(),uiAmountString:optional(string())}),GetTokenLargestAccountsResult=jsonRpcResultAndContext(array(type({address:PublicKeyFromString,amount:string(),uiAmount:nullable(number()),decimals:number(),uiAmountString:optional(string())}))),GetTokenAccountsByOwner=jsonRpcResultAndContext(array(type({pubkey:PublicKeyFromString,account:type({executable:boolean(),owner:PublicKeyFromString,lamports:number(),data:BufferFromRawAccountData,rentEpoch:number()})}))),ParsedAccountDataResult=type({program:string(),parsed:unknown(),space:number()}),GetParsedTokenAccountsByOwner=jsonRpcResultAndContext(array(type({pubkey:PublicKeyFromString,account:type({executable:boolean(),owner:PublicKeyFromString,lamports:number(),data:ParsedAccountDataResult,rentEpoch:number()})}))),GetLargestAccountsRpcResult=jsonRpcResultAndContext(array(type({lamports:number(),address:PublicKeyFromString}))),AccountInfoResult=type({executable:boolean(),owner:PublicKeyFromString,lamports:number(),data:BufferFromRawAccountData,rentEpoch:number()}),KeyedAccountInfoResult=type({pubkey:PublicKeyFromString,account:AccountInfoResult}),ParsedOrRawAccountData=coerce(union([instance(buffer.Buffer),ParsedAccountDataResult]),union([RawAccountDataResult,ParsedAccountDataResult]),Ke=>Array.isArray(Ke)?create(Ke,BufferFromRawAccountData):Ke),ParsedAccountInfoResult=type({executable:boolean(),owner:PublicKeyFromString,lamports:number(),data:ParsedOrRawAccountData,rentEpoch:number()}),KeyedParsedAccountInfoResult=type({pubkey:PublicKeyFromString,account:ParsedAccountInfoResult}),StakeActivationResult=type({state:union([literal("active"),literal("inactive"),literal("activating"),literal("deactivating")]),active:number(),inactive:number()}),GetConfirmedSignaturesForAddress2RpcResult=jsonRpcResult(array(type({signature:string(),slot:number(),err:TransactionErrorResult,memo:nullable(string()),blockTime:optional(nullable(number()))}))),GetSignaturesForAddressRpcResult=jsonRpcResult(array(type({signature:string(),slot:number(),err:TransactionErrorResult,memo:nullable(string()),blockTime:optional(nullable(number()))}))),AccountNotificationResult=type({subscription:number(),result:notificationResultAndContext(AccountInfoResult)}),ProgramAccountInfoResult=type({pubkey:PublicKeyFromString,account:AccountInfoResult}),ProgramAccountNotificationResult=type({subscription:number(),result:notificationResultAndContext(ProgramAccountInfoResult)}),SlotInfoResult=type({parent:number(),slot:number(),root:number()}),SlotNotificationResult=type({subscription:number(),result:SlotInfoResult}),SlotUpdateResult=union([type({type:union([literal("firstShredReceived"),literal("completed"),literal("optimisticConfirmation"),literal("root")]),slot:number(),timestamp:number()}),type({type:literal("createdBank"),parent:number(),slot:number(),timestamp:number()}),type({type:literal("frozen"),slot:number(),timestamp:number(),stats:type({numTransactionEntries:number(),numSuccessfulTransactions:number(),numFailedTransactions:number(),maxTransactionsPerEntry:number()})}),type({type:literal("dead"),slot:number(),timestamp:number(),err:string()})]),SlotUpdateNotificationResult=type({subscription:number(),result:SlotUpdateResult}),SignatureNotificationResult=type({subscription:number(),result:notificationResultAndContext(union([SignatureStatusResult,SignatureReceivedResult]))}),RootNotificationResult=type({subscription:number(),result:number()}),ContactInfoResult=type({pubkey:string(),gossip:nullable(string()),tpu:nullable(string()),rpc:nullable(string()),version:nullable(string())}),VoteAccountInfoResult=type({votePubkey:string(),nodePubkey:string(),activatedStake:number(),epochVoteAccount:boolean(),epochCredits:array(tuple([number(),number(),number()])),commission:number(),lastVote:number(),rootSlot:nullable(number())}),GetVoteAccounts=jsonRpcResult(type({current:array(VoteAccountInfoResult),delinquent:array(VoteAccountInfoResult)})),ConfirmationStatus=union([literal("processed"),literal("confirmed"),literal("finalized")]),SignatureStatusResponse=type({slot:number(),confirmations:nullable(number()),err:TransactionErrorResult,confirmationStatus:optional(ConfirmationStatus)}),GetSignatureStatusesRpcResult=jsonRpcResultAndContext(array(nullable(SignatureStatusResponse))),GetMinimumBalanceForRentExemptionRpcResult=jsonRpcResult(number()),AddressTableLookupStruct=type({accountKey:PublicKeyFromString,writableIndexes:array(number()),readonlyIndexes:array(number())}),ConfirmedTransactionResult=type({signatures:array(string()),message:type({accountKeys:array(string()),header:type({numRequiredSignatures:number(),numReadonlySignedAccounts:number(),numReadonlyUnsignedAccounts:number()}),instructions:array(type({accounts:array(number()),data:string(),programIdIndex:number()})),recentBlockhash:string(),addressTableLookups:optional(array(AddressTableLookupStruct))})}),ParsedInstructionResult=type({parsed:unknown(),program:string(),programId:PublicKeyFromString}),RawInstructionResult=type({accounts:array(PublicKeyFromString),data:string(),programId:PublicKeyFromString}),InstructionResult=union([RawInstructionResult,ParsedInstructionResult]),UnknownInstructionResult=union([type({parsed:unknown(),program:string(),programId:string()}),type({accounts:array(string()),data:string(),programId:string()})]),ParsedOrRawInstruction=coerce(InstructionResult,UnknownInstructionResult,Ke=>"accounts"in Ke?create(Ke,RawInstructionResult):create(Ke,ParsedInstructionResult)),ParsedConfirmedTransactionResult=type({signatures:array(string()),message:type({accountKeys:array(type({pubkey:PublicKeyFromString,signer:boolean(),writable:boolean(),source:optional(union([literal("transaction"),literal("lookupTable")]))})),instructions:array(ParsedOrRawInstruction),recentBlockhash:string(),addressTableLookups:optional(nullable(array(AddressTableLookupStruct)))})}),TokenBalanceResult=type({accountIndex:number(),mint:string(),owner:optional(string()),uiTokenAmount:TokenAmountResult}),LoadedAddressesResult=type({writable:array(PublicKeyFromString),readonly:array(PublicKeyFromString)}),ConfirmedTransactionMetaResult=type({err:TransactionErrorResult,fee:number(),innerInstructions:optional(nullable(array(type({index:number(),instructions:array(type({accounts:array(number()),data:string(),programIdIndex:number()}))})))),preBalances:array(number()),postBalances:array(number()),logMessages:optional(nullable(array(string()))),preTokenBalances:optional(nullable(array(TokenBalanceResult))),postTokenBalances:optional(nullable(array(TokenBalanceResult))),loadedAddresses:optional(LoadedAddressesResult),computeUnitsConsumed:optional(number())}),ParsedConfirmedTransactionMetaResult=type({err:TransactionErrorResult,fee:number(),innerInstructions:optional(nullable(array(type({index:number(),instructions:array(ParsedOrRawInstruction)})))),preBalances:array(number()),postBalances:array(number()),logMessages:optional(nullable(array(string()))),preTokenBalances:optional(nullable(array(TokenBalanceResult))),postTokenBalances:optional(nullable(array(TokenBalanceResult))),loadedAddresses:optional(LoadedAddressesResult),computeUnitsConsumed:optional(number())}),TransactionVersionStruct=union([literal(0),literal("legacy")]),GetBlockRpcResult=jsonRpcResult(nullable(type({blockhash:string(),previousBlockhash:string(),parentSlot:number(),transactions:array(type({transaction:ConfirmedTransactionResult,meta:nullable(ConfirmedTransactionMetaResult),version:optional(TransactionVersionStruct)})),rewards:optional(array(type({pubkey:string(),lamports:number(),postBalance:nullable(number()),rewardType:nullable(string())}))),blockTime:nullable(number()),blockHeight:nullable(number())}))),GetParsedBlockRpcResult=jsonRpcResult(nullable(type({blockhash:string(),previousBlockhash:string(),parentSlot:number(),transactions:array(type({transaction:ParsedConfirmedTransactionResult,meta:nullable(ParsedConfirmedTransactionMetaResult),version:optional(TransactionVersionStruct)})),rewards:optional(array(type({pubkey:string(),lamports:number(),postBalance:nullable(number()),rewardType:nullable(string())}))),blockTime:nullable(number()),blockHeight:nullable(number())}))),GetConfirmedBlockRpcResult=jsonRpcResult(nullable(type({blockhash:string(),previousBlockhash:string(),parentSlot:number(),transactions:array(type({transaction:ConfirmedTransactionResult,meta:nullable(ConfirmedTransactionMetaResult)})),rewards:optional(array(type({pubkey:string(),lamports:number(),postBalance:nullable(number()),rewardType:nullable(string())}))),blockTime:nullable(number())}))),GetBlockSignaturesRpcResult=jsonRpcResult(nullable(type({blockhash:string(),previousBlockhash:string(),parentSlot:number(),signatures:array(string()),blockTime:nullable(number())}))),GetTransactionRpcResult=jsonRpcResult(nullable(type({slot:number(),meta:ConfirmedTransactionMetaResult,blockTime:optional(nullable(number())),transaction:ConfirmedTransactionResult,version:optional(TransactionVersionStruct)}))),GetParsedTransactionRpcResult=jsonRpcResult(nullable(type({slot:number(),transaction:ParsedConfirmedTransactionResult,meta:nullable(ParsedConfirmedTransactionMetaResult),blockTime:optional(nullable(number())),version:optional(TransactionVersionStruct)}))),GetRecentBlockhashAndContextRpcResult=jsonRpcResultAndContext(type({blockhash:string(),feeCalculator:type({lamportsPerSignature:number()})})),GetLatestBlockhashRpcResult=jsonRpcResultAndContext(type({blockhash:string(),lastValidBlockHeight:number()})),PerfSampleResult=type({slot:number(),numTransactions:number(),numSlots:number(),samplePeriodSecs:number()}),GetRecentPerformanceSamplesRpcResult=jsonRpcResult(array(PerfSampleResult)),GetFeeCalculatorRpcResult=jsonRpcResultAndContext(nullable(type({feeCalculator:type({lamportsPerSignature:number()})}))),RequestAirdropRpcResult=jsonRpcResult(string()),SendTransactionRpcResult=jsonRpcResult(string()),LogsResult=type({err:TransactionErrorResult,logs:array(string()),signature:string()}),LogsNotificationResult=type({result:notificationResultAndContext(LogsResult),subscription:number()}),COMMON_HTTP_HEADERS={"solana-client":`js/${(_process$env$npm_pack="0.0.0-development")!==null&&_process$env$npm_pack!==void 0?_process$env$npm_pack:"UNKNOWN"}`};class Connection{constructor(Re,Fe){this._commitment=void 0,this._confirmTransactionInitialTimeout=void 0,this._rpcEndpoint=void 0,this._rpcWsEndpoint=void 0,this._rpcClient=void 0,this._rpcRequest=void 0,this._rpcBatchRequest=void 0,this._rpcWebSocket=void 0,this._rpcWebSocketConnected=!1,this._rpcWebSocketHeartbeat=null,this._rpcWebSocketIdleTimeout=null,this._rpcWebSocketGeneration=0,this._disableBlockhashCaching=!1,this._pollingBlockhash=!1,this._blockhashInfo={latestBlockhash:null,lastFetch:0,transactionSignatures:[],simulatedSignatures:[]},this._nextClientSubscriptionId=0,this._subscriptionDisposeFunctionsByClientSubscriptionId={},this._subscriptionCallbacksByServerSubscriptionId={},this._subscriptionsByHash={},this._subscriptionsAutoDisposedByRpc=new Set;let We,qe,Ze,Xe,Je;Fe&&typeof Fe=="string"?this._commitment=Fe:Fe&&(this._commitment=Fe.commitment,this._confirmTransactionInitialTimeout=Fe.confirmTransactionInitialTimeout,We=Fe.wsEndpoint,qe=Fe.httpHeaders,Ze=Fe.fetch,Xe=Fe.fetchMiddleware,Je=Fe.disableRetryOnRateLimit),this._rpcEndpoint=assertEndpointUrl(Re),this._rpcWsEndpoint=We||makeWebsocketUrl(Re),this._rpcClient=createRpcClient(Re,qe,Ze,Xe,Je),this._rpcRequest=createRpcRequest(this._rpcClient),this._rpcBatchRequest=createRpcBatchRequest(this._rpcClient),this._rpcWebSocket=new Client_1(this._rpcWsEndpoint,{autoconnect:!1,max_reconnects:1/0}),this._rpcWebSocket.on("open",this._wsOnOpen.bind(this)),this._rpcWebSocket.on("error",this._wsOnError.bind(this)),this._rpcWebSocket.on("close",this._wsOnClose.bind(this)),this._rpcWebSocket.on("accountNotification",this._wsOnAccountNotification.bind(this)),this._rpcWebSocket.on("programNotification",this._wsOnProgramAccountNotification.bind(this)),this._rpcWebSocket.on("slotNotification",this._wsOnSlotNotification.bind(this)),this._rpcWebSocket.on("slotsUpdatesNotification",this._wsOnSlotUpdatesNotification.bind(this)),this._rpcWebSocket.on("signatureNotification",this._wsOnSignatureNotification.bind(this)),this._rpcWebSocket.on("rootNotification",this._wsOnRootNotification.bind(this)),this._rpcWebSocket.on("logsNotification",this._wsOnLogsNotification.bind(this))}get commitment(){return this._commitment}get rpcEndpoint(){return this._rpcEndpoint}async getBalanceAndContext(Re,Fe){const{commitment:We,config:qe}=extractCommitmentFromConfig(Fe),Ze=this._buildArgs([Re.toBase58()],We,void 0,qe),Xe=await this._rpcRequest("getBalance",Ze),Je=create(Xe,jsonRpcResultAndContext(number()));if("error"in Je)throw new SolanaJSONRPCError(Je.error,`failed to get balance for ${Re.toBase58()}`);return Je.result}async getBalance(Re,Fe){return await this.getBalanceAndContext(Re,Fe).then(We=>We.value).catch(We=>{throw new Error("failed to get balance of account "+Re.toBase58()+": "+We)})}async getBlockTime(Re){const Fe=await this._rpcRequest("getBlockTime",[Re]),We=create(Fe,jsonRpcResult(nullable(number())));if("error"in We)throw new SolanaJSONRPCError(We.error,`failed to get block time for slot ${Re}`);return We.result}async getMinimumLedgerSlot(){const Re=await this._rpcRequest("minimumLedgerSlot",[]),Fe=create(Re,jsonRpcResult(number()));if("error"in Fe)throw new SolanaJSONRPCError(Fe.error,"failed to get minimum ledger slot");return Fe.result}async getFirstAvailableBlock(){const Re=await this._rpcRequest("getFirstAvailableBlock",[]),Fe=create(Re,SlotRpcResult);if("error"in Fe)throw new SolanaJSONRPCError(Fe.error,"failed to get first available block");return Fe.result}async getSupply(Re){let Fe={};typeof Re=="string"?Fe={commitment:Re}:Re?Fe={...Re,commitment:Re&&Re.commitment||this.commitment}:Fe={commitment:this.commitment};const We=await this._rpcRequest("getSupply",[Fe]),qe=create(We,GetSupplyRpcResult);if("error"in qe)throw new SolanaJSONRPCError(qe.error,"failed to get supply");return qe.result}async getTokenSupply(Re,Fe){const We=this._buildArgs([Re.toBase58()],Fe),qe=await this._rpcRequest("getTokenSupply",We),Ze=create(qe,jsonRpcResultAndContext(TokenAmountResult));if("error"in Ze)throw new SolanaJSONRPCError(Ze.error,"failed to get token supply");return Ze.result}async getTokenAccountBalance(Re,Fe){const We=this._buildArgs([Re.toBase58()],Fe),qe=await this._rpcRequest("getTokenAccountBalance",We),Ze=create(qe,jsonRpcResultAndContext(TokenAmountResult));if("error"in Ze)throw new SolanaJSONRPCError(Ze.error,"failed to get token account balance");return Ze.result}async getTokenAccountsByOwner(Re,Fe,We){const{commitment:qe,config:Ze}=extractCommitmentFromConfig(We);let Xe=[Re.toBase58()];"mint"in Fe?Xe.push({mint:Fe.mint.toBase58()}):Xe.push({programId:Fe.programId.toBase58()});const Je=this._buildArgs(Xe,qe,"base64",Ze),tr=await this._rpcRequest("getTokenAccountsByOwner",Je),er=create(tr,GetTokenAccountsByOwner);if("error"in er)throw new SolanaJSONRPCError(er.error,`failed to get token accounts owned by account ${Re.toBase58()}`);return er.result}async getParsedTokenAccountsByOwner(Re,Fe,We){let qe=[Re.toBase58()];"mint"in Fe?qe.push({mint:Fe.mint.toBase58()}):qe.push({programId:Fe.programId.toBase58()});const Ze=this._buildArgs(qe,We,"jsonParsed"),Xe=await this._rpcRequest("getTokenAccountsByOwner",Ze),Je=create(Xe,GetParsedTokenAccountsByOwner);if("error"in Je)throw new SolanaJSONRPCError(Je.error,`failed to get token accounts owned by account ${Re.toBase58()}`);return Je.result}async getLargestAccounts(Re){const Fe={...Re,commitment:Re&&Re.commitment||this.commitment},We=Fe.filter||Fe.commitment?[Fe]:[],qe=await this._rpcRequest("getLargestAccounts",We),Ze=create(qe,GetLargestAccountsRpcResult);if("error"in Ze)throw new SolanaJSONRPCError(Ze.error,"failed to get largest accounts");return Ze.result}async getTokenLargestAccounts(Re,Fe){const We=this._buildArgs([Re.toBase58()],Fe),qe=await this._rpcRequest("getTokenLargestAccounts",We),Ze=create(qe,GetTokenLargestAccountsResult);if("error"in Ze)throw new SolanaJSONRPCError(Ze.error,"failed to get token largest accounts");return Ze.result}async getAccountInfoAndContext(Re,Fe){const{commitment:We,config:qe}=extractCommitmentFromConfig(Fe),Ze=this._buildArgs([Re.toBase58()],We,"base64",qe),Xe=await this._rpcRequest("getAccountInfo",Ze),Je=create(Xe,jsonRpcResultAndContext(nullable(AccountInfoResult)));if("error"in Je)throw new SolanaJSONRPCError(Je.error,`failed to get info about account ${Re.toBase58()}`);return Je.result}async getParsedAccountInfo(Re,Fe){const{commitment:We,config:qe}=extractCommitmentFromConfig(Fe),Ze=this._buildArgs([Re.toBase58()],We,"jsonParsed",qe),Xe=await this._rpcRequest("getAccountInfo",Ze),Je=create(Xe,jsonRpcResultAndContext(nullable(ParsedAccountInfoResult)));if("error"in Je)throw new SolanaJSONRPCError(Je.error,`failed to get info about account ${Re.toBase58()}`);return Je.result}async getAccountInfo(Re,Fe){try{return(await this.getAccountInfoAndContext(Re,Fe)).value}catch(We){throw new Error("failed to get info about account "+Re.toBase58()+": "+We)}}async getMultipleParsedAccounts(Re,Fe){const{commitment:We,config:qe}=extractCommitmentFromConfig(Fe),Ze=Re.map(er=>er.toBase58()),Xe=this._buildArgs([Ze],We,"jsonParsed",qe),Je=await this._rpcRequest("getMultipleAccounts",Xe),tr=create(Je,jsonRpcResultAndContext(array(nullable(ParsedAccountInfoResult))));if("error"in tr)throw new SolanaJSONRPCError(tr.error,`failed to get info for accounts ${Ze}`);return tr.result}async getMultipleAccountsInfoAndContext(Re,Fe){const{commitment:We,config:qe}=extractCommitmentFromConfig(Fe),Ze=Re.map(er=>er.toBase58()),Xe=this._buildArgs([Ze],We,"base64",qe),Je=await this._rpcRequest("getMultipleAccounts",Xe),tr=create(Je,jsonRpcResultAndContext(array(nullable(AccountInfoResult))));if("error"in tr)throw new SolanaJSONRPCError(tr.error,`failed to get info for accounts ${Ze}`);return tr.result}async getMultipleAccountsInfo(Re,Fe){return(await this.getMultipleAccountsInfoAndContext(Re,Fe)).value}async getStakeActivation(Re,Fe,We){const{commitment:qe,config:Ze}=extractCommitmentFromConfig(Fe),Xe=this._buildArgs([Re.toBase58()],qe,void 0,{...Ze,epoch:We!=null?We:Ze==null?void 0:Ze.epoch}),Je=await this._rpcRequest("getStakeActivation",Xe),tr=create(Je,jsonRpcResult(StakeActivationResult));if("error"in tr)throw new SolanaJSONRPCError(tr.error,`failed to get Stake Activation ${Re.toBase58()}`);return tr.result}async getProgramAccounts(Re,Fe){const{commitment:We,config:qe}=extractCommitmentFromConfig(Fe),{encoding:Ze,...Xe}=qe||{},Je=this._buildArgs([Re.toBase58()],We,Ze||"base64",Xe),tr=await this._rpcRequest("getProgramAccounts",Je),er=create(tr,jsonRpcResult(array(KeyedAccountInfoResult)));if("error"in er)throw new SolanaJSONRPCError(er.error,`failed to get accounts owned by program ${Re.toBase58()}`);return er.result}async getParsedProgramAccounts(Re,Fe){const{commitment:We,config:qe}=extractCommitmentFromConfig(Fe),Ze=this._buildArgs([Re.toBase58()],We,"jsonParsed",qe),Xe=await this._rpcRequest("getProgramAccounts",Ze),Je=create(Xe,jsonRpcResult(array(KeyedParsedAccountInfoResult)));if("error"in Je)throw new SolanaJSONRPCError(Je.error,`failed to get accounts owned by program ${Re.toBase58()}`);return Je.result}async confirmTransaction(Re,Fe){let We;typeof Re=="string"?We=Re:We=Re.signature;let qe;try{qe=bs58.decode(We)}catch{throw new Error("signature must be base58 encoded: "+We)}assert(qe.length===64,"signature has invalid length");const Ze=Fe||this.commitment;let Xe,Je,tr=!1;const er=new Promise((fr,ur)=>{try{Je=this.onSignature(We,(mr,br)=>{Je=void 0;const wr={context:br,value:mr};tr=!0,fr({__type:TransactionStatus.PROCESSED,response:wr})},Ze)}catch(mr){ur(mr)}}),ir=new Promise(fr=>{if(typeof Re=="string"){let ur=this._confirmTransactionInitialTimeout||6e4;switch(Ze){case"processed":case"recent":case"single":case"confirmed":case"singleGossip":{ur=this._confirmTransactionInitialTimeout||30*1e3;break}}Xe=setTimeout(()=>fr({__type:TransactionStatus.TIMED_OUT,timeoutMs:ur}),ur)}else{let ur=Re;const mr=async()=>{try{return await this.getBlockHeight(Fe)}catch{return-1}};(async()=>{let br=await mr();if(!tr){for(;br<=ur.lastValidBlockHeight;)if(await sleep(1e3),tr||(br=await mr(),tr))return;fr({__type:TransactionStatus.BLOCKHEIGHT_EXCEEDED})}})()}});let lr;try{const fr=await Promise.race([er,ir]);switch(fr.__type){case TransactionStatus.BLOCKHEIGHT_EXCEEDED:throw new TransactionExpiredBlockheightExceededError(We);case TransactionStatus.PROCESSED:lr=fr.response;break;case TransactionStatus.TIMED_OUT:throw new TransactionExpiredTimeoutError(We,fr.timeoutMs/1e3)}}finally{clearTimeout(Xe),Je&&this.removeSignatureListener(Je)}return lr}async getClusterNodes(){const Re=await this._rpcRequest("getClusterNodes",[]),Fe=create(Re,jsonRpcResult(array(ContactInfoResult)));if("error"in Fe)throw new SolanaJSONRPCError(Fe.error,"failed to get cluster nodes");return Fe.result}async getVoteAccounts(Re){const Fe=this._buildArgs([],Re),We=await this._rpcRequest("getVoteAccounts",Fe),qe=create(We,GetVoteAccounts);if("error"in qe)throw new SolanaJSONRPCError(qe.error,"failed to get vote accounts");return qe.result}async getSlot(Re){const{commitment:Fe,config:We}=extractCommitmentFromConfig(Re),qe=this._buildArgs([],Fe,void 0,We),Ze=await this._rpcRequest("getSlot",qe),Xe=create(Ze,jsonRpcResult(number()));if("error"in Xe)throw new SolanaJSONRPCError(Xe.error,"failed to get slot");return Xe.result}async getSlotLeader(Re){const{commitment:Fe,config:We}=extractCommitmentFromConfig(Re),qe=this._buildArgs([],Fe,void 0,We),Ze=await this._rpcRequest("getSlotLeader",qe),Xe=create(Ze,jsonRpcResult(string()));if("error"in Xe)throw new SolanaJSONRPCError(Xe.error,"failed to get slot leader");return Xe.result}async getSlotLeaders(Re,Fe){const We=[Re,Fe],qe=await this._rpcRequest("getSlotLeaders",We),Ze=create(qe,jsonRpcResult(array(PublicKeyFromString)));if("error"in Ze)throw new SolanaJSONRPCError(Ze.error,"failed to get slot leaders");return Ze.result}async getSignatureStatus(Re,Fe){const{context:We,value:qe}=await this.getSignatureStatuses([Re],Fe);assert(qe.length===1);const Ze=qe[0];return{context:We,value:Ze}}async getSignatureStatuses(Re,Fe){const We=[Re];Fe&&We.push(Fe);const qe=await this._rpcRequest("getSignatureStatuses",We),Ze=create(qe,GetSignatureStatusesRpcResult);if("error"in Ze)throw new SolanaJSONRPCError(Ze.error,"failed to get signature status");return Ze.result}async getTransactionCount(Re){const{commitment:Fe,config:We}=extractCommitmentFromConfig(Re),qe=this._buildArgs([],Fe,void 0,We),Ze=await this._rpcRequest("getTransactionCount",qe),Xe=create(Ze,jsonRpcResult(number()));if("error"in Xe)throw new SolanaJSONRPCError(Xe.error,"failed to get transaction count");return Xe.result}async getTotalSupply(Re){return(await this.getSupply({commitment:Re,excludeNonCirculatingAccountsList:!0})).value.total}async getInflationGovernor(Re){const Fe=this._buildArgs([],Re),We=await this._rpcRequest("getInflationGovernor",Fe),qe=create(We,GetInflationGovernorRpcResult);if("error"in qe)throw new SolanaJSONRPCError(qe.error,"failed to get inflation");return qe.result}async getInflationReward(Re,Fe,We){const{commitment:qe,config:Ze}=extractCommitmentFromConfig(We),Xe=this._buildArgs([Re.map(er=>er.toBase58())],qe,void 0,{...Ze,epoch:Fe!=null?Fe:Ze==null?void 0:Ze.epoch}),Je=await this._rpcRequest("getInflationReward",Xe),tr=create(Je,GetInflationRewardResult);if("error"in tr)throw new SolanaJSONRPCError(tr.error,"failed to get inflation reward");return tr.result}async getEpochInfo(Re){const{commitment:Fe,config:We}=extractCommitmentFromConfig(Re),qe=this._buildArgs([],Fe,void 0,We),Ze=await this._rpcRequest("getEpochInfo",qe),Xe=create(Ze,GetEpochInfoRpcResult);if("error"in Xe)throw new SolanaJSONRPCError(Xe.error,"failed to get epoch info");return Xe.result}async getEpochSchedule(){const Re=await this._rpcRequest("getEpochSchedule",[]),Fe=create(Re,GetEpochScheduleRpcResult);if("error"in Fe)throw new SolanaJSONRPCError(Fe.error,"failed to get epoch schedule");const We=Fe.result;return new EpochSchedule(We.slotsPerEpoch,We.leaderScheduleSlotOffset,We.warmup,We.firstNormalEpoch,We.firstNormalSlot)}async getLeaderSchedule(){const Re=await this._rpcRequest("getLeaderSchedule",[]),Fe=create(Re,GetLeaderScheduleRpcResult);if("error"in Fe)throw new SolanaJSONRPCError(Fe.error,"failed to get leader schedule");return Fe.result}async getMinimumBalanceForRentExemption(Re,Fe){const We=this._buildArgs([Re],Fe),qe=await this._rpcRequest("getMinimumBalanceForRentExemption",We),Ze=create(qe,GetMinimumBalanceForRentExemptionRpcResult);return"error"in Ze?(console.warn("Unable to fetch minimum balance for rent exemption"),0):Ze.result}async getRecentBlockhashAndContext(Re){const Fe=this._buildArgs([],Re),We=await this._rpcRequest("getRecentBlockhash",Fe),qe=create(We,GetRecentBlockhashAndContextRpcResult);if("error"in qe)throw new SolanaJSONRPCError(qe.error,"failed to get recent blockhash");return qe.result}async getRecentPerformanceSamples(Re){const Fe=await this._rpcRequest("getRecentPerformanceSamples",Re?[Re]:[]),We=create(Fe,GetRecentPerformanceSamplesRpcResult);if("error"in We)throw new SolanaJSONRPCError(We.error,"failed to get recent performance samples");return We.result}async getFeeCalculatorForBlockhash(Re,Fe){const We=this._buildArgs([Re],Fe),qe=await this._rpcRequest("getFeeCalculatorForBlockhash",We),Ze=create(qe,GetFeeCalculatorRpcResult);if("error"in Ze)throw new SolanaJSONRPCError(Ze.error,"failed to get fee calculator");const{context:Xe,value:Je}=Ze.result;return{context:Xe,value:Je!==null?Je.feeCalculator:null}}async getFeeForMessage(Re,Fe){const We=Re.serialize().toString("base64"),qe=this._buildArgs([We],Fe),Ze=await this._rpcRequest("getFeeForMessage",qe),Xe=create(Ze,jsonRpcResultAndContext(nullable(number())));if("error"in Xe)throw new SolanaJSONRPCError(Xe.error,"failed to get fee for message");if(Xe.result===null)throw new Error("invalid blockhash");return Xe.result}async getRecentBlockhash(Re){try{return(await this.getRecentBlockhashAndContext(Re)).value}catch(Fe){throw new Error("failed to get recent blockhash: "+Fe)}}async getLatestBlockhash(Re){try{return(await this.getLatestBlockhashAndContext(Re)).value}catch(Fe){throw new Error("failed to get recent blockhash: "+Fe)}}async getLatestBlockhashAndContext(Re){const{commitment:Fe,config:We}=extractCommitmentFromConfig(Re),qe=this._buildArgs([],Fe,void 0,We),Ze=await this._rpcRequest("getLatestBlockhash",qe),Xe=create(Ze,GetLatestBlockhashRpcResult);if("error"in Xe)throw new SolanaJSONRPCError(Xe.error,"failed to get latest blockhash");return Xe.result}async getVersion(){const Re=await this._rpcRequest("getVersion",[]),Fe=create(Re,jsonRpcResult(VersionResult));if("error"in Fe)throw new SolanaJSONRPCError(Fe.error,"failed to get version");return Fe.result}async getGenesisHash(){const Re=await this._rpcRequest("getGenesisHash",[]),Fe=create(Re,jsonRpcResult(string()));if("error"in Fe)throw new SolanaJSONRPCError(Fe.error,"failed to get genesis hash");return Fe.result}async getBlock(Re,Fe){const{commitment:We,config:qe}=extractCommitmentFromConfig(Fe),Ze=this._buildArgsAtLeastConfirmed([Re],We,void 0,qe),Xe=await this._rpcRequest("getBlock",Ze),Je=create(Xe,GetBlockRpcResult);if("error"in Je)throw new SolanaJSONRPCError(Je.error,"failed to get confirmed block");const tr=Je.result;return tr&&{...tr,transactions:tr.transactions.map(({transaction:er,meta:ir,version:lr})=>({meta:ir,transaction:{...er,message:versionedMessageFromResponse(lr,er.message)},version:lr}))}}async getParsedBlock(Re,Fe){const{commitment:We,config:qe}=extractCommitmentFromConfig(Fe),Ze=this._buildArgsAtLeastConfirmed([Re],We,"jsonParsed",qe),Xe=await this._rpcRequest("getBlock",Ze),Je=create(Xe,GetParsedBlockRpcResult);if("error"in Je)throw new SolanaJSONRPCError(Je.error,"failed to get block");return Je.result}async getBlockHeight(Re){const{commitment:Fe,config:We}=extractCommitmentFromConfig(Re),qe=this._buildArgs([],Fe,void 0,We),Ze=await this._rpcRequest("getBlockHeight",qe),Xe=create(Ze,jsonRpcResult(number()));if("error"in Xe)throw new SolanaJSONRPCError(Xe.error,"failed to get block height information");return Xe.result}async getBlockProduction(Re){let Fe,We;if(typeof Re=="string")We=Re;else if(Re){const{commitment:Je,...tr}=Re;We=Je,Fe=tr}const qe=this._buildArgs([],We,"base64",Fe),Ze=await this._rpcRequest("getBlockProduction",qe),Xe=create(Ze,BlockProductionResponseStruct);if("error"in Xe)throw new SolanaJSONRPCError(Xe.error,"failed to get block production information");return Xe.result}async getTransaction(Re,Fe){const{commitment:We,config:qe}=extractCommitmentFromConfig(Fe),Ze=this._buildArgsAtLeastConfirmed([Re],We,void 0,qe),Xe=await this._rpcRequest("getTransaction",Ze),Je=create(Xe,GetTransactionRpcResult);if("error"in Je)throw new SolanaJSONRPCError(Je.error,"failed to get transaction");const tr=Je.result;return tr&&{...tr,transaction:{...tr.transaction,message:versionedMessageFromResponse(tr.version,tr.transaction.message)}}}async getParsedTransaction(Re,Fe){const{commitment:We,config:qe}=extractCommitmentFromConfig(Fe),Ze=this._buildArgsAtLeastConfirmed([Re],We,"jsonParsed",qe),Xe=await this._rpcRequest("getTransaction",Ze),Je=create(Xe,GetParsedTransactionRpcResult);if("error"in Je)throw new SolanaJSONRPCError(Je.error,"failed to get transaction");return Je.result}async getParsedTransactions(Re,Fe){const{commitment:We,config:qe}=extractCommitmentFromConfig(Fe),Ze=Re.map(tr=>({methodName:"getTransaction",args:this._buildArgsAtLeastConfirmed([tr],We,"jsonParsed",qe)}));return(await this._rpcBatchRequest(Ze)).map(tr=>{const er=create(tr,GetParsedTransactionRpcResult);if("error"in er)throw new SolanaJSONRPCError(er.error,"failed to get transactions");return er.result})}async getTransactions(Re,Fe){const{commitment:We,config:qe}=extractCommitmentFromConfig(Fe),Ze=Re.map(tr=>({methodName:"getTransaction",args:this._buildArgsAtLeastConfirmed([tr],We,void 0,qe)}));return(await this._rpcBatchRequest(Ze)).map(tr=>{const er=create(tr,GetTransactionRpcResult);if("error"in er)throw new SolanaJSONRPCError(er.error,"failed to get transactions");const ir=er.result;return ir&&{...ir,transaction:{...ir.transaction,message:versionedMessageFromResponse(ir.version,ir.transaction.message)}}})}async getConfirmedBlock(Re,Fe){const We=this._buildArgsAtLeastConfirmed([Re],Fe),qe=await this._rpcRequest("getConfirmedBlock",We),Ze=create(qe,GetConfirmedBlockRpcResult);if("error"in Ze)throw new SolanaJSONRPCError(Ze.error,"failed to get confirmed block");const Xe=Ze.result;if(!Xe)throw new Error("Confirmed block "+Re+" not found");const Je={...Xe,transactions:Xe.transactions.map(({transaction:tr,meta:er})=>{const ir=new Message(tr.message);return{meta:er,transaction:{...tr,message:ir}}})};return{...Je,transactions:Je.transactions.map(({transaction:tr,meta:er})=>({meta:er,transaction:Transaction.populate(tr.message,tr.signatures)}))}}async getBlocks(Re,Fe,We){const qe=this._buildArgsAtLeastConfirmed(Fe!==void 0?[Re,Fe]:[Re],We),Ze=await this._rpcRequest("getBlocks",qe),Xe=create(Ze,jsonRpcResult(array(number())));if("error"in Xe)throw new SolanaJSONRPCError(Xe.error,"failed to get blocks");return Xe.result}async getBlockSignatures(Re,Fe){const We=this._buildArgsAtLeastConfirmed([Re],Fe,void 0,{transactionDetails:"signatures",rewards:!1}),qe=await this._rpcRequest("getBlock",We),Ze=create(qe,GetBlockSignaturesRpcResult);if("error"in Ze)throw new SolanaJSONRPCError(Ze.error,"failed to get block");const Xe=Ze.result;if(!Xe)throw new Error("Block "+Re+" not found");return Xe}async getConfirmedBlockSignatures(Re,Fe){const We=this._buildArgsAtLeastConfirmed([Re],Fe,void 0,{transactionDetails:"signatures",rewards:!1}),qe=await this._rpcRequest("getConfirmedBlock",We),Ze=create(qe,GetBlockSignaturesRpcResult);if("error"in Ze)throw new SolanaJSONRPCError(Ze.error,"failed to get confirmed block");const Xe=Ze.result;if(!Xe)throw new Error("Confirmed block "+Re+" not found");return Xe}async getConfirmedTransaction(Re,Fe){const We=this._buildArgsAtLeastConfirmed([Re],Fe),qe=await this._rpcRequest("getConfirmedTransaction",We),Ze=create(qe,GetTransactionRpcResult);if("error"in Ze)throw new SolanaJSONRPCError(Ze.error,"failed to get transaction");const Xe=Ze.result;if(!Xe)return Xe;const Je=new Message(Xe.transaction.message),tr=Xe.transaction.signatures;return{...Xe,transaction:Transaction.populate(Je,tr)}}async getParsedConfirmedTransaction(Re,Fe){const We=this._buildArgsAtLeastConfirmed([Re],Fe,"jsonParsed"),qe=await this._rpcRequest("getConfirmedTransaction",We),Ze=create(qe,GetParsedTransactionRpcResult);if("error"in Ze)throw new SolanaJSONRPCError(Ze.error,"failed to get confirmed transaction");return Ze.result}async getParsedConfirmedTransactions(Re,Fe){const We=Re.map(Xe=>({methodName:"getConfirmedTransaction",args:this._buildArgsAtLeastConfirmed([Xe],Fe,"jsonParsed")}));return(await this._rpcBatchRequest(We)).map(Xe=>{const Je=create(Xe,GetParsedTransactionRpcResult);if("error"in Je)throw new SolanaJSONRPCError(Je.error,"failed to get confirmed transactions");return Je.result})}async getConfirmedSignaturesForAddress(Re,Fe,We){let qe={},Ze=await this.getFirstAvailableBlock();for(;!("until"in qe)&&(Fe--,!(Fe<=0||Fe<Ze));)try{const tr=await this.getConfirmedBlockSignatures(Fe,"finalized");tr.signatures.length>0&&(qe.until=tr.signatures[tr.signatures.length-1].toString())}catch(tr){if(tr instanceof Error&&tr.message.includes("skipped"))continue;throw tr}let Xe=await this.getSlot("finalized");for(;!("before"in qe)&&(We++,!(We>Xe));)try{const tr=await this.getConfirmedBlockSignatures(We);tr.signatures.length>0&&(qe.before=tr.signatures[tr.signatures.length-1].toString())}catch(tr){if(tr instanceof Error&&tr.message.includes("skipped"))continue;throw tr}return(await this.getConfirmedSignaturesForAddress2(Re,qe)).map(tr=>tr.signature)}async getConfirmedSignaturesForAddress2(Re,Fe,We){const qe=this._buildArgsAtLeastConfirmed([Re.toBase58()],We,void 0,Fe),Ze=await this._rpcRequest("getConfirmedSignaturesForAddress2",qe),Xe=create(Ze,GetConfirmedSignaturesForAddress2RpcResult);if("error"in Xe)throw new SolanaJSONRPCError(Xe.error,"failed to get confirmed signatures for address");return Xe.result}async getSignaturesForAddress(Re,Fe,We){const qe=this._buildArgsAtLeastConfirmed([Re.toBase58()],We,void 0,Fe),Ze=await this._rpcRequest("getSignaturesForAddress",qe),Xe=create(Ze,GetSignaturesForAddressRpcResult);if("error"in Xe)throw new SolanaJSONRPCError(Xe.error,"failed to get signatures for address");return Xe.result}async getAddressLookupTable(Re,Fe){const{context:We,value:qe}=await this.getAccountInfoAndContext(Re,Fe);let Ze=null;return qe!==null&&(Ze=new AddressLookupTableAccount({key:Re,state:AddressLookupTableAccount.deserialize(qe.data)})),{context:We,value:Ze}}async getNonceAndContext(Re,Fe){const{context:We,value:qe}=await this.getAccountInfoAndContext(Re,Fe);let Ze=null;return qe!==null&&(Ze=NonceAccount.fromAccountData(qe.data)),{context:We,value:Ze}}async getNonce(Re,Fe){return await this.getNonceAndContext(Re,Fe).then(We=>We.value).catch(We=>{throw new Error("failed to get nonce for account "+Re.toBase58()+": "+We)})}async requestAirdrop(Re,Fe){const We=await this._rpcRequest("requestAirdrop",[Re.toBase58(),Fe]),qe=create(We,RequestAirdropRpcResult);if("error"in qe)throw new SolanaJSONRPCError(qe.error,`airdrop to ${Re.toBase58()} failed`);return qe.result}async _blockhashWithExpiryBlockHeight(Re){if(!Re){for(;this._pollingBlockhash;)await sleep(100);const We=Date.now()-this._blockhashInfo.lastFetch>=BLOCKHASH_CACHE_TIMEOUT_MS;if(this._blockhashInfo.latestBlockhash!==null&&!We)return this._blockhashInfo.latestBlockhash}return await this._pollNewBlockhash()}async _pollNewBlockhash(){this._pollingBlockhash=!0;try{const Re=Date.now(),Fe=this._blockhashInfo.latestBlockhash,We=Fe?Fe.blockhash:null;for(let qe=0;qe<50;qe++){const Ze=await this.getLatestBlockhash("finalized");if(We!==Ze.blockhash)return this._blockhashInfo={latestBlockhash:Ze,lastFetch:Date.now(),transactionSignatures:[],simulatedSignatures:[]},Ze;await sleep(MS_PER_SLOT/2)}throw new Error(`Unable to obtain a new blockhash after ${Date.now()-Re}ms`)}finally{this._pollingBlockhash=!1}}async getStakeMinimumDelegation(Re){const{commitment:Fe,config:We}=extractCommitmentFromConfig(Re),qe=this._buildArgs([],Fe,"base64",We),Ze=await this._rpcRequest("getStakeMinimumDelegation",qe),Xe=create(Ze,jsonRpcResultAndContext(number()));if("error"in Xe)throw new SolanaJSONRPCError(Xe.error,"failed to get stake minimum delegation");return Xe.result}async simulateTransaction(Re,Fe,We){if("message"in Re){const br=Re.serialize(),wr=buffer.Buffer.from(br).toString("base64");if(Array.isArray(Fe)||We!==void 0)throw new Error("Invalid arguments");const Sr=Fe||{};Sr.encoding="base64","commitment"in Sr||(Sr.commitment=this.commitment);const kr=[wr,Sr],Er=await this._rpcRequest("simulateTransaction",kr),Ir=create(Er,SimulatedTransactionResponseStruct);if("error"in Ir)throw new Error("failed to simulate transaction: "+Ir.error.message);return Ir.result}let qe;if(Re instanceof Transaction){let mr=Re;qe=new Transaction,qe.feePayer=mr.feePayer,qe.instructions=Re.instructions,qe.nonceInfo=mr.nonceInfo,qe.signatures=mr.signatures}else qe=Transaction.populate(Re),qe._message=qe._json=void 0;if(Fe!==void 0&&!Array.isArray(Fe))throw new Error("Invalid arguments");const Ze=Fe;if(qe.nonceInfo&&Ze)qe.sign(...Ze);else{let mr=this._disableBlockhashCaching;for(;;){const br=await this._blockhashWithExpiryBlockHeight(mr);if(qe.lastValidBlockHeight=br.lastValidBlockHeight,qe.recentBlockhash=br.blockhash,!Ze)break;if(qe.sign(...Ze),!qe.signature)throw new Error("!signature");const wr=qe.signature.toString("base64");if(!this._blockhashInfo.simulatedSignatures.includes(wr)&&!this._blockhashInfo.transactionSignatures.includes(wr)){this._blockhashInfo.simulatedSignatures.push(wr);break}else mr=!0}}const Xe=qe._compile(),Je=Xe.serialize(),er=qe._serialize(Je).toString("base64"),ir={encoding:"base64",commitment:this.commitment};if(We){const mr=(Array.isArray(We)?We:Xe.nonProgramIds()).map(br=>br.toBase58());ir.accounts={encoding:"base64",addresses:mr}}Ze&&(ir.sigVerify=!0);const lr=[er,ir],fr=await this._rpcRequest("simulateTransaction",lr),ur=create(fr,SimulatedTransactionResponseStruct);if("error"in ur){let mr;if("data"in ur.error&&(mr=ur.error.data.logs,mr&&Array.isArray(mr))){const br=`
    `,wr=br+mr.join(br);console.error(ur.error.message,wr)}throw new SendTransactionError("failed to simulate transaction: "+ur.error.message,mr)}return ur.result}async sendTransaction(Re,Fe,We){if("version"in Re){if(Fe&&Array.isArray(Fe))throw new Error("Invalid arguments");const Xe=Re.serialize();return await this.sendRawTransaction(Xe,We)}if(Fe===void 0||!Array.isArray(Fe))throw new Error("Invalid arguments");const qe=Fe;if(Re.nonceInfo)Re.sign(...qe);else{let Xe=this._disableBlockhashCaching;for(;;){const Je=await this._blockhashWithExpiryBlockHeight(Xe);if(Re.lastValidBlockHeight=Je.lastValidBlockHeight,Re.recentBlockhash=Je.blockhash,Re.sign(...qe),!Re.signature)throw new Error("!signature");const tr=Re.signature.toString("base64");if(this._blockhashInfo.transactionSignatures.includes(tr))Xe=!0;else{this._blockhashInfo.transactionSignatures.push(tr);break}}}const Ze=Re.serialize();return await this.sendRawTransaction(Ze,We)}async sendRawTransaction(Re,Fe){const We=toBuffer(Re).toString("base64");return await this.sendEncodedTransaction(We,Fe)}async sendEncodedTransaction(Re,Fe){const We={encoding:"base64"},qe=Fe&&Fe.skipPreflight,Ze=Fe&&Fe.preflightCommitment||this.commitment;Fe&&Fe.maxRetries!=null&&(We.maxRetries=Fe.maxRetries),Fe&&Fe.minContextSlot!=null&&(We.minContextSlot=Fe.minContextSlot),qe&&(We.skipPreflight=qe),Ze&&(We.preflightCommitment=Ze);const Xe=[Re,We],Je=await this._rpcRequest("sendTransaction",Xe),tr=create(Je,SendTransactionRpcResult);if("error"in tr){let er;throw"data"in tr.error&&(er=tr.error.data.logs),new SendTransactionError("failed to send transaction: "+tr.error.message,er)}return tr.result}_wsOnOpen(){this._rpcWebSocketConnected=!0,this._rpcWebSocketHeartbeat=setInterval(()=>{this._rpcWebSocket.notify("ping").catch(()=>{})},5e3),this._updateSubscriptions()}_wsOnError(Re){this._rpcWebSocketConnected=!1,console.error("ws error:",Re.message)}_wsOnClose(Re){if(this._rpcWebSocketConnected=!1,this._rpcWebSocketGeneration=(this._rpcWebSocketGeneration+1)%Number.MAX_SAFE_INTEGER,this._rpcWebSocketIdleTimeout&&(clearTimeout(this._rpcWebSocketIdleTimeout),this._rpcWebSocketIdleTimeout=null),this._rpcWebSocketHeartbeat&&(clearInterval(this._rpcWebSocketHeartbeat),this._rpcWebSocketHeartbeat=null),Re===1e3){this._updateSubscriptions();return}this._subscriptionCallbacksByServerSubscriptionId={},Object.entries(this._subscriptionsByHash).forEach(([Fe,We])=>{this._subscriptionsByHash[Fe]={...We,state:"pending"}})}async _updateSubscriptions(){if(Object.keys(this._subscriptionsByHash).length===0){this._rpcWebSocketConnected&&(this._rpcWebSocketConnected=!1,this._rpcWebSocketIdleTimeout=setTimeout(()=>{this._rpcWebSocketIdleTimeout=null;try{this._rpcWebSocket.close()}catch(We){We instanceof Error&&console.log(`Error when closing socket connection: ${We.message}`)}},500));return}if(this._rpcWebSocketIdleTimeout!==null&&(clearTimeout(this._rpcWebSocketIdleTimeout),this._rpcWebSocketIdleTimeout=null,this._rpcWebSocketConnected=!0),!this._rpcWebSocketConnected){this._rpcWebSocket.connect();return}const Re=this._rpcWebSocketGeneration,Fe=()=>Re===this._rpcWebSocketGeneration;await Promise.all(Object.keys(this._subscriptionsByHash).map(async We=>{const qe=this._subscriptionsByHash[We];if(qe!==void 0)switch(qe.state){case"pending":case"unsubscribed":if(qe.callbacks.size===0){delete this._subscriptionsByHash[We],qe.state==="unsubscribed"&&delete this._subscriptionCallbacksByServerSubscriptionId[qe.serverSubscriptionId],await this._updateSubscriptions();return}await(async()=>{const{args:Ze,method:Xe}=qe;try{this._subscriptionsByHash[We]={...qe,state:"subscribing"};const Je=await this._rpcWebSocket.call(Xe,Ze);this._subscriptionsByHash[We]={...qe,serverSubscriptionId:Je,state:"subscribed"},this._subscriptionCallbacksByServerSubscriptionId[Je]=qe.callbacks,await this._updateSubscriptions()}catch(Je){if(Je instanceof Error&&console.error(`${Xe} error for argument`,Ze,Je.message),!Fe())return;this._subscriptionsByHash[We]={...qe,state:"pending"},await this._updateSubscriptions()}})();break;case"subscribed":qe.callbacks.size===0&&await(async()=>{const{serverSubscriptionId:Ze,unsubscribeMethod:Xe}=qe;if(this._subscriptionsAutoDisposedByRpc.has(Ze))this._subscriptionsAutoDisposedByRpc.delete(Ze);else{this._subscriptionsByHash[We]={...qe,state:"unsubscribing"};try{await this._rpcWebSocket.call(Xe,[Ze])}catch(Je){if(Je instanceof Error&&console.error(`${Xe} error:`,Je.message),!Fe())return;this._subscriptionsByHash[We]={...qe,state:"subscribed"},await this._updateSubscriptions();return}}this._subscriptionsByHash[We]={...qe,state:"unsubscribed"},await this._updateSubscriptions()})();break}}))}_handleServerNotification(Re,Fe){const We=this._subscriptionCallbacksByServerSubscriptionId[Re];We!==void 0&&We.forEach(qe=>{try{qe(...Fe)}catch(Ze){console.error(Ze)}})}_wsOnAccountNotification(Re){const{result:Fe,subscription:We}=create(Re,AccountNotificationResult);this._handleServerNotification(We,[Fe.value,Fe.context])}_makeSubscription(Re,Fe){const We=this._nextClientSubscriptionId++,qe=fastStableStringify$1([Re.method,Fe]),Ze=this._subscriptionsByHash[qe];return Ze===void 0?this._subscriptionsByHash[qe]={...Re,args:Fe,callbacks:new Set([Re.callback]),state:"pending"}:Ze.callbacks.add(Re.callback),this._subscriptionDisposeFunctionsByClientSubscriptionId[We]=async()=>{delete this._subscriptionDisposeFunctionsByClientSubscriptionId[We];const Xe=this._subscriptionsByHash[qe];assert(Xe!==void 0,`Could not find a \`Subscription\` when tearing down client subscription #${We}`),Xe.callbacks.delete(Re.callback),await this._updateSubscriptions()},this._updateSubscriptions(),We}onAccountChange(Re,Fe,We){const qe=this._buildArgs([Re.toBase58()],We||this._commitment||"finalized","base64");return this._makeSubscription({callback:Fe,method:"accountSubscribe",unsubscribeMethod:"accountUnsubscribe"},qe)}async removeAccountChangeListener(Re){await this._unsubscribeClientSubscription(Re,"account change")}_wsOnProgramAccountNotification(Re){const{result:Fe,subscription:We}=create(Re,ProgramAccountNotificationResult);this._handleServerNotification(We,[{accountId:Fe.value.pubkey,accountInfo:Fe.value.account},Fe.context])}onProgramAccountChange(Re,Fe,We,qe){const Ze=this._buildArgs([Re.toBase58()],We||this._commitment||"finalized","base64",qe?{filters:qe}:void 0);return this._makeSubscription({callback:Fe,method:"programSubscribe",unsubscribeMethod:"programUnsubscribe"},Ze)}async removeProgramAccountChangeListener(Re){await this._unsubscribeClientSubscription(Re,"program account change")}onLogs(Re,Fe,We){const qe=this._buildArgs([typeof Re=="object"?{mentions:[Re.toString()]}:Re],We||this._commitment||"finalized");return this._makeSubscription({callback:Fe,method:"logsSubscribe",unsubscribeMethod:"logsUnsubscribe"},qe)}async removeOnLogsListener(Re){await this._unsubscribeClientSubscription(Re,"logs")}_wsOnLogsNotification(Re){const{result:Fe,subscription:We}=create(Re,LogsNotificationResult);this._handleServerNotification(We,[Fe.value,Fe.context])}_wsOnSlotNotification(Re){const{result:Fe,subscription:We}=create(Re,SlotNotificationResult);this._handleServerNotification(We,[Fe])}onSlotChange(Re){return this._makeSubscription({callback:Re,method:"slotSubscribe",unsubscribeMethod:"slotUnsubscribe"},[])}async removeSlotChangeListener(Re){await this._unsubscribeClientSubscription(Re,"slot change")}_wsOnSlotUpdatesNotification(Re){const{result:Fe,subscription:We}=create(Re,SlotUpdateNotificationResult);this._handleServerNotification(We,[Fe])}onSlotUpdate(Re){return this._makeSubscription({callback:Re,method:"slotsUpdatesSubscribe",unsubscribeMethod:"slotsUpdatesUnsubscribe"},[])}async removeSlotUpdateListener(Re){await this._unsubscribeClientSubscription(Re,"slot update")}async _unsubscribeClientSubscription(Re,Fe){const We=this._subscriptionDisposeFunctionsByClientSubscriptionId[Re];We?await We():console.warn(`Ignored unsubscribe request because an active subscription with id \`${Re}\` for '${Fe}' events could not be found.`)}_buildArgs(Re,Fe,We,qe){const Ze=Fe||this._commitment;if(Ze||We||qe){let Xe={};We&&(Xe.encoding=We),Ze&&(Xe.commitment=Ze),qe&&(Xe=Object.assign(Xe,qe)),Re.push(Xe)}return Re}_buildArgsAtLeastConfirmed(Re,Fe,We,qe){const Ze=Fe||this._commitment;if(Ze&&!["confirmed","finalized"].includes(Ze))throw new Error("Using Connection with default commitment: `"+this._commitment+"`, but method requires at least `confirmed`");return this._buildArgs(Re,Fe,We,qe)}_wsOnSignatureNotification(Re){const{result:Fe,subscription:We}=create(Re,SignatureNotificationResult);Fe.value!=="receivedSignature"&&this._subscriptionsAutoDisposedByRpc.add(We),this._handleServerNotification(We,Fe.value==="receivedSignature"?[{type:"received"},Fe.context]:[{type:"status",result:Fe.value},Fe.context])}onSignature(Re,Fe,We){const qe=this._buildArgs([Re],We||this._commitment||"finalized"),Ze=this._makeSubscription({callback:(Xe,Je)=>{if(Xe.type==="status"){Fe(Xe.result,Je);try{this.removeSignatureListener(Ze)}catch{}}},method:"signatureSubscribe",unsubscribeMethod:"signatureUnsubscribe"},qe);return Ze}onSignatureWithOptions(Re,Fe,We){const{commitment:qe,...Ze}={...We,commitment:We&&We.commitment||this._commitment||"finalized"},Xe=this._buildArgs([Re],qe,void 0,Ze),Je=this._makeSubscription({callback:(tr,er)=>{Fe(tr,er);try{this.removeSignatureListener(Je)}catch{}},method:"signatureSubscribe",unsubscribeMethod:"signatureUnsubscribe"},Xe);return Je}async removeSignatureListener(Re){await this._unsubscribeClientSubscription(Re,"signature result")}_wsOnRootNotification(Re){const{result:Fe,subscription:We}=create(Re,RootNotificationResult);this._handleServerNotification(We,[Fe])}onRootChange(Re){return this._makeSubscription({callback:Re,method:"rootSubscribe",unsubscribeMethod:"rootUnsubscribe"},[])}async removeRootChangeListener(Re){await this._unsubscribeClientSubscription(Re,"root change")}}class Keypair{constructor(Re){this._keypair=void 0,this._keypair=Re!=null?Re:generateKeypair()}static generate(){return new Keypair(generateKeypair())}static fromSecretKey(Re,Fe){if(Re.byteLength!==64)throw new Error("bad secret key size");const We=Re.slice(32,64);if(!Fe||!Fe.skipValidation){const qe=Re.slice(0,32),Ze=getPublicKey(qe);for(let Xe=0;Xe<32;Xe++)if(We[Xe]!==Ze[Xe])throw new Error("provided secretKey is invalid")}return new Keypair({publicKey:We,secretKey:Re})}static fromSeed(Re){const Fe=getPublicKey(Re),We=new Uint8Array(64);return We.set(Re),We.set(Fe,32),new Keypair({publicKey:Fe,secretKey:We})}get publicKey(){return new PublicKey(this._keypair.publicKey)}get secretKey(){return new Uint8Array(this._keypair.secretKey)}}const LOOKUP_TABLE_INSTRUCTION_LAYOUTS=Object.freeze({CreateLookupTable:{index:0,layout:struct([u32("instruction"),u64("recentSlot"),u8("bumpSeed")])},FreezeLookupTable:{index:1,layout:struct([u32("instruction")])},ExtendLookupTable:{index:2,layout:struct([u32("instruction"),u64(),seq(publicKey(),offset(u32(),-8),"addresses")])},DeactivateLookupTable:{index:3,layout:struct([u32("instruction")])},CloseLookupTable:{index:4,layout:struct([u32("instruction")])}});class AddressLookupTableInstruction{constructor(){}static decodeInstructionType(Re){this.checkProgramId(Re.programId);const We=u32("instruction").decode(Re.data);let qe;for(const[Ze,Xe]of Object.entries(LOOKUP_TABLE_INSTRUCTION_LAYOUTS))if(Xe.index==We){qe=Ze;break}if(!qe)throw new Error("Invalid Instruction. Should be a LookupTable Instruction");return qe}static decodeCreateLookupTable(Re){this.checkProgramId(Re.programId),this.checkKeysLength(Re.keys,4);const{recentSlot:Fe}=decodeData$1(LOOKUP_TABLE_INSTRUCTION_LAYOUTS.CreateLookupTable,Re.data);return{authority:Re.keys[1].pubkey,payer:Re.keys[2].pubkey,recentSlot:Number(Fe)}}static decodeExtendLookupTable(Re){if(this.checkProgramId(Re.programId),Re.keys.length<2)throw new Error(`invalid instruction; found ${Re.keys.length} keys, expected at least 2`);const{addresses:Fe}=decodeData$1(LOOKUP_TABLE_INSTRUCTION_LAYOUTS.ExtendLookupTable,Re.data);return{lookupTable:Re.keys[0].pubkey,authority:Re.keys[1].pubkey,payer:Re.keys.length>2?Re.keys[2].pubkey:void 0,addresses:Fe.map(We=>new PublicKey(We))}}static decodeCloseLookupTable(Re){return this.checkProgramId(Re.programId),this.checkKeysLength(Re.keys,3),{lookupTable:Re.keys[0].pubkey,authority:Re.keys[1].pubkey,recipient:Re.keys[2].pubkey}}static decodeFreezeLookupTable(Re){return this.checkProgramId(Re.programId),this.checkKeysLength(Re.keys,2),{lookupTable:Re.keys[0].pubkey,authority:Re.keys[1].pubkey}}static decodeDeactivateLookupTable(Re){return this.checkProgramId(Re.programId),this.checkKeysLength(Re.keys,2),{lookupTable:Re.keys[0].pubkey,authority:Re.keys[1].pubkey}}static checkProgramId(Re){if(!Re.equals(AddressLookupTableProgram.programId))throw new Error("invalid instruction; programId is not AddressLookupTable Program")}static checkKeysLength(Re,Fe){if(Re.length<Fe)throw new Error(`invalid instruction; found ${Re.length} keys, expected at least ${Fe}`)}}class AddressLookupTableProgram{constructor(){}static createLookupTable(Re){const[Fe,We]=PublicKey.findProgramAddressSync([Re.authority.toBuffer(),toBufferLE_1(BigInt(Re.recentSlot),8)],this.programId),qe=LOOKUP_TABLE_INSTRUCTION_LAYOUTS.CreateLookupTable,Ze=encodeData(qe,{recentSlot:BigInt(Re.recentSlot),bumpSeed:We}),Xe=[{pubkey:Fe,isSigner:!1,isWritable:!0},{pubkey:Re.authority,isSigner:!0,isWritable:!1},{pubkey:Re.payer,isSigner:!0,isWritable:!0},{pubkey:SystemProgram.programId,isSigner:!1,isWritable:!1}];return[new TransactionInstruction({programId:this.programId,keys:Xe,data:Ze}),Fe]}static freezeLookupTable(Re){const Fe=LOOKUP_TABLE_INSTRUCTION_LAYOUTS.FreezeLookupTable,We=encodeData(Fe),qe=[{pubkey:Re.lookupTable,isSigner:!1,isWritable:!0},{pubkey:Re.authority,isSigner:!0,isWritable:!1}];return new TransactionInstruction({programId:this.programId,keys:qe,data:We})}static extendLookupTable(Re){const Fe=LOOKUP_TABLE_INSTRUCTION_LAYOUTS.ExtendLookupTable,We=encodeData(Fe,{addresses:Re.addresses.map(Ze=>Ze.toBytes())}),qe=[{pubkey:Re.lookupTable,isSigner:!1,isWritable:!0},{pubkey:Re.authority,isSigner:!0,isWritable:!1}];return Re.payer&&qe.push({pubkey:Re.payer,isSigner:!0,isWritable:!0},{pubkey:SystemProgram.programId,isSigner:!1,isWritable:!1}),new TransactionInstruction({programId:this.programId,keys:qe,data:We})}static deactivateLookupTable(Re){const Fe=LOOKUP_TABLE_INSTRUCTION_LAYOUTS.DeactivateLookupTable,We=encodeData(Fe),qe=[{pubkey:Re.lookupTable,isSigner:!1,isWritable:!0},{pubkey:Re.authority,isSigner:!0,isWritable:!1}];return new TransactionInstruction({programId:this.programId,keys:qe,data:We})}static closeLookupTable(Re){const Fe=LOOKUP_TABLE_INSTRUCTION_LAYOUTS.CloseLookupTable,We=encodeData(Fe),qe=[{pubkey:Re.lookupTable,isSigner:!1,isWritable:!0},{pubkey:Re.authority,isSigner:!0,isWritable:!1},{pubkey:Re.recipient,isSigner:!1,isWritable:!0}];return new TransactionInstruction({programId:this.programId,keys:qe,data:We})}}AddressLookupTableProgram.programId=new PublicKey("AddressLookupTab1e1111111111111111111111111");class ComputeBudgetInstruction{constructor(){}static decodeInstructionType(Re){this.checkProgramId(Re.programId);const We=u8("instruction").decode(Re.data);let qe;for(const[Ze,Xe]of Object.entries(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS))if(Xe.index==We){qe=Ze;break}if(!qe)throw new Error("Instruction type incorrect; not a ComputeBudgetInstruction");return qe}static decodeRequestUnits(Re){this.checkProgramId(Re.programId);const{units:Fe,additionalFee:We}=decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestUnits,Re.data);return{units:Fe,additionalFee:We}}static decodeRequestHeapFrame(Re){this.checkProgramId(Re.programId);const{bytes:Fe}=decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestHeapFrame,Re.data);return{bytes:Fe}}static decodeSetComputeUnitLimit(Re){this.checkProgramId(Re.programId);const{units:Fe}=decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitLimit,Re.data);return{units:Fe}}static decodeSetComputeUnitPrice(Re){this.checkProgramId(Re.programId);const{microLamports:Fe}=decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitPrice,Re.data);return{microLamports:Fe}}static checkProgramId(Re){if(!Re.equals(ComputeBudgetProgram.programId))throw new Error("invalid instruction; programId is not ComputeBudgetProgram")}}const COMPUTE_BUDGET_INSTRUCTION_LAYOUTS=Object.freeze({RequestUnits:{index:0,layout:struct([u8("instruction"),u32("units"),u32("additionalFee")])},RequestHeapFrame:{index:1,layout:struct([u8("instruction"),u32("bytes")])},SetComputeUnitLimit:{index:2,layout:struct([u8("instruction"),u32("units")])},SetComputeUnitPrice:{index:3,layout:struct([u8("instruction"),u64("microLamports")])}});class ComputeBudgetProgram{constructor(){}static requestUnits(Re){const Fe=COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestUnits,We=encodeData(Fe,Re);return new TransactionInstruction({keys:[],programId:this.programId,data:We})}static requestHeapFrame(Re){const Fe=COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestHeapFrame,We=encodeData(Fe,Re);return new TransactionInstruction({keys:[],programId:this.programId,data:We})}static setComputeUnitLimit(Re){const Fe=COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitLimit,We=encodeData(Fe,Re);return new TransactionInstruction({keys:[],programId:this.programId,data:We})}static setComputeUnitPrice(Re){const Fe=COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitPrice,We=encodeData(Fe,{microLamports:BigInt(Re.microLamports)});return new TransactionInstruction({keys:[],programId:this.programId,data:We})}}ComputeBudgetProgram.programId=new PublicKey("ComputeBudget111111111111111111111111111111");const PRIVATE_KEY_BYTES$1=64,PUBLIC_KEY_BYTES$1=32,SIGNATURE_BYTES=64,ED25519_INSTRUCTION_LAYOUT=struct([u8("numSignatures"),u8("padding"),u16("signatureOffset"),u16("signatureInstructionIndex"),u16("publicKeyOffset"),u16("publicKeyInstructionIndex"),u16("messageDataOffset"),u16("messageDataSize"),u16("messageInstructionIndex")]);class Ed25519Program{constructor(){}static createInstructionWithPublicKey(Re){const{publicKey:Fe,message:We,signature:qe,instructionIndex:Ze}=Re;assert(Fe.length===PUBLIC_KEY_BYTES$1,`Public Key must be ${PUBLIC_KEY_BYTES$1} bytes but received ${Fe.length} bytes`),assert(qe.length===SIGNATURE_BYTES,`Signature must be ${SIGNATURE_BYTES} bytes but received ${qe.length} bytes`);const Xe=ED25519_INSTRUCTION_LAYOUT.span,Je=Xe+Fe.length,tr=Je+qe.length,er=1,ir=buffer.Buffer.alloc(tr+We.length),lr=Ze==null?65535:Ze;return ED25519_INSTRUCTION_LAYOUT.encode({numSignatures:er,padding:0,signatureOffset:Je,signatureInstructionIndex:lr,publicKeyOffset:Xe,publicKeyInstructionIndex:lr,messageDataOffset:tr,messageDataSize:We.length,messageInstructionIndex:lr},ir),ir.fill(Fe,Xe),ir.fill(qe,Je),ir.fill(We,tr),new TransactionInstruction({keys:[],programId:Ed25519Program.programId,data:ir})}static createInstructionWithPrivateKey(Re){const{privateKey:Fe,message:We,instructionIndex:qe}=Re;assert(Fe.length===PRIVATE_KEY_BYTES$1,`Private key must be ${PRIVATE_KEY_BYTES$1} bytes but received ${Fe.length} bytes`);try{const Ze=Keypair.fromSecretKey(Fe),Xe=Ze.publicKey.toBytes(),Je=sign(We,Ze.secretKey);return this.createInstructionWithPublicKey({publicKey:Xe,message:We,signature:Je,instructionIndex:qe})}catch(Ze){throw new Error(`Error creating instruction; ${Ze}`)}}}Ed25519Program.programId=new PublicKey("Ed25519SigVerify111111111111111111111111111");utils.hmacSha256Sync=(Ke,...Re)=>{const Fe=hmac.create(sha256$1,Ke);return Re.forEach(We=>Fe.update(We)),Fe.digest()};const ecdsaSign=(Ke,Re)=>signSync(Ke,Re,{der:!1,recovered:!0});utils.isValidPrivateKey;const publicKeyCreate=getPublicKey$1,PRIVATE_KEY_BYTES=32,ETHEREUM_ADDRESS_BYTES=20,PUBLIC_KEY_BYTES=64,SIGNATURE_OFFSETS_SERIALIZED_SIZE=11,SECP256K1_INSTRUCTION_LAYOUT=struct([u8("numSignatures"),u16("signatureOffset"),u8("signatureInstructionIndex"),u16("ethAddressOffset"),u8("ethAddressInstructionIndex"),u16("messageDataOffset"),u16("messageDataSize"),u8("messageInstructionIndex"),blob(20,"ethAddress"),blob(64,"signature"),u8("recoveryId")]);class Secp256k1Program{constructor(){}static publicKeyToEthAddress(Re){assert(Re.length===PUBLIC_KEY_BYTES,`Public key must be ${PUBLIC_KEY_BYTES} bytes but received ${Re.length} bytes`);try{return buffer.Buffer.from(keccak_256(toBuffer(Re))).slice(-ETHEREUM_ADDRESS_BYTES)}catch(Fe){throw new Error(`Error constructing Ethereum address: ${Fe}`)}}static createInstructionWithPublicKey(Re){const{publicKey:Fe,message:We,signature:qe,recoveryId:Ze,instructionIndex:Xe}=Re;return Secp256k1Program.createInstructionWithEthAddress({ethAddress:Secp256k1Program.publicKeyToEthAddress(Fe),message:We,signature:qe,recoveryId:Ze,instructionIndex:Xe})}static createInstructionWithEthAddress(Re){const{ethAddress:Fe,message:We,signature:qe,recoveryId:Ze,instructionIndex:Xe=0}=Re;let Je;typeof Fe=="string"?Fe.startsWith("0x")?Je=buffer.Buffer.from(Fe.substr(2),"hex"):Je=buffer.Buffer.from(Fe,"hex"):Je=Fe,assert(Je.length===ETHEREUM_ADDRESS_BYTES,`Address must be ${ETHEREUM_ADDRESS_BYTES} bytes but received ${Je.length} bytes`);const tr=1+SIGNATURE_OFFSETS_SERIALIZED_SIZE,er=tr,ir=tr+Je.length,lr=ir+qe.length+1,fr=1,ur=buffer.Buffer.alloc(SECP256K1_INSTRUCTION_LAYOUT.span+We.length);return SECP256K1_INSTRUCTION_LAYOUT.encode({numSignatures:fr,signatureOffset:ir,signatureInstructionIndex:Xe,ethAddressOffset:er,ethAddressInstructionIndex:Xe,messageDataOffset:lr,messageDataSize:We.length,messageInstructionIndex:Xe,signature:toBuffer(qe),ethAddress:toBuffer(Je),recoveryId:Ze},ur),ur.fill(toBuffer(We),SECP256K1_INSTRUCTION_LAYOUT.span),new TransactionInstruction({keys:[],programId:Secp256k1Program.programId,data:ur})}static createInstructionWithPrivateKey(Re){const{privateKey:Fe,message:We,instructionIndex:qe}=Re;assert(Fe.length===PRIVATE_KEY_BYTES,`Private key must be ${PRIVATE_KEY_BYTES} bytes but received ${Fe.length} bytes`);try{const Ze=toBuffer(Fe),Xe=publicKeyCreate(Ze,!1).slice(1),Je=buffer.Buffer.from(keccak_256(toBuffer(We))),[tr,er]=ecdsaSign(Je,Ze);return this.createInstructionWithPublicKey({publicKey:Xe,message:We,signature:tr,recoveryId:er,instructionIndex:qe})}catch(Ze){throw new Error(`Error creating instruction; ${Ze}`)}}}Secp256k1Program.programId=new PublicKey("KeccakSecp256k11111111111111111111111111111");const STAKE_CONFIG_ID=new PublicKey("StakeConfig11111111111111111111111111111111");class Authorized{constructor(Re,Fe){this.staker=void 0,this.withdrawer=void 0,this.staker=Re,this.withdrawer=Fe}}class Lockup{constructor(Re,Fe,We){this.unixTimestamp=void 0,this.epoch=void 0,this.custodian=void 0,this.unixTimestamp=Re,this.epoch=Fe,this.custodian=We}}Lockup.default=new Lockup(0,0,PublicKey.default);class StakeInstruction{constructor(){}static decodeInstructionType(Re){this.checkProgramId(Re.programId);const We=u32("instruction").decode(Re.data);let qe;for(const[Ze,Xe]of Object.entries(STAKE_INSTRUCTION_LAYOUTS))if(Xe.index==We){qe=Ze;break}if(!qe)throw new Error("Instruction type incorrect; not a StakeInstruction");return qe}static decodeInitialize(Re){this.checkProgramId(Re.programId),this.checkKeyLength(Re.keys,2);const{authorized:Fe,lockup:We}=decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Initialize,Re.data);return{stakePubkey:Re.keys[0].pubkey,authorized:new Authorized(new PublicKey(Fe.staker),new PublicKey(Fe.withdrawer)),lockup:new Lockup(We.unixTimestamp,We.epoch,new PublicKey(We.custodian))}}static decodeDelegate(Re){return this.checkProgramId(Re.programId),this.checkKeyLength(Re.keys,6),decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Delegate,Re.data),{stakePubkey:Re.keys[0].pubkey,votePubkey:Re.keys[1].pubkey,authorizedPubkey:Re.keys[5].pubkey}}static decodeAuthorize(Re){this.checkProgramId(Re.programId),this.checkKeyLength(Re.keys,3);const{newAuthorized:Fe,stakeAuthorizationType:We}=decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Authorize,Re.data),qe={stakePubkey:Re.keys[0].pubkey,authorizedPubkey:Re.keys[2].pubkey,newAuthorizedPubkey:new PublicKey(Fe),stakeAuthorizationType:{index:We}};return Re.keys.length>3&&(qe.custodianPubkey=Re.keys[3].pubkey),qe}static decodeAuthorizeWithSeed(Re){this.checkProgramId(Re.programId),this.checkKeyLength(Re.keys,2);const{newAuthorized:Fe,stakeAuthorizationType:We,authoritySeed:qe,authorityOwner:Ze}=decodeData$1(STAKE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed,Re.data),Xe={stakePubkey:Re.keys[0].pubkey,authorityBase:Re.keys[1].pubkey,authoritySeed:qe,authorityOwner:new PublicKey(Ze),newAuthorizedPubkey:new PublicKey(Fe),stakeAuthorizationType:{index:We}};return Re.keys.length>3&&(Xe.custodianPubkey=Re.keys[3].pubkey),Xe}static decodeSplit(Re){this.checkProgramId(Re.programId),this.checkKeyLength(Re.keys,3);const{lamports:Fe}=decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Split,Re.data);return{stakePubkey:Re.keys[0].pubkey,splitStakePubkey:Re.keys[1].pubkey,authorizedPubkey:Re.keys[2].pubkey,lamports:Fe}}static decodeMerge(Re){return this.checkProgramId(Re.programId),this.checkKeyLength(Re.keys,3),decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Merge,Re.data),{stakePubkey:Re.keys[0].pubkey,sourceStakePubKey:Re.keys[1].pubkey,authorizedPubkey:Re.keys[4].pubkey}}static decodeWithdraw(Re){this.checkProgramId(Re.programId),this.checkKeyLength(Re.keys,5);const{lamports:Fe}=decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Withdraw,Re.data),We={stakePubkey:Re.keys[0].pubkey,toPubkey:Re.keys[1].pubkey,authorizedPubkey:Re.keys[4].pubkey,lamports:Fe};return Re.keys.length>5&&(We.custodianPubkey=Re.keys[5].pubkey),We}static decodeDeactivate(Re){return this.checkProgramId(Re.programId),this.checkKeyLength(Re.keys,3),decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Deactivate,Re.data),{stakePubkey:Re.keys[0].pubkey,authorizedPubkey:Re.keys[2].pubkey}}static checkProgramId(Re){if(!Re.equals(StakeProgram.programId))throw new Error("invalid instruction; programId is not StakeProgram")}static checkKeyLength(Re,Fe){if(Re.length<Fe)throw new Error(`invalid instruction; found ${Re.length} keys, expected at least ${Fe}`)}}const STAKE_INSTRUCTION_LAYOUTS=Object.freeze({Initialize:{index:0,layout:struct([u32("instruction"),authorized(),lockup()])},Authorize:{index:1,layout:struct([u32("instruction"),publicKey("newAuthorized"),u32("stakeAuthorizationType")])},Delegate:{index:2,layout:struct([u32("instruction")])},Split:{index:3,layout:struct([u32("instruction"),ns64("lamports")])},Withdraw:{index:4,layout:struct([u32("instruction"),ns64("lamports")])},Deactivate:{index:5,layout:struct([u32("instruction")])},Merge:{index:7,layout:struct([u32("instruction")])},AuthorizeWithSeed:{index:8,layout:struct([u32("instruction"),publicKey("newAuthorized"),u32("stakeAuthorizationType"),rustString("authoritySeed"),publicKey("authorityOwner")])}}),StakeAuthorizationLayout=Object.freeze({Staker:{index:0},Withdrawer:{index:1}});class StakeProgram{constructor(){}static initialize(Re){const{stakePubkey:Fe,authorized:We,lockup:qe}=Re,Ze=qe||Lockup.default,Xe=STAKE_INSTRUCTION_LAYOUTS.Initialize,Je=encodeData(Xe,{authorized:{staker:toBuffer(We.staker.toBuffer()),withdrawer:toBuffer(We.withdrawer.toBuffer())},lockup:{unixTimestamp:Ze.unixTimestamp,epoch:Ze.epoch,custodian:toBuffer(Ze.custodian.toBuffer())}}),tr={keys:[{pubkey:Fe,isSigner:!1,isWritable:!0},{pubkey:SYSVAR_RENT_PUBKEY,isSigner:!1,isWritable:!1}],programId:this.programId,data:Je};return new TransactionInstruction(tr)}static createAccountWithSeed(Re){const Fe=new Transaction;Fe.add(SystemProgram.createAccountWithSeed({fromPubkey:Re.fromPubkey,newAccountPubkey:Re.stakePubkey,basePubkey:Re.basePubkey,seed:Re.seed,lamports:Re.lamports,space:this.space,programId:this.programId}));const{stakePubkey:We,authorized:qe,lockup:Ze}=Re;return Fe.add(this.initialize({stakePubkey:We,authorized:qe,lockup:Ze}))}static createAccount(Re){const Fe=new Transaction;Fe.add(SystemProgram.createAccount({fromPubkey:Re.fromPubkey,newAccountPubkey:Re.stakePubkey,lamports:Re.lamports,space:this.space,programId:this.programId}));const{stakePubkey:We,authorized:qe,lockup:Ze}=Re;return Fe.add(this.initialize({stakePubkey:We,authorized:qe,lockup:Ze}))}static delegate(Re){const{stakePubkey:Fe,authorizedPubkey:We,votePubkey:qe}=Re,Ze=STAKE_INSTRUCTION_LAYOUTS.Delegate,Xe=encodeData(Ze);return new Transaction().add({keys:[{pubkey:Fe,isSigner:!1,isWritable:!0},{pubkey:qe,isSigner:!1,isWritable:!1},{pubkey:SYSVAR_CLOCK_PUBKEY,isSigner:!1,isWritable:!1},{pubkey:SYSVAR_STAKE_HISTORY_PUBKEY,isSigner:!1,isWritable:!1},{pubkey:STAKE_CONFIG_ID,isSigner:!1,isWritable:!1},{pubkey:We,isSigner:!0,isWritable:!1}],programId:this.programId,data:Xe})}static authorize(Re){const{stakePubkey:Fe,authorizedPubkey:We,newAuthorizedPubkey:qe,stakeAuthorizationType:Ze,custodianPubkey:Xe}=Re,Je=STAKE_INSTRUCTION_LAYOUTS.Authorize,tr=encodeData(Je,{newAuthorized:toBuffer(qe.toBuffer()),stakeAuthorizationType:Ze.index}),er=[{pubkey:Fe,isSigner:!1,isWritable:!0},{pubkey:SYSVAR_CLOCK_PUBKEY,isSigner:!1,isWritable:!0},{pubkey:We,isSigner:!0,isWritable:!1}];return Xe&&er.push({pubkey:Xe,isSigner:!1,isWritable:!1}),new Transaction().add({keys:er,programId:this.programId,data:tr})}static authorizeWithSeed(Re){const{stakePubkey:Fe,authorityBase:We,authoritySeed:qe,authorityOwner:Ze,newAuthorizedPubkey:Xe,stakeAuthorizationType:Je,custodianPubkey:tr}=Re,er=STAKE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed,ir=encodeData(er,{newAuthorized:toBuffer(Xe.toBuffer()),stakeAuthorizationType:Je.index,authoritySeed:qe,authorityOwner:toBuffer(Ze.toBuffer())}),lr=[{pubkey:Fe,isSigner:!1,isWritable:!0},{pubkey:We,isSigner:!0,isWritable:!1},{pubkey:SYSVAR_CLOCK_PUBKEY,isSigner:!1,isWritable:!1}];return tr&&lr.push({pubkey:tr,isSigner:!1,isWritable:!1}),new Transaction().add({keys:lr,programId:this.programId,data:ir})}static splitInstruction(Re){const{stakePubkey:Fe,authorizedPubkey:We,splitStakePubkey:qe,lamports:Ze}=Re,Xe=STAKE_INSTRUCTION_LAYOUTS.Split,Je=encodeData(Xe,{lamports:Ze});return new TransactionInstruction({keys:[{pubkey:Fe,isSigner:!1,isWritable:!0},{pubkey:qe,isSigner:!1,isWritable:!0},{pubkey:We,isSigner:!0,isWritable:!1}],programId:this.programId,data:Je})}static split(Re){const Fe=new Transaction;return Fe.add(SystemProgram.createAccount({fromPubkey:Re.authorizedPubkey,newAccountPubkey:Re.splitStakePubkey,lamports:0,space:this.space,programId:this.programId})),Fe.add(this.splitInstruction(Re))}static splitWithSeed(Re){const{stakePubkey:Fe,authorizedPubkey:We,splitStakePubkey:qe,basePubkey:Ze,seed:Xe,lamports:Je}=Re,tr=new Transaction;return tr.add(SystemProgram.allocate({accountPubkey:qe,basePubkey:Ze,seed:Xe,space:this.space,programId:this.programId})),tr.add(this.splitInstruction({stakePubkey:Fe,authorizedPubkey:We,splitStakePubkey:qe,lamports:Je}))}static merge(Re){const{stakePubkey:Fe,sourceStakePubKey:We,authorizedPubkey:qe}=Re,Ze=STAKE_INSTRUCTION_LAYOUTS.Merge,Xe=encodeData(Ze);return new Transaction().add({keys:[{pubkey:Fe,isSigner:!1,isWritable:!0},{pubkey:We,isSigner:!1,isWritable:!0},{pubkey:SYSVAR_CLOCK_PUBKEY,isSigner:!1,isWritable:!1},{pubkey:SYSVAR_STAKE_HISTORY_PUBKEY,isSigner:!1,isWritable:!1},{pubkey:qe,isSigner:!0,isWritable:!1}],programId:this.programId,data:Xe})}static withdraw(Re){const{stakePubkey:Fe,authorizedPubkey:We,toPubkey:qe,lamports:Ze,custodianPubkey:Xe}=Re,Je=STAKE_INSTRUCTION_LAYOUTS.Withdraw,tr=encodeData(Je,{lamports:Ze}),er=[{pubkey:Fe,isSigner:!1,isWritable:!0},{pubkey:qe,isSigner:!1,isWritable:!0},{pubkey:SYSVAR_CLOCK_PUBKEY,isSigner:!1,isWritable:!1},{pubkey:SYSVAR_STAKE_HISTORY_PUBKEY,isSigner:!1,isWritable:!1},{pubkey:We,isSigner:!0,isWritable:!1}];return Xe&&er.push({pubkey:Xe,isSigner:!1,isWritable:!1}),new Transaction().add({keys:er,programId:this.programId,data:tr})}static deactivate(Re){const{stakePubkey:Fe,authorizedPubkey:We}=Re,qe=STAKE_INSTRUCTION_LAYOUTS.Deactivate,Ze=encodeData(qe);return new Transaction().add({keys:[{pubkey:Fe,isSigner:!1,isWritable:!0},{pubkey:SYSVAR_CLOCK_PUBKEY,isSigner:!1,isWritable:!1},{pubkey:We,isSigner:!0,isWritable:!1}],programId:this.programId,data:Ze})}}StakeProgram.programId=new PublicKey("Stake11111111111111111111111111111111111111");StakeProgram.space=200;class VoteInit{constructor(Re,Fe,We,qe){this.nodePubkey=void 0,this.authorizedVoter=void 0,this.authorizedWithdrawer=void 0,this.commission=void 0,this.nodePubkey=Re,this.authorizedVoter=Fe,this.authorizedWithdrawer=We,this.commission=qe}}class VoteInstruction{constructor(){}static decodeInstructionType(Re){this.checkProgramId(Re.programId);const We=u32("instruction").decode(Re.data);let qe;for(const[Ze,Xe]of Object.entries(VOTE_INSTRUCTION_LAYOUTS))if(Xe.index==We){qe=Ze;break}if(!qe)throw new Error("Instruction type incorrect; not a VoteInstruction");return qe}static decodeInitializeAccount(Re){this.checkProgramId(Re.programId),this.checkKeyLength(Re.keys,4);const{voteInit:Fe}=decodeData$1(VOTE_INSTRUCTION_LAYOUTS.InitializeAccount,Re.data);return{votePubkey:Re.keys[0].pubkey,nodePubkey:Re.keys[3].pubkey,voteInit:new VoteInit(new PublicKey(Fe.nodePubkey),new PublicKey(Fe.authorizedVoter),new PublicKey(Fe.authorizedWithdrawer),Fe.commission)}}static decodeAuthorize(Re){this.checkProgramId(Re.programId),this.checkKeyLength(Re.keys,3);const{newAuthorized:Fe,voteAuthorizationType:We}=decodeData$1(VOTE_INSTRUCTION_LAYOUTS.Authorize,Re.data);return{votePubkey:Re.keys[0].pubkey,authorizedPubkey:Re.keys[2].pubkey,newAuthorizedPubkey:new PublicKey(Fe),voteAuthorizationType:{index:We}}}static decodeAuthorizeWithSeed(Re){this.checkProgramId(Re.programId),this.checkKeyLength(Re.keys,3);const{voteAuthorizeWithSeedArgs:{currentAuthorityDerivedKeyOwnerPubkey:Fe,currentAuthorityDerivedKeySeed:We,newAuthorized:qe,voteAuthorizationType:Ze}}=decodeData$1(VOTE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed,Re.data);return{currentAuthorityDerivedKeyBasePubkey:Re.keys[2].pubkey,currentAuthorityDerivedKeyOwnerPubkey:new PublicKey(Fe),currentAuthorityDerivedKeySeed:We,newAuthorizedPubkey:new PublicKey(qe),voteAuthorizationType:{index:Ze},votePubkey:Re.keys[0].pubkey}}static decodeWithdraw(Re){this.checkProgramId(Re.programId),this.checkKeyLength(Re.keys,3);const{lamports:Fe}=decodeData$1(VOTE_INSTRUCTION_LAYOUTS.Withdraw,Re.data);return{votePubkey:Re.keys[0].pubkey,authorizedWithdrawerPubkey:Re.keys[2].pubkey,lamports:Fe,toPubkey:Re.keys[1].pubkey}}static checkProgramId(Re){if(!Re.equals(VoteProgram.programId))throw new Error("invalid instruction; programId is not VoteProgram")}static checkKeyLength(Re,Fe){if(Re.length<Fe)throw new Error(`invalid instruction; found ${Re.length} keys, expected at least ${Fe}`)}}const VOTE_INSTRUCTION_LAYOUTS=Object.freeze({InitializeAccount:{index:0,layout:struct([u32("instruction"),voteInit()])},Authorize:{index:1,layout:struct([u32("instruction"),publicKey("newAuthorized"),u32("voteAuthorizationType")])},Withdraw:{index:3,layout:struct([u32("instruction"),ns64("lamports")])},AuthorizeWithSeed:{index:10,layout:struct([u32("instruction"),voteAuthorizeWithSeedArgs()])}}),VoteAuthorizationLayout=Object.freeze({Voter:{index:0},Withdrawer:{index:1}});class VoteProgram{constructor(){}static initializeAccount(Re){const{votePubkey:Fe,nodePubkey:We,voteInit:qe}=Re,Ze=VOTE_INSTRUCTION_LAYOUTS.InitializeAccount,Xe=encodeData(Ze,{voteInit:{nodePubkey:toBuffer(qe.nodePubkey.toBuffer()),authorizedVoter:toBuffer(qe.authorizedVoter.toBuffer()),authorizedWithdrawer:toBuffer(qe.authorizedWithdrawer.toBuffer()),commission:qe.commission}}),Je={keys:[{pubkey:Fe,isSigner:!1,isWritable:!0},{pubkey:SYSVAR_RENT_PUBKEY,isSigner:!1,isWritable:!1},{pubkey:SYSVAR_CLOCK_PUBKEY,isSigner:!1,isWritable:!1},{pubkey:We,isSigner:!0,isWritable:!1}],programId:this.programId,data:Xe};return new TransactionInstruction(Je)}static createAccount(Re){const Fe=new Transaction;return Fe.add(SystemProgram.createAccount({fromPubkey:Re.fromPubkey,newAccountPubkey:Re.votePubkey,lamports:Re.lamports,space:this.space,programId:this.programId})),Fe.add(this.initializeAccount({votePubkey:Re.votePubkey,nodePubkey:Re.voteInit.nodePubkey,voteInit:Re.voteInit}))}static authorize(Re){const{votePubkey:Fe,authorizedPubkey:We,newAuthorizedPubkey:qe,voteAuthorizationType:Ze}=Re,Xe=VOTE_INSTRUCTION_LAYOUTS.Authorize,Je=encodeData(Xe,{newAuthorized:toBuffer(qe.toBuffer()),voteAuthorizationType:Ze.index}),tr=[{pubkey:Fe,isSigner:!1,isWritable:!0},{pubkey:SYSVAR_CLOCK_PUBKEY,isSigner:!1,isWritable:!1},{pubkey:We,isSigner:!0,isWritable:!1}];return new Transaction().add({keys:tr,programId:this.programId,data:Je})}static authorizeWithSeed(Re){const{currentAuthorityDerivedKeyBasePubkey:Fe,currentAuthorityDerivedKeyOwnerPubkey:We,currentAuthorityDerivedKeySeed:qe,newAuthorizedPubkey:Ze,voteAuthorizationType:Xe,votePubkey:Je}=Re,tr=VOTE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed,er=encodeData(tr,{voteAuthorizeWithSeedArgs:{currentAuthorityDerivedKeyOwnerPubkey:toBuffer(We.toBuffer()),currentAuthorityDerivedKeySeed:qe,newAuthorized:toBuffer(Ze.toBuffer()),voteAuthorizationType:Xe.index}}),ir=[{pubkey:Je,isSigner:!1,isWritable:!0},{pubkey:SYSVAR_CLOCK_PUBKEY,isSigner:!1,isWritable:!1},{pubkey:Fe,isSigner:!0,isWritable:!1}];return new Transaction().add({keys:ir,programId:this.programId,data:er})}static withdraw(Re){const{votePubkey:Fe,authorizedWithdrawerPubkey:We,lamports:qe,toPubkey:Ze}=Re,Xe=VOTE_INSTRUCTION_LAYOUTS.Withdraw,Je=encodeData(Xe,{lamports:qe}),tr=[{pubkey:Fe,isSigner:!1,isWritable:!0},{pubkey:Ze,isSigner:!1,isWritable:!0},{pubkey:We,isSigner:!0,isWritable:!1}];return new Transaction().add({keys:tr,programId:this.programId,data:Je})}static safeWithdraw(Re,Fe,We){if(Re.lamports>Fe-We)throw new Error("Withdraw will leave vote account with insuffcient funds.");return VoteProgram.withdraw(Re)}}VoteProgram.programId=new PublicKey("Vote111111111111111111111111111111111111111");VoteProgram.space=3731;const VALIDATOR_INFO_KEY=new PublicKey("Va1idator1nfo111111111111111111111111111111"),InfoString=type({name:string(),website:optional(string()),details:optional(string()),keybaseUsername:optional(string())});class ValidatorInfo{constructor(Re,Fe){this.key=void 0,this.info=void 0,this.key=Re,this.info=Fe}static fromConfigData(Re){let Fe=[...Re];if(decodeLength(Fe)!==2)return null;const qe=[];for(let Ze=0;Ze<2;Ze++){const Xe=new PublicKey(Fe.slice(0,PUBLIC_KEY_LENGTH));Fe=Fe.slice(PUBLIC_KEY_LENGTH);const Je=Fe.slice(0,1)[0]===1;Fe=Fe.slice(1),qe.push({publicKey:Xe,isSigner:Je})}if(qe[0].publicKey.equals(VALIDATOR_INFO_KEY)&&qe[1].isSigner){const Ze=rustString().decode(buffer.Buffer.from(Fe)),Xe=JSON.parse(Ze);return assert$1(Xe,InfoString),new ValidatorInfo(qe[1].publicKey,Xe)}return null}}const VOTE_PROGRAM_ID=new PublicKey("Vote111111111111111111111111111111111111111"),VoteAccountLayout=struct([publicKey("nodePubkey"),publicKey("authorizedWithdrawer"),u8("commission"),nu64(),seq(struct([nu64("slot"),u32("confirmationCount")]),offset(u32(),-8),"votes"),u8("rootSlotValid"),nu64("rootSlot"),nu64(),seq(struct([nu64("epoch"),publicKey("authorizedVoter")]),offset(u32(),-8),"authorizedVoters"),struct([seq(struct([publicKey("authorizedPubkey"),nu64("epochOfLastAuthorizedSwitch"),nu64("targetEpoch")]),32,"buf"),nu64("idx"),u8("isEmpty")],"priorVoters"),nu64(),seq(struct([nu64("epoch"),nu64("credits"),nu64("prevCredits")]),offset(u32(),-8),"epochCredits"),struct([nu64("slot"),nu64("timestamp")],"lastTimestamp")]);class VoteAccount{constructor(Re){this.nodePubkey=void 0,this.authorizedWithdrawer=void 0,this.commission=void 0,this.rootSlot=void 0,this.votes=void 0,this.authorizedVoters=void 0,this.priorVoters=void 0,this.epochCredits=void 0,this.lastTimestamp=void 0,this.nodePubkey=Re.nodePubkey,this.authorizedWithdrawer=Re.authorizedWithdrawer,this.commission=Re.commission,this.rootSlot=Re.rootSlot,this.votes=Re.votes,this.authorizedVoters=Re.authorizedVoters,this.priorVoters=Re.priorVoters,this.epochCredits=Re.epochCredits,this.lastTimestamp=Re.lastTimestamp}static fromAccountData(Re){const We=VoteAccountLayout.decode(toBuffer(Re),4);let qe=We.rootSlot;return We.rootSlotValid||(qe=null),new VoteAccount({nodePubkey:new PublicKey(We.nodePubkey),authorizedWithdrawer:new PublicKey(We.authorizedWithdrawer),commission:We.commission,votes:We.votes,rootSlot:qe,authorizedVoters:We.authorizedVoters.map(parseAuthorizedVoter),priorVoters:getPriorVoters(We.priorVoters),epochCredits:We.epochCredits,lastTimestamp:We.lastTimestamp})}}function parseAuthorizedVoter({authorizedVoter:Ke,epoch:Re}){return{epoch:Re,authorizedVoter:new PublicKey(Ke)}}function parsePriorVoters({authorizedPubkey:Ke,epochOfLastAuthorizedSwitch:Re,targetEpoch:Fe}){return{authorizedPubkey:new PublicKey(Ke),epochOfLastAuthorizedSwitch:Re,targetEpoch:Fe}}function getPriorVoters({buf:Ke,idx:Re,isEmpty:Fe}){return Fe?[]:[...Ke.slice(Re+1).map(parsePriorVoters),...Ke.slice(0,Re).map(parsePriorVoters)]}const endpoint={http:{devnet:"http://api.devnet.solana.com",testnet:"http://api.testnet.solana.com","mainnet-beta":"http://api.mainnet-beta.solana.com/"},https:{devnet:"https://api.devnet.solana.com",testnet:"https://api.testnet.solana.com","mainnet-beta":"https://api.mainnet-beta.solana.com/"}};function clusterApiUrl(Ke,Re){const Fe=Re===!1?"http":"https";if(!Ke)return endpoint[Fe].devnet;const We=endpoint[Fe][Ke];if(!We)throw new Error(`Unknown ${Fe} cluster: ${Ke}`);return We}async function sendAndConfirmRawTransaction(Ke,Re,Fe,We){let qe,Ze;Fe&&Object.prototype.hasOwnProperty.call(Fe,"lastValidBlockHeight")?(qe=Fe,Ze=We):Ze=Fe;const Xe=Ze&&{skipPreflight:Ze.skipPreflight,preflightCommitment:Ze.preflightCommitment||Ze.commitment,minContextSlot:Ze.minContextSlot},Je=await Ke.sendRawTransaction(Re,Xe),tr=Ze&&Ze.commitment,ir=(await(qe?Ke.confirmTransaction(qe,tr):Ke.confirmTransaction(Je,tr))).value;if(ir.err)throw new Error(`Raw transaction ${Je} failed (${JSON.stringify(ir)})`);return Je}const LAMPORTS_PER_SOL=1e9,index_browser_esm=Object.freeze(Object.defineProperty({__proto__:null,Account,AddressLookupTableAccount,AddressLookupTableInstruction,AddressLookupTableProgram,Authorized,BLOCKHASH_CACHE_TIMEOUT_MS,BPF_LOADER_DEPRECATED_PROGRAM_ID,BPF_LOADER_PROGRAM_ID,BpfLoader,COMPUTE_BUDGET_INSTRUCTION_LAYOUTS,ComputeBudgetInstruction,ComputeBudgetProgram,Connection,Ed25519Program,Enum,EpochSchedule,FeeCalculatorLayout,Keypair,LAMPORTS_PER_SOL,LOOKUP_TABLE_INSTRUCTION_LAYOUTS,Loader,Lockup,MAX_SEED_LENGTH,Message,MessageAccountKeys,MessageV0,NONCE_ACCOUNT_LENGTH,NonceAccount,PACKET_DATA_SIZE,PUBLIC_KEY_LENGTH,PublicKey,SIGNATURE_LENGTH_IN_BYTES,SOLANA_SCHEMA,STAKE_CONFIG_ID,STAKE_INSTRUCTION_LAYOUTS,SYSTEM_INSTRUCTION_LAYOUTS,SYSVAR_CLOCK_PUBKEY,SYSVAR_EPOCH_SCHEDULE_PUBKEY,SYSVAR_INSTRUCTIONS_PUBKEY,SYSVAR_RECENT_BLOCKHASHES_PUBKEY,SYSVAR_RENT_PUBKEY,SYSVAR_REWARDS_PUBKEY,SYSVAR_SLOT_HASHES_PUBKEY,SYSVAR_SLOT_HISTORY_PUBKEY,SYSVAR_STAKE_HISTORY_PUBKEY,Secp256k1Program,SendTransactionError,SolanaJSONRPCError,SolanaJSONRPCErrorCode,StakeAuthorizationLayout,StakeInstruction,StakeProgram,Struct,SystemInstruction,SystemProgram,Transaction,TransactionExpiredBlockheightExceededError,TransactionExpiredTimeoutError,TransactionInstruction,TransactionMessage,get TransactionStatus(){return TransactionStatus},VALIDATOR_INFO_KEY,VERSION_PREFIX_MASK,VOTE_PROGRAM_ID,ValidatorInfo,VersionedMessage,VersionedTransaction,VoteAccount,VoteAuthorizationLayout,VoteInit,VoteInstruction,VoteProgram,clusterApiUrl,sendAndConfirmRawTransaction,sendAndConfirmTransaction},Symbol.toStringTag,{value:"Module"})),PROGRAM_KEY="DByFcag9yDLwRGnBCT8bJpJPM7akth4dpHXosf7eaB7s";let NETWORK="devnet";var camelcase={exports:{}};const preserveCamelCase=Ke=>{let Re=!1,Fe=!1,We=!1;for(let qe=0;qe<Ke.length;qe++){const Ze=Ke[qe];Re&&/[a-zA-Z]/.test(Ze)&&Ze.toUpperCase()===Ze?(Ke=Ke.slice(0,qe)+"-"+Ke.slice(qe),Re=!1,We=Fe,Fe=!0,qe++):Fe&&We&&/[a-zA-Z]/.test(Ze)&&Ze.toLowerCase()===Ze?(Ke=Ke.slice(0,qe-1)+"-"+Ke.slice(qe-1),We=Fe,Fe=!1,Re=!0):(Re=Ze.toLowerCase()===Ze&&Ze.toUpperCase()!==Ze,We=Fe,Fe=Ze.toUpperCase()===Ze&&Ze.toLowerCase()!==Ze)}return Ke},camelCase=(Ke,Re)=>{if(!(typeof Ke=="string"||Array.isArray(Ke)))throw new TypeError("Expected the input to be `string | string[]`");Re=Object.assign({pascalCase:!1},Re);const Fe=qe=>Re.pascalCase?qe.charAt(0).toUpperCase()+qe.slice(1):qe;return Array.isArray(Ke)?Ke=Ke.map(qe=>qe.trim()).filter(qe=>qe.length).join("-"):Ke=Ke.trim(),Ke.length===0?"":Ke.length===1?Re.pascalCase?Ke.toUpperCase():Ke.toLowerCase():(Ke!==Ke.toLowerCase()&&(Ke=preserveCamelCase(Ke)),Ke=Ke.replace(/^[_.\- ]+/,"").toLowerCase().replace(/[_.\- ]+(\w|$)/g,(qe,Ze)=>Ze.toUpperCase()).replace(/\d+(\w|$)/g,qe=>qe.toUpperCase()),Fe(Ke))};camelcase.exports=camelCase;camelcase.exports.default=camelCase;var sha256={exports:{}};/**
 * [js-sha256]{@link https://github.com/emn178/js-sha256}
 *
 * @version 0.9.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2014-2017
 * @license MIT
 */(function(module){(function(){var ERROR="input is invalid type",WINDOW=typeof window=="object",root=WINDOW?window:{};root.JS_SHA256_NO_WINDOW&&(WINDOW=!1);var WEB_WORKER=!WINDOW&&typeof self=="object",NODE_JS=!root.JS_SHA256_NO_NODE_JS&&typeof process=="object"&&process.versions&&process.versions.node;NODE_JS?root=commonjsGlobal:WEB_WORKER&&(root=self);var COMMON_JS=!root.JS_SHA256_NO_COMMON_JS&&!0&&module.exports,ARRAY_BUFFER=!root.JS_SHA256_NO_ARRAY_BUFFER&&typeof ArrayBuffer<"u",HEX_CHARS="0123456789abcdef".split(""),EXTRA=[-2147483648,8388608,32768,128],SHIFT=[24,16,8,0],K=[1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298],OUTPUT_TYPES=["hex","array","digest","arrayBuffer"],blocks=[];(root.JS_SHA256_NO_NODE_JS||!Array.isArray)&&(Array.isArray=function(Ke){return Object.prototype.toString.call(Ke)==="[object Array]"}),ARRAY_BUFFER&&(root.JS_SHA256_NO_ARRAY_BUFFER_IS_VIEW||!ArrayBuffer.isView)&&(ArrayBuffer.isView=function(Ke){return typeof Ke=="object"&&Ke.buffer&&Ke.buffer.constructor===ArrayBuffer});var createOutputMethod=function(Ke,Re){return function(Fe){return new Sha256(Re,!0).update(Fe)[Ke]()}},createMethod=function(Ke){var Re=createOutputMethod("hex",Ke);NODE_JS&&(Re=nodeWrap(Re,Ke)),Re.create=function(){return new Sha256(Ke)},Re.update=function(qe){return Re.create().update(qe)};for(var Fe=0;Fe<OUTPUT_TYPES.length;++Fe){var We=OUTPUT_TYPES[Fe];Re[We]=createOutputMethod(We,Ke)}return Re},nodeWrap=function(method,is224){var crypto=eval("require('crypto')"),Buffer=eval("require('buffer').Buffer"),algorithm=is224?"sha224":"sha256",nodeMethod=function(Ke){if(typeof Ke=="string")return crypto.createHash(algorithm).update(Ke,"utf8").digest("hex");if(Ke==null)throw new Error(ERROR);return Ke.constructor===ArrayBuffer&&(Ke=new Uint8Array(Ke)),Array.isArray(Ke)||ArrayBuffer.isView(Ke)||Ke.constructor===Buffer?crypto.createHash(algorithm).update(new Buffer(Ke)).digest("hex"):method(Ke)};return nodeMethod},createHmacOutputMethod=function(Ke,Re){return function(Fe,We){return new HmacSha256(Fe,Re,!0).update(We)[Ke]()}},createHmacMethod=function(Ke){var Re=createHmacOutputMethod("hex",Ke);Re.create=function(qe){return new HmacSha256(qe,Ke)},Re.update=function(qe,Ze){return Re.create(qe).update(Ze)};for(var Fe=0;Fe<OUTPUT_TYPES.length;++Fe){var We=OUTPUT_TYPES[Fe];Re[We]=createHmacOutputMethod(We,Ke)}return Re};function Sha256(Ke,Re){Re?(blocks[0]=blocks[16]=blocks[1]=blocks[2]=blocks[3]=blocks[4]=blocks[5]=blocks[6]=blocks[7]=blocks[8]=blocks[9]=blocks[10]=blocks[11]=blocks[12]=blocks[13]=blocks[14]=blocks[15]=0,this.blocks=blocks):this.blocks=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],Ke?(this.h0=3238371032,this.h1=914150663,this.h2=812702999,this.h3=4144912697,this.h4=4290775857,this.h5=1750603025,this.h6=1694076839,this.h7=3204075428):(this.h0=1779033703,this.h1=3144134277,this.h2=1013904242,this.h3=2773480762,this.h4=1359893119,this.h5=2600822924,this.h6=528734635,this.h7=1541459225),this.block=this.start=this.bytes=this.hBytes=0,this.finalized=this.hashed=!1,this.first=!0,this.is224=Ke}Sha256.prototype.update=function(Ke){if(!this.finalized){var Re,Fe=typeof Ke;if(Fe!=="string"){if(Fe==="object"){if(Ke===null)throw new Error(ERROR);if(ARRAY_BUFFER&&Ke.constructor===ArrayBuffer)Ke=new Uint8Array(Ke);else if(!Array.isArray(Ke)&&(!ARRAY_BUFFER||!ArrayBuffer.isView(Ke)))throw new Error(ERROR)}else throw new Error(ERROR);Re=!0}for(var We,qe=0,Ze,Xe=Ke.length,Je=this.blocks;qe<Xe;){if(this.hashed&&(this.hashed=!1,Je[0]=this.block,Je[16]=Je[1]=Je[2]=Je[3]=Je[4]=Je[5]=Je[6]=Je[7]=Je[8]=Je[9]=Je[10]=Je[11]=Je[12]=Je[13]=Je[14]=Je[15]=0),Re)for(Ze=this.start;qe<Xe&&Ze<64;++qe)Je[Ze>>2]|=Ke[qe]<<SHIFT[Ze++&3];else for(Ze=this.start;qe<Xe&&Ze<64;++qe)We=Ke.charCodeAt(qe),We<128?Je[Ze>>2]|=We<<SHIFT[Ze++&3]:We<2048?(Je[Ze>>2]|=(192|We>>6)<<SHIFT[Ze++&3],Je[Ze>>2]|=(128|We&63)<<SHIFT[Ze++&3]):We<55296||We>=57344?(Je[Ze>>2]|=(224|We>>12)<<SHIFT[Ze++&3],Je[Ze>>2]|=(128|We>>6&63)<<SHIFT[Ze++&3],Je[Ze>>2]|=(128|We&63)<<SHIFT[Ze++&3]):(We=65536+((We&1023)<<10|Ke.charCodeAt(++qe)&1023),Je[Ze>>2]|=(240|We>>18)<<SHIFT[Ze++&3],Je[Ze>>2]|=(128|We>>12&63)<<SHIFT[Ze++&3],Je[Ze>>2]|=(128|We>>6&63)<<SHIFT[Ze++&3],Je[Ze>>2]|=(128|We&63)<<SHIFT[Ze++&3]);this.lastByteIndex=Ze,this.bytes+=Ze-this.start,Ze>=64?(this.block=Je[16],this.start=Ze-64,this.hash(),this.hashed=!0):this.start=Ze}return this.bytes>4294967295&&(this.hBytes+=this.bytes/4294967296<<0,this.bytes=this.bytes%4294967296),this}},Sha256.prototype.finalize=function(){if(!this.finalized){this.finalized=!0;var Ke=this.blocks,Re=this.lastByteIndex;Ke[16]=this.block,Ke[Re>>2]|=EXTRA[Re&3],this.block=Ke[16],Re>=56&&(this.hashed||this.hash(),Ke[0]=this.block,Ke[16]=Ke[1]=Ke[2]=Ke[3]=Ke[4]=Ke[5]=Ke[6]=Ke[7]=Ke[8]=Ke[9]=Ke[10]=Ke[11]=Ke[12]=Ke[13]=Ke[14]=Ke[15]=0),Ke[14]=this.hBytes<<3|this.bytes>>>29,Ke[15]=this.bytes<<3,this.hash()}},Sha256.prototype.hash=function(){var Ke=this.h0,Re=this.h1,Fe=this.h2,We=this.h3,qe=this.h4,Ze=this.h5,Xe=this.h6,Je=this.h7,tr=this.blocks,er,ir,lr,fr,ur,mr,br,wr,Sr,kr,Er;for(er=16;er<64;++er)ur=tr[er-15],ir=(ur>>>7|ur<<25)^(ur>>>18|ur<<14)^ur>>>3,ur=tr[er-2],lr=(ur>>>17|ur<<15)^(ur>>>19|ur<<13)^ur>>>10,tr[er]=tr[er-16]+ir+tr[er-7]+lr<<0;for(Er=Re&Fe,er=0;er<64;er+=4)this.first?(this.is224?(wr=300032,ur=tr[0]-1413257819,Je=ur-150054599<<0,We=ur+24177077<<0):(wr=704751109,ur=tr[0]-210244248,Je=ur-1521486534<<0,We=ur+143694565<<0),this.first=!1):(ir=(Ke>>>2|Ke<<30)^(Ke>>>13|Ke<<19)^(Ke>>>22|Ke<<10),lr=(qe>>>6|qe<<26)^(qe>>>11|qe<<21)^(qe>>>25|qe<<7),wr=Ke&Re,fr=wr^Ke&Fe^Er,br=qe&Ze^~qe&Xe,ur=Je+lr+br+K[er]+tr[er],mr=ir+fr,Je=We+ur<<0,We=ur+mr<<0),ir=(We>>>2|We<<30)^(We>>>13|We<<19)^(We>>>22|We<<10),lr=(Je>>>6|Je<<26)^(Je>>>11|Je<<21)^(Je>>>25|Je<<7),Sr=We&Ke,fr=Sr^We&Re^wr,br=Je&qe^~Je&Ze,ur=Xe+lr+br+K[er+1]+tr[er+1],mr=ir+fr,Xe=Fe+ur<<0,Fe=ur+mr<<0,ir=(Fe>>>2|Fe<<30)^(Fe>>>13|Fe<<19)^(Fe>>>22|Fe<<10),lr=(Xe>>>6|Xe<<26)^(Xe>>>11|Xe<<21)^(Xe>>>25|Xe<<7),kr=Fe&We,fr=kr^Fe&Ke^Sr,br=Xe&Je^~Xe&qe,ur=Ze+lr+br+K[er+2]+tr[er+2],mr=ir+fr,Ze=Re+ur<<0,Re=ur+mr<<0,ir=(Re>>>2|Re<<30)^(Re>>>13|Re<<19)^(Re>>>22|Re<<10),lr=(Ze>>>6|Ze<<26)^(Ze>>>11|Ze<<21)^(Ze>>>25|Ze<<7),Er=Re&Fe,fr=Er^Re&We^kr,br=Ze&Xe^~Ze&Je,ur=qe+lr+br+K[er+3]+tr[er+3],mr=ir+fr,qe=Ke+ur<<0,Ke=ur+mr<<0;this.h0=this.h0+Ke<<0,this.h1=this.h1+Re<<0,this.h2=this.h2+Fe<<0,this.h3=this.h3+We<<0,this.h4=this.h4+qe<<0,this.h5=this.h5+Ze<<0,this.h6=this.h6+Xe<<0,this.h7=this.h7+Je<<0},Sha256.prototype.hex=function(){this.finalize();var Ke=this.h0,Re=this.h1,Fe=this.h2,We=this.h3,qe=this.h4,Ze=this.h5,Xe=this.h6,Je=this.h7,tr=HEX_CHARS[Ke>>28&15]+HEX_CHARS[Ke>>24&15]+HEX_CHARS[Ke>>20&15]+HEX_CHARS[Ke>>16&15]+HEX_CHARS[Ke>>12&15]+HEX_CHARS[Ke>>8&15]+HEX_CHARS[Ke>>4&15]+HEX_CHARS[Ke&15]+HEX_CHARS[Re>>28&15]+HEX_CHARS[Re>>24&15]+HEX_CHARS[Re>>20&15]+HEX_CHARS[Re>>16&15]+HEX_CHARS[Re>>12&15]+HEX_CHARS[Re>>8&15]+HEX_CHARS[Re>>4&15]+HEX_CHARS[Re&15]+HEX_CHARS[Fe>>28&15]+HEX_CHARS[Fe>>24&15]+HEX_CHARS[Fe>>20&15]+HEX_CHARS[Fe>>16&15]+HEX_CHARS[Fe>>12&15]+HEX_CHARS[Fe>>8&15]+HEX_CHARS[Fe>>4&15]+HEX_CHARS[Fe&15]+HEX_CHARS[We>>28&15]+HEX_CHARS[We>>24&15]+HEX_CHARS[We>>20&15]+HEX_CHARS[We>>16&15]+HEX_CHARS[We>>12&15]+HEX_CHARS[We>>8&15]+HEX_CHARS[We>>4&15]+HEX_CHARS[We&15]+HEX_CHARS[qe>>28&15]+HEX_CHARS[qe>>24&15]+HEX_CHARS[qe>>20&15]+HEX_CHARS[qe>>16&15]+HEX_CHARS[qe>>12&15]+HEX_CHARS[qe>>8&15]+HEX_CHARS[qe>>4&15]+HEX_CHARS[qe&15]+HEX_CHARS[Ze>>28&15]+HEX_CHARS[Ze>>24&15]+HEX_CHARS[Ze>>20&15]+HEX_CHARS[Ze>>16&15]+HEX_CHARS[Ze>>12&15]+HEX_CHARS[Ze>>8&15]+HEX_CHARS[Ze>>4&15]+HEX_CHARS[Ze&15]+HEX_CHARS[Xe>>28&15]+HEX_CHARS[Xe>>24&15]+HEX_CHARS[Xe>>20&15]+HEX_CHARS[Xe>>16&15]+HEX_CHARS[Xe>>12&15]+HEX_CHARS[Xe>>8&15]+HEX_CHARS[Xe>>4&15]+HEX_CHARS[Xe&15];return this.is224||(tr+=HEX_CHARS[Je>>28&15]+HEX_CHARS[Je>>24&15]+HEX_CHARS[Je>>20&15]+HEX_CHARS[Je>>16&15]+HEX_CHARS[Je>>12&15]+HEX_CHARS[Je>>8&15]+HEX_CHARS[Je>>4&15]+HEX_CHARS[Je&15]),tr},Sha256.prototype.toString=Sha256.prototype.hex,Sha256.prototype.digest=function(){this.finalize();var Ke=this.h0,Re=this.h1,Fe=this.h2,We=this.h3,qe=this.h4,Ze=this.h5,Xe=this.h6,Je=this.h7,tr=[Ke>>24&255,Ke>>16&255,Ke>>8&255,Ke&255,Re>>24&255,Re>>16&255,Re>>8&255,Re&255,Fe>>24&255,Fe>>16&255,Fe>>8&255,Fe&255,We>>24&255,We>>16&255,We>>8&255,We&255,qe>>24&255,qe>>16&255,qe>>8&255,qe&255,Ze>>24&255,Ze>>16&255,Ze>>8&255,Ze&255,Xe>>24&255,Xe>>16&255,Xe>>8&255,Xe&255];return this.is224||tr.push(Je>>24&255,Je>>16&255,Je>>8&255,Je&255),tr},Sha256.prototype.array=Sha256.prototype.digest,Sha256.prototype.arrayBuffer=function(){this.finalize();var Ke=new ArrayBuffer(this.is224?28:32),Re=new DataView(Ke);return Re.setUint32(0,this.h0),Re.setUint32(4,this.h1),Re.setUint32(8,this.h2),Re.setUint32(12,this.h3),Re.setUint32(16,this.h4),Re.setUint32(20,this.h5),Re.setUint32(24,this.h6),this.is224||Re.setUint32(28,this.h7),Ke};function HmacSha256(Ke,Re,Fe){var We,qe=typeof Ke;if(qe==="string"){var Ze=[],Xe=Ke.length,Je=0,tr;for(We=0;We<Xe;++We)tr=Ke.charCodeAt(We),tr<128?Ze[Je++]=tr:tr<2048?(Ze[Je++]=192|tr>>6,Ze[Je++]=128|tr&63):tr<55296||tr>=57344?(Ze[Je++]=224|tr>>12,Ze[Je++]=128|tr>>6&63,Ze[Je++]=128|tr&63):(tr=65536+((tr&1023)<<10|Ke.charCodeAt(++We)&1023),Ze[Je++]=240|tr>>18,Ze[Je++]=128|tr>>12&63,Ze[Je++]=128|tr>>6&63,Ze[Je++]=128|tr&63);Ke=Ze}else if(qe==="object"){if(Ke===null)throw new Error(ERROR);if(ARRAY_BUFFER&&Ke.constructor===ArrayBuffer)Ke=new Uint8Array(Ke);else if(!Array.isArray(Ke)&&(!ARRAY_BUFFER||!ArrayBuffer.isView(Ke)))throw new Error(ERROR)}else throw new Error(ERROR);Ke.length>64&&(Ke=new Sha256(Re,!0).update(Ke).array());var er=[],ir=[];for(We=0;We<64;++We){var lr=Ke[We]||0;er[We]=92^lr,ir[We]=54^lr}Sha256.call(this,Re,Fe),this.update(ir),this.oKeyPad=er,this.inner=!0,this.sharedMemory=Fe}HmacSha256.prototype=new Sha256,HmacSha256.prototype.finalize=function(){if(Sha256.prototype.finalize.call(this),this.inner){this.inner=!1;var Ke=this.array();Sha256.call(this,this.is224,this.sharedMemory),this.update(this.oKeyPad),this.update(Ke),Sha256.prototype.finalize.call(this)}};var exports=createMethod();exports.sha256=exports,exports.sha224=createMethod(!0),exports.sha256.hmac=createHmacMethod(),exports.sha224.hmac=createHmacMethod(!0),COMMON_JS?module.exports=exports:(root.sha256=exports.sha256,root.sha224=exports.sha224)})()})(sha256);var lib={},Layout$1={};class Layout{constructor(Re,Fe){if(!Number.isInteger(Re))throw new TypeError("span must be an integer");this.span=Re,this.property=Fe}makeDestinationObject(){return{}}decode(Re,Fe){throw new Error("Layout is abstract")}encode(Re,Fe,We){throw new Error("Layout is abstract")}getSpan(Re,Fe){if(0>this.span)throw new RangeError("indeterminate span");return this.span}replicate(Re){const Fe=Object.create(this.constructor.prototype);return Object.assign(Fe,this),Fe.property=Re,Fe}fromArray(Re){}}Layout$1.Layout=Layout;function nameWithProperty(Ke,Re){return Re.property?Ke+"["+Re.property+"]":Ke}Layout$1.nameWithProperty=nameWithProperty;function bindConstructorLayout(Ke,Re){if(typeof Ke!="function")throw new TypeError("Class must be constructor");if(Ke.hasOwnProperty("layout_"))throw new Error("Class is already bound to a layout");if(!(Re&&Re instanceof Layout))throw new TypeError("layout must be a Layout");if(Re.hasOwnProperty("boundConstructor_"))throw new Error("layout is already bound to a constructor");Ke.layout_=Re,Re.boundConstructor_=Ke,Re.makeDestinationObject=()=>new Ke,Object.defineProperty(Ke.prototype,"encode",{value:function(Fe,We){return Re.encode(this,Fe,We)},writable:!0}),Object.defineProperty(Ke,"decode",{value:function(Fe,We){return Re.decode(Fe,We)},writable:!0})}Layout$1.bindConstructorLayout=bindConstructorLayout;class ExternalLayout extends Layout{isCount(){throw new Error("ExternalLayout is abstract")}}class GreedyCount extends ExternalLayout{constructor(Re,Fe){if(Re===void 0&&(Re=1),!Number.isInteger(Re)||0>=Re)throw new TypeError("elementSpan must be a (positive) integer");super(-1,Fe),this.elementSpan=Re}isCount(){return!0}decode(Re,Fe){Fe===void 0&&(Fe=0);const We=Re.length-Fe;return Math.floor(We/this.elementSpan)}encode(Re,Fe,We){return 0}}class OffsetLayout extends ExternalLayout{constructor(Re,Fe,We){if(!(Re instanceof Layout))throw new TypeError("layout must be a Layout");if(Fe===void 0)Fe=0;else if(!Number.isInteger(Fe))throw new TypeError("offset must be integer or undefined");super(Re.span,We||Re.property),this.layout=Re,this.offset=Fe}isCount(){return this.layout instanceof UInt||this.layout instanceof UIntBE}decode(Re,Fe){return Fe===void 0&&(Fe=0),this.layout.decode(Re,Fe+this.offset)}encode(Re,Fe,We){return We===void 0&&(We=0),this.layout.encode(Re,Fe,We+this.offset)}}class UInt extends Layout{constructor(Re,Fe){if(super(Re,Fe),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(Re,Fe){return Fe===void 0&&(Fe=0),Re.readUIntLE(Fe,this.span)}encode(Re,Fe,We){return We===void 0&&(We=0),Fe.writeUIntLE(Re,We,this.span),this.span}}class UIntBE extends Layout{constructor(Re,Fe){if(super(Re,Fe),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(Re,Fe){return Fe===void 0&&(Fe=0),Re.readUIntBE(Fe,this.span)}encode(Re,Fe,We){return We===void 0&&(We=0),Fe.writeUIntBE(Re,We,this.span),this.span}}class Int extends Layout{constructor(Re,Fe){if(super(Re,Fe),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(Re,Fe){return Fe===void 0&&(Fe=0),Re.readIntLE(Fe,this.span)}encode(Re,Fe,We){return We===void 0&&(We=0),Fe.writeIntLE(Re,We,this.span),this.span}}class IntBE extends Layout{constructor(Re,Fe){if(super(Re,Fe),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(Re,Fe){return Fe===void 0&&(Fe=0),Re.readIntBE(Fe,this.span)}encode(Re,Fe,We){return We===void 0&&(We=0),Fe.writeIntBE(Re,We,this.span),this.span}}const V2E32=Math.pow(2,32);function divmodInt64(Ke){const Re=Math.floor(Ke/V2E32),Fe=Ke-Re*V2E32;return{hi32:Re,lo32:Fe}}function roundedInt64(Ke,Re){return Ke*V2E32+Re}class NearUInt64 extends Layout{constructor(Re){super(8,Re)}decode(Re,Fe){Fe===void 0&&(Fe=0);const We=Re.readUInt32LE(Fe),qe=Re.readUInt32LE(Fe+4);return roundedInt64(qe,We)}encode(Re,Fe,We){We===void 0&&(We=0);const qe=divmodInt64(Re);return Fe.writeUInt32LE(qe.lo32,We),Fe.writeUInt32LE(qe.hi32,We+4),8}}class NearUInt64BE extends Layout{constructor(Re){super(8,Re)}decode(Re,Fe){Fe===void 0&&(Fe=0);const We=Re.readUInt32BE(Fe),qe=Re.readUInt32BE(Fe+4);return roundedInt64(We,qe)}encode(Re,Fe,We){We===void 0&&(We=0);const qe=divmodInt64(Re);return Fe.writeUInt32BE(qe.hi32,We),Fe.writeUInt32BE(qe.lo32,We+4),8}}class NearInt64 extends Layout{constructor(Re){super(8,Re)}decode(Re,Fe){Fe===void 0&&(Fe=0);const We=Re.readUInt32LE(Fe),qe=Re.readInt32LE(Fe+4);return roundedInt64(qe,We)}encode(Re,Fe,We){We===void 0&&(We=0);const qe=divmodInt64(Re);return Fe.writeUInt32LE(qe.lo32,We),Fe.writeInt32LE(qe.hi32,We+4),8}}class NearInt64BE extends Layout{constructor(Re){super(8,Re)}decode(Re,Fe){Fe===void 0&&(Fe=0);const We=Re.readInt32BE(Fe),qe=Re.readUInt32BE(Fe+4);return roundedInt64(We,qe)}encode(Re,Fe,We){We===void 0&&(We=0);const qe=divmodInt64(Re);return Fe.writeInt32BE(qe.hi32,We),Fe.writeUInt32BE(qe.lo32,We+4),8}}class Float extends Layout{constructor(Re){super(4,Re)}decode(Re,Fe){return Fe===void 0&&(Fe=0),Re.readFloatLE(Fe)}encode(Re,Fe,We){return We===void 0&&(We=0),Fe.writeFloatLE(Re,We),4}}class FloatBE extends Layout{constructor(Re){super(4,Re)}decode(Re,Fe){return Fe===void 0&&(Fe=0),Re.readFloatBE(Fe)}encode(Re,Fe,We){return We===void 0&&(We=0),Fe.writeFloatBE(Re,We),4}}class Double extends Layout{constructor(Re){super(8,Re)}decode(Re,Fe){return Fe===void 0&&(Fe=0),Re.readDoubleLE(Fe)}encode(Re,Fe,We){return We===void 0&&(We=0),Fe.writeDoubleLE(Re,We),8}}class DoubleBE extends Layout{constructor(Re){super(8,Re)}decode(Re,Fe){return Fe===void 0&&(Fe=0),Re.readDoubleBE(Fe)}encode(Re,Fe,We){return We===void 0&&(We=0),Fe.writeDoubleBE(Re,We),8}}class Sequence extends Layout{constructor(Re,Fe,We){if(!(Re instanceof Layout))throw new TypeError("elementLayout must be a Layout");if(!(Fe instanceof ExternalLayout&&Fe.isCount()||Number.isInteger(Fe)&&0<=Fe))throw new TypeError("count must be non-negative integer or an unsigned integer ExternalLayout");let qe=-1;!(Fe instanceof ExternalLayout)&&0<Re.span&&(qe=Fe*Re.span),super(qe,We),this.elementLayout=Re,this.count=Fe}getSpan(Re,Fe){if(0<=this.span)return this.span;Fe===void 0&&(Fe=0);let We=0,qe=this.count;if(qe instanceof ExternalLayout&&(qe=qe.decode(Re,Fe)),0<this.elementLayout.span)We=qe*this.elementLayout.span;else{let Ze=0;for(;Ze<qe;)We+=this.elementLayout.getSpan(Re,Fe+We),++Ze}return We}decode(Re,Fe){Fe===void 0&&(Fe=0);const We=[];let qe=0,Ze=this.count;for(Ze instanceof ExternalLayout&&(Ze=Ze.decode(Re,Fe));qe<Ze;)We.push(this.elementLayout.decode(Re,Fe)),Fe+=this.elementLayout.getSpan(Re,Fe),qe+=1;return We}encode(Re,Fe,We){We===void 0&&(We=0);const qe=this.elementLayout,Ze=Re.reduce((Xe,Je)=>Xe+qe.encode(Je,Fe,We+Xe),0);return this.count instanceof ExternalLayout&&this.count.encode(Re.length,Fe,We),Ze}}class Structure extends Layout{constructor(Re,Fe,We){if(!(Array.isArray(Re)&&Re.reduce((Ze,Xe)=>Ze&&Xe instanceof Layout,!0)))throw new TypeError("fields must be array of Layout instances");typeof Fe=="boolean"&&We===void 0&&(We=Fe,Fe=void 0);for(const Ze of Re)if(0>Ze.span&&Ze.property===void 0)throw new Error("fields cannot contain unnamed variable-length layout");let qe=-1;try{qe=Re.reduce((Ze,Xe)=>Ze+Xe.getSpan(),0)}catch{}super(qe,Fe),this.fields=Re,this.decodePrefixes=!!We}getSpan(Re,Fe){if(0<=this.span)return this.span;Fe===void 0&&(Fe=0);let We=0;try{We=this.fields.reduce((qe,Ze)=>{const Xe=Ze.getSpan(Re,Fe);return Fe+=Xe,qe+Xe},0)}catch{throw new RangeError("indeterminate span")}return We}decode(Re,Fe){Fe===void 0&&(Fe=0);const We=this.makeDestinationObject();for(const qe of this.fields)if(qe.property!==void 0&&(We[qe.property]=qe.decode(Re,Fe)),Fe+=qe.getSpan(Re,Fe),this.decodePrefixes&&Re.length===Fe)break;return We}encode(Re,Fe,We){We===void 0&&(We=0);const qe=We;let Ze=0,Xe=0;for(const Je of this.fields){let tr=Je.span;if(Xe=0<tr?tr:0,Je.property!==void 0){const er=Re[Je.property];er!==void 0&&(Xe=Je.encode(er,Fe,We),0>tr&&(tr=Je.getSpan(Fe,We)))}Ze=We,We+=tr}return Ze+Xe-qe}fromArray(Re){const Fe=this.makeDestinationObject();for(const We of this.fields)We.property!==void 0&&0<Re.length&&(Fe[We.property]=Re.shift());return Fe}layoutFor(Re){if(typeof Re!="string")throw new TypeError("property must be string");for(const Fe of this.fields)if(Fe.property===Re)return Fe}offsetOf(Re){if(typeof Re!="string")throw new TypeError("property must be string");let Fe=0;for(const We of this.fields){if(We.property===Re)return Fe;0>We.span?Fe=-1:0<=Fe&&(Fe+=We.span)}}}class UnionDiscriminator{constructor(Re){this.property=Re}decode(){throw new Error("UnionDiscriminator is abstract")}encode(){throw new Error("UnionDiscriminator is abstract")}}class UnionLayoutDiscriminator extends UnionDiscriminator{constructor(Re,Fe){if(!(Re instanceof ExternalLayout&&Re.isCount()))throw new TypeError("layout must be an unsigned integer ExternalLayout");super(Fe||Re.property||"variant"),this.layout=Re}decode(Re,Fe){return this.layout.decode(Re,Fe)}encode(Re,Fe,We){return this.layout.encode(Re,Fe,We)}}class Union extends Layout{constructor(Re,Fe,We){const qe=Re instanceof UInt||Re instanceof UIntBE;if(qe)Re=new UnionLayoutDiscriminator(new OffsetLayout(Re));else if(Re instanceof ExternalLayout&&Re.isCount())Re=new UnionLayoutDiscriminator(Re);else if(!(Re instanceof UnionDiscriminator))throw new TypeError("discr must be a UnionDiscriminator or an unsigned integer layout");if(Fe===void 0&&(Fe=null),!(Fe===null||Fe instanceof Layout))throw new TypeError("defaultLayout must be null or a Layout");if(Fe!==null){if(0>Fe.span)throw new Error("defaultLayout must have constant span");Fe.property===void 0&&(Fe=Fe.replicate("content"))}let Ze=-1;Fe&&(Ze=Fe.span,0<=Ze&&qe&&(Ze+=Re.layout.span)),super(Ze,We),this.discriminator=Re,this.usesPrefixDiscriminator=qe,this.defaultLayout=Fe,this.registry={};let Xe=this.defaultGetSourceVariant.bind(this);this.getSourceVariant=function(Je){return Xe(Je)},this.configGetSourceVariant=function(Je){Xe=Je.bind(this)}}getSpan(Re,Fe){if(0<=this.span)return this.span;Fe===void 0&&(Fe=0);const We=this.getVariant(Re,Fe);if(!We)throw new Error("unable to determine span for unrecognized variant");return We.getSpan(Re,Fe)}defaultGetSourceVariant(Re){if(Re.hasOwnProperty(this.discriminator.property)){if(this.defaultLayout&&Re.hasOwnProperty(this.defaultLayout.property))return;const Fe=this.registry[Re[this.discriminator.property]];if(Fe&&(!Fe.layout||Re.hasOwnProperty(Fe.property)))return Fe}else for(const Fe in this.registry){const We=this.registry[Fe];if(Re.hasOwnProperty(We.property))return We}throw new Error("unable to infer src variant")}decode(Re,Fe){Fe===void 0&&(Fe=0);let We;const qe=this.discriminator,Ze=qe.decode(Re,Fe);let Xe=this.registry[Ze];if(Xe===void 0){let Je=0;Xe=this.defaultLayout,this.usesPrefixDiscriminator&&(Je=qe.layout.span),We=this.makeDestinationObject(),We[qe.property]=Ze,We[Xe.property]=this.defaultLayout.decode(Re,Fe+Je)}else We=Xe.decode(Re,Fe);return We}encode(Re,Fe,We){We===void 0&&(We=0);const qe=this.getSourceVariant(Re);if(qe===void 0){const Ze=this.discriminator,Xe=this.defaultLayout;let Je=0;return this.usesPrefixDiscriminator&&(Je=Ze.layout.span),Ze.encode(Re[Ze.property],Fe,We),Je+Xe.encode(Re[Xe.property],Fe,We+Je)}return qe.encode(Re,Fe,We)}addVariant(Re,Fe,We){const qe=new VariantLayout(this,Re,Fe,We);return this.registry[Re]=qe,qe}getVariant(Re,Fe){let We=Re;return Buffer.isBuffer(Re)&&(Fe===void 0&&(Fe=0),We=this.discriminator.decode(Re,Fe)),this.registry[We]}}class VariantLayout extends Layout{constructor(Re,Fe,We,qe){if(!(Re instanceof Union))throw new TypeError("union must be a Union");if(!Number.isInteger(Fe)||0>Fe)throw new TypeError("variant must be a (non-negative) integer");if(typeof We=="string"&&qe===void 0&&(qe=We,We=null),We){if(!(We instanceof Layout))throw new TypeError("layout must be a Layout");if(Re.defaultLayout!==null&&0<=We.span&&We.span>Re.defaultLayout.span)throw new Error("variant span exceeds span of containing union");if(typeof qe!="string")throw new TypeError("variant must have a String property")}let Ze=Re.span;0>Re.span&&(Ze=We?We.span:0,0<=Ze&&Re.usesPrefixDiscriminator&&(Ze+=Re.discriminator.layout.span)),super(Ze,qe),this.union=Re,this.variant=Fe,this.layout=We||null}getSpan(Re,Fe){if(0<=this.span)return this.span;Fe===void 0&&(Fe=0);let We=0;return this.union.usesPrefixDiscriminator&&(We=this.union.discriminator.layout.span),We+this.layout.getSpan(Re,Fe+We)}decode(Re,Fe){const We=this.makeDestinationObject();if(Fe===void 0&&(Fe=0),this!==this.union.getVariant(Re,Fe))throw new Error("variant mismatch");let qe=0;return this.union.usesPrefixDiscriminator&&(qe=this.union.discriminator.layout.span),this.layout?We[this.property]=this.layout.decode(Re,Fe+qe):this.property?We[this.property]=!0:this.union.usesPrefixDiscriminator&&(We[this.union.discriminator.property]=this.variant),We}encode(Re,Fe,We){We===void 0&&(We=0);let qe=0;if(this.union.usesPrefixDiscriminator&&(qe=this.union.discriminator.layout.span),this.layout&&!Re.hasOwnProperty(this.property))throw new TypeError("variant lacks property "+this.property);this.union.discriminator.encode(this.variant,Fe,We);let Ze=qe;if(this.layout&&(this.layout.encode(Re[this.property],Fe,We+qe),Ze+=this.layout.getSpan(Fe,We+qe),0<=this.union.span&&Ze>this.union.span))throw new Error("encoded variant overruns containing union");return Ze}fromArray(Re){if(this.layout)return this.layout.fromArray(Re)}}function fixBitwiseResult(Ke){return 0>Ke&&(Ke+=4294967296),Ke}class BitStructure extends Layout{constructor(Re,Fe,We){if(!(Re instanceof UInt||Re instanceof UIntBE))throw new TypeError("word must be a UInt or UIntBE layout");if(typeof Fe=="string"&&We===void 0&&(We=Fe,Fe=void 0),4<Re.span)throw new RangeError("word cannot exceed 32 bits");super(Re.span,We),this.word=Re,this.msb=!!Fe,this.fields=[];let qe=0;this._packedSetValue=function(Ze){return qe=fixBitwiseResult(Ze),this},this._packedGetValue=function(){return qe}}decode(Re,Fe){const We=this.makeDestinationObject();Fe===void 0&&(Fe=0);const qe=this.word.decode(Re,Fe);this._packedSetValue(qe);for(const Ze of this.fields)Ze.property!==void 0&&(We[Ze.property]=Ze.decode(qe));return We}encode(Re,Fe,We){We===void 0&&(We=0);const qe=this.word.decode(Fe,We);this._packedSetValue(qe);for(const Ze of this.fields)if(Ze.property!==void 0){const Xe=Re[Ze.property];Xe!==void 0&&Ze.encode(Xe)}return this.word.encode(this._packedGetValue(),Fe,We)}addField(Re,Fe){const We=new BitField(this,Re,Fe);return this.fields.push(We),We}addBoolean(Re){const Fe=new Boolean$1(this,Re);return this.fields.push(Fe),Fe}fieldFor(Re){if(typeof Re!="string")throw new TypeError("property must be string");for(const Fe of this.fields)if(Fe.property===Re)return Fe}}class BitField{constructor(Re,Fe,We){if(!(Re instanceof BitStructure))throw new TypeError("container must be a BitStructure");if(!Number.isInteger(Fe)||0>=Fe)throw new TypeError("bits must be positive integer");const qe=8*Re.span,Ze=Re.fields.reduce((Xe,Je)=>Xe+Je.bits,0);if(Fe+Ze>qe)throw new Error("bits too long for span remainder ("+(qe-Ze)+" of "+qe+" remain)");this.container=Re,this.bits=Fe,this.valueMask=(1<<Fe)-1,Fe===32&&(this.valueMask=4294967295),this.start=Ze,this.container.msb&&(this.start=qe-Ze-Fe),this.wordMask=fixBitwiseResult(this.valueMask<<this.start),this.property=We}decode(){const Re=this.container._packedGetValue();return fixBitwiseResult(Re&this.wordMask)>>>this.start}encode(Re){if(!Number.isInteger(Re)||Re!==fixBitwiseResult(Re&this.valueMask))throw new TypeError(nameWithProperty("BitField.encode",this)+" value must be integer not exceeding "+this.valueMask);const Fe=this.container._packedGetValue(),We=fixBitwiseResult(Re<<this.start);this.container._packedSetValue(fixBitwiseResult(Fe&~this.wordMask)|We)}}class Boolean$1 extends BitField{constructor(Re,Fe){super(Re,1,Fe)}decode(Re,Fe){return!!BitField.prototype.decode.call(this,Re,Fe)}encode(Re){return typeof Re=="boolean"&&(Re=+Re),BitField.prototype.encode.call(this,Re)}}class Blob$1 extends Layout{constructor(Re,Fe){if(!(Re instanceof ExternalLayout&&Re.isCount()||Number.isInteger(Re)&&0<=Re))throw new TypeError("length must be positive integer or an unsigned integer ExternalLayout");let We=-1;Re instanceof ExternalLayout||(We=Re),super(We,Fe),this.length=Re}getSpan(Re,Fe){let We=this.span;return 0>We&&(We=this.length.decode(Re,Fe)),We}decode(Re,Fe){Fe===void 0&&(Fe=0);let We=this.span;return 0>We&&(We=this.length.decode(Re,Fe)),Re.slice(Fe,Fe+We)}encode(Re,Fe,We){let qe=this.length;if(this.length instanceof ExternalLayout&&(qe=Re.length),!(Buffer.isBuffer(Re)&&qe===Re.length))throw new TypeError(nameWithProperty("Blob.encode",this)+" requires (length "+qe+") Buffer as src");if(We+qe>Fe.length)throw new RangeError("encoding overruns Buffer");return Fe.write(Re.toString("hex"),We,qe,"hex"),this.length instanceof ExternalLayout&&this.length.encode(qe,Fe,We),qe}}class CString extends Layout{constructor(Re){super(-1,Re)}getSpan(Re,Fe){if(!Buffer.isBuffer(Re))throw new TypeError("b must be a Buffer");Fe===void 0&&(Fe=0);let We=Fe;for(;We<Re.length&&Re[We]!==0;)We+=1;return 1+We-Fe}decode(Re,Fe,We){Fe===void 0&&(Fe=0);let qe=this.getSpan(Re,Fe);return Re.slice(Fe,Fe+qe-1).toString("utf-8")}encode(Re,Fe,We){We===void 0&&(We=0),typeof Re!="string"&&(Re=Re.toString());const qe=new Buffer(Re,"utf8"),Ze=qe.length;if(We+Ze>Fe.length)throw new RangeError("encoding overruns Buffer");return qe.copy(Fe,We),Fe[We+Ze]=0,Ze+1}}class UTF8 extends Layout{constructor(Re,Fe){if(typeof Re=="string"&&Fe===void 0&&(Fe=Re,Re=void 0),Re===void 0)Re=-1;else if(!Number.isInteger(Re))throw new TypeError("maxSpan must be an integer");super(-1,Fe),this.maxSpan=Re}getSpan(Re,Fe){if(!Buffer.isBuffer(Re))throw new TypeError("b must be a Buffer");return Fe===void 0&&(Fe=0),Re.length-Fe}decode(Re,Fe,We){Fe===void 0&&(Fe=0);let qe=this.getSpan(Re,Fe);if(0<=this.maxSpan&&this.maxSpan<qe)throw new RangeError("text length exceeds maxSpan");return Re.slice(Fe,Fe+qe).toString("utf-8")}encode(Re,Fe,We){We===void 0&&(We=0),typeof Re!="string"&&(Re=Re.toString());const qe=new Buffer(Re,"utf8"),Ze=qe.length;if(0<=this.maxSpan&&this.maxSpan<Ze)throw new RangeError("text length exceeds maxSpan");if(We+Ze>Fe.length)throw new RangeError("encoding overruns Buffer");return qe.copy(Fe,We),Ze}}class Constant extends Layout{constructor(Re,Fe){super(0,Fe),this.value=Re}decode(Re,Fe,We){return this.value}encode(Re,Fe,We){return 0}}Layout$1.ExternalLayout=ExternalLayout;Layout$1.GreedyCount=GreedyCount;Layout$1.OffsetLayout=OffsetLayout;Layout$1.UInt=UInt;Layout$1.UIntBE=UIntBE;Layout$1.Int=Int;Layout$1.IntBE=IntBE;Layout$1.Float=Float;Layout$1.FloatBE=FloatBE;Layout$1.Double=Double;Layout$1.DoubleBE=DoubleBE;Layout$1.Sequence=Sequence;Layout$1.Structure=Structure;Layout$1.UnionDiscriminator=UnionDiscriminator;Layout$1.UnionLayoutDiscriminator=UnionLayoutDiscriminator;Layout$1.Union=Union;Layout$1.VariantLayout=VariantLayout;Layout$1.BitStructure=BitStructure;Layout$1.BitField=BitField;Layout$1.Boolean=Boolean$1;Layout$1.Blob=Blob$1;Layout$1.CString=CString;Layout$1.UTF8=UTF8;Layout$1.Constant=Constant;Layout$1.greedy=(Ke,Re)=>new GreedyCount(Ke,Re);Layout$1.offset=(Ke,Re,Fe)=>new OffsetLayout(Ke,Re,Fe);Layout$1.u8=Ke=>new UInt(1,Ke);Layout$1.u16=Ke=>new UInt(2,Ke);Layout$1.u24=Ke=>new UInt(3,Ke);Layout$1.u32=Ke=>new UInt(4,Ke);Layout$1.u40=Ke=>new UInt(5,Ke);Layout$1.u48=Ke=>new UInt(6,Ke);Layout$1.nu64=Ke=>new NearUInt64(Ke);Layout$1.u16be=Ke=>new UIntBE(2,Ke);Layout$1.u24be=Ke=>new UIntBE(3,Ke);Layout$1.u32be=Ke=>new UIntBE(4,Ke);Layout$1.u40be=Ke=>new UIntBE(5,Ke);Layout$1.u48be=Ke=>new UIntBE(6,Ke);Layout$1.nu64be=Ke=>new NearUInt64BE(Ke);Layout$1.s8=Ke=>new Int(1,Ke);Layout$1.s16=Ke=>new Int(2,Ke);Layout$1.s24=Ke=>new Int(3,Ke);Layout$1.s32=Ke=>new Int(4,Ke);Layout$1.s40=Ke=>new Int(5,Ke);Layout$1.s48=Ke=>new Int(6,Ke);Layout$1.ns64=Ke=>new NearInt64(Ke);Layout$1.s16be=Ke=>new IntBE(2,Ke);Layout$1.s24be=Ke=>new IntBE(3,Ke);Layout$1.s32be=Ke=>new IntBE(4,Ke);Layout$1.s40be=Ke=>new IntBE(5,Ke);Layout$1.s48be=Ke=>new IntBE(6,Ke);Layout$1.ns64be=Ke=>new NearInt64BE(Ke);Layout$1.f32=Ke=>new Float(Ke);Layout$1.f32be=Ke=>new FloatBE(Ke);Layout$1.f64=Ke=>new Double(Ke);Layout$1.f64be=Ke=>new DoubleBE(Ke);Layout$1.struct=(Ke,Re,Fe)=>new Structure(Ke,Re,Fe);Layout$1.bits=(Ke,Re,Fe)=>new BitStructure(Ke,Re,Fe);Layout$1.seq=(Ke,Re,Fe)=>new Sequence(Ke,Re,Fe);Layout$1.union=(Ke,Re,Fe)=>new Union(Ke,Re,Fe);Layout$1.unionLayoutDiscriminator=(Ke,Re)=>new UnionLayoutDiscriminator(Ke,Re);Layout$1.blob=(Ke,Re)=>new Blob$1(Ke,Re);Layout$1.cstr=Ke=>new CString(Ke);Layout$1.utf8=(Ke,Re)=>new UTF8(Ke,Re);Layout$1.const=(Ke,Re)=>new Constant(Ke,Re);const require$$1=getAugmentedNamespace(index_browser_esm);(function(Ke){var Re=commonjsGlobal&&commonjsGlobal.__importDefault||function(Cr){return Cr&&Cr.__esModule?Cr:{default:Cr}};Object.defineProperty(Ke,"__esModule",{value:!0}),Ke.map=Ke.array=Ke.rustEnum=Ke.str=Ke.vecU8=Ke.tagged=Ke.vec=Ke.bool=Ke.option=Ke.publicKey=Ke.i128=Ke.u128=Ke.i64=Ke.u64=Ke.struct=Ke.f64=Ke.f32=Ke.i32=Ke.u32=Ke.i16=Ke.u16=Ke.i8=Ke.u8=void 0;const Fe=Layout$1,We=require$$1,qe=Re(bn$1.exports);var Ze=Layout$1;Object.defineProperty(Ke,"u8",{enumerable:!0,get:function(){return Ze.u8}}),Object.defineProperty(Ke,"i8",{enumerable:!0,get:function(){return Ze.s8}}),Object.defineProperty(Ke,"u16",{enumerable:!0,get:function(){return Ze.u16}}),Object.defineProperty(Ke,"i16",{enumerable:!0,get:function(){return Ze.s16}}),Object.defineProperty(Ke,"u32",{enumerable:!0,get:function(){return Ze.u32}}),Object.defineProperty(Ke,"i32",{enumerable:!0,get:function(){return Ze.s32}}),Object.defineProperty(Ke,"f32",{enumerable:!0,get:function(){return Ze.f32}}),Object.defineProperty(Ke,"f64",{enumerable:!0,get:function(){return Ze.f64}}),Object.defineProperty(Ke,"struct",{enumerable:!0,get:function(){return Ze.struct}});class Xe extends Fe.Layout{constructor(Tr,Mr,ar){super(Tr,ar),this.blob=Fe.blob(Tr),this.signed=Mr}decode(Tr,Mr=0){const ar=new qe.default(this.blob.decode(Tr,Mr),10,"le");return this.signed?ar.fromTwos(this.span*8).clone():ar}encode(Tr,Mr,ar=0){return this.signed&&(Tr=Tr.toTwos(this.span*8)),this.blob.encode(Tr.toArrayLike(Buffer,"le",this.span),Mr,ar)}}function Je(Cr){return new Xe(8,!1,Cr)}Ke.u64=Je;function tr(Cr){return new Xe(8,!0,Cr)}Ke.i64=tr;function er(Cr){return new Xe(16,!1,Cr)}Ke.u128=er;function ir(Cr){return new Xe(16,!0,Cr)}Ke.i128=ir;class lr extends Fe.Layout{constructor(Tr,Mr,ar,Dt){super(Tr.span,Dt),this.layout=Tr,this.decoder=Mr,this.encoder=ar}decode(Tr,Mr){return this.decoder(this.layout.decode(Tr,Mr))}encode(Tr,Mr,ar){return this.layout.encode(this.encoder(Tr),Mr,ar)}getSpan(Tr,Mr){return this.layout.getSpan(Tr,Mr)}}function fr(Cr){return new lr(Fe.blob(32),Tr=>new We.PublicKey(Tr),Tr=>Tr.toBuffer(),Cr)}Ke.publicKey=fr;class ur extends Fe.Layout{constructor(Tr,Mr){super(-1,Mr),this.layout=Tr,this.discriminator=Fe.u8()}encode(Tr,Mr,ar=0){return Tr==null?this.discriminator.encode(0,Mr,ar):(this.discriminator.encode(1,Mr,ar),this.layout.encode(Tr,Mr,ar+1)+1)}decode(Tr,Mr=0){const ar=this.discriminator.decode(Tr,Mr);if(ar===0)return null;if(ar===1)return this.layout.decode(Tr,Mr+1);throw new Error("Invalid option "+this.property)}getSpan(Tr,Mr=0){const ar=this.discriminator.decode(Tr,Mr);if(ar===0)return 1;if(ar===1)return this.layout.getSpan(Tr,Mr+1)+1;throw new Error("Invalid option "+this.property)}}function mr(Cr,Tr){return new ur(Cr,Tr)}Ke.option=mr;function br(Cr){return new lr(Fe.u8(),wr,Sr,Cr)}Ke.bool=br;function wr(Cr){if(Cr===0)return!1;if(Cr===1)return!0;throw new Error("Invalid bool: "+Cr)}function Sr(Cr){return Cr?1:0}function kr(Cr,Tr){const Mr=Fe.u32("length"),ar=Fe.struct([Mr,Fe.seq(Cr,Fe.offset(Mr,-Mr.span),"values")]);return new lr(ar,({values:Dt})=>Dt,Dt=>({values:Dt}),Tr)}Ke.vec=kr;function Er(Cr,Tr,Mr){const ar=Fe.struct([Je("tag"),Tr.replicate("data")]);function Dt({tag:sr,data:cr}){if(!sr.eq(Cr))throw new Error("Invalid tag, expected: "+Cr.toString("hex")+", got: "+sr.toString("hex"));return cr}return new lr(ar,Dt,sr=>({tag:Cr,data:sr}),Mr)}Ke.tagged=Er;function Ir(Cr){const Tr=Fe.u32("length"),Mr=Fe.struct([Tr,Fe.blob(Fe.offset(Tr,-Tr.span),"data")]);return new lr(Mr,({data:ar})=>ar,ar=>({data:ar}),Cr)}Ke.vecU8=Ir;function Rr(Cr){return new lr(Ir(),Tr=>Tr.toString("utf-8"),Tr=>Buffer.from(Tr,"utf-8"),Cr)}Ke.str=Rr;function Pr(Cr,Tr,Mr){const ar=Fe.union(Mr!=null?Mr:Fe.u8(),Tr);return Cr.forEach((Dt,sr)=>ar.addVariant(sr,Dt,Dt.property)),ar}Ke.rustEnum=Pr;function Br(Cr,Tr,Mr){const ar=Fe.struct([Fe.seq(Cr,Tr,"values")]);return new lr(ar,({values:Dt})=>Dt,Dt=>({values:Dt}),Mr)}Ke.array=Br;class Or extends Fe.Layout{constructor(Tr,Mr,ar){super(Tr.span+Mr.span,ar),this.keyLayout=Tr,this.valueLayout=Mr}decode(Tr,Mr){Mr=Mr||0;const ar=this.keyLayout.decode(Tr,Mr),Dt=this.valueLayout.decode(Tr,Mr+this.keyLayout.getSpan(Tr,Mr));return[ar,Dt]}encode(Tr,Mr,ar){ar=ar||0;const Dt=this.keyLayout.encode(Tr[0],Mr,ar),sr=this.valueLayout.encode(Tr[1],Mr,ar+Dt);return Dt+sr}getSpan(Tr,Mr){return this.keyLayout.getSpan(Tr,Mr)+this.valueLayout.getSpan(Tr,Mr)}}function Nr(Cr,Tr,Mr){const ar=Fe.u32("length"),Dt=Fe.struct([ar,Fe.seq(new Or(Cr,Tr),Fe.offset(ar,-ar.span),"values")]);return new lr(Dt,({values:sr})=>new Map(sr),sr=>({values:Array.from(sr.entries())}),Mr)}Ke.map=Nr})(lib);/*! pako 2.0.4 https://github.com/nodeca/pako @license (MIT AND Zlib) */const Z_FIXED$1=4,Z_BINARY=0,Z_TEXT=1,Z_UNKNOWN$1=2;function zero$1(Ke){let Re=Ke.length;for(;--Re>=0;)Ke[Re]=0}const STORED_BLOCK=0,STATIC_TREES=1,DYN_TREES=2,MIN_MATCH$1=3,MAX_MATCH$1=258,LENGTH_CODES$1=29,LITERALS$1=256,L_CODES$1=LITERALS$1+1+LENGTH_CODES$1,D_CODES$1=30,BL_CODES$1=19,HEAP_SIZE$1=2*L_CODES$1+1,MAX_BITS$1=15,Buf_size=16,MAX_BL_BITS=7,END_BLOCK=256,REP_3_6=16,REPZ_3_10=17,REPZ_11_138=18,extra_lbits=new Uint8Array([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0]),extra_dbits=new Uint8Array([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13]),extra_blbits=new Uint8Array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7]),bl_order=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),DIST_CODE_LEN=512,static_ltree=new Array((L_CODES$1+2)*2);zero$1(static_ltree);const static_dtree=new Array(D_CODES$1*2);zero$1(static_dtree);const _dist_code=new Array(DIST_CODE_LEN);zero$1(_dist_code);const _length_code=new Array(MAX_MATCH$1-MIN_MATCH$1+1);zero$1(_length_code);const base_length=new Array(LENGTH_CODES$1);zero$1(base_length);const base_dist=new Array(D_CODES$1);zero$1(base_dist);function StaticTreeDesc(Ke,Re,Fe,We,qe){this.static_tree=Ke,this.extra_bits=Re,this.extra_base=Fe,this.elems=We,this.max_length=qe,this.has_stree=Ke&&Ke.length}let static_l_desc,static_d_desc,static_bl_desc;function TreeDesc(Ke,Re){this.dyn_tree=Ke,this.max_code=0,this.stat_desc=Re}const d_code=Ke=>Ke<256?_dist_code[Ke]:_dist_code[256+(Ke>>>7)],put_short=(Ke,Re)=>{Ke.pending_buf[Ke.pending++]=Re&255,Ke.pending_buf[Ke.pending++]=Re>>>8&255},send_bits=(Ke,Re,Fe)=>{Ke.bi_valid>Buf_size-Fe?(Ke.bi_buf|=Re<<Ke.bi_valid&65535,put_short(Ke,Ke.bi_buf),Ke.bi_buf=Re>>Buf_size-Ke.bi_valid,Ke.bi_valid+=Fe-Buf_size):(Ke.bi_buf|=Re<<Ke.bi_valid&65535,Ke.bi_valid+=Fe)},send_code=(Ke,Re,Fe)=>{send_bits(Ke,Fe[Re*2],Fe[Re*2+1])},bi_reverse=(Ke,Re)=>{let Fe=0;do Fe|=Ke&1,Ke>>>=1,Fe<<=1;while(--Re>0);return Fe>>>1},bi_flush=Ke=>{Ke.bi_valid===16?(put_short(Ke,Ke.bi_buf),Ke.bi_buf=0,Ke.bi_valid=0):Ke.bi_valid>=8&&(Ke.pending_buf[Ke.pending++]=Ke.bi_buf&255,Ke.bi_buf>>=8,Ke.bi_valid-=8)},gen_bitlen=(Ke,Re)=>{const Fe=Re.dyn_tree,We=Re.max_code,qe=Re.stat_desc.static_tree,Ze=Re.stat_desc.has_stree,Xe=Re.stat_desc.extra_bits,Je=Re.stat_desc.extra_base,tr=Re.stat_desc.max_length;let er,ir,lr,fr,ur,mr,br=0;for(fr=0;fr<=MAX_BITS$1;fr++)Ke.bl_count[fr]=0;for(Fe[Ke.heap[Ke.heap_max]*2+1]=0,er=Ke.heap_max+1;er<HEAP_SIZE$1;er++)ir=Ke.heap[er],fr=Fe[Fe[ir*2+1]*2+1]+1,fr>tr&&(fr=tr,br++),Fe[ir*2+1]=fr,!(ir>We)&&(Ke.bl_count[fr]++,ur=0,ir>=Je&&(ur=Xe[ir-Je]),mr=Fe[ir*2],Ke.opt_len+=mr*(fr+ur),Ze&&(Ke.static_len+=mr*(qe[ir*2+1]+ur)));if(br!==0){do{for(fr=tr-1;Ke.bl_count[fr]===0;)fr--;Ke.bl_count[fr]--,Ke.bl_count[fr+1]+=2,Ke.bl_count[tr]--,br-=2}while(br>0);for(fr=tr;fr!==0;fr--)for(ir=Ke.bl_count[fr];ir!==0;)lr=Ke.heap[--er],!(lr>We)&&(Fe[lr*2+1]!==fr&&(Ke.opt_len+=(fr-Fe[lr*2+1])*Fe[lr*2],Fe[lr*2+1]=fr),ir--)}},gen_codes=(Ke,Re,Fe)=>{const We=new Array(MAX_BITS$1+1);let qe=0,Ze,Xe;for(Ze=1;Ze<=MAX_BITS$1;Ze++)We[Ze]=qe=qe+Fe[Ze-1]<<1;for(Xe=0;Xe<=Re;Xe++){let Je=Ke[Xe*2+1];Je!==0&&(Ke[Xe*2]=bi_reverse(We[Je]++,Je))}},tr_static_init=()=>{let Ke,Re,Fe,We,qe;const Ze=new Array(MAX_BITS$1+1);for(Fe=0,We=0;We<LENGTH_CODES$1-1;We++)for(base_length[We]=Fe,Ke=0;Ke<1<<extra_lbits[We];Ke++)_length_code[Fe++]=We;for(_length_code[Fe-1]=We,qe=0,We=0;We<16;We++)for(base_dist[We]=qe,Ke=0;Ke<1<<extra_dbits[We];Ke++)_dist_code[qe++]=We;for(qe>>=7;We<D_CODES$1;We++)for(base_dist[We]=qe<<7,Ke=0;Ke<1<<extra_dbits[We]-7;Ke++)_dist_code[256+qe++]=We;for(Re=0;Re<=MAX_BITS$1;Re++)Ze[Re]=0;for(Ke=0;Ke<=143;)static_ltree[Ke*2+1]=8,Ke++,Ze[8]++;for(;Ke<=255;)static_ltree[Ke*2+1]=9,Ke++,Ze[9]++;for(;Ke<=279;)static_ltree[Ke*2+1]=7,Ke++,Ze[7]++;for(;Ke<=287;)static_ltree[Ke*2+1]=8,Ke++,Ze[8]++;for(gen_codes(static_ltree,L_CODES$1+1,Ze),Ke=0;Ke<D_CODES$1;Ke++)static_dtree[Ke*2+1]=5,static_dtree[Ke*2]=bi_reverse(Ke,5);static_l_desc=new StaticTreeDesc(static_ltree,extra_lbits,LITERALS$1+1,L_CODES$1,MAX_BITS$1),static_d_desc=new StaticTreeDesc(static_dtree,extra_dbits,0,D_CODES$1,MAX_BITS$1),static_bl_desc=new StaticTreeDesc(new Array(0),extra_blbits,0,BL_CODES$1,MAX_BL_BITS)},init_block=Ke=>{let Re;for(Re=0;Re<L_CODES$1;Re++)Ke.dyn_ltree[Re*2]=0;for(Re=0;Re<D_CODES$1;Re++)Ke.dyn_dtree[Re*2]=0;for(Re=0;Re<BL_CODES$1;Re++)Ke.bl_tree[Re*2]=0;Ke.dyn_ltree[END_BLOCK*2]=1,Ke.opt_len=Ke.static_len=0,Ke.last_lit=Ke.matches=0},bi_windup=Ke=>{Ke.bi_valid>8?put_short(Ke,Ke.bi_buf):Ke.bi_valid>0&&(Ke.pending_buf[Ke.pending++]=Ke.bi_buf),Ke.bi_buf=0,Ke.bi_valid=0},copy_block=(Ke,Re,Fe,We)=>{bi_windup(Ke),We&&(put_short(Ke,Fe),put_short(Ke,~Fe)),Ke.pending_buf.set(Ke.window.subarray(Re,Re+Fe),Ke.pending),Ke.pending+=Fe},smaller=(Ke,Re,Fe,We)=>{const qe=Re*2,Ze=Fe*2;return Ke[qe]<Ke[Ze]||Ke[qe]===Ke[Ze]&&We[Re]<=We[Fe]},pqdownheap=(Ke,Re,Fe)=>{const We=Ke.heap[Fe];let qe=Fe<<1;for(;qe<=Ke.heap_len&&(qe<Ke.heap_len&&smaller(Re,Ke.heap[qe+1],Ke.heap[qe],Ke.depth)&&qe++,!smaller(Re,We,Ke.heap[qe],Ke.depth));)Ke.heap[Fe]=Ke.heap[qe],Fe=qe,qe<<=1;Ke.heap[Fe]=We},compress_block=(Ke,Re,Fe)=>{let We,qe,Ze=0,Xe,Je;if(Ke.last_lit!==0)do We=Ke.pending_buf[Ke.d_buf+Ze*2]<<8|Ke.pending_buf[Ke.d_buf+Ze*2+1],qe=Ke.pending_buf[Ke.l_buf+Ze],Ze++,We===0?send_code(Ke,qe,Re):(Xe=_length_code[qe],send_code(Ke,Xe+LITERALS$1+1,Re),Je=extra_lbits[Xe],Je!==0&&(qe-=base_length[Xe],send_bits(Ke,qe,Je)),We--,Xe=d_code(We),send_code(Ke,Xe,Fe),Je=extra_dbits[Xe],Je!==0&&(We-=base_dist[Xe],send_bits(Ke,We,Je)));while(Ze<Ke.last_lit);send_code(Ke,END_BLOCK,Re)},build_tree=(Ke,Re)=>{const Fe=Re.dyn_tree,We=Re.stat_desc.static_tree,qe=Re.stat_desc.has_stree,Ze=Re.stat_desc.elems;let Xe,Je,tr=-1,er;for(Ke.heap_len=0,Ke.heap_max=HEAP_SIZE$1,Xe=0;Xe<Ze;Xe++)Fe[Xe*2]!==0?(Ke.heap[++Ke.heap_len]=tr=Xe,Ke.depth[Xe]=0):Fe[Xe*2+1]=0;for(;Ke.heap_len<2;)er=Ke.heap[++Ke.heap_len]=tr<2?++tr:0,Fe[er*2]=1,Ke.depth[er]=0,Ke.opt_len--,qe&&(Ke.static_len-=We[er*2+1]);for(Re.max_code=tr,Xe=Ke.heap_len>>1;Xe>=1;Xe--)pqdownheap(Ke,Fe,Xe);er=Ze;do Xe=Ke.heap[1],Ke.heap[1]=Ke.heap[Ke.heap_len--],pqdownheap(Ke,Fe,1),Je=Ke.heap[1],Ke.heap[--Ke.heap_max]=Xe,Ke.heap[--Ke.heap_max]=Je,Fe[er*2]=Fe[Xe*2]+Fe[Je*2],Ke.depth[er]=(Ke.depth[Xe]>=Ke.depth[Je]?Ke.depth[Xe]:Ke.depth[Je])+1,Fe[Xe*2+1]=Fe[Je*2+1]=er,Ke.heap[1]=er++,pqdownheap(Ke,Fe,1);while(Ke.heap_len>=2);Ke.heap[--Ke.heap_max]=Ke.heap[1],gen_bitlen(Ke,Re),gen_codes(Fe,tr,Ke.bl_count)},scan_tree=(Ke,Re,Fe)=>{let We,qe=-1,Ze,Xe=Re[0*2+1],Je=0,tr=7,er=4;for(Xe===0&&(tr=138,er=3),Re[(Fe+1)*2+1]=65535,We=0;We<=Fe;We++)Ze=Xe,Xe=Re[(We+1)*2+1],!(++Je<tr&&Ze===Xe)&&(Je<er?Ke.bl_tree[Ze*2]+=Je:Ze!==0?(Ze!==qe&&Ke.bl_tree[Ze*2]++,Ke.bl_tree[REP_3_6*2]++):Je<=10?Ke.bl_tree[REPZ_3_10*2]++:Ke.bl_tree[REPZ_11_138*2]++,Je=0,qe=Ze,Xe===0?(tr=138,er=3):Ze===Xe?(tr=6,er=3):(tr=7,er=4))},send_tree=(Ke,Re,Fe)=>{let We,qe=-1,Ze,Xe=Re[0*2+1],Je=0,tr=7,er=4;for(Xe===0&&(tr=138,er=3),We=0;We<=Fe;We++)if(Ze=Xe,Xe=Re[(We+1)*2+1],!(++Je<tr&&Ze===Xe)){if(Je<er)do send_code(Ke,Ze,Ke.bl_tree);while(--Je!==0);else Ze!==0?(Ze!==qe&&(send_code(Ke,Ze,Ke.bl_tree),Je--),send_code(Ke,REP_3_6,Ke.bl_tree),send_bits(Ke,Je-3,2)):Je<=10?(send_code(Ke,REPZ_3_10,Ke.bl_tree),send_bits(Ke,Je-3,3)):(send_code(Ke,REPZ_11_138,Ke.bl_tree),send_bits(Ke,Je-11,7));Je=0,qe=Ze,Xe===0?(tr=138,er=3):Ze===Xe?(tr=6,er=3):(tr=7,er=4)}},build_bl_tree=Ke=>{let Re;for(scan_tree(Ke,Ke.dyn_ltree,Ke.l_desc.max_code),scan_tree(Ke,Ke.dyn_dtree,Ke.d_desc.max_code),build_tree(Ke,Ke.bl_desc),Re=BL_CODES$1-1;Re>=3&&Ke.bl_tree[bl_order[Re]*2+1]===0;Re--);return Ke.opt_len+=3*(Re+1)+5+5+4,Re},send_all_trees=(Ke,Re,Fe,We)=>{let qe;for(send_bits(Ke,Re-257,5),send_bits(Ke,Fe-1,5),send_bits(Ke,We-4,4),qe=0;qe<We;qe++)send_bits(Ke,Ke.bl_tree[bl_order[qe]*2+1],3);send_tree(Ke,Ke.dyn_ltree,Re-1),send_tree(Ke,Ke.dyn_dtree,Fe-1)},detect_data_type=Ke=>{let Re=4093624447,Fe;for(Fe=0;Fe<=31;Fe++,Re>>>=1)if(Re&1&&Ke.dyn_ltree[Fe*2]!==0)return Z_BINARY;if(Ke.dyn_ltree[9*2]!==0||Ke.dyn_ltree[10*2]!==0||Ke.dyn_ltree[13*2]!==0)return Z_TEXT;for(Fe=32;Fe<LITERALS$1;Fe++)if(Ke.dyn_ltree[Fe*2]!==0)return Z_TEXT;return Z_BINARY};let static_init_done=!1;const _tr_init$1=Ke=>{static_init_done||(tr_static_init(),static_init_done=!0),Ke.l_desc=new TreeDesc(Ke.dyn_ltree,static_l_desc),Ke.d_desc=new TreeDesc(Ke.dyn_dtree,static_d_desc),Ke.bl_desc=new TreeDesc(Ke.bl_tree,static_bl_desc),Ke.bi_buf=0,Ke.bi_valid=0,init_block(Ke)},_tr_stored_block$1=(Ke,Re,Fe,We)=>{send_bits(Ke,(STORED_BLOCK<<1)+(We?1:0),3),copy_block(Ke,Re,Fe,!0)},_tr_align$1=Ke=>{send_bits(Ke,STATIC_TREES<<1,3),send_code(Ke,END_BLOCK,static_ltree),bi_flush(Ke)},_tr_flush_block$1=(Ke,Re,Fe,We)=>{let qe,Ze,Xe=0;Ke.level>0?(Ke.strm.data_type===Z_UNKNOWN$1&&(Ke.strm.data_type=detect_data_type(Ke)),build_tree(Ke,Ke.l_desc),build_tree(Ke,Ke.d_desc),Xe=build_bl_tree(Ke),qe=Ke.opt_len+3+7>>>3,Ze=Ke.static_len+3+7>>>3,Ze<=qe&&(qe=Ze)):qe=Ze=Fe+5,Fe+4<=qe&&Re!==-1?_tr_stored_block$1(Ke,Re,Fe,We):Ke.strategy===Z_FIXED$1||Ze===qe?(send_bits(Ke,(STATIC_TREES<<1)+(We?1:0),3),compress_block(Ke,static_ltree,static_dtree)):(send_bits(Ke,(DYN_TREES<<1)+(We?1:0),3),send_all_trees(Ke,Ke.l_desc.max_code+1,Ke.d_desc.max_code+1,Xe+1),compress_block(Ke,Ke.dyn_ltree,Ke.dyn_dtree)),init_block(Ke),We&&bi_windup(Ke)},_tr_tally$1=(Ke,Re,Fe)=>(Ke.pending_buf[Ke.d_buf+Ke.last_lit*2]=Re>>>8&255,Ke.pending_buf[Ke.d_buf+Ke.last_lit*2+1]=Re&255,Ke.pending_buf[Ke.l_buf+Ke.last_lit]=Fe&255,Ke.last_lit++,Re===0?Ke.dyn_ltree[Fe*2]++:(Ke.matches++,Re--,Ke.dyn_ltree[(_length_code[Fe]+LITERALS$1+1)*2]++,Ke.dyn_dtree[d_code(Re)*2]++),Ke.last_lit===Ke.lit_bufsize-1);var _tr_init_1=_tr_init$1,_tr_stored_block_1=_tr_stored_block$1,_tr_flush_block_1=_tr_flush_block$1,_tr_tally_1=_tr_tally$1,_tr_align_1=_tr_align$1,trees={_tr_init:_tr_init_1,_tr_stored_block:_tr_stored_block_1,_tr_flush_block:_tr_flush_block_1,_tr_tally:_tr_tally_1,_tr_align:_tr_align_1};const adler32=(Ke,Re,Fe,We)=>{let qe=Ke&65535|0,Ze=Ke>>>16&65535|0,Xe=0;for(;Fe!==0;){Xe=Fe>2e3?2e3:Fe,Fe-=Xe;do qe=qe+Re[We++]|0,Ze=Ze+qe|0;while(--Xe);qe%=65521,Ze%=65521}return qe|Ze<<16|0};var adler32_1=adler32;const makeTable=()=>{let Ke,Re=[];for(var Fe=0;Fe<256;Fe++){Ke=Fe;for(var We=0;We<8;We++)Ke=Ke&1?3988292384^Ke>>>1:Ke>>>1;Re[Fe]=Ke}return Re},crcTable=new Uint32Array(makeTable()),crc32=(Ke,Re,Fe,We)=>{const qe=crcTable,Ze=We+Fe;Ke^=-1;for(let Xe=We;Xe<Ze;Xe++)Ke=Ke>>>8^qe[(Ke^Re[Xe])&255];return Ke^-1};var crc32_1=crc32,messages={2:"need dictionary",1:"stream end",0:"","-1":"file error","-2":"stream error","-3":"data error","-4":"insufficient memory","-5":"buffer error","-6":"incompatible version"},constants$2={Z_NO_FLUSH:0,Z_PARTIAL_FLUSH:1,Z_SYNC_FLUSH:2,Z_FULL_FLUSH:3,Z_FINISH:4,Z_BLOCK:5,Z_TREES:6,Z_OK:0,Z_STREAM_END:1,Z_NEED_DICT:2,Z_ERRNO:-1,Z_STREAM_ERROR:-2,Z_DATA_ERROR:-3,Z_MEM_ERROR:-4,Z_BUF_ERROR:-5,Z_NO_COMPRESSION:0,Z_BEST_SPEED:1,Z_BEST_COMPRESSION:9,Z_DEFAULT_COMPRESSION:-1,Z_FILTERED:1,Z_HUFFMAN_ONLY:2,Z_RLE:3,Z_FIXED:4,Z_DEFAULT_STRATEGY:0,Z_BINARY:0,Z_TEXT:1,Z_UNKNOWN:2,Z_DEFLATED:8};const{_tr_init,_tr_stored_block,_tr_flush_block,_tr_tally,_tr_align}=trees,{Z_NO_FLUSH:Z_NO_FLUSH$2,Z_PARTIAL_FLUSH,Z_FULL_FLUSH:Z_FULL_FLUSH$1,Z_FINISH:Z_FINISH$3,Z_BLOCK:Z_BLOCK$1,Z_OK:Z_OK$3,Z_STREAM_END:Z_STREAM_END$3,Z_STREAM_ERROR:Z_STREAM_ERROR$2,Z_DATA_ERROR:Z_DATA_ERROR$2,Z_BUF_ERROR:Z_BUF_ERROR$1,Z_DEFAULT_COMPRESSION:Z_DEFAULT_COMPRESSION$1,Z_FILTERED,Z_HUFFMAN_ONLY,Z_RLE,Z_FIXED,Z_DEFAULT_STRATEGY:Z_DEFAULT_STRATEGY$1,Z_UNKNOWN,Z_DEFLATED:Z_DEFLATED$2}=constants$2,MAX_MEM_LEVEL=9,MAX_WBITS$1=15,DEF_MEM_LEVEL=8,LENGTH_CODES=29,LITERALS=256,L_CODES=LITERALS+1+LENGTH_CODES,D_CODES=30,BL_CODES=19,HEAP_SIZE=2*L_CODES+1,MAX_BITS=15,MIN_MATCH=3,MAX_MATCH=258,MIN_LOOKAHEAD=MAX_MATCH+MIN_MATCH+1,PRESET_DICT=32,INIT_STATE=42,EXTRA_STATE=69,NAME_STATE=73,COMMENT_STATE=91,HCRC_STATE=103,BUSY_STATE=113,FINISH_STATE=666,BS_NEED_MORE=1,BS_BLOCK_DONE=2,BS_FINISH_STARTED=3,BS_FINISH_DONE=4,OS_CODE=3,err=(Ke,Re)=>(Ke.msg=messages[Re],Re),rank=Ke=>(Ke<<1)-(Ke>4?9:0),zero=Ke=>{let Re=Ke.length;for(;--Re>=0;)Ke[Re]=0};let HASH_ZLIB=(Ke,Re,Fe)=>(Re<<Ke.hash_shift^Fe)&Ke.hash_mask,HASH=HASH_ZLIB;const flush_pending=Ke=>{const Re=Ke.state;let Fe=Re.pending;Fe>Ke.avail_out&&(Fe=Ke.avail_out),Fe!==0&&(Ke.output.set(Re.pending_buf.subarray(Re.pending_out,Re.pending_out+Fe),Ke.next_out),Ke.next_out+=Fe,Re.pending_out+=Fe,Ke.total_out+=Fe,Ke.avail_out-=Fe,Re.pending-=Fe,Re.pending===0&&(Re.pending_out=0))},flush_block_only=(Ke,Re)=>{_tr_flush_block(Ke,Ke.block_start>=0?Ke.block_start:-1,Ke.strstart-Ke.block_start,Re),Ke.block_start=Ke.strstart,flush_pending(Ke.strm)},put_byte=(Ke,Re)=>{Ke.pending_buf[Ke.pending++]=Re},putShortMSB=(Ke,Re)=>{Ke.pending_buf[Ke.pending++]=Re>>>8&255,Ke.pending_buf[Ke.pending++]=Re&255},read_buf=(Ke,Re,Fe,We)=>{let qe=Ke.avail_in;return qe>We&&(qe=We),qe===0?0:(Ke.avail_in-=qe,Re.set(Ke.input.subarray(Ke.next_in,Ke.next_in+qe),Fe),Ke.state.wrap===1?Ke.adler=adler32_1(Ke.adler,Re,qe,Fe):Ke.state.wrap===2&&(Ke.adler=crc32_1(Ke.adler,Re,qe,Fe)),Ke.next_in+=qe,Ke.total_in+=qe,qe)},longest_match=(Ke,Re)=>{let Fe=Ke.max_chain_length,We=Ke.strstart,qe,Ze,Xe=Ke.prev_length,Je=Ke.nice_match;const tr=Ke.strstart>Ke.w_size-MIN_LOOKAHEAD?Ke.strstart-(Ke.w_size-MIN_LOOKAHEAD):0,er=Ke.window,ir=Ke.w_mask,lr=Ke.prev,fr=Ke.strstart+MAX_MATCH;let ur=er[We+Xe-1],mr=er[We+Xe];Ke.prev_length>=Ke.good_match&&(Fe>>=2),Je>Ke.lookahead&&(Je=Ke.lookahead);do if(qe=Re,!(er[qe+Xe]!==mr||er[qe+Xe-1]!==ur||er[qe]!==er[We]||er[++qe]!==er[We+1])){We+=2,qe++;do;while(er[++We]===er[++qe]&&er[++We]===er[++qe]&&er[++We]===er[++qe]&&er[++We]===er[++qe]&&er[++We]===er[++qe]&&er[++We]===er[++qe]&&er[++We]===er[++qe]&&er[++We]===er[++qe]&&We<fr);if(Ze=MAX_MATCH-(fr-We),We=fr-MAX_MATCH,Ze>Xe){if(Ke.match_start=Re,Xe=Ze,Ze>=Je)break;ur=er[We+Xe-1],mr=er[We+Xe]}}while((Re=lr[Re&ir])>tr&&--Fe!==0);return Xe<=Ke.lookahead?Xe:Ke.lookahead},fill_window=Ke=>{const Re=Ke.w_size;let Fe,We,qe,Ze,Xe;do{if(Ze=Ke.window_size-Ke.lookahead-Ke.strstart,Ke.strstart>=Re+(Re-MIN_LOOKAHEAD)){Ke.window.set(Ke.window.subarray(Re,Re+Re),0),Ke.match_start-=Re,Ke.strstart-=Re,Ke.block_start-=Re,We=Ke.hash_size,Fe=We;do qe=Ke.head[--Fe],Ke.head[Fe]=qe>=Re?qe-Re:0;while(--We);We=Re,Fe=We;do qe=Ke.prev[--Fe],Ke.prev[Fe]=qe>=Re?qe-Re:0;while(--We);Ze+=Re}if(Ke.strm.avail_in===0)break;if(We=read_buf(Ke.strm,Ke.window,Ke.strstart+Ke.lookahead,Ze),Ke.lookahead+=We,Ke.lookahead+Ke.insert>=MIN_MATCH)for(Xe=Ke.strstart-Ke.insert,Ke.ins_h=Ke.window[Xe],Ke.ins_h=HASH(Ke,Ke.ins_h,Ke.window[Xe+1]);Ke.insert&&(Ke.ins_h=HASH(Ke,Ke.ins_h,Ke.window[Xe+MIN_MATCH-1]),Ke.prev[Xe&Ke.w_mask]=Ke.head[Ke.ins_h],Ke.head[Ke.ins_h]=Xe,Xe++,Ke.insert--,!(Ke.lookahead+Ke.insert<MIN_MATCH)););}while(Ke.lookahead<MIN_LOOKAHEAD&&Ke.strm.avail_in!==0)},deflate_stored=(Ke,Re)=>{let Fe=65535;for(Fe>Ke.pending_buf_size-5&&(Fe=Ke.pending_buf_size-5);;){if(Ke.lookahead<=1){if(fill_window(Ke),Ke.lookahead===0&&Re===Z_NO_FLUSH$2)return BS_NEED_MORE;if(Ke.lookahead===0)break}Ke.strstart+=Ke.lookahead,Ke.lookahead=0;const We=Ke.block_start+Fe;if((Ke.strstart===0||Ke.strstart>=We)&&(Ke.lookahead=Ke.strstart-We,Ke.strstart=We,flush_block_only(Ke,!1),Ke.strm.avail_out===0)||Ke.strstart-Ke.block_start>=Ke.w_size-MIN_LOOKAHEAD&&(flush_block_only(Ke,!1),Ke.strm.avail_out===0))return BS_NEED_MORE}return Ke.insert=0,Re===Z_FINISH$3?(flush_block_only(Ke,!0),Ke.strm.avail_out===0?BS_FINISH_STARTED:BS_FINISH_DONE):(Ke.strstart>Ke.block_start&&(flush_block_only(Ke,!1),Ke.strm.avail_out===0),BS_NEED_MORE)},deflate_fast=(Ke,Re)=>{let Fe,We;for(;;){if(Ke.lookahead<MIN_LOOKAHEAD){if(fill_window(Ke),Ke.lookahead<MIN_LOOKAHEAD&&Re===Z_NO_FLUSH$2)return BS_NEED_MORE;if(Ke.lookahead===0)break}if(Fe=0,Ke.lookahead>=MIN_MATCH&&(Ke.ins_h=HASH(Ke,Ke.ins_h,Ke.window[Ke.strstart+MIN_MATCH-1]),Fe=Ke.prev[Ke.strstart&Ke.w_mask]=Ke.head[Ke.ins_h],Ke.head[Ke.ins_h]=Ke.strstart),Fe!==0&&Ke.strstart-Fe<=Ke.w_size-MIN_LOOKAHEAD&&(Ke.match_length=longest_match(Ke,Fe)),Ke.match_length>=MIN_MATCH)if(We=_tr_tally(Ke,Ke.strstart-Ke.match_start,Ke.match_length-MIN_MATCH),Ke.lookahead-=Ke.match_length,Ke.match_length<=Ke.max_lazy_match&&Ke.lookahead>=MIN_MATCH){Ke.match_length--;do Ke.strstart++,Ke.ins_h=HASH(Ke,Ke.ins_h,Ke.window[Ke.strstart+MIN_MATCH-1]),Fe=Ke.prev[Ke.strstart&Ke.w_mask]=Ke.head[Ke.ins_h],Ke.head[Ke.ins_h]=Ke.strstart;while(--Ke.match_length!==0);Ke.strstart++}else Ke.strstart+=Ke.match_length,Ke.match_length=0,Ke.ins_h=Ke.window[Ke.strstart],Ke.ins_h=HASH(Ke,Ke.ins_h,Ke.window[Ke.strstart+1]);else We=_tr_tally(Ke,0,Ke.window[Ke.strstart]),Ke.lookahead--,Ke.strstart++;if(We&&(flush_block_only(Ke,!1),Ke.strm.avail_out===0))return BS_NEED_MORE}return Ke.insert=Ke.strstart<MIN_MATCH-1?Ke.strstart:MIN_MATCH-1,Re===Z_FINISH$3?(flush_block_only(Ke,!0),Ke.strm.avail_out===0?BS_FINISH_STARTED:BS_FINISH_DONE):Ke.last_lit&&(flush_block_only(Ke,!1),Ke.strm.avail_out===0)?BS_NEED_MORE:BS_BLOCK_DONE},deflate_slow=(Ke,Re)=>{let Fe,We,qe;for(;;){if(Ke.lookahead<MIN_LOOKAHEAD){if(fill_window(Ke),Ke.lookahead<MIN_LOOKAHEAD&&Re===Z_NO_FLUSH$2)return BS_NEED_MORE;if(Ke.lookahead===0)break}if(Fe=0,Ke.lookahead>=MIN_MATCH&&(Ke.ins_h=HASH(Ke,Ke.ins_h,Ke.window[Ke.strstart+MIN_MATCH-1]),Fe=Ke.prev[Ke.strstart&Ke.w_mask]=Ke.head[Ke.ins_h],Ke.head[Ke.ins_h]=Ke.strstart),Ke.prev_length=Ke.match_length,Ke.prev_match=Ke.match_start,Ke.match_length=MIN_MATCH-1,Fe!==0&&Ke.prev_length<Ke.max_lazy_match&&Ke.strstart-Fe<=Ke.w_size-MIN_LOOKAHEAD&&(Ke.match_length=longest_match(Ke,Fe),Ke.match_length<=5&&(Ke.strategy===Z_FILTERED||Ke.match_length===MIN_MATCH&&Ke.strstart-Ke.match_start>4096)&&(Ke.match_length=MIN_MATCH-1)),Ke.prev_length>=MIN_MATCH&&Ke.match_length<=Ke.prev_length){qe=Ke.strstart+Ke.lookahead-MIN_MATCH,We=_tr_tally(Ke,Ke.strstart-1-Ke.prev_match,Ke.prev_length-MIN_MATCH),Ke.lookahead-=Ke.prev_length-1,Ke.prev_length-=2;do++Ke.strstart<=qe&&(Ke.ins_h=HASH(Ke,Ke.ins_h,Ke.window[Ke.strstart+MIN_MATCH-1]),Fe=Ke.prev[Ke.strstart&Ke.w_mask]=Ke.head[Ke.ins_h],Ke.head[Ke.ins_h]=Ke.strstart);while(--Ke.prev_length!==0);if(Ke.match_available=0,Ke.match_length=MIN_MATCH-1,Ke.strstart++,We&&(flush_block_only(Ke,!1),Ke.strm.avail_out===0))return BS_NEED_MORE}else if(Ke.match_available){if(We=_tr_tally(Ke,0,Ke.window[Ke.strstart-1]),We&&flush_block_only(Ke,!1),Ke.strstart++,Ke.lookahead--,Ke.strm.avail_out===0)return BS_NEED_MORE}else Ke.match_available=1,Ke.strstart++,Ke.lookahead--}return Ke.match_available&&(We=_tr_tally(Ke,0,Ke.window[Ke.strstart-1]),Ke.match_available=0),Ke.insert=Ke.strstart<MIN_MATCH-1?Ke.strstart:MIN_MATCH-1,Re===Z_FINISH$3?(flush_block_only(Ke,!0),Ke.strm.avail_out===0?BS_FINISH_STARTED:BS_FINISH_DONE):Ke.last_lit&&(flush_block_only(Ke,!1),Ke.strm.avail_out===0)?BS_NEED_MORE:BS_BLOCK_DONE},deflate_rle=(Ke,Re)=>{let Fe,We,qe,Ze;const Xe=Ke.window;for(;;){if(Ke.lookahead<=MAX_MATCH){if(fill_window(Ke),Ke.lookahead<=MAX_MATCH&&Re===Z_NO_FLUSH$2)return BS_NEED_MORE;if(Ke.lookahead===0)break}if(Ke.match_length=0,Ke.lookahead>=MIN_MATCH&&Ke.strstart>0&&(qe=Ke.strstart-1,We=Xe[qe],We===Xe[++qe]&&We===Xe[++qe]&&We===Xe[++qe])){Ze=Ke.strstart+MAX_MATCH;do;while(We===Xe[++qe]&&We===Xe[++qe]&&We===Xe[++qe]&&We===Xe[++qe]&&We===Xe[++qe]&&We===Xe[++qe]&&We===Xe[++qe]&&We===Xe[++qe]&&qe<Ze);Ke.match_length=MAX_MATCH-(Ze-qe),Ke.match_length>Ke.lookahead&&(Ke.match_length=Ke.lookahead)}if(Ke.match_length>=MIN_MATCH?(Fe=_tr_tally(Ke,1,Ke.match_length-MIN_MATCH),Ke.lookahead-=Ke.match_length,Ke.strstart+=Ke.match_length,Ke.match_length=0):(Fe=_tr_tally(Ke,0,Ke.window[Ke.strstart]),Ke.lookahead--,Ke.strstart++),Fe&&(flush_block_only(Ke,!1),Ke.strm.avail_out===0))return BS_NEED_MORE}return Ke.insert=0,Re===Z_FINISH$3?(flush_block_only(Ke,!0),Ke.strm.avail_out===0?BS_FINISH_STARTED:BS_FINISH_DONE):Ke.last_lit&&(flush_block_only(Ke,!1),Ke.strm.avail_out===0)?BS_NEED_MORE:BS_BLOCK_DONE},deflate_huff=(Ke,Re)=>{let Fe;for(;;){if(Ke.lookahead===0&&(fill_window(Ke),Ke.lookahead===0)){if(Re===Z_NO_FLUSH$2)return BS_NEED_MORE;break}if(Ke.match_length=0,Fe=_tr_tally(Ke,0,Ke.window[Ke.strstart]),Ke.lookahead--,Ke.strstart++,Fe&&(flush_block_only(Ke,!1),Ke.strm.avail_out===0))return BS_NEED_MORE}return Ke.insert=0,Re===Z_FINISH$3?(flush_block_only(Ke,!0),Ke.strm.avail_out===0?BS_FINISH_STARTED:BS_FINISH_DONE):Ke.last_lit&&(flush_block_only(Ke,!1),Ke.strm.avail_out===0)?BS_NEED_MORE:BS_BLOCK_DONE};function Config(Ke,Re,Fe,We,qe){this.good_length=Ke,this.max_lazy=Re,this.nice_length=Fe,this.max_chain=We,this.func=qe}const configuration_table=[new Config(0,0,0,0,deflate_stored),new Config(4,4,8,4,deflate_fast),new Config(4,5,16,8,deflate_fast),new Config(4,6,32,32,deflate_fast),new Config(4,4,16,16,deflate_slow),new Config(8,16,32,32,deflate_slow),new Config(8,16,128,128,deflate_slow),new Config(8,32,128,256,deflate_slow),new Config(32,128,258,1024,deflate_slow),new Config(32,258,258,4096,deflate_slow)],lm_init=Ke=>{Ke.window_size=2*Ke.w_size,zero(Ke.head),Ke.max_lazy_match=configuration_table[Ke.level].max_lazy,Ke.good_match=configuration_table[Ke.level].good_length,Ke.nice_match=configuration_table[Ke.level].nice_length,Ke.max_chain_length=configuration_table[Ke.level].max_chain,Ke.strstart=0,Ke.block_start=0,Ke.lookahead=0,Ke.insert=0,Ke.match_length=Ke.prev_length=MIN_MATCH-1,Ke.match_available=0,Ke.ins_h=0};function DeflateState(){this.strm=null,this.status=0,this.pending_buf=null,this.pending_buf_size=0,this.pending_out=0,this.pending=0,this.wrap=0,this.gzhead=null,this.gzindex=0,this.method=Z_DEFLATED$2,this.last_flush=-1,this.w_size=0,this.w_bits=0,this.w_mask=0,this.window=null,this.window_size=0,this.prev=null,this.head=null,this.ins_h=0,this.hash_size=0,this.hash_bits=0,this.hash_mask=0,this.hash_shift=0,this.block_start=0,this.match_length=0,this.prev_match=0,this.match_available=0,this.strstart=0,this.match_start=0,this.lookahead=0,this.prev_length=0,this.max_chain_length=0,this.max_lazy_match=0,this.level=0,this.strategy=0,this.good_match=0,this.nice_match=0,this.dyn_ltree=new Uint16Array(HEAP_SIZE*2),this.dyn_dtree=new Uint16Array((2*D_CODES+1)*2),this.bl_tree=new Uint16Array((2*BL_CODES+1)*2),zero(this.dyn_ltree),zero(this.dyn_dtree),zero(this.bl_tree),this.l_desc=null,this.d_desc=null,this.bl_desc=null,this.bl_count=new Uint16Array(MAX_BITS+1),this.heap=new Uint16Array(2*L_CODES+1),zero(this.heap),this.heap_len=0,this.heap_max=0,this.depth=new Uint16Array(2*L_CODES+1),zero(this.depth),this.l_buf=0,this.lit_bufsize=0,this.last_lit=0,this.d_buf=0,this.opt_len=0,this.static_len=0,this.matches=0,this.insert=0,this.bi_buf=0,this.bi_valid=0}const deflateResetKeep=Ke=>{if(!Ke||!Ke.state)return err(Ke,Z_STREAM_ERROR$2);Ke.total_in=Ke.total_out=0,Ke.data_type=Z_UNKNOWN;const Re=Ke.state;return Re.pending=0,Re.pending_out=0,Re.wrap<0&&(Re.wrap=-Re.wrap),Re.status=Re.wrap?INIT_STATE:BUSY_STATE,Ke.adler=Re.wrap===2?0:1,Re.last_flush=Z_NO_FLUSH$2,_tr_init(Re),Z_OK$3},deflateReset=Ke=>{const Re=deflateResetKeep(Ke);return Re===Z_OK$3&&lm_init(Ke.state),Re},deflateSetHeader=(Ke,Re)=>!Ke||!Ke.state||Ke.state.wrap!==2?Z_STREAM_ERROR$2:(Ke.state.gzhead=Re,Z_OK$3),deflateInit2=(Ke,Re,Fe,We,qe,Ze)=>{if(!Ke)return Z_STREAM_ERROR$2;let Xe=1;if(Re===Z_DEFAULT_COMPRESSION$1&&(Re=6),We<0?(Xe=0,We=-We):We>15&&(Xe=2,We-=16),qe<1||qe>MAX_MEM_LEVEL||Fe!==Z_DEFLATED$2||We<8||We>15||Re<0||Re>9||Ze<0||Ze>Z_FIXED)return err(Ke,Z_STREAM_ERROR$2);We===8&&(We=9);const Je=new DeflateState;return Ke.state=Je,Je.strm=Ke,Je.wrap=Xe,Je.gzhead=null,Je.w_bits=We,Je.w_size=1<<Je.w_bits,Je.w_mask=Je.w_size-1,Je.hash_bits=qe+7,Je.hash_size=1<<Je.hash_bits,Je.hash_mask=Je.hash_size-1,Je.hash_shift=~~((Je.hash_bits+MIN_MATCH-1)/MIN_MATCH),Je.window=new Uint8Array(Je.w_size*2),Je.head=new Uint16Array(Je.hash_size),Je.prev=new Uint16Array(Je.w_size),Je.lit_bufsize=1<<qe+6,Je.pending_buf_size=Je.lit_bufsize*4,Je.pending_buf=new Uint8Array(Je.pending_buf_size),Je.d_buf=1*Je.lit_bufsize,Je.l_buf=(1+2)*Je.lit_bufsize,Je.level=Re,Je.strategy=Ze,Je.method=Fe,deflateReset(Ke)},deflateInit=(Ke,Re)=>deflateInit2(Ke,Re,Z_DEFLATED$2,MAX_WBITS$1,DEF_MEM_LEVEL,Z_DEFAULT_STRATEGY$1),deflate$2=(Ke,Re)=>{let Fe,We;if(!Ke||!Ke.state||Re>Z_BLOCK$1||Re<0)return Ke?err(Ke,Z_STREAM_ERROR$2):Z_STREAM_ERROR$2;const qe=Ke.state;if(!Ke.output||!Ke.input&&Ke.avail_in!==0||qe.status===FINISH_STATE&&Re!==Z_FINISH$3)return err(Ke,Ke.avail_out===0?Z_BUF_ERROR$1:Z_STREAM_ERROR$2);qe.strm=Ke;const Ze=qe.last_flush;if(qe.last_flush=Re,qe.status===INIT_STATE)if(qe.wrap===2)Ke.adler=0,put_byte(qe,31),put_byte(qe,139),put_byte(qe,8),qe.gzhead?(put_byte(qe,(qe.gzhead.text?1:0)+(qe.gzhead.hcrc?2:0)+(qe.gzhead.extra?4:0)+(qe.gzhead.name?8:0)+(qe.gzhead.comment?16:0)),put_byte(qe,qe.gzhead.time&255),put_byte(qe,qe.gzhead.time>>8&255),put_byte(qe,qe.gzhead.time>>16&255),put_byte(qe,qe.gzhead.time>>24&255),put_byte(qe,qe.level===9?2:qe.strategy>=Z_HUFFMAN_ONLY||qe.level<2?4:0),put_byte(qe,qe.gzhead.os&255),qe.gzhead.extra&&qe.gzhead.extra.length&&(put_byte(qe,qe.gzhead.extra.length&255),put_byte(qe,qe.gzhead.extra.length>>8&255)),qe.gzhead.hcrc&&(Ke.adler=crc32_1(Ke.adler,qe.pending_buf,qe.pending,0)),qe.gzindex=0,qe.status=EXTRA_STATE):(put_byte(qe,0),put_byte(qe,0),put_byte(qe,0),put_byte(qe,0),put_byte(qe,0),put_byte(qe,qe.level===9?2:qe.strategy>=Z_HUFFMAN_ONLY||qe.level<2?4:0),put_byte(qe,OS_CODE),qe.status=BUSY_STATE);else{let Xe=Z_DEFLATED$2+(qe.w_bits-8<<4)<<8,Je=-1;qe.strategy>=Z_HUFFMAN_ONLY||qe.level<2?Je=0:qe.level<6?Je=1:qe.level===6?Je=2:Je=3,Xe|=Je<<6,qe.strstart!==0&&(Xe|=PRESET_DICT),Xe+=31-Xe%31,qe.status=BUSY_STATE,putShortMSB(qe,Xe),qe.strstart!==0&&(putShortMSB(qe,Ke.adler>>>16),putShortMSB(qe,Ke.adler&65535)),Ke.adler=1}if(qe.status===EXTRA_STATE)if(qe.gzhead.extra){for(Fe=qe.pending;qe.gzindex<(qe.gzhead.extra.length&65535)&&!(qe.pending===qe.pending_buf_size&&(qe.gzhead.hcrc&&qe.pending>Fe&&(Ke.adler=crc32_1(Ke.adler,qe.pending_buf,qe.pending-Fe,Fe)),flush_pending(Ke),Fe=qe.pending,qe.pending===qe.pending_buf_size));)put_byte(qe,qe.gzhead.extra[qe.gzindex]&255),qe.gzindex++;qe.gzhead.hcrc&&qe.pending>Fe&&(Ke.adler=crc32_1(Ke.adler,qe.pending_buf,qe.pending-Fe,Fe)),qe.gzindex===qe.gzhead.extra.length&&(qe.gzindex=0,qe.status=NAME_STATE)}else qe.status=NAME_STATE;if(qe.status===NAME_STATE)if(qe.gzhead.name){Fe=qe.pending;do{if(qe.pending===qe.pending_buf_size&&(qe.gzhead.hcrc&&qe.pending>Fe&&(Ke.adler=crc32_1(Ke.adler,qe.pending_buf,qe.pending-Fe,Fe)),flush_pending(Ke),Fe=qe.pending,qe.pending===qe.pending_buf_size)){We=1;break}qe.gzindex<qe.gzhead.name.length?We=qe.gzhead.name.charCodeAt(qe.gzindex++)&255:We=0,put_byte(qe,We)}while(We!==0);qe.gzhead.hcrc&&qe.pending>Fe&&(Ke.adler=crc32_1(Ke.adler,qe.pending_buf,qe.pending-Fe,Fe)),We===0&&(qe.gzindex=0,qe.status=COMMENT_STATE)}else qe.status=COMMENT_STATE;if(qe.status===COMMENT_STATE)if(qe.gzhead.comment){Fe=qe.pending;do{if(qe.pending===qe.pending_buf_size&&(qe.gzhead.hcrc&&qe.pending>Fe&&(Ke.adler=crc32_1(Ke.adler,qe.pending_buf,qe.pending-Fe,Fe)),flush_pending(Ke),Fe=qe.pending,qe.pending===qe.pending_buf_size)){We=1;break}qe.gzindex<qe.gzhead.comment.length?We=qe.gzhead.comment.charCodeAt(qe.gzindex++)&255:We=0,put_byte(qe,We)}while(We!==0);qe.gzhead.hcrc&&qe.pending>Fe&&(Ke.adler=crc32_1(Ke.adler,qe.pending_buf,qe.pending-Fe,Fe)),We===0&&(qe.status=HCRC_STATE)}else qe.status=HCRC_STATE;if(qe.status===HCRC_STATE&&(qe.gzhead.hcrc?(qe.pending+2>qe.pending_buf_size&&flush_pending(Ke),qe.pending+2<=qe.pending_buf_size&&(put_byte(qe,Ke.adler&255),put_byte(qe,Ke.adler>>8&255),Ke.adler=0,qe.status=BUSY_STATE)):qe.status=BUSY_STATE),qe.pending!==0){if(flush_pending(Ke),Ke.avail_out===0)return qe.last_flush=-1,Z_OK$3}else if(Ke.avail_in===0&&rank(Re)<=rank(Ze)&&Re!==Z_FINISH$3)return err(Ke,Z_BUF_ERROR$1);if(qe.status===FINISH_STATE&&Ke.avail_in!==0)return err(Ke,Z_BUF_ERROR$1);if(Ke.avail_in!==0||qe.lookahead!==0||Re!==Z_NO_FLUSH$2&&qe.status!==FINISH_STATE){let Xe=qe.strategy===Z_HUFFMAN_ONLY?deflate_huff(qe,Re):qe.strategy===Z_RLE?deflate_rle(qe,Re):configuration_table[qe.level].func(qe,Re);if((Xe===BS_FINISH_STARTED||Xe===BS_FINISH_DONE)&&(qe.status=FINISH_STATE),Xe===BS_NEED_MORE||Xe===BS_FINISH_STARTED)return Ke.avail_out===0&&(qe.last_flush=-1),Z_OK$3;if(Xe===BS_BLOCK_DONE&&(Re===Z_PARTIAL_FLUSH?_tr_align(qe):Re!==Z_BLOCK$1&&(_tr_stored_block(qe,0,0,!1),Re===Z_FULL_FLUSH$1&&(zero(qe.head),qe.lookahead===0&&(qe.strstart=0,qe.block_start=0,qe.insert=0))),flush_pending(Ke),Ke.avail_out===0))return qe.last_flush=-1,Z_OK$3}return Re!==Z_FINISH$3?Z_OK$3:qe.wrap<=0?Z_STREAM_END$3:(qe.wrap===2?(put_byte(qe,Ke.adler&255),put_byte(qe,Ke.adler>>8&255),put_byte(qe,Ke.adler>>16&255),put_byte(qe,Ke.adler>>24&255),put_byte(qe,Ke.total_in&255),put_byte(qe,Ke.total_in>>8&255),put_byte(qe,Ke.total_in>>16&255),put_byte(qe,Ke.total_in>>24&255)):(putShortMSB(qe,Ke.adler>>>16),putShortMSB(qe,Ke.adler&65535)),flush_pending(Ke),qe.wrap>0&&(qe.wrap=-qe.wrap),qe.pending!==0?Z_OK$3:Z_STREAM_END$3)},deflateEnd=Ke=>{if(!Ke||!Ke.state)return Z_STREAM_ERROR$2;const Re=Ke.state.status;return Re!==INIT_STATE&&Re!==EXTRA_STATE&&Re!==NAME_STATE&&Re!==COMMENT_STATE&&Re!==HCRC_STATE&&Re!==BUSY_STATE&&Re!==FINISH_STATE?err(Ke,Z_STREAM_ERROR$2):(Ke.state=null,Re===BUSY_STATE?err(Ke,Z_DATA_ERROR$2):Z_OK$3)},deflateSetDictionary=(Ke,Re)=>{let Fe=Re.length;if(!Ke||!Ke.state)return Z_STREAM_ERROR$2;const We=Ke.state,qe=We.wrap;if(qe===2||qe===1&&We.status!==INIT_STATE||We.lookahead)return Z_STREAM_ERROR$2;if(qe===1&&(Ke.adler=adler32_1(Ke.adler,Re,Fe,0)),We.wrap=0,Fe>=We.w_size){qe===0&&(zero(We.head),We.strstart=0,We.block_start=0,We.insert=0);let tr=new Uint8Array(We.w_size);tr.set(Re.subarray(Fe-We.w_size,Fe),0),Re=tr,Fe=We.w_size}const Ze=Ke.avail_in,Xe=Ke.next_in,Je=Ke.input;for(Ke.avail_in=Fe,Ke.next_in=0,Ke.input=Re,fill_window(We);We.lookahead>=MIN_MATCH;){let tr=We.strstart,er=We.lookahead-(MIN_MATCH-1);do We.ins_h=HASH(We,We.ins_h,We.window[tr+MIN_MATCH-1]),We.prev[tr&We.w_mask]=We.head[We.ins_h],We.head[We.ins_h]=tr,tr++;while(--er);We.strstart=tr,We.lookahead=MIN_MATCH-1,fill_window(We)}return We.strstart+=We.lookahead,We.block_start=We.strstart,We.insert=We.lookahead,We.lookahead=0,We.match_length=We.prev_length=MIN_MATCH-1,We.match_available=0,Ke.next_in=Xe,Ke.input=Je,Ke.avail_in=Ze,We.wrap=qe,Z_OK$3};var deflateInit_1=deflateInit,deflateInit2_1=deflateInit2,deflateReset_1=deflateReset,deflateResetKeep_1=deflateResetKeep,deflateSetHeader_1=deflateSetHeader,deflate_2$1=deflate$2,deflateEnd_1=deflateEnd,deflateSetDictionary_1=deflateSetDictionary,deflateInfo="pako deflate (from Nodeca project)",deflate_1$2={deflateInit:deflateInit_1,deflateInit2:deflateInit2_1,deflateReset:deflateReset_1,deflateResetKeep:deflateResetKeep_1,deflateSetHeader:deflateSetHeader_1,deflate:deflate_2$1,deflateEnd:deflateEnd_1,deflateSetDictionary:deflateSetDictionary_1,deflateInfo};const _has=(Ke,Re)=>Object.prototype.hasOwnProperty.call(Ke,Re);var assign=function(Ke){const Re=Array.prototype.slice.call(arguments,1);for(;Re.length;){const Fe=Re.shift();if(!!Fe){if(typeof Fe!="object")throw new TypeError(Fe+"must be non-object");for(const We in Fe)_has(Fe,We)&&(Ke[We]=Fe[We])}}return Ke},flattenChunks=Ke=>{let Re=0;for(let We=0,qe=Ke.length;We<qe;We++)Re+=Ke[We].length;const Fe=new Uint8Array(Re);for(let We=0,qe=0,Ze=Ke.length;We<Ze;We++){let Xe=Ke[We];Fe.set(Xe,qe),qe+=Xe.length}return Fe},common={assign,flattenChunks};let STR_APPLY_UIA_OK=!0;try{String.fromCharCode.apply(null,new Uint8Array(1))}catch(Ke){STR_APPLY_UIA_OK=!1}const _utf8len=new Uint8Array(256);for(let Ke=0;Ke<256;Ke++)_utf8len[Ke]=Ke>=252?6:Ke>=248?5:Ke>=240?4:Ke>=224?3:Ke>=192?2:1;_utf8len[254]=_utf8len[254]=1;var string2buf=Ke=>{if(typeof TextEncoder=="function"&&TextEncoder.prototype.encode)return new TextEncoder().encode(Ke);let Re,Fe,We,qe,Ze,Xe=Ke.length,Je=0;for(qe=0;qe<Xe;qe++)Fe=Ke.charCodeAt(qe),(Fe&64512)===55296&&qe+1<Xe&&(We=Ke.charCodeAt(qe+1),(We&64512)===56320&&(Fe=65536+(Fe-55296<<10)+(We-56320),qe++)),Je+=Fe<128?1:Fe<2048?2:Fe<65536?3:4;for(Re=new Uint8Array(Je),Ze=0,qe=0;Ze<Je;qe++)Fe=Ke.charCodeAt(qe),(Fe&64512)===55296&&qe+1<Xe&&(We=Ke.charCodeAt(qe+1),(We&64512)===56320&&(Fe=65536+(Fe-55296<<10)+(We-56320),qe++)),Fe<128?Re[Ze++]=Fe:Fe<2048?(Re[Ze++]=192|Fe>>>6,Re[Ze++]=128|Fe&63):Fe<65536?(Re[Ze++]=224|Fe>>>12,Re[Ze++]=128|Fe>>>6&63,Re[Ze++]=128|Fe&63):(Re[Ze++]=240|Fe>>>18,Re[Ze++]=128|Fe>>>12&63,Re[Ze++]=128|Fe>>>6&63,Re[Ze++]=128|Fe&63);return Re};const buf2binstring=(Ke,Re)=>{if(Re<65534&&Ke.subarray&&STR_APPLY_UIA_OK)return String.fromCharCode.apply(null,Ke.length===Re?Ke:Ke.subarray(0,Re));let Fe="";for(let We=0;We<Re;We++)Fe+=String.fromCharCode(Ke[We]);return Fe};var buf2string=(Ke,Re)=>{const Fe=Re||Ke.length;if(typeof TextDecoder=="function"&&TextDecoder.prototype.decode)return new TextDecoder().decode(Ke.subarray(0,Re));let We,qe;const Ze=new Array(Fe*2);for(qe=0,We=0;We<Fe;){let Xe=Ke[We++];if(Xe<128){Ze[qe++]=Xe;continue}let Je=_utf8len[Xe];if(Je>4){Ze[qe++]=65533,We+=Je-1;continue}for(Xe&=Je===2?31:Je===3?15:7;Je>1&&We<Fe;)Xe=Xe<<6|Ke[We++]&63,Je--;if(Je>1){Ze[qe++]=65533;continue}Xe<65536?Ze[qe++]=Xe:(Xe-=65536,Ze[qe++]=55296|Xe>>10&1023,Ze[qe++]=56320|Xe&1023)}return buf2binstring(Ze,qe)},utf8border=(Ke,Re)=>{Re=Re||Ke.length,Re>Ke.length&&(Re=Ke.length);let Fe=Re-1;for(;Fe>=0&&(Ke[Fe]&192)===128;)Fe--;return Fe<0||Fe===0?Re:Fe+_utf8len[Ke[Fe]]>Re?Fe:Re},strings={string2buf,buf2string,utf8border};function ZStream(){this.input=null,this.next_in=0,this.avail_in=0,this.total_in=0,this.output=null,this.next_out=0,this.avail_out=0,this.total_out=0,this.msg="",this.state=null,this.data_type=2,this.adler=0}var zstream=ZStream;const toString$1=Object.prototype.toString,{Z_NO_FLUSH:Z_NO_FLUSH$1,Z_SYNC_FLUSH,Z_FULL_FLUSH,Z_FINISH:Z_FINISH$2,Z_OK:Z_OK$2,Z_STREAM_END:Z_STREAM_END$2,Z_DEFAULT_COMPRESSION,Z_DEFAULT_STRATEGY,Z_DEFLATED:Z_DEFLATED$1}=constants$2;function Deflate$1(Ke){this.options=common.assign({level:Z_DEFAULT_COMPRESSION,method:Z_DEFLATED$1,chunkSize:16384,windowBits:15,memLevel:8,strategy:Z_DEFAULT_STRATEGY},Ke||{});let Re=this.options;Re.raw&&Re.windowBits>0?Re.windowBits=-Re.windowBits:Re.gzip&&Re.windowBits>0&&Re.windowBits<16&&(Re.windowBits+=16),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new zstream,this.strm.avail_out=0;let Fe=deflate_1$2.deflateInit2(this.strm,Re.level,Re.method,Re.windowBits,Re.memLevel,Re.strategy);if(Fe!==Z_OK$2)throw new Error(messages[Fe]);if(Re.header&&deflate_1$2.deflateSetHeader(this.strm,Re.header),Re.dictionary){let We;if(typeof Re.dictionary=="string"?We=strings.string2buf(Re.dictionary):toString$1.call(Re.dictionary)==="[object ArrayBuffer]"?We=new Uint8Array(Re.dictionary):We=Re.dictionary,Fe=deflate_1$2.deflateSetDictionary(this.strm,We),Fe!==Z_OK$2)throw new Error(messages[Fe]);this._dict_set=!0}}Deflate$1.prototype.push=function(Ke,Re){const Fe=this.strm,We=this.options.chunkSize;let qe,Ze;if(this.ended)return!1;for(Re===~~Re?Ze=Re:Ze=Re===!0?Z_FINISH$2:Z_NO_FLUSH$1,typeof Ke=="string"?Fe.input=strings.string2buf(Ke):toString$1.call(Ke)==="[object ArrayBuffer]"?Fe.input=new Uint8Array(Ke):Fe.input=Ke,Fe.next_in=0,Fe.avail_in=Fe.input.length;;){if(Fe.avail_out===0&&(Fe.output=new Uint8Array(We),Fe.next_out=0,Fe.avail_out=We),(Ze===Z_SYNC_FLUSH||Ze===Z_FULL_FLUSH)&&Fe.avail_out<=6){this.onData(Fe.output.subarray(0,Fe.next_out)),Fe.avail_out=0;continue}if(qe=deflate_1$2.deflate(Fe,Ze),qe===Z_STREAM_END$2)return Fe.next_out>0&&this.onData(Fe.output.subarray(0,Fe.next_out)),qe=deflate_1$2.deflateEnd(this.strm),this.onEnd(qe),this.ended=!0,qe===Z_OK$2;if(Fe.avail_out===0){this.onData(Fe.output);continue}if(Ze>0&&Fe.next_out>0){this.onData(Fe.output.subarray(0,Fe.next_out)),Fe.avail_out=0;continue}if(Fe.avail_in===0)break}return!0};Deflate$1.prototype.onData=function(Ke){this.chunks.push(Ke)};Deflate$1.prototype.onEnd=function(Ke){Ke===Z_OK$2&&(this.result=common.flattenChunks(this.chunks)),this.chunks=[],this.err=Ke,this.msg=this.strm.msg};const BAD$1=30,TYPE$1=12;var inffast=function Ke(Re,Fe){let We,qe,Ze,Xe,Je,tr,er,ir,lr,fr,ur,mr,br,wr,Sr,kr,Er,Ir,Rr,Pr,Br,Or,Nr,Cr;const Tr=Re.state;We=Re.next_in,Nr=Re.input,qe=We+(Re.avail_in-5),Ze=Re.next_out,Cr=Re.output,Xe=Ze-(Fe-Re.avail_out),Je=Ze+(Re.avail_out-257),tr=Tr.dmax,er=Tr.wsize,ir=Tr.whave,lr=Tr.wnext,fr=Tr.window,ur=Tr.hold,mr=Tr.bits,br=Tr.lencode,wr=Tr.distcode,Sr=(1<<Tr.lenbits)-1,kr=(1<<Tr.distbits)-1;e:do{mr<15&&(ur+=Nr[We++]<<mr,mr+=8,ur+=Nr[We++]<<mr,mr+=8),Er=br[ur&Sr];t:for(;;){if(Ir=Er>>>24,ur>>>=Ir,mr-=Ir,Ir=Er>>>16&255,Ir===0)Cr[Ze++]=Er&65535;else if(Ir&16){Rr=Er&65535,Ir&=15,Ir&&(mr<Ir&&(ur+=Nr[We++]<<mr,mr+=8),Rr+=ur&(1<<Ir)-1,ur>>>=Ir,mr-=Ir),mr<15&&(ur+=Nr[We++]<<mr,mr+=8,ur+=Nr[We++]<<mr,mr+=8),Er=wr[ur&kr];r:for(;;){if(Ir=Er>>>24,ur>>>=Ir,mr-=Ir,Ir=Er>>>16&255,Ir&16){if(Pr=Er&65535,Ir&=15,mr<Ir&&(ur+=Nr[We++]<<mr,mr+=8,mr<Ir&&(ur+=Nr[We++]<<mr,mr+=8)),Pr+=ur&(1<<Ir)-1,Pr>tr){Re.msg="invalid distance too far back",Tr.mode=BAD$1;break e}if(ur>>>=Ir,mr-=Ir,Ir=Ze-Xe,Pr>Ir){if(Ir=Pr-Ir,Ir>ir&&Tr.sane){Re.msg="invalid distance too far back",Tr.mode=BAD$1;break e}if(Br=0,Or=fr,lr===0){if(Br+=er-Ir,Ir<Rr){Rr-=Ir;do Cr[Ze++]=fr[Br++];while(--Ir);Br=Ze-Pr,Or=Cr}}else if(lr<Ir){if(Br+=er+lr-Ir,Ir-=lr,Ir<Rr){Rr-=Ir;do Cr[Ze++]=fr[Br++];while(--Ir);if(Br=0,lr<Rr){Ir=lr,Rr-=Ir;do Cr[Ze++]=fr[Br++];while(--Ir);Br=Ze-Pr,Or=Cr}}}else if(Br+=lr-Ir,Ir<Rr){Rr-=Ir;do Cr[Ze++]=fr[Br++];while(--Ir);Br=Ze-Pr,Or=Cr}for(;Rr>2;)Cr[Ze++]=Or[Br++],Cr[Ze++]=Or[Br++],Cr[Ze++]=Or[Br++],Rr-=3;Rr&&(Cr[Ze++]=Or[Br++],Rr>1&&(Cr[Ze++]=Or[Br++]))}else{Br=Ze-Pr;do Cr[Ze++]=Cr[Br++],Cr[Ze++]=Cr[Br++],Cr[Ze++]=Cr[Br++],Rr-=3;while(Rr>2);Rr&&(Cr[Ze++]=Cr[Br++],Rr>1&&(Cr[Ze++]=Cr[Br++]))}}else if((Ir&64)===0){Er=wr[(Er&65535)+(ur&(1<<Ir)-1)];continue r}else{Re.msg="invalid distance code",Tr.mode=BAD$1;break e}break}}else if((Ir&64)===0){Er=br[(Er&65535)+(ur&(1<<Ir)-1)];continue t}else if(Ir&32){Tr.mode=TYPE$1;break e}else{Re.msg="invalid literal/length code",Tr.mode=BAD$1;break e}break}}while(We<qe&&Ze<Je);Rr=mr>>3,We-=Rr,mr-=Rr<<3,ur&=(1<<mr)-1,Re.next_in=We,Re.next_out=Ze,Re.avail_in=We<qe?5+(qe-We):5-(We-qe),Re.avail_out=Ze<Je?257+(Je-Ze):257-(Ze-Je),Tr.hold=ur,Tr.bits=mr};const MAXBITS=15,ENOUGH_LENS$1=852,ENOUGH_DISTS$1=592,CODES$1=0,LENS$1=1,DISTS$1=2,lbase=new Uint16Array([3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0]),lext=new Uint8Array([16,16,16,16,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,16,72,78]),dbase=new Uint16Array([1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0]),dext=new Uint8Array([16,16,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,64,64]),inflate_table=(Ke,Re,Fe,We,qe,Ze,Xe,Je)=>{const tr=Je.bits;let er=0,ir=0,lr=0,fr=0,ur=0,mr=0,br=0,wr=0,Sr=0,kr=0,Er,Ir,Rr,Pr,Br,Or=null,Nr=0,Cr;const Tr=new Uint16Array(MAXBITS+1),Mr=new Uint16Array(MAXBITS+1);let ar=null,Dt=0,sr,cr,yr;for(er=0;er<=MAXBITS;er++)Tr[er]=0;for(ir=0;ir<We;ir++)Tr[Re[Fe+ir]]++;for(ur=tr,fr=MAXBITS;fr>=1&&Tr[fr]===0;fr--);if(ur>fr&&(ur=fr),fr===0)return qe[Ze++]=1<<24|64<<16|0,qe[Ze++]=1<<24|64<<16|0,Je.bits=1,0;for(lr=1;lr<fr&&Tr[lr]===0;lr++);for(ur<lr&&(ur=lr),wr=1,er=1;er<=MAXBITS;er++)if(wr<<=1,wr-=Tr[er],wr<0)return-1;if(wr>0&&(Ke===CODES$1||fr!==1))return-1;for(Mr[1]=0,er=1;er<MAXBITS;er++)Mr[er+1]=Mr[er]+Tr[er];for(ir=0;ir<We;ir++)Re[Fe+ir]!==0&&(Xe[Mr[Re[Fe+ir]]++]=ir);if(Ke===CODES$1?(Or=ar=Xe,Cr=19):Ke===LENS$1?(Or=lbase,Nr-=257,ar=lext,Dt-=257,Cr=256):(Or=dbase,ar=dext,Cr=-1),kr=0,ir=0,er=lr,Br=Ze,mr=ur,br=0,Rr=-1,Sr=1<<ur,Pr=Sr-1,Ke===LENS$1&&Sr>ENOUGH_LENS$1||Ke===DISTS$1&&Sr>ENOUGH_DISTS$1)return 1;for(;;){sr=er-br,Xe[ir]<Cr?(cr=0,yr=Xe[ir]):Xe[ir]>Cr?(cr=ar[Dt+Xe[ir]],yr=Or[Nr+Xe[ir]]):(cr=32+64,yr=0),Er=1<<er-br,Ir=1<<mr,lr=Ir;do Ir-=Er,qe[Br+(kr>>br)+Ir]=sr<<24|cr<<16|yr|0;while(Ir!==0);for(Er=1<<er-1;kr&Er;)Er>>=1;if(Er!==0?(kr&=Er-1,kr+=Er):kr=0,ir++,--Tr[er]===0){if(er===fr)break;er=Re[Fe+Xe[ir]]}if(er>ur&&(kr&Pr)!==Rr){for(br===0&&(br=ur),Br+=lr,mr=er-br,wr=1<<mr;mr+br<fr&&(wr-=Tr[mr+br],!(wr<=0));)mr++,wr<<=1;if(Sr+=1<<mr,Ke===LENS$1&&Sr>ENOUGH_LENS$1||Ke===DISTS$1&&Sr>ENOUGH_DISTS$1)return 1;Rr=kr&Pr,qe[Rr]=ur<<24|mr<<16|Br-Ze|0}}return kr!==0&&(qe[Br+kr]=er-br<<24|64<<16|0),Je.bits=ur,0};var inftrees=inflate_table;const CODES=0,LENS=1,DISTS=2,{Z_FINISH:Z_FINISH$1,Z_BLOCK,Z_TREES,Z_OK:Z_OK$1,Z_STREAM_END:Z_STREAM_END$1,Z_NEED_DICT:Z_NEED_DICT$1,Z_STREAM_ERROR:Z_STREAM_ERROR$1,Z_DATA_ERROR:Z_DATA_ERROR$1,Z_MEM_ERROR:Z_MEM_ERROR$1,Z_BUF_ERROR,Z_DEFLATED}=constants$2,HEAD=1,FLAGS=2,TIME=3,OS=4,EXLEN=5,EXTRA=6,NAME=7,COMMENT=8,HCRC=9,DICTID=10,DICT=11,TYPE=12,TYPEDO=13,STORED=14,COPY_=15,COPY=16,TABLE=17,LENLENS=18,CODELENS=19,LEN_=20,LEN=21,LENEXT=22,DIST=23,DISTEXT=24,MATCH=25,LIT=26,CHECK=27,LENGTH=28,DONE=29,BAD=30,MEM=31,SYNC=32,ENOUGH_LENS=852,ENOUGH_DISTS=592,MAX_WBITS=15,DEF_WBITS=MAX_WBITS,zswap32=Ke=>(Ke>>>24&255)+(Ke>>>8&65280)+((Ke&65280)<<8)+((Ke&255)<<24);function InflateState(){this.mode=0,this.last=!1,this.wrap=0,this.havedict=!1,this.flags=0,this.dmax=0,this.check=0,this.total=0,this.head=null,this.wbits=0,this.wsize=0,this.whave=0,this.wnext=0,this.window=null,this.hold=0,this.bits=0,this.length=0,this.offset=0,this.extra=0,this.lencode=null,this.distcode=null,this.lenbits=0,this.distbits=0,this.ncode=0,this.nlen=0,this.ndist=0,this.have=0,this.next=null,this.lens=new Uint16Array(320),this.work=new Uint16Array(288),this.lendyn=null,this.distdyn=null,this.sane=0,this.back=0,this.was=0}const inflateResetKeep=Ke=>{if(!Ke||!Ke.state)return Z_STREAM_ERROR$1;const Re=Ke.state;return Ke.total_in=Ke.total_out=Re.total=0,Ke.msg="",Re.wrap&&(Ke.adler=Re.wrap&1),Re.mode=HEAD,Re.last=0,Re.havedict=0,Re.dmax=32768,Re.head=null,Re.hold=0,Re.bits=0,Re.lencode=Re.lendyn=new Int32Array(ENOUGH_LENS),Re.distcode=Re.distdyn=new Int32Array(ENOUGH_DISTS),Re.sane=1,Re.back=-1,Z_OK$1},inflateReset=Ke=>{if(!Ke||!Ke.state)return Z_STREAM_ERROR$1;const Re=Ke.state;return Re.wsize=0,Re.whave=0,Re.wnext=0,inflateResetKeep(Ke)},inflateReset2=(Ke,Re)=>{let Fe;if(!Ke||!Ke.state)return Z_STREAM_ERROR$1;const We=Ke.state;return Re<0?(Fe=0,Re=-Re):(Fe=(Re>>4)+1,Re<48&&(Re&=15)),Re&&(Re<8||Re>15)?Z_STREAM_ERROR$1:(We.window!==null&&We.wbits!==Re&&(We.window=null),We.wrap=Fe,We.wbits=Re,inflateReset(Ke))},inflateInit2=(Ke,Re)=>{if(!Ke)return Z_STREAM_ERROR$1;const Fe=new InflateState;Ke.state=Fe,Fe.window=null;const We=inflateReset2(Ke,Re);return We!==Z_OK$1&&(Ke.state=null),We},inflateInit=Ke=>inflateInit2(Ke,DEF_WBITS);let virgin=!0,lenfix,distfix;const fixedtables=Ke=>{if(virgin){lenfix=new Int32Array(512),distfix=new Int32Array(32);let Re=0;for(;Re<144;)Ke.lens[Re++]=8;for(;Re<256;)Ke.lens[Re++]=9;for(;Re<280;)Ke.lens[Re++]=7;for(;Re<288;)Ke.lens[Re++]=8;for(inftrees(LENS,Ke.lens,0,288,lenfix,0,Ke.work,{bits:9}),Re=0;Re<32;)Ke.lens[Re++]=5;inftrees(DISTS,Ke.lens,0,32,distfix,0,Ke.work,{bits:5}),virgin=!1}Ke.lencode=lenfix,Ke.lenbits=9,Ke.distcode=distfix,Ke.distbits=5},updatewindow=(Ke,Re,Fe,We)=>{let qe;const Ze=Ke.state;return Ze.window===null&&(Ze.wsize=1<<Ze.wbits,Ze.wnext=0,Ze.whave=0,Ze.window=new Uint8Array(Ze.wsize)),We>=Ze.wsize?(Ze.window.set(Re.subarray(Fe-Ze.wsize,Fe),0),Ze.wnext=0,Ze.whave=Ze.wsize):(qe=Ze.wsize-Ze.wnext,qe>We&&(qe=We),Ze.window.set(Re.subarray(Fe-We,Fe-We+qe),Ze.wnext),We-=qe,We?(Ze.window.set(Re.subarray(Fe-We,Fe),0),Ze.wnext=We,Ze.whave=Ze.wsize):(Ze.wnext+=qe,Ze.wnext===Ze.wsize&&(Ze.wnext=0),Ze.whave<Ze.wsize&&(Ze.whave+=qe))),0},inflate$2=(Ke,Re)=>{let Fe,We,qe,Ze,Xe,Je,tr,er,ir,lr,fr,ur,mr,br,wr=0,Sr,kr,Er,Ir,Rr,Pr,Br,Or;const Nr=new Uint8Array(4);let Cr,Tr;const Mr=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]);if(!Ke||!Ke.state||!Ke.output||!Ke.input&&Ke.avail_in!==0)return Z_STREAM_ERROR$1;Fe=Ke.state,Fe.mode===TYPE&&(Fe.mode=TYPEDO),Xe=Ke.next_out,qe=Ke.output,tr=Ke.avail_out,Ze=Ke.next_in,We=Ke.input,Je=Ke.avail_in,er=Fe.hold,ir=Fe.bits,lr=Je,fr=tr,Or=Z_OK$1;e:for(;;)switch(Fe.mode){case HEAD:if(Fe.wrap===0){Fe.mode=TYPEDO;break}for(;ir<16;){if(Je===0)break e;Je--,er+=We[Ze++]<<ir,ir+=8}if(Fe.wrap&2&&er===35615){Fe.check=0,Nr[0]=er&255,Nr[1]=er>>>8&255,Fe.check=crc32_1(Fe.check,Nr,2,0),er=0,ir=0,Fe.mode=FLAGS;break}if(Fe.flags=0,Fe.head&&(Fe.head.done=!1),!(Fe.wrap&1)||(((er&255)<<8)+(er>>8))%31){Ke.msg="incorrect header check",Fe.mode=BAD;break}if((er&15)!==Z_DEFLATED){Ke.msg="unknown compression method",Fe.mode=BAD;break}if(er>>>=4,ir-=4,Br=(er&15)+8,Fe.wbits===0)Fe.wbits=Br;else if(Br>Fe.wbits){Ke.msg="invalid window size",Fe.mode=BAD;break}Fe.dmax=1<<Fe.wbits,Ke.adler=Fe.check=1,Fe.mode=er&512?DICTID:TYPE,er=0,ir=0;break;case FLAGS:for(;ir<16;){if(Je===0)break e;Je--,er+=We[Ze++]<<ir,ir+=8}if(Fe.flags=er,(Fe.flags&255)!==Z_DEFLATED){Ke.msg="unknown compression method",Fe.mode=BAD;break}if(Fe.flags&57344){Ke.msg="unknown header flags set",Fe.mode=BAD;break}Fe.head&&(Fe.head.text=er>>8&1),Fe.flags&512&&(Nr[0]=er&255,Nr[1]=er>>>8&255,Fe.check=crc32_1(Fe.check,Nr,2,0)),er=0,ir=0,Fe.mode=TIME;case TIME:for(;ir<32;){if(Je===0)break e;Je--,er+=We[Ze++]<<ir,ir+=8}Fe.head&&(Fe.head.time=er),Fe.flags&512&&(Nr[0]=er&255,Nr[1]=er>>>8&255,Nr[2]=er>>>16&255,Nr[3]=er>>>24&255,Fe.check=crc32_1(Fe.check,Nr,4,0)),er=0,ir=0,Fe.mode=OS;case OS:for(;ir<16;){if(Je===0)break e;Je--,er+=We[Ze++]<<ir,ir+=8}Fe.head&&(Fe.head.xflags=er&255,Fe.head.os=er>>8),Fe.flags&512&&(Nr[0]=er&255,Nr[1]=er>>>8&255,Fe.check=crc32_1(Fe.check,Nr,2,0)),er=0,ir=0,Fe.mode=EXLEN;case EXLEN:if(Fe.flags&1024){for(;ir<16;){if(Je===0)break e;Je--,er+=We[Ze++]<<ir,ir+=8}Fe.length=er,Fe.head&&(Fe.head.extra_len=er),Fe.flags&512&&(Nr[0]=er&255,Nr[1]=er>>>8&255,Fe.check=crc32_1(Fe.check,Nr,2,0)),er=0,ir=0}else Fe.head&&(Fe.head.extra=null);Fe.mode=EXTRA;case EXTRA:if(Fe.flags&1024&&(ur=Fe.length,ur>Je&&(ur=Je),ur&&(Fe.head&&(Br=Fe.head.extra_len-Fe.length,Fe.head.extra||(Fe.head.extra=new Uint8Array(Fe.head.extra_len)),Fe.head.extra.set(We.subarray(Ze,Ze+ur),Br)),Fe.flags&512&&(Fe.check=crc32_1(Fe.check,We,ur,Ze)),Je-=ur,Ze+=ur,Fe.length-=ur),Fe.length))break e;Fe.length=0,Fe.mode=NAME;case NAME:if(Fe.flags&2048){if(Je===0)break e;ur=0;do Br=We[Ze+ur++],Fe.head&&Br&&Fe.length<65536&&(Fe.head.name+=String.fromCharCode(Br));while(Br&&ur<Je);if(Fe.flags&512&&(Fe.check=crc32_1(Fe.check,We,ur,Ze)),Je-=ur,Ze+=ur,Br)break e}else Fe.head&&(Fe.head.name=null);Fe.length=0,Fe.mode=COMMENT;case COMMENT:if(Fe.flags&4096){if(Je===0)break e;ur=0;do Br=We[Ze+ur++],Fe.head&&Br&&Fe.length<65536&&(Fe.head.comment+=String.fromCharCode(Br));while(Br&&ur<Je);if(Fe.flags&512&&(Fe.check=crc32_1(Fe.check,We,ur,Ze)),Je-=ur,Ze+=ur,Br)break e}else Fe.head&&(Fe.head.comment=null);Fe.mode=HCRC;case HCRC:if(Fe.flags&512){for(;ir<16;){if(Je===0)break e;Je--,er+=We[Ze++]<<ir,ir+=8}if(er!==(Fe.check&65535)){Ke.msg="header crc mismatch",Fe.mode=BAD;break}er=0,ir=0}Fe.head&&(Fe.head.hcrc=Fe.flags>>9&1,Fe.head.done=!0),Ke.adler=Fe.check=0,Fe.mode=TYPE;break;case DICTID:for(;ir<32;){if(Je===0)break e;Je--,er+=We[Ze++]<<ir,ir+=8}Ke.adler=Fe.check=zswap32(er),er=0,ir=0,Fe.mode=DICT;case DICT:if(Fe.havedict===0)return Ke.next_out=Xe,Ke.avail_out=tr,Ke.next_in=Ze,Ke.avail_in=Je,Fe.hold=er,Fe.bits=ir,Z_NEED_DICT$1;Ke.adler=Fe.check=1,Fe.mode=TYPE;case TYPE:if(Re===Z_BLOCK||Re===Z_TREES)break e;case TYPEDO:if(Fe.last){er>>>=ir&7,ir-=ir&7,Fe.mode=CHECK;break}for(;ir<3;){if(Je===0)break e;Je--,er+=We[Ze++]<<ir,ir+=8}switch(Fe.last=er&1,er>>>=1,ir-=1,er&3){case 0:Fe.mode=STORED;break;case 1:if(fixedtables(Fe),Fe.mode=LEN_,Re===Z_TREES){er>>>=2,ir-=2;break e}break;case 2:Fe.mode=TABLE;break;case 3:Ke.msg="invalid block type",Fe.mode=BAD}er>>>=2,ir-=2;break;case STORED:for(er>>>=ir&7,ir-=ir&7;ir<32;){if(Je===0)break e;Je--,er+=We[Ze++]<<ir,ir+=8}if((er&65535)!==(er>>>16^65535)){Ke.msg="invalid stored block lengths",Fe.mode=BAD;break}if(Fe.length=er&65535,er=0,ir=0,Fe.mode=COPY_,Re===Z_TREES)break e;case COPY_:Fe.mode=COPY;case COPY:if(ur=Fe.length,ur){if(ur>Je&&(ur=Je),ur>tr&&(ur=tr),ur===0)break e;qe.set(We.subarray(Ze,Ze+ur),Xe),Je-=ur,Ze+=ur,tr-=ur,Xe+=ur,Fe.length-=ur;break}Fe.mode=TYPE;break;case TABLE:for(;ir<14;){if(Je===0)break e;Je--,er+=We[Ze++]<<ir,ir+=8}if(Fe.nlen=(er&31)+257,er>>>=5,ir-=5,Fe.ndist=(er&31)+1,er>>>=5,ir-=5,Fe.ncode=(er&15)+4,er>>>=4,ir-=4,Fe.nlen>286||Fe.ndist>30){Ke.msg="too many length or distance symbols",Fe.mode=BAD;break}Fe.have=0,Fe.mode=LENLENS;case LENLENS:for(;Fe.have<Fe.ncode;){for(;ir<3;){if(Je===0)break e;Je--,er+=We[Ze++]<<ir,ir+=8}Fe.lens[Mr[Fe.have++]]=er&7,er>>>=3,ir-=3}for(;Fe.have<19;)Fe.lens[Mr[Fe.have++]]=0;if(Fe.lencode=Fe.lendyn,Fe.lenbits=7,Cr={bits:Fe.lenbits},Or=inftrees(CODES,Fe.lens,0,19,Fe.lencode,0,Fe.work,Cr),Fe.lenbits=Cr.bits,Or){Ke.msg="invalid code lengths set",Fe.mode=BAD;break}Fe.have=0,Fe.mode=CODELENS;case CODELENS:for(;Fe.have<Fe.nlen+Fe.ndist;){for(;wr=Fe.lencode[er&(1<<Fe.lenbits)-1],Sr=wr>>>24,kr=wr>>>16&255,Er=wr&65535,!(Sr<=ir);){if(Je===0)break e;Je--,er+=We[Ze++]<<ir,ir+=8}if(Er<16)er>>>=Sr,ir-=Sr,Fe.lens[Fe.have++]=Er;else{if(Er===16){for(Tr=Sr+2;ir<Tr;){if(Je===0)break e;Je--,er+=We[Ze++]<<ir,ir+=8}if(er>>>=Sr,ir-=Sr,Fe.have===0){Ke.msg="invalid bit length repeat",Fe.mode=BAD;break}Br=Fe.lens[Fe.have-1],ur=3+(er&3),er>>>=2,ir-=2}else if(Er===17){for(Tr=Sr+3;ir<Tr;){if(Je===0)break e;Je--,er+=We[Ze++]<<ir,ir+=8}er>>>=Sr,ir-=Sr,Br=0,ur=3+(er&7),er>>>=3,ir-=3}else{for(Tr=Sr+7;ir<Tr;){if(Je===0)break e;Je--,er+=We[Ze++]<<ir,ir+=8}er>>>=Sr,ir-=Sr,Br=0,ur=11+(er&127),er>>>=7,ir-=7}if(Fe.have+ur>Fe.nlen+Fe.ndist){Ke.msg="invalid bit length repeat",Fe.mode=BAD;break}for(;ur--;)Fe.lens[Fe.have++]=Br}}if(Fe.mode===BAD)break;if(Fe.lens[256]===0){Ke.msg="invalid code -- missing end-of-block",Fe.mode=BAD;break}if(Fe.lenbits=9,Cr={bits:Fe.lenbits},Or=inftrees(LENS,Fe.lens,0,Fe.nlen,Fe.lencode,0,Fe.work,Cr),Fe.lenbits=Cr.bits,Or){Ke.msg="invalid literal/lengths set",Fe.mode=BAD;break}if(Fe.distbits=6,Fe.distcode=Fe.distdyn,Cr={bits:Fe.distbits},Or=inftrees(DISTS,Fe.lens,Fe.nlen,Fe.ndist,Fe.distcode,0,Fe.work,Cr),Fe.distbits=Cr.bits,Or){Ke.msg="invalid distances set",Fe.mode=BAD;break}if(Fe.mode=LEN_,Re===Z_TREES)break e;case LEN_:Fe.mode=LEN;case LEN:if(Je>=6&&tr>=258){Ke.next_out=Xe,Ke.avail_out=tr,Ke.next_in=Ze,Ke.avail_in=Je,Fe.hold=er,Fe.bits=ir,inffast(Ke,fr),Xe=Ke.next_out,qe=Ke.output,tr=Ke.avail_out,Ze=Ke.next_in,We=Ke.input,Je=Ke.avail_in,er=Fe.hold,ir=Fe.bits,Fe.mode===TYPE&&(Fe.back=-1);break}for(Fe.back=0;wr=Fe.lencode[er&(1<<Fe.lenbits)-1],Sr=wr>>>24,kr=wr>>>16&255,Er=wr&65535,!(Sr<=ir);){if(Je===0)break e;Je--,er+=We[Ze++]<<ir,ir+=8}if(kr&&(kr&240)===0){for(Ir=Sr,Rr=kr,Pr=Er;wr=Fe.lencode[Pr+((er&(1<<Ir+Rr)-1)>>Ir)],Sr=wr>>>24,kr=wr>>>16&255,Er=wr&65535,!(Ir+Sr<=ir);){if(Je===0)break e;Je--,er+=We[Ze++]<<ir,ir+=8}er>>>=Ir,ir-=Ir,Fe.back+=Ir}if(er>>>=Sr,ir-=Sr,Fe.back+=Sr,Fe.length=Er,kr===0){Fe.mode=LIT;break}if(kr&32){Fe.back=-1,Fe.mode=TYPE;break}if(kr&64){Ke.msg="invalid literal/length code",Fe.mode=BAD;break}Fe.extra=kr&15,Fe.mode=LENEXT;case LENEXT:if(Fe.extra){for(Tr=Fe.extra;ir<Tr;){if(Je===0)break e;Je--,er+=We[Ze++]<<ir,ir+=8}Fe.length+=er&(1<<Fe.extra)-1,er>>>=Fe.extra,ir-=Fe.extra,Fe.back+=Fe.extra}Fe.was=Fe.length,Fe.mode=DIST;case DIST:for(;wr=Fe.distcode[er&(1<<Fe.distbits)-1],Sr=wr>>>24,kr=wr>>>16&255,Er=wr&65535,!(Sr<=ir);){if(Je===0)break e;Je--,er+=We[Ze++]<<ir,ir+=8}if((kr&240)===0){for(Ir=Sr,Rr=kr,Pr=Er;wr=Fe.distcode[Pr+((er&(1<<Ir+Rr)-1)>>Ir)],Sr=wr>>>24,kr=wr>>>16&255,Er=wr&65535,!(Ir+Sr<=ir);){if(Je===0)break e;Je--,er+=We[Ze++]<<ir,ir+=8}er>>>=Ir,ir-=Ir,Fe.back+=Ir}if(er>>>=Sr,ir-=Sr,Fe.back+=Sr,kr&64){Ke.msg="invalid distance code",Fe.mode=BAD;break}Fe.offset=Er,Fe.extra=kr&15,Fe.mode=DISTEXT;case DISTEXT:if(Fe.extra){for(Tr=Fe.extra;ir<Tr;){if(Je===0)break e;Je--,er+=We[Ze++]<<ir,ir+=8}Fe.offset+=er&(1<<Fe.extra)-1,er>>>=Fe.extra,ir-=Fe.extra,Fe.back+=Fe.extra}if(Fe.offset>Fe.dmax){Ke.msg="invalid distance too far back",Fe.mode=BAD;break}Fe.mode=MATCH;case MATCH:if(tr===0)break e;if(ur=fr-tr,Fe.offset>ur){if(ur=Fe.offset-ur,ur>Fe.whave&&Fe.sane){Ke.msg="invalid distance too far back",Fe.mode=BAD;break}ur>Fe.wnext?(ur-=Fe.wnext,mr=Fe.wsize-ur):mr=Fe.wnext-ur,ur>Fe.length&&(ur=Fe.length),br=Fe.window}else br=qe,mr=Xe-Fe.offset,ur=Fe.length;ur>tr&&(ur=tr),tr-=ur,Fe.length-=ur;do qe[Xe++]=br[mr++];while(--ur);Fe.length===0&&(Fe.mode=LEN);break;case LIT:if(tr===0)break e;qe[Xe++]=Fe.length,tr--,Fe.mode=LEN;break;case CHECK:if(Fe.wrap){for(;ir<32;){if(Je===0)break e;Je--,er|=We[Ze++]<<ir,ir+=8}if(fr-=tr,Ke.total_out+=fr,Fe.total+=fr,fr&&(Ke.adler=Fe.check=Fe.flags?crc32_1(Fe.check,qe,fr,Xe-fr):adler32_1(Fe.check,qe,fr,Xe-fr)),fr=tr,(Fe.flags?er:zswap32(er))!==Fe.check){Ke.msg="incorrect data check",Fe.mode=BAD;break}er=0,ir=0}Fe.mode=LENGTH;case LENGTH:if(Fe.wrap&&Fe.flags){for(;ir<32;){if(Je===0)break e;Je--,er+=We[Ze++]<<ir,ir+=8}if(er!==(Fe.total&4294967295)){Ke.msg="incorrect length check",Fe.mode=BAD;break}er=0,ir=0}Fe.mode=DONE;case DONE:Or=Z_STREAM_END$1;break e;case BAD:Or=Z_DATA_ERROR$1;break e;case MEM:return Z_MEM_ERROR$1;case SYNC:default:return Z_STREAM_ERROR$1}return Ke.next_out=Xe,Ke.avail_out=tr,Ke.next_in=Ze,Ke.avail_in=Je,Fe.hold=er,Fe.bits=ir,(Fe.wsize||fr!==Ke.avail_out&&Fe.mode<BAD&&(Fe.mode<CHECK||Re!==Z_FINISH$1))&&updatewindow(Ke,Ke.output,Ke.next_out,fr-Ke.avail_out),lr-=Ke.avail_in,fr-=Ke.avail_out,Ke.total_in+=lr,Ke.total_out+=fr,Fe.total+=fr,Fe.wrap&&fr&&(Ke.adler=Fe.check=Fe.flags?crc32_1(Fe.check,qe,fr,Ke.next_out-fr):adler32_1(Fe.check,qe,fr,Ke.next_out-fr)),Ke.data_type=Fe.bits+(Fe.last?64:0)+(Fe.mode===TYPE?128:0)+(Fe.mode===LEN_||Fe.mode===COPY_?256:0),(lr===0&&fr===0||Re===Z_FINISH$1)&&Or===Z_OK$1&&(Or=Z_BUF_ERROR),Or},inflateEnd=Ke=>{if(!Ke||!Ke.state)return Z_STREAM_ERROR$1;let Re=Ke.state;return Re.window&&(Re.window=null),Ke.state=null,Z_OK$1},inflateGetHeader=(Ke,Re)=>{if(!Ke||!Ke.state)return Z_STREAM_ERROR$1;const Fe=Ke.state;return(Fe.wrap&2)===0?Z_STREAM_ERROR$1:(Fe.head=Re,Re.done=!1,Z_OK$1)},inflateSetDictionary=(Ke,Re)=>{const Fe=Re.length;let We,qe,Ze;return!Ke||!Ke.state||(We=Ke.state,We.wrap!==0&&We.mode!==DICT)?Z_STREAM_ERROR$1:We.mode===DICT&&(qe=1,qe=adler32_1(qe,Re,Fe,0),qe!==We.check)?Z_DATA_ERROR$1:(Ze=updatewindow(Ke,Re,Fe,Fe),Ze?(We.mode=MEM,Z_MEM_ERROR$1):(We.havedict=1,Z_OK$1))};var inflateReset_1=inflateReset,inflateReset2_1=inflateReset2,inflateResetKeep_1=inflateResetKeep,inflateInit_1=inflateInit,inflateInit2_1=inflateInit2,inflate_2$1=inflate$2,inflateEnd_1=inflateEnd,inflateGetHeader_1=inflateGetHeader,inflateSetDictionary_1=inflateSetDictionary,inflateInfo="pako inflate (from Nodeca project)",inflate_1$2={inflateReset:inflateReset_1,inflateReset2:inflateReset2_1,inflateResetKeep:inflateResetKeep_1,inflateInit:inflateInit_1,inflateInit2:inflateInit2_1,inflate:inflate_2$1,inflateEnd:inflateEnd_1,inflateGetHeader:inflateGetHeader_1,inflateSetDictionary:inflateSetDictionary_1,inflateInfo};function GZheader(){this.text=0,this.time=0,this.xflags=0,this.os=0,this.extra=null,this.extra_len=0,this.name="",this.comment="",this.hcrc=0,this.done=!1}var gzheader=GZheader;const toString=Object.prototype.toString,{Z_NO_FLUSH,Z_FINISH,Z_OK,Z_STREAM_END,Z_NEED_DICT,Z_STREAM_ERROR,Z_DATA_ERROR,Z_MEM_ERROR}=constants$2;function Inflate$1(Ke){this.options=common.assign({chunkSize:1024*64,windowBits:15,to:""},Ke||{});const Re=this.options;Re.raw&&Re.windowBits>=0&&Re.windowBits<16&&(Re.windowBits=-Re.windowBits,Re.windowBits===0&&(Re.windowBits=-15)),Re.windowBits>=0&&Re.windowBits<16&&!(Ke&&Ke.windowBits)&&(Re.windowBits+=32),Re.windowBits>15&&Re.windowBits<48&&(Re.windowBits&15)===0&&(Re.windowBits|=15),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new zstream,this.strm.avail_out=0;let Fe=inflate_1$2.inflateInit2(this.strm,Re.windowBits);if(Fe!==Z_OK)throw new Error(messages[Fe]);if(this.header=new gzheader,inflate_1$2.inflateGetHeader(this.strm,this.header),Re.dictionary&&(typeof Re.dictionary=="string"?Re.dictionary=strings.string2buf(Re.dictionary):toString.call(Re.dictionary)==="[object ArrayBuffer]"&&(Re.dictionary=new Uint8Array(Re.dictionary)),Re.raw&&(Fe=inflate_1$2.inflateSetDictionary(this.strm,Re.dictionary),Fe!==Z_OK)))throw new Error(messages[Fe])}Inflate$1.prototype.push=function(Ke,Re){const Fe=this.strm,We=this.options.chunkSize,qe=this.options.dictionary;let Ze,Xe,Je;if(this.ended)return!1;for(Re===~~Re?Xe=Re:Xe=Re===!0?Z_FINISH:Z_NO_FLUSH,toString.call(Ke)==="[object ArrayBuffer]"?Fe.input=new Uint8Array(Ke):Fe.input=Ke,Fe.next_in=0,Fe.avail_in=Fe.input.length;;){for(Fe.avail_out===0&&(Fe.output=new Uint8Array(We),Fe.next_out=0,Fe.avail_out=We),Ze=inflate_1$2.inflate(Fe,Xe),Ze===Z_NEED_DICT&&qe&&(Ze=inflate_1$2.inflateSetDictionary(Fe,qe),Ze===Z_OK?Ze=inflate_1$2.inflate(Fe,Xe):Ze===Z_DATA_ERROR&&(Ze=Z_NEED_DICT));Fe.avail_in>0&&Ze===Z_STREAM_END&&Fe.state.wrap>0&&Ke[Fe.next_in]!==0;)inflate_1$2.inflateReset(Fe),Ze=inflate_1$2.inflate(Fe,Xe);switch(Ze){case Z_STREAM_ERROR:case Z_DATA_ERROR:case Z_NEED_DICT:case Z_MEM_ERROR:return this.onEnd(Ze),this.ended=!0,!1}if(Je=Fe.avail_out,Fe.next_out&&(Fe.avail_out===0||Ze===Z_STREAM_END))if(this.options.to==="string"){let tr=strings.utf8border(Fe.output,Fe.next_out),er=Fe.next_out-tr,ir=strings.buf2string(Fe.output,tr);Fe.next_out=er,Fe.avail_out=We-er,er&&Fe.output.set(Fe.output.subarray(tr,tr+er),0),this.onData(ir)}else this.onData(Fe.output.length===Fe.next_out?Fe.output:Fe.output.subarray(0,Fe.next_out));if(!(Ze===Z_OK&&Je===0)){if(Ze===Z_STREAM_END)return Ze=inflate_1$2.inflateEnd(this.strm),this.onEnd(Ze),this.ended=!0,!0;if(Fe.avail_in===0)break}}return!0};Inflate$1.prototype.onData=function(Ke){this.chunks.push(Ke)};Inflate$1.prototype.onEnd=function(Ke){Ke===Z_OK&&(this.options.to==="string"?this.result=this.chunks.join(""):this.result=common.flattenChunks(this.chunks)),this.chunks=[],this.err=Ke,this.msg=this.strm.msg};function inflate$1(Ke,Re){const Fe=new Inflate$1(Re);if(Fe.push(Ke),Fe.err)throw Fe.msg||messages[Fe.err];return Fe.result}function inflateRaw$1(Ke,Re){return Re=Re||{},Re.raw=!0,inflate$1(Ke,Re)}var Inflate_1$1=Inflate$1,inflate_2=inflate$1,inflateRaw_1$1=inflateRaw$1,ungzip$1=inflate$1,constants=constants$2,inflate_1$1={Inflate:Inflate_1$1,inflate:inflate_2,inflateRaw:inflateRaw_1$1,ungzip:ungzip$1,constants};const{Inflate,inflate,inflateRaw,ungzip}=inflate_1$1;var inflate_1=inflate,w=Object.freeze({__proto__:null,encode:function(Ke){return Ke.reduce((Re,Fe)=>Re+Fe.toString(16).padStart(2,"0"),"0x")},decode:function(Ke){Ke.indexOf("0x")===0&&(Ke=Ke.substr(2)),Ke.length%2==1&&(Ke="0"+Ke);let Re=Ke.match(/.{2}/g);return Re===null?buffer.Buffer.from([]):buffer.Buffer.from(Re.map(Fe=>parseInt(Fe,16)))}});function v(Ke){return new TextDecoder("utf-8").decode(Ke)}function b(Ke){return new TextEncoder().encode(Ke)}var A=Object.freeze({__proto__:null,decode:v,encode:b});function _(Ke){return bs58.encode(Ke)}var S=Object.freeze({__proto__:null,encode:_,decode:function(Ke){return bs58.decode(Ke)}});function E(Ke){return buffer.Buffer.from(toByteArray_1(Ke))}var I=Object.freeze({__proto__:null,encode:function(Ke){return fromByteArray_1(Ke)},decode:E}),k=Object.freeze({__proto__:null,hex:w,utf8:A,bs58:S,base64:I});function M(Ke){const Re=new Map;return Ke.errors&&Ke.errors.forEach(Fe=>{var We;let qe=(We=Fe.msg)!==null&&We!==void 0?We:Fe.name;Re.set(Fe.code,qe)}),Re}function x(Ke,...Re){if(Ke.args.length!=Re.length)throw new Error("Invalid argument length");const Fe={};let We=0;return Ke.args.forEach(qe=>{Fe[qe.name]=Re[We],We+=1}),Fe}function P(Ke,Re={}){Ke.forEach(Fe=>{if("accounts"in Fe)P(Fe.accounts,Re[Fe.name]);else if(Re[Fe.name]===void 0)throw new Error(`Invalid arguments: ${Fe.name} not provided.`)})}function L(Ke){return Ke instanceof PublicKey?Ke:new PublicKey(Ke)}class T extends TypeError{constructor(Re,Fe){let We;const{message:qe,...Ze}=Re,{path:Xe}=Re;super(Xe.length===0?qe:"At path: "+Xe.join(".")+" -- "+qe),this.value=void 0,this.key=void 0,this.type=void 0,this.refinement=void 0,this.path=void 0,this.branch=void 0,this.failures=void 0,Object.assign(this,Ze),this.name=this.constructor.name,this.failures=()=>{var Je;return(Je=We)!=null?Je:We=[Re,...Fe()]}}}function C(Ke){return typeof Ke=="object"&&Ke!=null}function z(Ke){return typeof Ke=="string"?JSON.stringify(Ke):""+Ke}function B(Ke,Re,Fe,We){if(Ke===!0)return;Ke===!1?Ke={}:typeof Ke=="string"&&(Ke={message:Ke});const{path:qe,branch:Ze}=Re,{type:Xe}=Fe,{refinement:Je,message:tr="Expected a value of type `"+Xe+"`"+(Je?" with refinement `"+Je+"`":"")+", but received: `"+z(We)+"`"}=Ke;return{value:We,type:Xe,refinement:Je,key:qe[qe.length-1],path:qe,branch:Ze,...Ke,message:tr}}function*O(Ke,Re,Fe,We){var qe;C(qe=Ke)&&typeof qe[Symbol.iterator]=="function"||(Ke=[Ke]);for(const Ze of Ke){const Xe=B(Ze,Re,Fe,We);Xe&&(yield Xe)}}function*D(Ke,Re,Fe){Fe===void 0&&(Fe={});const{path:We=[],branch:qe=[Ke],coerce:Ze=!1,mask:Xe=!1}=Fe,Je={path:We,branch:qe};if(Ze&&(Ke=Re.coercer(Ke,Je),Xe&&Re.type!=="type"&&C(Re.schema)&&C(Ke)&&!Array.isArray(Ke)))for(const er in Ke)Re.schema[er]===void 0&&delete Ke[er];let tr=!0;for(const er of Re.validator(Ke,Je))tr=!1,yield[er,void 0];for(let[er,ir,lr]of Re.entries(Ke,Je)){const fr=D(ir,lr,{path:er===void 0?We:[...We,er],branch:er===void 0?qe:[...qe,ir],coerce:Ze,mask:Xe});for(const ur of fr)ur[0]?(tr=!1,yield[ur[0],void 0]):Ze&&(ir=ur[1],er===void 0?Ke=ir:Ke instanceof Map?Ke.set(er,ir):Ke instanceof Set?Ke.add(ir):C(Ke)&&(Ke[er]=ir))}if(tr)for(const er of Re.refiner(Ke,Je))tr=!1,yield[er,void 0];tr&&(yield[void 0,Ke])}class N{constructor(Re){this.TYPE=void 0,this.type=void 0,this.schema=void 0,this.coercer=void 0,this.validator=void 0,this.refiner=void 0,this.entries=void 0;const{type:Fe,schema:We,validator:qe,refiner:Ze,coercer:Xe=tr=>tr,entries:Je=function*(){}}=Re;this.type=Fe,this.schema=We,this.entries=Je,this.coercer=Xe,this.validator=qe?(tr,er)=>O(qe(tr,er),er,this,tr):()=>[],this.refiner=Ze?(tr,er)=>O(Ze(tr,er),er,this,tr):()=>[]}assert(Re){return function(Fe,We){const qe=U(Fe,We);if(qe[0])throw qe[0]}(Re,this)}create(Re){return R(Re,this)}is(Re){return V(Re,this)}mask(Re){return function(Fe,We){const qe=U(Fe,We,{coerce:!0,mask:!0});if(qe[0])throw qe[0];return qe[1]}(Re,this)}validate(Re,Fe){return Fe===void 0&&(Fe={}),U(Re,this,Fe)}}function R(Ke,Re){const Fe=U(Ke,Re,{coerce:!0});if(Fe[0])throw Fe[0];return Fe[1]}function V(Ke,Re){return!U(Ke,Re)[0]}function U(Ke,Re,Fe){Fe===void 0&&(Fe={});const We=D(Ke,Re,Fe),qe=function(Ze){const{done:Xe,value:Je}=Ze.next();return Xe?void 0:Je}(We);return qe[0]?[new T(qe[0],function*(){for(const Ze of We)Ze[0]&&(yield Ze[0])}),void 0]:[void 0,qe[1]]}function j(Ke,Re){return new N({type:Ke,schema:null,validator:Re})}function $(Ke){return new N({type:"array",schema:Ke,*entries(Re){if(Ke&&Array.isArray(Re))for(const[Fe,We]of Re.entries())yield[Fe,We,Ke]},coercer:Re=>Array.isArray(Re)?Re.slice():Re,validator:Re=>Array.isArray(Re)||"Expected an array value, but received: "+z(Re)})}function K(Ke){const Re=z(Ke),Fe=typeof Ke;return new N({type:"literal",schema:Fe==="string"||Fe==="number"||Fe==="boolean"?Ke:null,validator:We=>We===Ke||"Expected the literal `"+Re+"`, but received: "+z(We)})}function q(Ke){return new N({...Ke,validator:(Re,Fe)=>Re===null||Ke.validator(Re,Fe),refiner:(Re,Fe)=>Re===null||Ke.refiner(Re,Fe)})}function F(){return j("number",Ke=>typeof Ke=="number"&&!isNaN(Ke)||"Expected a number, but received: "+z(Ke))}function W(Ke){return new N({...Ke,validator:(Re,Fe)=>Re===void 0||Ke.validator(Re,Fe),refiner:(Re,Fe)=>Re===void 0||Ke.refiner(Re,Fe)})}function G(){return j("string",Ke=>typeof Ke=="string"||"Expected a string, but received: "+z(Ke))}function H(Ke){const Re=Object.keys(Ke);return new N({type:"type",schema:Ke,*entries(Fe){if(C(Fe))for(const We of Re)yield[We,Fe[We],Ke[We]]},validator:Fe=>C(Fe)||"Expected an object, but received: "+z(Fe)})}function J(Ke){const Re=Ke.map(Fe=>Fe.type).join(" | ");return new N({type:"union",schema:null,coercer:(Fe,We)=>(Ke.find(qe=>{const[Ze]=qe.validate(Fe,{coerce:!0});return!Ze})||Z()).coercer(Fe,We),validator(Fe,We){const qe=[];for(const Ze of Ke){const[...Xe]=D(Fe,Ze,We),[Je]=Xe;if(!Je[0])return[];for(const[tr]of Xe)tr&&qe.push(tr)}return["Expected the value to satisfy a union of `"+Re+"`, but received: "+z(Fe),...qe]}})}function Z(){return j("unknown",()=>!0)}async function X(Ke,Re,Fe){if(Re.length<=99)return await Q(Ke,Re,Fe);{const We=function(qe,Ze){return Array.apply(0,new Array(Math.ceil(qe.length/Ze))).map((Xe,Je)=>qe.slice(Je*Ze,(Je+1)*Ze))}(Re,99);return(await Promise.all(We.map(qe=>Q(Ke,qe,Fe)))).flat()}}async function Q(Ke,Re,Fe){const We=Fe!=null?Fe:Ke.commitment;return(await Ke.getMultipleAccountsInfo(Re,We)).map((qe,Ze)=>qe===null?null:{publicKey:Re[Ze],account:qe})}async function Y(Ke,Re,Fe,We,qe){Fe&&Fe.length>0&&Re.sign(...Fe);const Ze=Re._compile(),Xe=Ze.serialize(),Je=Re._serialize(Xe).toString("base64"),tr={encoding:"base64",commitment:We!=null?We:Ke.commitment};if(qe){const lr=(Array.isArray(qe)?qe:Ze.nonProgramIds()).map(fr=>fr.toBase58());tr.accounts={encoding:"base64",addresses:lr}}Fe&&(tr.sigVerify=!0);const er=[Je,tr],ir=R(await Ke._rpcRequest("simulateTransaction",er),rt);if("error"in ir){let lr;if("data"in ir.error&&(lr=ir.error.data.logs,lr&&Array.isArray(lr))){const fr=`
    `,ur=fr+lr.join(fr);console.error(ir.error.message,ur)}throw new SendTransactionError("failed to simulate transaction: "+ir.error.message,lr)}return ir.result}function tt(Ke){return function(Re,Fe,We){return new N({...Re,coercer:(qe,Ze)=>V(qe,Fe)?Re.coercer(We(qe,Ze),Ze):Re.coercer(qe,Ze)})}(nt(Ke),et,Re=>"error"in Re?Re:{...Re,result:R(Re.result,Ke)})}const et=nt(Z());function nt(Ke){return J([H({jsonrpc:K("2.0"),id:G(),result:Ke}),H({jsonrpc:K("2.0"),id:G(),error:H({code:Z(),message:G(),data:W(j("any",()=>!0))})})])}const rt=(ot=H({err:q(J([H({}),G()])),logs:q($(G())),accounts:W(q($(q(H({executable:j("boolean",Ke=>typeof Ke=="boolean"),owner:G(),lamports:F(),data:$(G()),rentEpoch:W(F())}))))),unitsConsumed:W(F())}),tt(H({context:H({slot:F()}),value:ot})));var ot,it=Object.freeze({__proto__:null,invoke:async function(Ke,Re,Fe,We){Ke=L(Ke),We||(We=lt());const qe=new Transaction;if(qe.add(new TransactionInstruction({programId:Ke,keys:Re!=null?Re:[],data:Fe})),We.sendAndConfirm===void 0)throw new Error("This function requires 'Provider.sendAndConfirm' to be implemented.");return await We.sendAndConfirm(qe,[])},getMultipleAccounts:X,simulateTransaction:Y});class st{constructor(Re,Fe,We){this.connection=Re,this.wallet=Fe,this.opts=We,this.publicKey=Fe.publicKey}static defaultOptions(){return{preflightCommitment:"processed",commitment:"processed"}}static local(Re,Fe){throw new Error("Provider local is not available on browser.")}static env(){throw new Error("Provider env is not available on browser.")}async sendAndConfirm(Re,Fe,We){var qe;We===void 0&&(We=this.opts),Re.feePayer=this.wallet.publicKey,Re.recentBlockhash=(await this.connection.getRecentBlockhash(We.preflightCommitment)).blockhash,Re=await this.wallet.signTransaction(Re),(Fe!=null?Fe:[]).forEach(Xe=>{Re.partialSign(Xe)});const Ze=Re.serialize();try{return await ct(this.connection,Ze,We)}catch(Xe){if(Xe instanceof ut){const Je=await this.connection.getTransaction(_(Re.signature),{commitment:"confirmed"});if(Je){const tr=(qe=Je.meta)===null||qe===void 0?void 0:qe.logMessages;throw tr?new SendTransactionError(Xe.message,tr):Xe}throw Xe}throw Xe}}async sendAll(Re,Fe){Fe===void 0&&(Fe=this.opts);const We=await this.connection.getRecentBlockhash(Fe.preflightCommitment);let qe=Re.map(Je=>{var tr;let er=Je.tx,ir=(tr=Je.signers)!==null&&tr!==void 0?tr:[];return er.feePayer=this.wallet.publicKey,er.recentBlockhash=We.blockhash,ir.forEach(lr=>{er.partialSign(lr)}),er});const Ze=await this.wallet.signAllTransactions(qe),Xe=[];for(let Je=0;Je<qe.length;Je+=1){const tr=Ze[Je].serialize();Xe.push(await ct(this.connection,tr,Fe))}return Xe}async simulate(Re,Fe,We,qe){Re.feePayer=this.wallet.publicKey,Re.recentBlockhash=(await this.connection.getLatestBlockhash(We!=null?We:this.connection.commitment)).blockhash,Re=await this.wallet.signTransaction(Re);const Ze=await Y(this.connection,Re,Fe,We,qe);if(Ze.value.err)throw new at(Ze.value);return Ze.value}}class at extends Error{constructor(Re,Fe){super(Fe),this.simulationResponse=Re}}async function ct(Ke,Re,Fe){const We=Fe&&{skipPreflight:Fe.skipPreflight,preflightCommitment:Fe.preflightCommitment||Fe.commitment},qe=await Ke.sendRawTransaction(Re,We),Ze=(await Ke.confirmTransaction(qe,Fe&&Fe.commitment)).value;if(Ze.err)throw new ut(`Raw transaction ${qe} failed (${JSON.stringify(Ze)})`);return qe}class ut extends Error{constructor(Re){super(Re)}}function lt(){return ht===null?st.local():ht}let ht=null;const pt=new Set(["anchor-deprecated-state","debug-logs"]),ft=new Map;function mt(Ke){return ft.get(Ke)!==void 0}var yt=Object.freeze({__proto__:null,set:function(Ke){if(!pt.has(Ke))throw new Error("Invalid feature");ft.set(Ke,!0)},isSet:mt});class gt extends Error{constructor(Re){super(Re),this.name="IdlError"}}class wt{constructor(Re){this.stack=Re}static parse(Re){var Fe;const We=/^Program (\w*) invoke/,qe=/^Program \w* success/,Ze=[];for(let Xe=0;Xe<Re.length;Xe++){if(qe.exec(Re[Xe])){Ze.pop();continue}const Je=(Fe=We.exec(Re[Xe]))===null||Fe===void 0?void 0:Fe[1];Je&&Ze.push(new PublicKey(Je))}return new wt(Ze)}}class vt extends Error{constructor(Re,Fe,We,qe,Ze,Xe){super(We.join(`
`).replace("Program log: ","")),this.errorLogs=We,this.logs=qe,this.error={errorCode:Re,errorMessage:Fe,comparedValues:Xe,origin:Ze},this._programErrorStack=wt.parse(qe)}static parse(Re){if(!Re)return null;const Fe=Re.findIndex(er=>er.startsWith("Program log: AnchorError"));if(Fe===-1)return null;const We=Re[Fe],qe=[We];let Ze;if(Fe+1<Re.length){if(Re[Fe+1]==="Program log: Left:"){const er=/^Program log: (.*)$/,ir=er.exec(Re[Fe+2])[1],lr=er.exec(Re[Fe+4])[1];Ze=[new PublicKey(ir),new PublicKey(lr)],qe.push(...Re.slice(Fe+1,Fe+5))}else if(Re[Fe+1].startsWith("Program log: Left:")){const er=/^Program log: (Left|Right): (.*)$/,ir=er.exec(Re[Fe+1])[2],lr=er.exec(Re[Fe+2])[2];qe.push(...Re.slice(Fe+1,Fe+3)),Ze=[ir,lr]}}const Xe=/^Program log: AnchorError occurred\. Error Code: (.*)\. Error Number: (\d*)\. Error Message: (.*)\./.exec(We),Je=/^Program log: AnchorError thrown in (.*):(\d*)\. Error Code: (.*)\. Error Number: (\d*)\. Error Message: (.*)\./.exec(We),tr=/^Program log: AnchorError caused by account: (.*)\. Error Code: (.*)\. Error Number: (\d*)\. Error Message: (.*)\./.exec(We);if(Xe){const[er,ir,lr]=Xe.slice(1,4),fr={code:er,number:parseInt(ir)};return new vt(fr,lr,qe,Re,void 0,Ze)}if(Je){const[er,ir,lr,fr,ur]=Je.slice(1,6),mr={code:lr,number:parseInt(fr)},br={file:er,line:parseInt(ir)};return new vt(mr,ur,qe,Re,br,Ze)}if(tr){const[er,ir,lr,fr]=tr.slice(1,5),ur=er,mr={code:ir,number:parseInt(lr)};return new vt(mr,fr,qe,Re,ur,Ze)}return null}get program(){return this._programErrorStack.stack[this._programErrorStack.stack.length-1]}get programErrorStack(){return this._programErrorStack.stack}toString(){return this.message}}class bt extends Error{constructor(Re,Fe,We){super(),this.code=Re,this.msg=Fe,this.logs=We,We&&(this._programErrorStack=wt.parse(We))}static parse(Re,Fe){const We=Re.toString();let qe,Ze;if(We.includes("custom program error:")){let Je=We.split("custom program error: ");if(Je.length!==2)return null;qe=Je[1]}else{const Je=We.match(/"Custom":([0-9]+)}/g);if(!Je||Je.length>1)return null;qe=Je[0].match(/([0-9]+)/g)[0]}try{Ze=parseInt(qe)}catch{return null}let Xe=Fe.get(Ze);return Xe!==void 0?new bt(Ze,Xe,Re.logs):(Xe=St.get(Ze),Xe!==void 0?new bt(Ze,Xe,Re.logs):null)}get program(){var Re;return(Re=this._programErrorStack)===null||Re===void 0?void 0:Re.stack[this._programErrorStack.stack.length-1]}get programErrorStack(){var Re;return(Re=this._programErrorStack)===null||Re===void 0?void 0:Re.stack}toString(){return this.msg}}function At(Ke,Re){mt("debug-logs")&&console.log("Translating error:",Ke);const Fe=vt.parse(Ke.logs);if(Fe)return Fe;const We=bt.parse(Ke,Re);if(We)return We;if(Ke.logs){const qe={get:function(Ze,Xe){return Xe==="programErrorStack"?Ze.programErrorStack.stack:Xe==="program"?Ze.programErrorStack.stack[Ke.programErrorStack.stack.length-1]:Reflect.get(...arguments)}};return Ke.programErrorStack=wt.parse(Ke.logs),new Proxy(Ke,qe)}return Ke}const _t={InstructionMissing:100,InstructionFallbackNotFound:101,InstructionDidNotDeserialize:102,InstructionDidNotSerialize:103,IdlInstructionStub:1e3,IdlInstructionInvalidProgram:1001,ConstraintMut:2e3,ConstraintHasOne:2001,ConstraintSigner:2002,ConstraintRaw:2003,ConstraintOwner:2004,ConstraintRentExempt:2005,ConstraintSeeds:2006,ConstraintExecutable:2007,ConstraintState:2008,ConstraintAssociated:2009,ConstraintAssociatedInit:2010,ConstraintClose:2011,ConstraintAddress:2012,ConstraintZero:2013,ConstraintTokenMint:2014,ConstraintTokenOwner:2015,ConstraintMintMintAuthority:2016,ConstraintMintFreezeAuthority:2017,ConstraintMintDecimals:2018,ConstraintSpace:2019,RequireViolated:2500,RequireEqViolated:2501,RequireKeysEqViolated:2502,RequireNeqViolated:2503,RequireKeysNeqViolated:2504,RequireGtViolated:2505,RequireGteViolated:2506,AccountDiscriminatorAlreadySet:3e3,AccountDiscriminatorNotFound:3001,AccountDiscriminatorMismatch:3002,AccountDidNotDeserialize:3003,AccountDidNotSerialize:3004,AccountNotEnoughKeys:3005,AccountNotMutable:3006,AccountOwnedByWrongProgram:3007,InvalidProgramId:3008,InvalidProgramExecutable:3009,AccountNotSigner:3010,AccountNotSystemOwned:3011,AccountNotInitialized:3012,AccountNotProgramData:3013,AccountNotAssociatedTokenAccount:3014,AccountSysvarMismatch:3015,AccountReallocExceedsLimit:3016,AccountDuplicateReallocs:3017,StateInvalidAddress:4e3,DeclaredProgramIdMismatch:4100,Deprecated:5e3},St=new Map([[_t.InstructionMissing,"8 byte instruction identifier not provided"],[_t.InstructionFallbackNotFound,"Fallback functions are not supported"],[_t.InstructionDidNotDeserialize,"The program could not deserialize the given instruction"],[_t.InstructionDidNotSerialize,"The program could not serialize the given instruction"],[_t.IdlInstructionStub,"The program was compiled without idl instructions"],[_t.IdlInstructionInvalidProgram,"The transaction was given an invalid program for the IDL instruction"],[_t.ConstraintMut,"A mut constraint was violated"],[_t.ConstraintHasOne,"A has_one constraint was violated"],[_t.ConstraintSigner,"A signer constraint was violated"],[_t.ConstraintRaw,"A raw constraint was violated"],[_t.ConstraintOwner,"An owner constraint was violated"],[_t.ConstraintRentExempt,"A rent exemption constraint was violated"],[_t.ConstraintSeeds,"A seeds constraint was violated"],[_t.ConstraintExecutable,"An executable constraint was violated"],[_t.ConstraintState,"A state constraint was violated"],[_t.ConstraintAssociated,"An associated constraint was violated"],[_t.ConstraintAssociatedInit,"An associated init constraint was violated"],[_t.ConstraintClose,"A close constraint was violated"],[_t.ConstraintAddress,"An address constraint was violated"],[_t.ConstraintZero,"Expected zero account discriminant"],[_t.ConstraintTokenMint,"A token mint constraint was violated"],[_t.ConstraintTokenOwner,"A token owner constraint was violated"],[_t.ConstraintMintMintAuthority,"A mint mint authority constraint was violated"],[_t.ConstraintMintFreezeAuthority,"A mint freeze authority constraint was violated"],[_t.ConstraintMintDecimals,"A mint decimals constraint was violated"],[_t.ConstraintSpace,"A space constraint was violated"],[_t.RequireViolated,"A require expression was violated"],[_t.RequireEqViolated,"A require_eq expression was violated"],[_t.RequireKeysEqViolated,"A require_keys_eq expression was violated"],[_t.RequireNeqViolated,"A require_neq expression was violated"],[_t.RequireKeysNeqViolated,"A require_keys_neq expression was violated"],[_t.RequireGtViolated,"A require_gt expression was violated"],[_t.RequireGteViolated,"A require_gte expression was violated"],[_t.AccountDiscriminatorAlreadySet,"The account discriminator was already set on this account"],[_t.AccountDiscriminatorNotFound,"No 8 byte discriminator was found on the account"],[_t.AccountDiscriminatorMismatch,"8 byte discriminator did not match what was expected"],[_t.AccountDidNotDeserialize,"Failed to deserialize the account"],[_t.AccountDidNotSerialize,"Failed to serialize the account"],[_t.AccountNotEnoughKeys,"Not enough account keys given to the instruction"],[_t.AccountNotMutable,"The given account is not mutable"],[_t.AccountOwnedByWrongProgram,"The given account is owned by a different program than expected"],[_t.InvalidProgramId,"Program ID was not as expected"],[_t.InvalidProgramExecutable,"Program account is not executable"],[_t.AccountNotSigner,"The given account did not sign"],[_t.AccountNotSystemOwned,"The given account is not owned by the system program"],[_t.AccountNotInitialized,"The program expected this account to be already initialized"],[_t.AccountNotProgramData,"The given account is not a program data account"],[_t.AccountNotAssociatedTokenAccount,"The given account is not the associated token account"],[_t.AccountSysvarMismatch,"The given public key does not match the required sysvar"],[_t.AccountReallocExceedsLimit,"The account reallocation exceeds the MAX_PERMITTED_DATA_INCREASE limit"],[_t.AccountDuplicateReallocs,"The account was duplicated for more than one reallocation"],[_t.StateInvalidAddress,"The given state account does not have the correct address"],[_t.DeclaredProgramIdMismatch,"The declared program id does not match the actual program id"],[_t.Deprecated,"The API being used is deprecated and should no longer be used"]]);/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */var Et=function(){return Et=Object.assign||function(Ke){for(var Re,Fe=1,We=arguments.length;Fe<We;Fe++)for(var qe in Re=arguments[Fe])Object.prototype.hasOwnProperty.call(Re,qe)&&(Ke[qe]=Re[qe]);return Ke},Et.apply(this,arguments)};function It(Ke){return Ke.toLowerCase()}var kt=[/([a-z0-9])([A-Z])/g,/([A-Z])([A-Z][a-z])/g],Mt=/[^A-Z0-9]+/gi;function xt(Ke,Re,Fe){return Re instanceof RegExp?Ke.replace(Re,Fe):Re.reduce(function(We,qe){return We.replace(qe,Fe)},Ke)}function Pt(Ke,Re){return Re===void 0&&(Re={}),function(Fe,We){We===void 0&&(We={});for(var qe=We.splitRegexp,Ze=qe===void 0?kt:qe,Xe=We.stripRegexp,Je=Xe===void 0?Mt:Xe,tr=We.transform,er=tr===void 0?It:tr,ir=We.delimiter,lr=ir===void 0?" ":ir,fr=xt(xt(Fe,Ze,"$1\0$2"),Je,"\0"),ur=0,mr=fr.length;fr.charAt(ur)==="\0";)ur++;for(;fr.charAt(mr-1)==="\0";)mr--;return fr.slice(ur,mr).split("\0").map(er).join(lr)}(Ke,Et({delimiter:"."},Re))}class Lt{static fieldLayout(Re,Fe){const We=Re.name!==void 0?camelcase.exports(Re.name):void 0;switch(Re.type){case"bool":return lib.bool(We);case"u8":return lib.u8(We);case"i8":return lib.i8(We);case"u16":return lib.u16(We);case"i16":return lib.i16(We);case"u32":return lib.u32(We);case"i32":return lib.i32(We);case"f32":return lib.f32(We);case"u64":return lib.u64(We);case"i64":return lib.i64(We);case"f64":return lib.f64(We);case"u128":return lib.u128(We);case"i128":return lib.i128(We);case"bytes":return lib.vecU8(We);case"string":return lib.str(We);case"publicKey":return lib.publicKey(We);default:if("vec"in Re.type)return lib.vec(Lt.fieldLayout({name:void 0,type:Re.type.vec},Fe),We);if("option"in Re.type)return lib.option(Lt.fieldLayout({name:void 0,type:Re.type.option},Fe),We);if("defined"in Re.type){const qe=Re.type.defined;if(Fe===void 0)throw new gt("User defined types not provided");const Ze=Fe.filter(Xe=>Xe.name===qe);if(Ze.length!==1)throw new gt(`Type not found: ${JSON.stringify(Re)}`);return Lt.typeDefLayout(Ze[0],Fe,We)}if("array"in Re.type){let qe=Re.type.array[0],Ze=Re.type.array[1],Xe=Lt.fieldLayout({name:void 0,type:qe},Fe);return lib.array(Xe,Ze,We)}throw new Error(`Not yet implemented: ${Re}`)}}static typeDefLayout(Re,Fe=[],We){if(Re.type.kind==="struct"){const qe=Re.type.fields.map(Ze=>Lt.fieldLayout(Ze,Fe));return lib.struct(qe,We)}if(Re.type.kind==="enum"){let qe=Re.type.variants.map(Ze=>{const Xe=camelcase.exports(Ze.name);if(Ze.fields===void 0)return lib.struct([],Xe);const Je=Ze.fields.map(tr=>{if(!tr.hasOwnProperty("name"))throw new Error("Tuple enum variants not yet implemented.");return Lt.fieldLayout(tr,Fe)});return lib.struct(Je,Xe)});return We!==void 0?lib.rustEnum(qe).replicate(We):lib.rustEnum(qe,We)}throw new Error(`Unknown type kint: ${Re}`)}}class Tt{constructor(Re){this.idl=Re,this.ixLayout=Tt.parseIxLayout(Re);const Fe=new Map;Re.instructions.forEach(We=>{const qe=zt("global",We.name);Fe.set(bs58.encode(qe),{layout:this.ixLayout.get(We.name),name:We.name})}),Re.state&&Re.state.methods.map(We=>{const qe=zt("state",We.name);Fe.set(bs58.encode(qe),{layout:this.ixLayout.get(We.name),name:We.name})}),this.sighashLayouts=Fe}encode(Re,Fe){return this._encode("global",Re,Fe)}encodeState(Re,Fe){return this._encode("state",Re,Fe)}_encode(Re,Fe,We){const qe=buffer.Buffer.alloc(1e3),Ze=camelcase.exports(Fe),Xe=this.ixLayout.get(Ze);if(!Xe)throw new Error(`Unknown method: ${Ze}`);const Je=Xe.encode(We,qe),tr=qe.slice(0,Je);return buffer.Buffer.concat([zt(Re,Fe),tr])}static parseIxLayout(Re){const Fe=(Re.state?Re.state.methods:[]).map(We=>{let qe=We.args.map(Xe=>{var Je,tr;return Lt.fieldLayout(Xe,Array.from([...(Je=Re.accounts)!==null&&Je!==void 0?Je:[],...(tr=Re.types)!==null&&tr!==void 0?tr:[]]))});const Ze=camelcase.exports(We.name);return[Ze,lib.struct(qe,Ze)]}).concat(Re.instructions.map(We=>{let qe=We.args.map(Xe=>{var Je,tr;return Lt.fieldLayout(Xe,Array.from([...(Je=Re.accounts)!==null&&Je!==void 0?Je:[],...(tr=Re.types)!==null&&tr!==void 0?tr:[]]))});const Ze=camelcase.exports(We.name);return[Ze,lib.struct(qe,Ze)]}));return new Map(Fe)}decode(Re,Fe="hex"){typeof Re=="string"&&(Re=Fe==="hex"?buffer.Buffer.from(Re,"hex"):bs58.decode(Re));let We=bs58.encode(Re.slice(0,8)),qe=Re.slice(8);const Ze=this.sighashLayouts.get(We);return Ze?{data:Ze.layout.decode(qe),name:Ze.name}:null}format(Re,Fe){return Ct.format(Re,Fe,this.idl)}}class Ct{static format(Re,Fe,We){const qe=We.instructions.filter(Je=>Re.name===Je.name)[0];if(qe===void 0)return console.error("Invalid instruction given"),null;const Ze=qe.args.map(Je=>({name:Je.name,type:Ct.formatIdlType(Je.type),data:Ct.formatIdlData(Je,Re.data[Je.name],We.types)})),Xe=Ct.flattenIdlAccounts(qe.accounts);return{args:Ze,accounts:Fe.map((Je,tr)=>tr<Xe.length?{name:Xe[tr].name,...Je}:{name:void 0,...Je})}}static formatIdlType(Re){if(typeof Re=="string")return Re;if("vec"in Re)return`Vec<${this.formatIdlType(Re.vec)}>`;if("option"in Re)return`Option<${this.formatIdlType(Re.option)}>`;if("defined"in Re)return Re.defined;if("array"in Re)return`Array<${Re.array[0]}; ${Re.array[1]}>`;throw new Error(`Unknown IDL type: ${Re}`)}static formatIdlData(Re,Fe,We){if(typeof Re.type=="string")return Fe.toString();if(Re.type.hasOwnProperty("vec"))return"["+Fe.map(qe=>this.formatIdlData({name:"",type:Re.type.vec},qe)).join(", ")+"]";if(Re.type.hasOwnProperty("option"))return Fe===null?"null":this.formatIdlData({name:"",type:Re.type.option},Fe,We);if(Re.type.hasOwnProperty("defined")){if(We===void 0)throw new Error("User defined types not provided");const qe=We.filter(Ze=>Ze.name===Re.type.defined);if(qe.length!==1)throw new Error(`Type not found: ${Re.type.defined}`);return Ct.formatIdlDataDefined(qe[0],Fe,We)}return"unknown"}static formatIdlDataDefined(Re,Fe,We){if(Re.type.kind==="struct"){const qe=Re.type;return"{ "+Object.keys(Fe).map(Ze=>{const Xe=qe.fields.filter(Je=>Je.name===Ze)[0];if(Xe===void 0)throw new Error("Unable to find type");return Ze+": "+Ct.formatIdlData(Xe,Fe[Ze],We)}).join(", ")+" }"}if(Re.type.variants.length===0)return"{}";if(Re.type.variants[0].name){const qe=Re.type.variants,Ze=Object.keys(Fe)[0],Xe=Fe[Ze],Je=Object.keys(Xe).map(er=>{var ir;const lr=Xe[er],fr=(ir=qe[Ze])===null||ir===void 0?void 0:ir.filter(ur=>ur.name===er)[0];if(fr===void 0)throw new Error("Unable to find variant");return er+": "+Ct.formatIdlData(fr,lr,We)}).join(", "),tr=camelcase.exports(Ze,{pascalCase:!0});return Je.length===0?tr:`${tr} { ${Je} }`}return"Tuple formatting not yet implemented"}static flattenIdlAccounts(Re,Fe){return Re.map(We=>{const qe=function(Ze){const Xe=Ze.replace(/([A-Z])/g," $1");return Xe.charAt(0).toUpperCase()+Xe.slice(1)}(We.name);if(We.hasOwnProperty("accounts")){const Ze=Fe?`${Fe} > ${qe}`:qe;return Ct.flattenIdlAccounts(We.accounts,Ze)}return{...We,name:Fe?`${Fe} > ${qe}`:qe}}).flat()}}function zt(Ke,Re){var Fe;let We=`${Ke}:${Fe===void 0&&(Fe={}),Pt(Re,Et({delimiter:"_"},Fe))}`;return buffer.Buffer.from(sha256.exports.sha256.digest(We)).slice(0,8)}function Bt(Ke,Re){if(Re.type.kind==="enum"){let Fe=Re.type.variants.map(We=>We.fields===void 0?0:We.fields.map(qe=>{if(typeof qe!="object"||!("name"in qe))throw new Error("Tuple enum variants not yet implemented.");return Ot(Ke,qe.type)}).reduce((qe,Ze)=>qe+Ze));return Math.max(...Fe)+1}return Re.type.fields===void 0?0:Re.type.fields.map(Fe=>Ot(Ke,Fe.type)).reduce((Fe,We)=>Fe+We,0)}function Ot(Ke,Re){var Fe,We;switch(Re){case"bool":case"u8":case"i8":case"bytes":case"string":return 1;case"i16":case"u16":return 2;case"u32":case"i32":case"f32":return 4;case"u64":case"i64":case"f64":return 8;case"u128":case"i128":return 16;case"publicKey":return 32;default:if("vec"in Re)return 1;if("option"in Re)return 1+Ot(Ke,Re.option);if("coption"in Re)return 4+Ot(Ke,Re.coption);if("defined"in Re){const qe=(We=(Fe=Ke.types)===null||Fe===void 0?void 0:Fe.filter(Ze=>Ze.name===Re.defined))!==null&&We!==void 0?We:[];if(qe.length!==1)throw new gt(`Type not found: ${JSON.stringify(Re)}`);return Bt(Ke,qe[0])}if("array"in Re){let qe=Re.array[0],Ze=Re.array[1];return Ot(Ke,qe)*Ze}throw new Error(`Invalid type ${JSON.stringify(Re)}`)}}class Nt{constructor(Re){if(Re.accounts===void 0)return void(this.accountLayouts=new Map);const Fe=Re.accounts.map(We=>[We.name,Lt.typeDefLayout(We,Re.types)]);this.accountLayouts=new Map(Fe),this.idl=Re}async encode(Re,Fe){const We=buffer.Buffer.alloc(1e3),qe=this.accountLayouts.get(Re);if(!qe)throw new Error(`Unknown account: ${Re}`);const Ze=qe.encode(Fe,We);let Xe=We.slice(0,Ze),Je=Nt.accountDiscriminator(Re);return buffer.Buffer.concat([Je,Xe])}decode(Re,Fe){if(Nt.accountDiscriminator(Re).compare(Fe.slice(0,8)))throw new Error("Invalid account discriminator");return this.decodeUnchecked(Re,Fe)}decodeUnchecked(Re,Fe){const We=Fe.slice(8),qe=this.accountLayouts.get(Re);if(!qe)throw new Error(`Unknown account: ${Re}`);return qe.decode(We)}memcmp(Re,Fe){const We=Nt.accountDiscriminator(Re);return{offset:0,bytes:bs58.encode(Fe?buffer.Buffer.concat([We,Fe]):We)}}size(Re){var Fe;return 8+((Fe=Bt(this.idl,Re))!==null&&Fe!==void 0?Fe:0)}static accountDiscriminator(Re){return buffer.Buffer.from(sha256.exports.sha256.digest(`account:${camelcase.exports(Re,{pascalCase:!0})}`)).slice(0,8)}}class Rt{constructor(Re){if(Re.events===void 0)return void(this.layouts=new Map);const Fe=Re.events.map(We=>{let qe={name:We.name,type:{kind:"struct",fields:We.fields.map(Ze=>({name:Ze.name,type:Ze.type}))}};return[We.name,Lt.typeDefLayout(qe,Re.types)]});this.layouts=new Map(Fe),this.discriminators=new Map(Re.events===void 0?[]:Re.events.map(We=>[fromByteArray_1(Vt(We.name)),We.name]))}decode(Re){let Fe;try{Fe=buffer.Buffer.from(toByteArray_1(Re))}catch{return null}const We=fromByteArray_1(Fe.slice(0,8)),qe=this.discriminators.get(We);if(qe===void 0)return null;const Ze=this.layouts.get(qe);if(!Ze)throw new Error(`Unknown event: ${qe}`);return{data:Ze.decode(Fe.slice(8)),name:qe}}}function Vt(Ke){return buffer.Buffer.from(sha256.exports.sha256.digest(`event:${Ke}`)).slice(0,8)}class Ut{constructor(Re){if(Re.state===void 0)throw new Error("Idl state not defined.");this.layout=Lt.typeDefLayout(Re.state.struct,Re.types)}async encode(Re,Fe){const We=buffer.Buffer.alloc(1e3),qe=this.layout.encode(Fe,We),Ze=await jt(Re),Xe=We.slice(0,qe);return buffer.Buffer.concat([Ze,Xe])}decode(Re){const Fe=Re.slice(8);return this.layout.decode(Fe)}}async function jt(Ke){let Re=mt("anchor-deprecated-state")?"account":"state";return buffer.Buffer.from(sha256.exports.sha256.digest(`${Re}:${Ke}`)).slice(0,8)}class $t{constructor(Re){if(Re.types===void 0)return void(this.typeLayouts=new Map);const Fe=Re.types.map(We=>[We.name,Lt.typeDefLayout(We,Re.types)]);this.typeLayouts=new Map(Fe),this.idl=Re}encode(Re,Fe){const We=buffer.Buffer.alloc(1e3),qe=this.typeLayouts.get(Re);if(!qe)throw new Error(`Unknown type: ${Re}`);const Ze=qe.encode(Fe,We);return We.slice(0,Ze)}decode(Re,Fe){const We=this.typeLayouts.get(Re);if(!We)throw new Error(`Unknown type: ${Re}`);return We.decode(Fe)}}class Kt{constructor(Re){this.instruction=new Tt(Re),this.accounts=new Nt(Re),this.events=new Rt(Re),Re.state&&(this.state=new Ut(Re)),this.types=new $t(Re)}}var qt=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{};function Ft(Ke){return Ke&&Ke.__esModule&&Object.prototype.hasOwnProperty.call(Ke,"default")?Ke.default:Ke}class Wt{constructor(Re,Fe){if(!Number.isInteger(Re))throw new TypeError("span must be an integer");this.span=Re,this.property=Fe}makeDestinationObject(){return{}}decode(Re,Fe){throw new Error("Layout is abstract")}encode(Re,Fe,We){throw new Error("Layout is abstract")}getSpan(Re,Fe){if(0>this.span)throw new RangeError("indeterminate span");return this.span}replicate(Re){const Fe=Object.create(this.constructor.prototype);return Object.assign(Fe,this),Fe.property=Re,Fe}fromArray(Re){}}var Gt=Wt;class Ht extends Wt{isCount(){throw new Error("ExternalLayout is abstract")}}class Jt extends Ht{constructor(Re,Fe,We){if(!(Re instanceof Wt))throw new TypeError("layout must be a Layout");if(Fe===void 0)Fe=0;else if(!Number.isInteger(Fe))throw new TypeError("offset must be integer or undefined");super(Re.span,We||Re.property),this.layout=Re,this.offset=Fe}isCount(){return this.layout instanceof Zt||this.layout instanceof Xt}decode(Re,Fe){return Fe===void 0&&(Fe=0),this.layout.decode(Re,Fe+this.offset)}encode(Re,Fe,We){return We===void 0&&(We=0),this.layout.encode(Re,Fe,We+this.offset)}}class Zt extends Wt{constructor(Re,Fe){if(super(Re,Fe),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(Re,Fe){return Fe===void 0&&(Fe=0),Re.readUIntLE(Fe,this.span)}encode(Re,Fe,We){return We===void 0&&(We=0),Fe.writeUIntLE(Re,We,this.span),this.span}}class Xt extends Wt{constructor(Re,Fe){if(super(Re,Fe),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(Re,Fe){return Fe===void 0&&(Fe=0),Re.readUIntBE(Fe,this.span)}encode(Re,Fe,We){return We===void 0&&(We=0),Fe.writeUIntBE(Re,We,this.span),this.span}}const Qt=Math.pow(2,32);function Yt(Ke){const Re=Math.floor(Ke/Qt);return{hi32:Re,lo32:Ke-Re*Qt}}function te(Ke,Re){return Ke*Qt+Re}class ee extends Wt{constructor(Re){super(8,Re)}decode(Re,Fe){Fe===void 0&&(Fe=0);const We=Re.readUInt32LE(Fe);return te(Re.readUInt32LE(Fe+4),We)}encode(Re,Fe,We){We===void 0&&(We=0);const qe=Yt(Re);return Fe.writeUInt32LE(qe.lo32,We),Fe.writeUInt32LE(qe.hi32,We+4),8}}class ne extends Wt{constructor(Re){super(8,Re)}decode(Re,Fe){Fe===void 0&&(Fe=0);const We=Re.readUInt32LE(Fe);return te(Re.readInt32LE(Fe+4),We)}encode(Re,Fe,We){We===void 0&&(We=0);const qe=Yt(Re);return Fe.writeUInt32LE(qe.lo32,We),Fe.writeInt32LE(qe.hi32,We+4),8}}class re extends Wt{constructor(Re,Fe,We){if(!Array.isArray(Re)||!Re.reduce((Ze,Xe)=>Ze&&Xe instanceof Wt,!0))throw new TypeError("fields must be array of Layout instances");typeof Fe=="boolean"&&We===void 0&&(We=Fe,Fe=void 0);for(const Ze of Re)if(0>Ze.span&&Ze.property===void 0)throw new Error("fields cannot contain unnamed variable-length layout");let qe=-1;try{qe=Re.reduce((Ze,Xe)=>Ze+Xe.getSpan(),0)}catch{}super(qe,Fe),this.fields=Re,this.decodePrefixes=!!We}getSpan(Re,Fe){if(0<=this.span)return this.span;Fe===void 0&&(Fe=0);let We=0;try{We=this.fields.reduce((qe,Ze)=>{const Xe=Ze.getSpan(Re,Fe);return Fe+=Xe,qe+Xe},0)}catch{throw new RangeError("indeterminate span")}return We}decode(Re,Fe){Fe===void 0&&(Fe=0);const We=this.makeDestinationObject();for(const qe of this.fields)if(qe.property!==void 0&&(We[qe.property]=qe.decode(Re,Fe)),Fe+=qe.getSpan(Re,Fe),this.decodePrefixes&&Re.length===Fe)break;return We}encode(Re,Fe,We){We===void 0&&(We=0);const qe=We;let Ze=0,Xe=0;for(const Je of this.fields){let tr=Je.span;if(Xe=0<tr?tr:0,Je.property!==void 0){const er=Re[Je.property];er!==void 0&&(Xe=Je.encode(er,Fe,We),0>tr&&(tr=Je.getSpan(Fe,We)))}Ze=We,We+=tr}return Ze+Xe-qe}fromArray(Re){const Fe=this.makeDestinationObject();for(const We of this.fields)We.property!==void 0&&0<Re.length&&(Fe[We.property]=Re.shift());return Fe}layoutFor(Re){if(typeof Re!="string")throw new TypeError("property must be string");for(const Fe of this.fields)if(Fe.property===Re)return Fe}offsetOf(Re){if(typeof Re!="string")throw new TypeError("property must be string");let Fe=0;for(const We of this.fields){if(We.property===Re)return Fe;0>We.span?Fe=-1:0<=Fe&&(Fe+=We.span)}}}class oe{constructor(Re){this.property=Re}decode(){throw new Error("UnionDiscriminator is abstract")}encode(){throw new Error("UnionDiscriminator is abstract")}}class ie extends oe{constructor(Re,Fe){if(!(Re instanceof Ht&&Re.isCount()))throw new TypeError("layout must be an unsigned integer ExternalLayout");super(Fe||Re.property||"variant"),this.layout=Re}decode(Re,Fe){return this.layout.decode(Re,Fe)}encode(Re,Fe,We){return this.layout.encode(Re,Fe,We)}}class se extends Wt{constructor(Re,Fe,We){const qe=Re instanceof Zt||Re instanceof Xt;if(qe)Re=new ie(new Jt(Re));else if(Re instanceof Ht&&Re.isCount())Re=new ie(Re);else if(!(Re instanceof oe))throw new TypeError("discr must be a UnionDiscriminator or an unsigned integer layout");if(Fe===void 0&&(Fe=null),!(Fe===null||Fe instanceof Wt))throw new TypeError("defaultLayout must be null or a Layout");if(Fe!==null){if(0>Fe.span)throw new Error("defaultLayout must have constant span");Fe.property===void 0&&(Fe=Fe.replicate("content"))}let Ze=-1;Fe&&(Ze=Fe.span,0<=Ze&&qe&&(Ze+=Re.layout.span)),super(Ze,We),this.discriminator=Re,this.usesPrefixDiscriminator=qe,this.defaultLayout=Fe,this.registry={};let Xe=this.defaultGetSourceVariant.bind(this);this.getSourceVariant=function(Je){return Xe(Je)},this.configGetSourceVariant=function(Je){Xe=Je.bind(this)}}getSpan(Re,Fe){if(0<=this.span)return this.span;Fe===void 0&&(Fe=0);const We=this.getVariant(Re,Fe);if(!We)throw new Error("unable to determine span for unrecognized variant");return We.getSpan(Re,Fe)}defaultGetSourceVariant(Re){if(Re.hasOwnProperty(this.discriminator.property)){if(this.defaultLayout&&Re.hasOwnProperty(this.defaultLayout.property))return;const Fe=this.registry[Re[this.discriminator.property]];if(Fe&&(!Fe.layout||Re.hasOwnProperty(Fe.property)))return Fe}else for(const Fe in this.registry){const We=this.registry[Fe];if(Re.hasOwnProperty(We.property))return We}throw new Error("unable to infer src variant")}decode(Re,Fe){let We;Fe===void 0&&(Fe=0);const qe=this.discriminator,Ze=qe.decode(Re,Fe);let Xe=this.registry[Ze];if(Xe===void 0){let Je=0;Xe=this.defaultLayout,this.usesPrefixDiscriminator&&(Je=qe.layout.span),We=this.makeDestinationObject(),We[qe.property]=Ze,We[Xe.property]=this.defaultLayout.decode(Re,Fe+Je)}else We=Xe.decode(Re,Fe);return We}encode(Re,Fe,We){We===void 0&&(We=0);const qe=this.getSourceVariant(Re);if(qe===void 0){const Ze=this.discriminator,Xe=this.defaultLayout;let Je=0;return this.usesPrefixDiscriminator&&(Je=Ze.layout.span),Ze.encode(Re[Ze.property],Fe,We),Je+Xe.encode(Re[Xe.property],Fe,We+Je)}return qe.encode(Re,Fe,We)}addVariant(Re,Fe,We){const qe=new ae(this,Re,Fe,We);return this.registry[Re]=qe,qe}getVariant(Re,Fe){let We=Re;return Buffer.isBuffer(Re)&&(Fe===void 0&&(Fe=0),We=this.discriminator.decode(Re,Fe)),this.registry[We]}}class ae extends Wt{constructor(Re,Fe,We,qe){if(!(Re instanceof se))throw new TypeError("union must be a Union");if(!Number.isInteger(Fe)||0>Fe)throw new TypeError("variant must be a (non-negative) integer");if(typeof We=="string"&&qe===void 0&&(qe=We,We=null),We){if(!(We instanceof Wt))throw new TypeError("layout must be a Layout");if(Re.defaultLayout!==null&&0<=We.span&&We.span>Re.defaultLayout.span)throw new Error("variant span exceeds span of containing union");if(typeof qe!="string")throw new TypeError("variant must have a String property")}let Ze=Re.span;0>Re.span&&(Ze=We?We.span:0,0<=Ze&&Re.usesPrefixDiscriminator&&(Ze+=Re.discriminator.layout.span)),super(Ze,qe),this.union=Re,this.variant=Fe,this.layout=We||null}getSpan(Re,Fe){if(0<=this.span)return this.span;Fe===void 0&&(Fe=0);let We=0;return this.union.usesPrefixDiscriminator&&(We=this.union.discriminator.layout.span),We+this.layout.getSpan(Re,Fe+We)}decode(Re,Fe){const We=this.makeDestinationObject();if(Fe===void 0&&(Fe=0),this!==this.union.getVariant(Re,Fe))throw new Error("variant mismatch");let qe=0;return this.union.usesPrefixDiscriminator&&(qe=this.union.discriminator.layout.span),this.layout?We[this.property]=this.layout.decode(Re,Fe+qe):this.property?We[this.property]=!0:this.union.usesPrefixDiscriminator&&(We[this.union.discriminator.property]=this.variant),We}encode(Re,Fe,We){We===void 0&&(We=0);let qe=0;if(this.union.usesPrefixDiscriminator&&(qe=this.union.discriminator.layout.span),this.layout&&!Re.hasOwnProperty(this.property))throw new TypeError("variant lacks property "+this.property);this.union.discriminator.encode(this.variant,Fe,We);let Ze=qe;if(this.layout&&(this.layout.encode(Re[this.property],Fe,We+qe),Ze+=this.layout.getSpan(Fe,We+qe),0<=this.union.span&&Ze>this.union.span))throw new Error("encoded variant overruns containing union");return Ze}fromArray(Re){if(this.layout)return this.layout.fromArray(Re)}}class ce extends Wt{constructor(Re,Fe){if(!(Re instanceof Ht&&Re.isCount()||Number.isInteger(Re)&&0<=Re))throw new TypeError("length must be positive integer or an unsigned integer ExternalLayout");let We=-1;Re instanceof Ht||(We=Re),super(We,Fe),this.length=Re}getSpan(Re,Fe){let We=this.span;return 0>We&&(We=this.length.decode(Re,Fe)),We}decode(Re,Fe){Fe===void 0&&(Fe=0);let We=this.span;return 0>We&&(We=this.length.decode(Re,Fe)),Re.slice(Fe,Fe+We)}encode(Re,Fe,We){let qe=this.length;if(this.length instanceof Ht&&(qe=Re.length),!Buffer.isBuffer(Re)||qe!==Re.length)throw new TypeError((Ze="Blob.encode",((Xe=this).property?Ze+"["+Xe.property+"]":Ze)+" requires (length "+qe+") Buffer as src"));var Ze,Xe;if(We+qe>Fe.length)throw new RangeError("encoding overruns Buffer");return Fe.write(Re.toString("hex"),We,qe,"hex"),this.length instanceof Ht&&this.length.encode(qe,Fe,We),qe}}var ue=(Ke,Re,Fe)=>new Jt(Ke,Re,Fe),de=Ke=>new Zt(1,Ke),le=Ke=>new Zt(4,Ke),he=Ke=>new ee(Ke),pe=Ke=>new ne(Ke),fe=(Ke,Re,Fe)=>new re(Ke,Re,Fe),me=(Ke,Re,Fe)=>new se(Ke,Re,Fe),ye=(Ke,Re)=>new ce(Ke,Re);class ge{constructor(Re){}encode(Re,Fe){switch(camelcase.exports(Re)){case"initializeMint":return function({decimals:We,mintAuthority:qe,freezeAuthority:Ze}){return be({initializeMint:{decimals:We,mintAuthority:qe.toBuffer(),freezeAuthorityOption:!!Ze,freezeAuthority:(Ze||PublicKey.default).toBuffer()}})}(Fe);case"initializeAccount":return be({initializeAccount:{}});case"initializeMultisig":return function({m:We}){return be({initializeMultisig:{m:We}})}(Fe);case"transfer":return function({amount:We}){return be({transfer:{amount:We}})}(Fe);case"approve":return function({amount:We}){return be({approve:{amount:We}})}(Fe);case"revoke":return be({revoke:{}});case"setAuthority":return function({authorityType:We,newAuthority:qe}){return be({setAuthority:{authorityType:We,newAuthority:qe}})}(Fe);case"mintTo":return function({amount:We}){return be({mintTo:{amount:We}})}(Fe);case"burn":return function({amount:We}){return be({burn:{amount:We}})}(Fe);case"closeAccount":return be({closeAccount:{}});case"freezeAccount":return be({freezeAccount:{}});case"thawAccount":return be({thawAccount:{}});case"transferChecked":return function({amount:We,decimals:qe}){return be({transferChecked:{amount:We,decimals:qe}})}(Fe);case"approvedChecked":return function({amount:We,decimals:qe}){return be({approveChecked:{amount:We,decimals:qe}})}(Fe);case"mintToChecked":return function({amount:We,decimals:qe}){return be({mintToChecked:{amount:We,decimals:qe}})}(Fe);case"burnChecked":return function({amount:We,decimals:qe}){return be({burnChecked:{amount:We,decimals:qe}})}(Fe);case"intializeAccount2":return function({authority:We}){return be({initilaizeAccount2:{authority:We}})}(Fe);case"syncNative":return be({syncNative:{}});case"initializeAccount3":return function({authority:We}){return be({initializeAccount3:{authority:We}})}(Fe);case"initializeMultisig2":return function({m:We}){return be({initializeMultisig2:{m:We}})}(Fe);case"initializeMint2":return function({decimals:We,mintAuthority:qe,freezeAuthority:Ze}){return be({encodeInitializeMint2:{decimals:We,mintAuthority:qe,freezeAuthority:Ze}})}(Fe);default:throw new Error(`Invalid instruction: ${Re}`)}}encodeState(Re,Fe){throw new Error("SPL token does not have state")}}const we=me(de("instruction"));function ve(Ke){return ye(32,Ke)}function be(Ke){let Re=Buffer.alloc(Ae),Fe=we.encode(Ke,Re);return Re.slice(0,Fe)}we.addVariant(0,fe([de("decimals"),ye(32,"mintAuthority"),de("freezeAuthorityOption"),ve("freezeAuthority")]),"initializeMint"),we.addVariant(1,fe([]),"initializeAccount"),we.addVariant(2,fe([de("m")]),"initializeMultisig"),we.addVariant(3,fe([he("amount")]),"transfer"),we.addVariant(4,fe([he("amount")]),"approve"),we.addVariant(5,fe([]),"revoke"),we.addVariant(6,fe([de("authorityType"),de("newAuthorityOption"),ve("newAuthority")]),"setAuthority"),we.addVariant(7,fe([he("amount")]),"mintTo"),we.addVariant(8,fe([he("amount")]),"burn"),we.addVariant(9,fe([]),"closeAccount"),we.addVariant(10,fe([]),"freezeAccount"),we.addVariant(11,fe([]),"thawAccount"),we.addVariant(12,fe([he("amount"),de("decimals")]),"transferChecked"),we.addVariant(13,fe([he("amount"),de("decimals")]),"approvedChecked"),we.addVariant(14,fe([he("amount"),de("decimals")]),"mintToChecked"),we.addVariant(15,fe([he("amount"),de("decimals")]),"burnedChecked"),we.addVariant(16,fe([ve("authority")]),"InitializeAccount2"),we.addVariant(17,fe([]),"syncNative"),we.addVariant(18,fe([ve("authority")]),"initializeAccount3"),we.addVariant(19,fe([de("m")]),"initializeMultisig2"),we.addVariant(20,fe([de("decimals"),ve("mintAuthority"),de("freezeAuthorityOption"),ve("freezeAuthority")]),"initializeMint2");const Ae=Math.max(...Object.values(we.registry).map(Ke=>Ke.span));class _e{constructor(Re){}encode(Re,Fe){throw new Error("SPL token does not have state")}decode(Re){throw new Error("SPL token does not have state")}}function Se(Ke){return new ke(ye(8),Re=>Le.fromBuffer(Re),Re=>Re.toBuffer(),Ke)}function Ee(Ke){return new ke(ye(32),Re=>new PublicKey(Re),Re=>Re.toBuffer(),Ke)}function Ie(Ke,Re){return new Me(Ke,Re)}class ke extends Gt{constructor(Re,Fe,We,qe){super(Re.span,qe),this.layout=Re,this.decoder=Fe,this.encoder=We}decode(Re,Fe){return this.decoder(this.layout.decode(Re,Fe))}encode(Re,Fe,We){return this.layout.encode(this.encoder(Re),Fe,We)}getSpan(Re,Fe){return this.layout.getSpan(Re,Fe)}}class Me extends Gt{constructor(Re,Fe){super(-1,Fe),this.layout=Re,this.discriminator=le()}encode(Re,Fe,We=0){return Re==null?this.layout.span+this.discriminator.encode(0,Fe,We):(this.discriminator.encode(1,Fe,We),this.layout.encode(Re,Fe,We+4)+4)}decode(Re,Fe=0){const We=this.discriminator.decode(Re,Fe);if(We===0)return null;if(We===1)return this.layout.decode(Re,Fe+4);throw new Error("Invalid coption "+this.layout.property)}getSpan(Re,Fe=0){return this.layout.getSpan(Re,Fe+4)+4}}function xe(Ke){if(Ke===0)return!1;if(Ke===1)return!0;throw new Error("Invalid bool: "+Ke)}function Pe(Ke){return Ke?1:0}class Le extends u{toBuffer(){const Re=super.toArray().reverse(),Fe=Buffer.from(Re);if(Fe.length===8)return Fe;if(Fe.length>=8)throw new Error("u64 too large");const We=Buffer.alloc(8);return Fe.copy(We),We}static fromBuffer(Re){if(Re.length!==8)throw new Error(`Invalid buffer length: ${Re.length}`);return new Le([...Re].reverse().map(Fe=>`00${Fe.toString(16)}`.slice(-2)).join(""),16)}}class Te{constructor(Re){this.idl=Re}async encode(Re,Fe){switch(Re){case"token":{const We=Buffer.alloc(165),qe=Be.encode(Fe,We);return We.slice(0,qe)}case"mint":{const We=Buffer.alloc(82),qe=Ce.encode(Fe,We);return We.slice(0,qe)}default:throw new Error(`Invalid account name: ${Re}`)}}decode(Re,Fe){return this.decodeUnchecked(Re,Fe)}decodeUnchecked(Re,Fe){switch(Re){case"token":return function(We){return Be.decode(We)}(Fe);case"mint":return function(We){return Ce.decode(We)}(Fe);default:throw new Error(`Invalid account name: ${Re}`)}}memcmp(Re,Fe){switch(Re){case"token":return{dataSize:165};case"mint":return{dataSize:82};default:throw new Error(`Invalid account name: ${Re}`)}}size(Re){var Fe;return(Fe=Bt(this.idl,Re))!==null&&Fe!==void 0?Fe:0}}const Ce=fe([Ie(Ee(),"mintAuthority"),Se("supply"),de("decimals"),(ze="isInitialized",new ke(de(),xe,Pe,ze)),Ie(Ee(),"freezeAuthority")]);var ze;const Be=fe([Ee("mint"),Ee("authority"),Se("amount"),Ie(Ee(),"delegate"),de("state"),Ie(Se(),"isNative"),Se("delegatedAmount"),Ie(Ee(),"closeAuthority")]);class Oe{constructor(Re){}decode(Re){throw new Error("SPL token program does not have events")}}class De{constructor(Re){}encode(Re,Fe){throw new Error("SPL token does not have user-defined types")}decode(Re,Fe){throw new Error("SPL token does not have user-defined types")}}class Ne{constructor(Re){this.instruction=new ge(Re),this.accounts=new Te(Re),this.events=new Oe(Re),this.state=new _e(Re),this.types=new De(Re)}}class Ve extends Gt{constructor(Re){super(-1,Re),this.property=Re,this.layout=fe([le("length"),le("lengthPadding"),ye(ue(le(),-8),"chars")],this.property)}encode(Re,Fe,We=0){if(Re==null)return this.layout.span;const qe={chars:Buffer.from(Re,"utf8")};return this.layout.encode(qe,Fe,We)}decode(Re,Fe=0){return this.layout.decode(Re,Fe).chars.toString()}getSpan(Re,Fe=0){return le().span+le().span+new u(new Uint8Array(Re).slice(Fe,Fe+4),10,"le").toNumber()}}function Ue(Ke){return new Ve(Ke)}function je(Ke){return ye(32,Ke)}const $e=me(le("instruction"));$e.addVariant(0,fe([pe("lamports"),pe("space"),je("owner")]),"createAccount"),$e.addVariant(1,fe([je("owner")]),"assign"),$e.addVariant(2,fe([pe("lamports")]),"transfer"),$e.addVariant(3,fe([je("base"),Ue("seed"),pe("lamports"),pe("space"),je("owner")]),"createAccountWithSeed"),$e.addVariant(4,fe([je("authorized")]),"advanceNonceAccount"),$e.addVariant(5,fe([pe("lamports")]),"withdrawNonceAccount"),$e.addVariant(6,fe([je("authorized")]),"initializeNonceAccount"),$e.addVariant(7,fe([je("authorized")]),"authorizeNonceAccount"),$e.addVariant(8,fe([pe("space")]),"allocate"),$e.addVariant(9,fe([je("base"),Ue("seed"),pe("space"),je("owner")]),"allocateWithSeed"),$e.addVariant(10,fe([je("base"),Ue("seed"),je("owner")]),"assignWithSeed"),$e.addVariant(11,fe([pe("lamports"),Ue("seed"),je("owner")]),"transferWithSeed");Math.max(...Object.values($e.registry).map(Ke=>Ke.span));class Ge extends Gt{constructor(Re,Fe,We,qe){super(Re.span,qe),this.layout=Re,this.decoder=Fe,this.encoder=We}decode(Re,Fe){return this.decoder(this.layout.decode(Re,Fe))}encode(Re,Fe,We){return this.layout.encode(this.encoder(Re),Fe,We)}getSpan(Re,Fe){return this.layout.getSpan(Re,Fe)}}function He(Ke){return new Ge(ye(32),Re=>new PublicKey(Re),Re=>Re.toBuffer(),Ke)}fe([le("version"),le("state"),He("authorizedPubkey"),He("nonce"),fe([he("lamportsPerSignature")],"feeCalculator")]);var Ye=Object.freeze({__proto__:null,hash:function(Ke){return sha256.exports.sha256(Ke)}});function tn(Ke,Re,Fe){const We=buffer.Buffer.concat([Ke.toBuffer(),buffer.Buffer.from(Re),Fe.toBuffer()]),qe=sha256.exports.sha256.digest(We);return new PublicKey(buffer.Buffer.from(qe))}function en(Ke,Re){let Fe=buffer.Buffer.alloc(0);Ke.forEach(function(Ze){if(Ze.length>32)throw new TypeError("Max seed length exceeded");Fe=buffer.Buffer.concat([Fe,rn(Ze)])}),Fe=buffer.Buffer.concat([Fe,Re.toBuffer(),buffer.Buffer.from("ProgramDerivedAddress")]);let We=sha256.exports.sha256(new Uint8Array(Fe)),qe=new u(We,16).toArray(void 0,32);if(PublicKey.isOnCurve(new Uint8Array(qe)))throw new Error("Invalid seeds, address must fall off the curve");return new PublicKey(qe)}function nn(Ke,Re){let Fe,We=255;for(;We!=0;){try{Fe=en(Ke.concat(buffer.Buffer.from([We])),Re)}catch(qe){if(qe instanceof TypeError)throw qe;We--;continue}return[Fe,We]}throw new Error("Unable to find a viable program address nonce")}const rn=Ke=>Ke instanceof buffer.Buffer?Ke:Ke instanceof Uint8Array?buffer.Buffer.from(Ke.buffer,Ke.byteOffset,Ke.byteLength):buffer.Buffer.from(Ke);async function on(Ke,...Re){let Fe=[buffer.Buffer.from([97,110,99,104,111,114])];Re.forEach(qe=>{Fe.push(qe instanceof buffer.Buffer?qe:L(qe).toBuffer())});const[We]=await PublicKey.findProgramAddress(Fe,L(Ke));return We}var sn=Object.freeze({__proto__:null,createWithSeedSync:tn,createProgramAddressSync:en,findProgramAddressSync:nn,associated:on});const an=new PublicKey("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"),cn=new PublicKey("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL");var un=Object.freeze({__proto__:null,TOKEN_PROGRAM_ID:an,ASSOCIATED_PROGRAM_ID:cn,associatedAddress:async function({mint:Ke,owner:Re}){return(await PublicKey.findProgramAddress([Re.toBuffer(),an.toBuffer(),Ke.toBuffer()],cn))[0]}}),dn={exports:{}};(function(Ke,Re){var Fe=typeof self<"u"?self:qt,We=function(){function Ze(){this.fetch=!1,this.DOMException=Fe.DOMException}return Ze.prototype=Fe,new Ze}();(function(Ze){(function(Xe){var Je="URLSearchParams"in Ze,tr="Symbol"in Ze&&"iterator"in Symbol,er="FileReader"in Ze&&"Blob"in Ze&&function(){try{return new Blob,!0}catch{return!1}}(),ir="FormData"in Ze,lr="ArrayBuffer"in Ze;if(lr)var fr=["[object Int8Array]","[object Uint8Array]","[object Uint8ClampedArray]","[object Int16Array]","[object Uint16Array]","[object Int32Array]","[object Uint32Array]","[object Float32Array]","[object Float64Array]"],ur=ArrayBuffer.isView||function(ar){return ar&&fr.indexOf(Object.prototype.toString.call(ar))>-1};function mr(ar){if(typeof ar!="string"&&(ar=String(ar)),/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(ar))throw new TypeError("Invalid character in header field name");return ar.toLowerCase()}function br(ar){return typeof ar!="string"&&(ar=String(ar)),ar}function wr(ar){var Dt={next:function(){var sr=ar.shift();return{done:sr===void 0,value:sr}}};return tr&&(Dt[Symbol.iterator]=function(){return Dt}),Dt}function Sr(ar){this.map={},ar instanceof Sr?ar.forEach(function(Dt,sr){this.append(sr,Dt)},this):Array.isArray(ar)?ar.forEach(function(Dt){this.append(Dt[0],Dt[1])},this):ar&&Object.getOwnPropertyNames(ar).forEach(function(Dt){this.append(Dt,ar[Dt])},this)}function kr(ar){if(ar.bodyUsed)return Promise.reject(new TypeError("Already read"));ar.bodyUsed=!0}function Er(ar){return new Promise(function(Dt,sr){ar.onload=function(){Dt(ar.result)},ar.onerror=function(){sr(ar.error)}})}function Ir(ar){var Dt=new FileReader,sr=Er(Dt);return Dt.readAsArrayBuffer(ar),sr}function Rr(ar){if(ar.slice)return ar.slice(0);var Dt=new Uint8Array(ar.byteLength);return Dt.set(new Uint8Array(ar)),Dt.buffer}function Pr(){return this.bodyUsed=!1,this._initBody=function(ar){var Dt;this._bodyInit=ar,ar?typeof ar=="string"?this._bodyText=ar:er&&Blob.prototype.isPrototypeOf(ar)?this._bodyBlob=ar:ir&&FormData.prototype.isPrototypeOf(ar)?this._bodyFormData=ar:Je&&URLSearchParams.prototype.isPrototypeOf(ar)?this._bodyText=ar.toString():lr&&er&&(Dt=ar)&&DataView.prototype.isPrototypeOf(Dt)?(this._bodyArrayBuffer=Rr(ar.buffer),this._bodyInit=new Blob([this._bodyArrayBuffer])):lr&&(ArrayBuffer.prototype.isPrototypeOf(ar)||ur(ar))?this._bodyArrayBuffer=Rr(ar):this._bodyText=ar=Object.prototype.toString.call(ar):this._bodyText="",this.headers.get("content-type")||(typeof ar=="string"?this.headers.set("content-type","text/plain;charset=UTF-8"):this._bodyBlob&&this._bodyBlob.type?this.headers.set("content-type",this._bodyBlob.type):Je&&URLSearchParams.prototype.isPrototypeOf(ar)&&this.headers.set("content-type","application/x-www-form-urlencoded;charset=UTF-8"))},er&&(this.blob=function(){var ar=kr(this);if(ar)return ar;if(this._bodyBlob)return Promise.resolve(this._bodyBlob);if(this._bodyArrayBuffer)return Promise.resolve(new Blob([this._bodyArrayBuffer]));if(this._bodyFormData)throw new Error("could not read FormData body as blob");return Promise.resolve(new Blob([this._bodyText]))},this.arrayBuffer=function(){return this._bodyArrayBuffer?kr(this)||Promise.resolve(this._bodyArrayBuffer):this.blob().then(Ir)}),this.text=function(){var ar=kr(this);if(ar)return ar;if(this._bodyBlob)return function(Dt){var sr=new FileReader,cr=Er(sr);return sr.readAsText(Dt),cr}(this._bodyBlob);if(this._bodyArrayBuffer)return Promise.resolve(function(Dt){for(var sr=new Uint8Array(Dt),cr=new Array(sr.length),yr=0;yr<sr.length;yr++)cr[yr]=String.fromCharCode(sr[yr]);return cr.join("")}(this._bodyArrayBuffer));if(this._bodyFormData)throw new Error("could not read FormData body as text");return Promise.resolve(this._bodyText)},ir&&(this.formData=function(){return this.text().then(Nr)}),this.json=function(){return this.text().then(JSON.parse)},this}Sr.prototype.append=function(ar,Dt){ar=mr(ar),Dt=br(Dt);var sr=this.map[ar];this.map[ar]=sr?sr+", "+Dt:Dt},Sr.prototype.delete=function(ar){delete this.map[mr(ar)]},Sr.prototype.get=function(ar){return ar=mr(ar),this.has(ar)?this.map[ar]:null},Sr.prototype.has=function(ar){return this.map.hasOwnProperty(mr(ar))},Sr.prototype.set=function(ar,Dt){this.map[mr(ar)]=br(Dt)},Sr.prototype.forEach=function(ar,Dt){for(var sr in this.map)this.map.hasOwnProperty(sr)&&ar.call(Dt,this.map[sr],sr,this)},Sr.prototype.keys=function(){var ar=[];return this.forEach(function(Dt,sr){ar.push(sr)}),wr(ar)},Sr.prototype.values=function(){var ar=[];return this.forEach(function(Dt){ar.push(Dt)}),wr(ar)},Sr.prototype.entries=function(){var ar=[];return this.forEach(function(Dt,sr){ar.push([sr,Dt])}),wr(ar)},tr&&(Sr.prototype[Symbol.iterator]=Sr.prototype.entries);var Br=["DELETE","GET","HEAD","OPTIONS","POST","PUT"];function Or(ar,Dt){var sr,cr,yr=(Dt=Dt||{}).body;if(ar instanceof Or){if(ar.bodyUsed)throw new TypeError("Already read");this.url=ar.url,this.credentials=ar.credentials,Dt.headers||(this.headers=new Sr(ar.headers)),this.method=ar.method,this.mode=ar.mode,this.signal=ar.signal,yr||ar._bodyInit==null||(yr=ar._bodyInit,ar.bodyUsed=!0)}else this.url=String(ar);if(this.credentials=Dt.credentials||this.credentials||"same-origin",!Dt.headers&&this.headers||(this.headers=new Sr(Dt.headers)),this.method=(sr=Dt.method||this.method||"GET",cr=sr.toUpperCase(),Br.indexOf(cr)>-1?cr:sr),this.mode=Dt.mode||this.mode||null,this.signal=Dt.signal||this.signal,this.referrer=null,(this.method==="GET"||this.method==="HEAD")&&yr)throw new TypeError("Body not allowed for GET or HEAD requests");this._initBody(yr)}function Nr(ar){var Dt=new FormData;return ar.trim().split("&").forEach(function(sr){if(sr){var cr=sr.split("="),yr=cr.shift().replace(/\+/g," "),_r=cr.join("=").replace(/\+/g," ");Dt.append(decodeURIComponent(yr),decodeURIComponent(_r))}}),Dt}function Cr(ar,Dt){Dt||(Dt={}),this.type="default",this.status=Dt.status===void 0?200:Dt.status,this.ok=this.status>=200&&this.status<300,this.statusText="statusText"in Dt?Dt.statusText:"OK",this.headers=new Sr(Dt.headers),this.url=Dt.url||"",this._initBody(ar)}Or.prototype.clone=function(){return new Or(this,{body:this._bodyInit})},Pr.call(Or.prototype),Pr.call(Cr.prototype),Cr.prototype.clone=function(){return new Cr(this._bodyInit,{status:this.status,statusText:this.statusText,headers:new Sr(this.headers),url:this.url})},Cr.error=function(){var ar=new Cr(null,{status:0,statusText:""});return ar.type="error",ar};var Tr=[301,302,303,307,308];Cr.redirect=function(ar,Dt){if(Tr.indexOf(Dt)===-1)throw new RangeError("Invalid status code");return new Cr(null,{status:Dt,headers:{location:ar}})},Xe.DOMException=Ze.DOMException;try{new Xe.DOMException}catch{Xe.DOMException=function(Dt,sr){this.message=Dt,this.name=sr;var cr=Error(Dt);this.stack=cr.stack},Xe.DOMException.prototype=Object.create(Error.prototype),Xe.DOMException.prototype.constructor=Xe.DOMException}function Mr(ar,Dt){return new Promise(function(sr,cr){var yr=new Or(ar,Dt);if(yr.signal&&yr.signal.aborted)return cr(new Xe.DOMException("Aborted","AbortError"));var _r=new XMLHttpRequest;function xr(){_r.abort()}_r.onload=function(){var Ar,pr,rr={status:_r.status,statusText:_r.statusText,headers:(Ar=_r.getAllResponseHeaders()||"",pr=new Sr,Ar.replace(/\r?\n[\t ]+/g," ").split(/\r?\n/).forEach(function($r){var Lr=$r.split(":"),Ur=Lr.shift().trim();if(Ur){var Wr=Lr.join(":").trim();pr.append(Ur,Wr)}}),pr)};rr.url="responseURL"in _r?_r.responseURL:rr.headers.get("X-Request-URL");var hr="response"in _r?_r.response:_r.responseText;sr(new Cr(hr,rr))},_r.onerror=function(){cr(new TypeError("Network request failed"))},_r.ontimeout=function(){cr(new TypeError("Network request failed"))},_r.onabort=function(){cr(new Xe.DOMException("Aborted","AbortError"))},_r.open(yr.method,yr.url,!0),yr.credentials==="include"?_r.withCredentials=!0:yr.credentials==="omit"&&(_r.withCredentials=!1),"responseType"in _r&&er&&(_r.responseType="blob"),yr.headers.forEach(function(Ar,pr){_r.setRequestHeader(pr,Ar)}),yr.signal&&(yr.signal.addEventListener("abort",xr),_r.onreadystatechange=function(){_r.readyState===4&&yr.signal.removeEventListener("abort",xr)}),_r.send(yr._bodyInit===void 0?null:yr._bodyInit)})}Mr.polyfill=!0,Ze.fetch||(Ze.fetch=Mr,Ze.Headers=Sr,Ze.Request=Or,Ze.Response=Cr),Xe.Headers=Sr,Xe.Request=Or,Xe.Response=Cr,Xe.fetch=Mr,Object.defineProperty(Xe,"__esModule",{value:!0})})({})})(We),We.fetch.ponyfill=!0,delete We.fetch.polyfill;var qe=We;(Re=qe.fetch).default=qe.fetch,Re.fetch=qe.fetch,Re.Headers=qe.Headers,Re.Request=qe.Request,Re.Response=qe.Response,Ke.exports=Re})(dn,dn.exports);var ln=Ft(dn.exports);async function hn(Ke,Re){const Fe=await Ke.getAccountInfo(Re);if(Fe===null)throw new Error("program account not found");const{program:We}=fn(Fe.data),qe=await Ke.getAccountInfo(We.programdataAddress);if(qe===null)throw new Error("program data account not found");const{programData:Ze}=fn(qe.data);return Ze}const pn=lib.rustEnum([lib.struct([],"uninitialized"),lib.struct([lib.option(lib.publicKey(),"authorityAddress")],"buffer"),lib.struct([lib.publicKey("programdataAddress")],"program"),lib.struct([lib.u64("slot"),lib.option(lib.publicKey(),"upgradeAuthorityAddress")],"programData")],void 0,lib.u32());function fn(Ke){return pn.decode(Ke)}var mn=Object.freeze({__proto__:null,verifiedBuild:async function(Ke,Re,Fe=5){const We=`https://api.apr.dev/api/v0/program/${Re.toString()}/latest?limit=${Fe}`,[qe,Ze]=await Promise.all([hn(Ke,Re),ln(We)]),Xe=(await Ze.json()).filter(tr=>!tr.aborted&&tr.state==="Built"&&tr.verified==="Verified");if(Xe.length===0)return null;const Je=Xe[0];return qe.slot.toNumber()!==Je.verified_slot?null:Je},fetchData:hn,decodeUpgradeableLoaderState:fn});Object.freeze({__proto__:null,sha256:Ye,rpc:it,publicKey:sn,bytes:k,token:un,features:yt,registry:mn});const gn=lib.struct([lib.publicKey("authority"),lib.vecU8("data")]);function wn(Ke,Re){var Fe,We;let qe={};const Ze=Ke.args?Ke.args.length:0;if(Re.length>Ze){if(Re.length!==Ze+1)throw new Error(`provided too many arguments ${Re} to instruction ${Ke==null?void 0:Ke.name} expecting: ${(We=(Fe=Ke.args)===null||Fe===void 0?void 0:Fe.map(Xe=>Xe.name))!==null&&We!==void 0?We:[]}`);qe=Re.pop()}return[Re,qe]}class vn{static build(Re,Fe,We){if(Re.name==="_inner")throw new gt("the _inner name is reserved");const qe=(...Ze)=>{const[Xe,Je]=wn(Re,[...Ze]);P(Re.accounts,Je.accounts);const tr=qe.accounts(Je.accounts);return Je.remainingAccounts!==void 0&&tr.push(...Je.remainingAccounts),mt("debug-logs")&&console.log("Outgoing account metas:",tr),new TransactionInstruction({keys:tr,programId:We,data:Fe(Re.name,x(Re,...Xe))})};return qe.accounts=Ze=>vn.accountsArray(Ze,Re.accounts,Re.name),qe}static accountsArray(Re,Fe,We){return Re?Fe.map(qe=>{if(("accounts"in qe?qe.accounts:void 0)!==void 0){const Ze=Re[qe.name];return vn.accountsArray(Ze,qe.accounts,We).flat()}{const Ze=qe;let Xe;try{Xe=L(Re[qe.name])}catch{throw new Error(`Wrong input type for account "${qe.name}" in the instruction accounts object${We!==void 0?' for instruction "'+We+'"':""}. Expected PublicKey or string.`)}return{pubkey:Xe,isWritable:Ze.isMut,isSigner:Ze.isSigner}}}).flat():[]}}class bn{static build(Re,Fe,We,qe){return async(...Ze)=>{var Xe;const Je=Fe(...Ze),[,tr]=wn(Re,[...Ze]);if(qe.sendAndConfirm===void 0)throw new Error("This function requires 'Provider.sendAndConfirm' to be implemented.");try{return await qe.sendAndConfirm(Je,(Xe=tr.signers)!==null&&Xe!==void 0?Xe:[],tr.options)}catch(er){throw At(er,We)}}}}class An{static build(Re,Fe){return(...We)=>{var qe,Ze,Xe;const[,Je]=wn(Re,[...We]),tr=new Transaction;if(Je.preInstructions&&Je.instructions)throw new Error("instructions is deprecated, use preInstructions");return(qe=Je.preInstructions)===null||qe===void 0||qe.forEach(er=>tr.add(er)),(Ze=Je.instructions)===null||Ze===void 0||Ze.forEach(er=>tr.add(er)),tr.add(Fe(...We)),(Xe=Je.postInstructions)===null||Xe===void 0||Xe.forEach(er=>tr.add(er)),tr}}}class _n{constructor(Re,Fe,We=lt(),qe=new Kt(Re)){this.provider=We,this.coder=qe,this._idl=Re,this._programId=Fe,this._address=Sn(Fe),this._sub=null;const[Ze,Xe,Je]=(()=>{var tr;let er={},ir={},lr={};return(tr=Re.state)===null||tr===void 0||tr.methods.forEach(fr=>{const ur=vn.build(fr,(Sr,kr)=>qe.instruction.encodeState(Sr,kr),Fe);ur.accounts=Sr=>function(Er,Ir,Rr,Pr){if(Rr.name==="new"){const[Br]=nn([],Er);if(Ir.wallet===void 0)throw new Error("This function requires the Provider interface implementor to have a 'wallet' field.");return[{pubkey:Ir.wallet.publicKey,isWritable:!1,isSigner:!0},{pubkey:Sn(Er),isWritable:!0,isSigner:!1},{pubkey:Br,isWritable:!1,isSigner:!1},{pubkey:SystemProgram.programId,isWritable:!1,isSigner:!1},{pubkey:Er,isWritable:!1,isSigner:!1}]}return P(Rr.accounts,Pr),[{pubkey:Sn(Er),isWritable:!0,isSigner:!1}]}(Fe,We,fr,Sr).concat(vn.accountsArray(Sr,fr.accounts,fr.name));const mr=An.build(fr,ur),br=bn.build(fr,mr,M(Re),We),wr=camelcase.exports(fr.name);er[wr]=ur,ir[wr]=mr,lr[wr]=br}),[er,ir,lr]})();this.instruction=Ze,this.transaction=Xe,this.rpc=Je}get programId(){return this._programId}async fetch(){const Re=this.address(),Fe=await this.provider.connection.getAccountInfo(Re);if(Fe===null)throw new Error(`Account does not exist ${Re.toString()}`);const We=this._idl.state;if(!We)throw new Error("State is not specified in IDL.");if((await jt(We.struct.name)).compare(Fe.data.slice(0,8)))throw new Error("Invalid account discriminator");return this.coder.state.decode(Fe.data)}address(){return this._address}subscribe(Re){if(this._sub!==null)return this._sub.ee;const Fe=new y,We=this.provider.connection.onAccountChange(this.address(),qe=>{const Ze=this.coder.state.decode(qe.data);Fe.emit("change",Ze)},Re);return this._sub={ee:Fe,listener:We},Fe}unsubscribe(){this._sub!==null&&this.provider.connection.removeAccountChangeListener(this._sub.listener).then(async()=>{this._sub=null}).catch(console.error)}}function Sn(Ke){let[Re]=nn([],Ke);return tn(Re,"unversioned",Ke)}class En{constructor(Re,Fe,We,qe,Ze){this._idlAccount=Fe,this._programId=We,this._provider=qe!=null?qe:lt(),this._coder=Ze!=null?Ze:new Kt(Re),this._size=this._coder.accounts.size(Fe)}get size(){return this._size}get programId(){return this._programId}get provider(){return this._provider}get coder(){return this._coder}async fetchNullable(Re,Fe){const We=await this.getAccountInfo(Re,Fe);return We===null?null:this._coder.accounts.decode(this._idlAccount.name,We.data)}async fetch(Re,Fe){const We=await this.fetchNullable(Re,Fe);if(We===null)throw new Error(`Account does not exist ${Re.toString()}`);return We}async fetchMultiple(Re,Fe){return(await X(this._provider.connection,Re.map(We=>L(We)),Fe)).map(We=>We==null?null:this._coder.accounts.decode(this._idlAccount.name,We==null?void 0:We.account.data))}async all(Re){return(await this._provider.connection.getProgramAccounts(this._programId,{commitment:this._provider.connection.commitment,filters:[{memcmp:this.coder.accounts.memcmp(this._idlAccount.name,Re instanceof Buffer?Re:void 0)},...Array.isArray(Re)?Re:[]]})).map(({pubkey:Fe,account:We})=>({publicKey:Fe,account:this._coder.accounts.decode(this._idlAccount.name,We.data)}))}subscribe(Re,Fe){const We=In.get(Re.toString());if(We)return We.ee;const qe=new y;Re=L(Re);const Ze=this._provider.connection.onAccountChange(Re,Xe=>{const Je=this._coder.accounts.decode(this._idlAccount.name,Xe.data);qe.emit("change",Je)},Fe);return In.set(Re.toString(),{ee:qe,listener:Ze}),qe}async unsubscribe(Re){let Fe=In.get(Re.toString());Fe?In&&await this._provider.connection.removeAccountChangeListener(Fe.listener).then(()=>{In.delete(Re.toString())}).catch(console.error):console.warn("Address is not subscribed")}async createInstruction(Re,Fe){const We=this.size;if(this._provider.wallet===void 0)throw new Error("This function requires the Provider interface implementor to have a 'wallet' field.");return SystemProgram.createAccount({fromPubkey:this._provider.wallet.publicKey,newAccountPubkey:Re.publicKey,space:Fe!=null?Fe:We,lamports:await this._provider.connection.getMinimumBalanceForRentExemption(Fe!=null?Fe:We),programId:this._programId})}async associated(...Re){const Fe=await this.associatedAddress(...Re);return await this.fetch(Fe)}async associatedAddress(...Re){return await on(this._programId,...Re)}async getAccountInfo(Re,Fe){return await this._provider.connection.getAccountInfo(L(Re),Fe)}}const In=new Map,kn=13,Mn=14;class xn{constructor(Re,Fe,We){this._programId=Re,this._provider=Fe,this._eventParser=new Pn(Re,We),this._eventCallbacks=new Map,this._eventListeners=new Map,this._listenerIdCount=0}addEventListener(Re,Fe){var We;let qe=this._listenerIdCount;return this._listenerIdCount+=1,Re in this._eventCallbacks||this._eventListeners.set(Re,[]),this._eventListeners.set(Re,((We=this._eventListeners.get(Re))!==null&&We!==void 0?We:[]).concat(qe)),this._eventCallbacks.set(qe,[Re,Fe]),this._onLogsSubscriptionId!==void 0||(this._onLogsSubscriptionId=this._provider.connection.onLogs(this._programId,(Ze,Xe)=>{if(!Ze.err)for(const Je of this._eventParser.parseLogs(Ze.logs)){const tr=this._eventListeners.get(Je.name);tr&&tr.forEach(er=>{const ir=this._eventCallbacks.get(er);if(ir){const[,lr]=ir;lr(Je.data,Xe.slot,Ze.signature)}})}})),qe}async removeEventListener(Re){const Fe=this._eventCallbacks.get(Re);if(!Fe)throw new Error(`Event listener ${Re} doesn't exist!`);const[We]=Fe;let qe=this._eventListeners.get(We);if(!qe)throw new Error(`Event listeners don't exist for ${We}!`);this._eventCallbacks.delete(Re),qe=qe.filter(Ze=>Ze!==Re),qe.length===0&&this._eventListeners.delete(We),this._eventCallbacks.size==0&&((void 0)(this._eventListeners.size===0),this._onLogsSubscriptionId!==void 0&&(await this._provider.connection.removeOnLogsListener(this._onLogsSubscriptionId),this._onLogsSubscriptionId=void 0))}}class Pn{constructor(Re,Fe){this.coder=Fe,this.programId=Re}*parseLogs(Re){const Fe=new Tn(Re),We=new Ln;let qe=Fe.next();for(;qe!==null;){let[Ze,Xe,Je]=this.handleLog(We,qe);Ze&&(yield Ze),Xe&&We.push(Xe),Je&&We.pop(),qe=Fe.next()}}handleLog(Re,Fe){return Re.stack.length>0&&Re.program()===this.programId.toString()?this.handleProgramLog(Fe):[null,...this.handleSystemLog(Fe)]}handleProgramLog(Re){if(Re.startsWith("Program log: ")||Re.startsWith("Program data: ")){const Fe=Re.startsWith("Program log: ")?Re.slice(kn):Re.slice(Mn);return[this.coder.events.decode(Fe),null,!1]}return[null,...this.handleSystemLog(Re)]}handleSystemLog(Re){const Fe=Re.split(":")[0];return Fe.match(/^Program (.*) success/g)!==null?[null,!0]:Fe.startsWith(`Program ${this.programId.toString()} invoke`)?[this.programId.toString(),!1]:Fe.includes("invoke")?["cpi",!1]:[null,!1]}}class Ln{constructor(){this.stack=[]}program(){return(void 0)(this.stack.length>0),this.stack[this.stack.length-1]}push(Re){this.stack.push(Re)}pop(){(void 0)(this.stack.length>0),this.stack.pop()}}class Tn{constructor(Re){this.logs=Re}next(){if(this.logs.length===0)return null;let Re=this.logs[0];return this.logs=this.logs.slice(1),Re}}new PublicKey("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA");function zn(){return new Ne(Bn)}const Bn={version:"0.1.0",name:"spl_token",instructions:[{name:"initializeMint",accounts:[{name:"mint",isMut:!0,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1}],args:[{name:"decimals",type:"u8"},{name:"mintAuthority",type:"publicKey"},{name:"freezeAuthority",type:{coption:"publicKey"}}]},{name:"initializeAccount",accounts:[{name:"account",isMut:!0,isSigner:!1},{name:"mint",isMut:!1,isSigner:!1},{name:"authority",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1}],args:[]},{name:"initializeMultisig",accounts:[{name:"account",isMut:!0,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1}],args:[{name:"m",type:"u8"}]},{name:"transfer",accounts:[{name:"source",isMut:!0,isSigner:!1},{name:"destination",isMut:!0,isSigner:!1},{name:"authority",isMut:!1,isSigner:!0}],args:[{name:"amount",type:"u64"}]},{name:"approve",accounts:[{name:"source",isMut:!0,isSigner:!1},{name:"delegate",isMut:!1,isSigner:!1},{name:"authority",isMut:!1,isSigner:!0}],args:[{name:"amount",type:"u64"}]},{name:"revoke",accounts:[{name:"source",isMut:!0,isSigner:!1},{name:"authority",isMut:!1,isSigner:!0}],args:[]},{name:"setAuthority",accounts:[{name:"mint",isMut:!0,isSigner:!1},{name:"authority",isMut:!1,isSigner:!0}],args:[{name:"authorityType",type:"u8"},{name:"newAuthority",type:{coption:"publicKey"}}]},{name:"mintTo",accounts:[{name:"mint",isMut:!0,isSigner:!1},{name:"to",isMut:!0,isSigner:!1},{name:"authority",isMut:!1,isSigner:!0}],args:[{name:"amount",type:"u64"}]},{name:"burn",accounts:[{name:"source",isMut:!0,isSigner:!1},{name:"mint",isMut:!0,isSigner:!1},{name:"authority",isMut:!1,isSigner:!0}],args:[{name:"amount",type:"u64"}]},{name:"closeAccount",accounts:[{name:"account",isMut:!0,isSigner:!1},{name:"destination",isMut:!0,isSigner:!1},{name:"authority",isMut:!1,isSigner:!1}],args:[]},{name:"freezeAccount",accounts:[{name:"account",isMut:!0,isSigner:!1},{name:"mint",isMut:!1,isSigner:!1},{name:"authority",isMut:!1,isSigner:!0}],args:[]},{name:"thawAccount",accounts:[{name:"account",isMut:!0,isSigner:!1},{name:"mint",isMut:!1,isSigner:!1},{name:"authority",isMut:!1,isSigner:!0}],args:[]},{name:"transferChecked",accounts:[{name:"source",isMut:!0,isSigner:!1},{name:"mint",isMut:!1,isSigner:!1},{name:"destination",isMut:!0,isSigner:!1},{name:"authority",isMut:!1,isSigner:!0}],args:[{name:"amount",type:"u64"},{name:"decimals",type:"u8"}]},{name:"approveChecked",accounts:[{name:"source",isMut:!0,isSigner:!1},{name:"mint",isMut:!1,isSigner:!1},{name:"delegate",isMut:!1,isSigner:!1},{name:"authority",isMut:!1,isSigner:!0}],args:[{name:"amount",type:"u64"},{name:"decimals",type:"u8"}]},{name:"mintToChecked",accounts:[{name:"mint",isMut:!0,isSigner:!1},{name:"to",isMut:!0,isSigner:!1},{name:"authority",isMut:!1,isSigner:!0}],args:[{name:"amount",type:"u64"},{name:"decimals",type:"u8"}]},{name:"burnChecked",accounts:[{name:"source",isMut:!0,isSigner:!1},{name:"mint",isMut:!0,isSigner:!1},{name:"authority",isMut:!1,isSigner:!0}],args:[{name:"amount",type:"u64"},{name:"decimals",type:"u8"}]},{name:"initializeAccount2",accounts:[{name:"account",isMut:!0,isSigner:!1},{name:"mint",isMut:!1,isSigner:!1},{name:"rent",isMut:!1,isSigner:!1}],args:[{name:"authority",type:"publicKey"}]},{name:"syncNative",accounts:[{name:"account",isMut:!0,isSigner:!1}],args:[]},{name:"initializeAccount3",accounts:[{name:"account",isMut:!0,isSigner:!1},{name:"mint",isMut:!1,isSigner:!1}],args:[{name:"authority",type:"publicKey"}]},{name:"initializeMultisig2",accounts:[{name:"account",isMut:!0,isSigner:!1}],args:[{name:"m",type:"u8"}]},{name:"initializeMint2",accounts:[{name:"mint",isMut:!0,isSigner:!1}],args:[{name:"decimals",type:"u8"},{name:"mintAuthority",type:"publicKey"},{name:"freezeAuthority",type:{coption:"publicKey"}}]}],accounts:[{name:"mint",type:{kind:"struct",fields:[{name:"mintAuthority",type:{coption:"publicKey"}},{name:"supply",type:"u64"},{name:"decimals",type:"u8"},{name:"isInitialized",type:"bool"},{name:"freezeAuthority",type:{coption:"publicKey"}}]}},{name:"token",type:{kind:"struct",fields:[{name:"mint",type:"publicKey"},{name:"authority",type:"publicKey"},{name:"amount",type:"u64"},{name:"delegate",type:{coption:"publicKey"}},{name:"state",type:"u8"},{name:"isNative",type:{coption:"u64"}},{name:"delegatedAmount",type:"u64"},{name:"closeAuthority",type:{coption:"publicKey"}}]}}]};class On{constructor(Re,Fe,We,qe,Ze,Xe){this._args=Re,this._accounts=Fe,this._provider=We,this._programId=qe,this._idlIx=Ze,this._accountStore=new Dn(We,Xe)}async resolve(){for(let Re=0;Re<this._idlIx.accounts.length;Re+=1){const Fe=this._idlIx.accounts[Re],We=camelcase.exports(Fe.name);if(!Fe.isSigner||this._accounts[We])Reflect.has(On.CONST_ACCOUNTS,We)&&!this._accounts[We]&&(this._accounts[We]=On.CONST_ACCOUNTS[We]);else{if(this._provider.wallet===void 0)throw new Error("This function requires the Provider interface implementor to have a 'wallet' field.");this._accounts[We]=this._provider.wallet.publicKey}}for(let Re=0;Re<this._idlIx.accounts.length;Re+=1){const Fe=this._idlIx.accounts[Re],We=camelcase.exports(Fe.name);Fe.pda&&Fe.pda.seeds.length>0&&!this._accounts[We]&&await this.autoPopulatePda(Fe)}}async autoPopulatePda(Re){if(!Re.pda||!Re.pda.seeds)throw new Error("Must have seeds");const Fe=await Promise.all(Re.pda.seeds.map(Ze=>this.toBuffer(Ze))),We=await this.parseProgramId(Re),[qe]=await PublicKey.findProgramAddress(Fe,We);this._accounts[camelcase.exports(Re.name)]=qe}async parseProgramId(Re){var Fe;if(!(!((Fe=Re.pda)===null||Fe===void 0)&&Fe.programId))return this._programId;switch(Re.pda.programId.kind){case"const":return new PublicKey(this.toBufferConst(Re.pda.programId.value));case"arg":return this.argValue(Re.pda.programId);case"account":return await this.accountValue(Re.pda.programId);default:throw new Error(`Unexpected program seed kind: ${Re.pda.programId.kind}`)}}async toBuffer(Re){switch(Re.kind){case"const":return this.toBufferConst(Re);case"arg":return await this.toBufferArg(Re);case"account":return await this.toBufferAccount(Re);default:throw new Error(`Unexpected seed kind: ${Re.kind}`)}}toBufferConst(Re){return this.toBufferValue(Re.type,Re.value)}async toBufferArg(Re){const Fe=this.argValue(Re);return this.toBufferValue(Re.type,Fe)}argValue(Re){const Fe=camelcase.exports(Re.path.split(".")[0]),We=this._idlIx.args.findIndex(qe=>qe.name===Fe);if(We===-1)throw new Error(`Unable to find argument for seed: ${Fe}`);return this._args[We]}async toBufferAccount(Re){const Fe=await this.accountValue(Re);return this.toBufferValue(Re.type,Fe)}async accountValue(Re){const Fe=Re.path.split("."),We=Fe[0],qe=this._accounts[camelcase.exports(We)];if(Fe.length===1)return qe;const Ze=await this._accountStore.fetchAccount(Re.account,qe);return this.parseAccountValue(Ze,Fe.slice(1))}parseAccountValue(Re,Fe){let We;for(;Fe.length>0;)We=Re[camelcase.exports(Fe[0])],Fe=Fe.slice(1);return We}toBufferValue(Re,Fe){switch(Re){case"u8":return Buffer.from([Fe]);case"u16":let We=Buffer.alloc(2);return We.writeUInt16LE(Fe),We;case"u32":let qe=Buffer.alloc(4);return qe.writeUInt32LE(Fe),qe;case"u64":let Ze=Buffer.alloc(8);return Ze.writeBigUInt64LE(BigInt(Fe)),Ze;case"string":return Buffer.from(b(Fe));case"publicKey":return Fe.toBuffer();default:if(Re.array)return Buffer.from(Fe);throw new Error(`Unexpected seed type: ${Re}`)}}}On.CONST_ACCOUNTS={associatedTokenProgram:cn,rent:SYSVAR_RENT_PUBKEY,systemProgram:SystemProgram.programId,tokenProgram:an};class Dn{constructor(Re,Fe){this._provider=Re,this._accounts=Fe,this._cache=new Map}async fetchAccount(Re,Fe){const We=Fe.toString();if(!this._cache.has(We))if(Re==="TokenAccount"){const qe=await this._provider.connection.getAccountInfo(Fe);if(qe===null)throw new Error(`invalid account info for ${We}`);const Ze=zn().accounts.decode("token",qe.data);this._cache.set(We,Ze)}else{const qe=this._accounts[camelcase.exports(Re)].fetch(Fe);this._cache.set(We,qe)}return this._cache.get(We)}}class Nn{static build(Re,Fe,We,qe,Ze,Xe,Je,tr,er){return(...ir)=>new Rn(ir,qe,Ze,Xe,Je,tr,Re,Fe,We,er)}}class Rn{constructor(Re,Fe,We,qe,Ze,Xe,Je,tr,er,ir){this._args=Re,this._ixFn=Fe,this._txFn=We,this._rpcFn=qe,this._simulateFn=Ze,this._viewFn=Xe,this._accounts={},this._remainingAccounts=[],this._signers=[],this._preInstructions=[],this._postInstructions=[],this._autoResolveAccounts=!0,this._accountsResolver=new On(Re,this._accounts,Je,tr,er,ir)}async pubkeys(){return this._autoResolveAccounts&&await this._accountsResolver.resolve(),this._accounts}accounts(Re){return this._autoResolveAccounts=!0,Object.assign(this._accounts,Re),this}accountsStrict(Re){return this._autoResolveAccounts=!1,Object.assign(this._accounts,Re),this}signers(Re){return this._signers=this._signers.concat(Re),this}remainingAccounts(Re){return this._remainingAccounts=this._remainingAccounts.concat(Re),this}preInstructions(Re){return this._preInstructions=this._preInstructions.concat(Re),this}postInstructions(Re){return this._postInstructions=this._postInstructions.concat(Re),this}async rpc(Re){return this._autoResolveAccounts&&await this._accountsResolver.resolve(),this._rpcFn(...this._args,{accounts:this._accounts,signers:this._signers,remainingAccounts:this._remainingAccounts,preInstructions:this._preInstructions,postInstructions:this._postInstructions,options:Re})}async view(Re){if(this._autoResolveAccounts&&await this._accountsResolver.resolve(),!this._viewFn)throw new Error("Method does not support views");return this._viewFn(...this._args,{accounts:this._accounts,signers:this._signers,remainingAccounts:this._remainingAccounts,preInstructions:this._preInstructions,postInstructions:this._postInstructions,options:Re})}async simulate(Re){return this._autoResolveAccounts&&await this._accountsResolver.resolve(),this._simulateFn(...this._args,{accounts:this._accounts,signers:this._signers,remainingAccounts:this._remainingAccounts,preInstructions:this._preInstructions,postInstructions:this._postInstructions,options:Re})}async instruction(){return this._autoResolveAccounts&&await this._accountsResolver.resolve(),this._ixFn(...this._args,{accounts:this._accounts,signers:this._signers,remainingAccounts:this._remainingAccounts,preInstructions:this._preInstructions,postInstructions:this._postInstructions})}async transaction(){return this._autoResolveAccounts&&await this._accountsResolver.resolve(),this._txFn(...this._args,{accounts:this._accounts,signers:this._signers,remainingAccounts:this._remainingAccounts,preInstructions:this._preInstructions,postInstructions:this._postInstructions})}}class Vn{constructor(Re,Fe,We,qe){Fe=L(Fe),We||(We=lt()),this._idl=Re,this._provider=We,this._programId=Fe,this._coder=qe!=null?qe:new Kt(Re),this._events=new xn(this._programId,We,this._coder);const[Ze,Xe,Je,tr,er,ir,lr,fr]=class{static build(ur,mr,br,wr){const Sr={},kr={},Er={},Ir={},Rr={},Pr={},Br=M(ur),Or=ur.accounts?class{static build(Cr,Tr,Mr,ar){var Dt;const sr={};return(Dt=Cr.accounts)===null||Dt===void 0||Dt.forEach(cr=>{const yr=camelcase.exports(cr.name);sr[yr]=new En(Cr,cr,Mr,ar,Tr)}),sr}}.build(ur,mr,br,wr):{},Nr=class{static build(Cr,Tr,Mr,ar){if(Cr.state!==void 0)return new _n(Cr,Mr,ar,Tr)}}.build(ur,mr,br,wr);return ur.instructions.forEach(Cr=>{const Tr=vn.build(Cr,(_r,xr)=>mr.instruction.encode(_r,xr),br),Mr=An.build(Cr,Tr),ar=bn.build(Cr,Mr,Br,wr),Dt=class{static build(_r,xr,Ar,pr,rr,hr,$r){return async(...Lr)=>{var Ur;const Wr=xr(...Lr),[,Fr]=wn(_r,[...Lr]);let zr;if(pr.simulate===void 0)throw new Error("This function requires 'Provider.simulate' to be implemented.");try{zr=await pr.simulate(Wr,Fr.signers,(Ur=Fr.options)===null||Ur===void 0?void 0:Ur.commitment)}catch(Gr){throw At(Gr,Ar)}if(zr===void 0)throw new Error("Unable to simulate transaction");const Yr=zr.logs;if(!Yr)throw new Error("Simulated logs not found");const qr=[];if($r.events){let Gr=new Pn(hr,rr);for(const Hn of Gr.parseLogs(Yr))qr.push(Hn)}return{events:qr,raw:Yr}}}}.build(Cr,Mr,Br,wr,mr,br,ur),sr=class{static build(_r,xr,Ar,pr){const rr=xr.accounts.find($r=>$r.isMut),hr=!!xr.returns;if(!rr&&hr)return async(...$r)=>{var Lr,Ur;let Wr=await Ar(...$r);const Fr=`Program return: ${_r} `;let zr=Wr.raw.find(Gr=>Gr.startsWith(Fr));if(!zr)throw new Error("View expected return log");let Yr=E(zr.slice(Fr.length)),qr=xr.returns;if(!qr)throw new Error("View expected return type");return Lt.fieldLayout({type:qr},Array.from([...(Lr=pr.accounts)!==null&&Lr!==void 0?Lr:[],...(Ur=pr.types)!==null&&Ur!==void 0?Ur:[]])).decode(Yr)}}}.build(br,Cr,Dt,ur),cr=Nn.build(wr,br,Cr,Tr,Mr,ar,Dt,sr,Or),yr=camelcase.exports(Cr.name);kr[yr]=Tr,Er[yr]=Mr,Sr[yr]=ar,Ir[yr]=Dt,Rr[yr]=cr,sr&&(Pr[yr]=sr)}),[Sr,kr,Er,Or,Ir,Rr,Nr,Pr]}}.build(Re,this._coder,Fe,We);this.rpc=Ze,this.instruction=Xe,this.transaction=Je,this.account=tr,this.simulate=er,this.methods=ir,this.state=lr,this.views=fr}get programId(){return this._programId}get idl(){return this._idl}get coder(){return this._coder}get provider(){return this._provider}static async at(Re,Fe){const We=L(Re),qe=await Vn.fetchIdl(We,Fe);if(!qe)throw new Error(`IDL not found for program: ${Re.toString()}`);return new Vn(qe,We,Fe)}static async fetchIdl(Re,Fe){Fe=Fe!=null?Fe:lt();const We=L(Re),qe=await async function(er){const ir=(await PublicKey.findProgramAddress([],er))[0];return await PublicKey.createWithSeed(ir,"anchor:idl",er)}(We),Ze=await Fe.connection.getAccountInfo(qe);if(!Ze)return null;let Xe=(Je=Ze.data.slice(8),gn.decode(Je));var Je;const tr=inflate_1(Xe.data);return JSON.parse(v(tr))}addEventListener(Re,Fe){return this._events.addEventListener(Re,Fe)}async removeEventListener(Re){return await this._events.removeEventListener(Re)}}new PublicKey("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL");new PublicKey("11111111111111111111111111111111");const _keypair={publicKey:{0:113,1:111,2:234,3:67,4:72,5:32,6:190,7:55,8:243,9:64,10:43,11:46,12:158,13:18,14:99,15:146,16:76,17:163,18:117,19:206,20:240,21:94,22:91,23:57,24:27,25:128,26:91,27:114,28:231,29:225,30:146,31:185},secretKey:{0:161,1:133,2:44,3:68,4:54,5:36,6:149,7:153,8:20,9:232,10:86,11:88,12:169,13:165,14:108,15:110,16:173,17:249,18:226,19:38,20:41,21:224,22:174,23:49,24:230,25:104,26:17,27:26,28:191,29:247,30:27,31:236,32:113,33:111,34:234,35:67,36:72,37:32,38:190,39:55,40:243,41:64,42:43,43:46,44:158,45:18,46:99,47:146,48:76,49:163,50:117,51:206,52:240,53:94,54:91,55:57,56:27,57:128,58:91,59:114,60:231,61:225,62:146,63:185}},KeyPair={_keypair},network=clusterApiUrl(NETWORK),opts={preflightCommitment:"processed"},programID=new PublicKey(PROGRAM_KEY),getProvider=()=>{const Ke=new Connection(network,opts.preflightCommitment);return new st(Ke,window.solana,opts)},connectWallet=async()=>{const Ke=window.solana;if(!Ke)throw new Error("no solana connection");if(await Ke.connect({onlyIfTrusted:!1}),!Ke.isPhantom)throw new Error("no phnatom connection");return Ke},getBaseAccount=()=>{const Ke=Object.values(KeyPair._keypair.secretKey),Re=new Uint8Array(Ke);return Keypair.fromSecretKey(Re)},getProgram=async()=>{const Ke=getProvider(),Re=await Vn.fetchIdl(programID,Ke);return new Vn(Re,programID,Ke)},baseAccount=getBaseAccount(),createGifAccount=async()=>{try{const Ke=getProvider(),Re=await getProgram();console.log("createGifAccount"),console.log("provider.wallet.publicKey",Ke.wallet.publicKey.toString()),await Re.methods.startStuffOff().accounts({baseAccount:baseAccount.publicKey,user:Ke.wallet.publicKey,systemProgram:SystemProgram.programId}).signers([baseAccount]).rpc(),console.log("Created a new BaseAccount w/ address:",baseAccount.publicKey.toString())}catch(Ke){console.log("123 error: ",Ke)}},getGifList=async()=>{const Fe=(await(await getProgram()).account.baseAccount.fetch(baseAccount.publicKey)).gifList;return Fe||[]},sendGif=async Ke=>{if(Ke.length<=0)return console.log("Empty input. Try again.");const Re=getProvider(),Fe=await getProgram();console.log("program",Fe),await Fe.methods.addGif(Ke).accounts({baseAccount:baseAccount.publicKey,user:Re.wallet.publicKey}).rpc(),console.log("success added gif")},voteGif=async Ke=>{if(Ke.length<=0)return console.log("Empty input. Try again.");const Re=getProvider(),Fe=await getProgram();try{await Fe.methods.voteGif(Ke).accounts({baseAccount:baseAccount.publicKey,user:Re.wallet.publicKey}).rpc()}catch(We){console.log("error",We)}console.log("success voted gif")};function Likes({value:Ke=0,onChange:Re=()=>null}){const[Fe,We]=p(!1),[qe,Ze]=p(!1),[Xe,Je]=p(Ke),tr=T$2(async()=>{Ze(!0),await Re(!0),We(!0),Je(er=>er+1),Ze(!1)},[Re]);return Fe?o("div",{className:"text-red-500 flex items-center cursor-not-allowed",children:[o("svg",{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 24 24",fill:"currentColor",className:"w-5 h-5",children:o("path",{d:"M11.645 20.91l-.007-.003-.022-.012a15.247 15.247 0 01-.383-.218 25.18 25.18 0 01-4.244-3.17C4.688 15.36 2.25 12.174 2.25 8.25 2.25 5.322 4.714 3 7.688 3A5.5 5.5 0 0112 5.052 5.5 5.5 0 0116.313 3c2.973 0 5.437 2.322 5.437 5.25 0 3.925-2.438 7.111-4.739 9.256a25.175 25.175 0 01-4.244 3.17 15.247 15.247 0 01-.383.219l-.022.012-.007.004-.003.001a.752.752 0 01-.704 0l-.003-.001z"})}),o("span",{className:"px-1",children:Xe})]}):o("button",{disabled:qe,className:cl("text-red-500 flex items-center",{"animate-pulse cursor-not-allowed":qe}),onClick:tr,children:[o("svg",{xmlns:"http://www.w3.org/2000/svg",fill:"none",viewBox:"0 0 24 24",strokeWidth:2,stroke:"currentColor",className:"w-5 h-5",children:o("path",{strokeLinecap:"round",strokeLinejoin:"round",d:"M21 8.25c0-2.485-2.099-4.5-4.688-4.5-1.935 0-3.597 1.126-4.312 2.733-.715-1.607-2.377-2.733-4.313-2.733C5.1 3.75 3 5.765 3 8.25c0 7.22 9 12 9 12s9-4.78 9-12z"})}),o("span",{className:"px-1",children:Ke})]})}function ImagePreview({item:Ke}){p(!1);const Re=F$2(()=>Ke.userAddress.toString(),[Ke]),Fe=F$2(()=>Ke.votes.length,[Ke]),We=T$2(async()=>voteGif(Ke.gifLink),[Ke]);return o("div",{className:"h-full border-2 border-black rounded-xl p-2 py-0 flex flex-col z-10 bg-white shadow-[6px_6px_0_0_#000]",children:[o("div",{className:"py-2 px-1 flex justify-between items-center",children:[o("img",{className:"h-8 w-8 rounded-full border border-stone-200",src:"https://avatars.githubusercontent.com/t/6813046?s=280&v=4"}),o("div",{className:"truncate pl-8",children:o("span",{children:Re})})]}),o("img",{className:"w-full h-full max-h-64 rounded-xl border border-stone-200",src:Ke.gifLink}),o("div",{className:"py-2 px-1 flex justify-between items-center space-x-2",children:[o(Likes,{value:Fe,onChange:We}),o("button",{className:"text-green-600 flex justify-between items-center",children:o("span",{className:"text-xs",children:"Donate"})})]})]})}const base="_base_ezksi_1",styles_module={base},usePhantomWallet=()=>{const[Ke,Re]=p(null),Fe=T$2(async()=>{const We=await connectWallet();Re(We.publicKey.toString())},[]);return[Ke,Fe]};function App(){const[Ke,Re]=p([]),[Fe,We]=p(!1),[qe,Ze]=p(!1),[Xe,Je]=usePhantomWallet(),tr=F$2(()=>(Ke==null?void 0:Ke.length)>0&&Xe,[Xe,Ke]),er=T$2(async()=>{try{We(!0);const br=await getGifList();if(!br)return;const wr=br==null?void 0:br.filter(Sr=>Sr.gifLink);Re(wr),Ze(!0)}catch(br){console.log("error",br)}finally{We(!1)}},[]),ir=T$2(async()=>{try{We(!0),await createGifAccount()}finally{We(!1)}await er()},[er]);h(()=>{Xe&&async function(){await er()}()},[Xe,er]);const lr=T$2(async()=>{try{We(!0),await Je()}finally{We(!1)}},[Je]),fr=T$2(async br=>{try{We(!0),await sendGif(br),await er()}catch(wr){console.log("error",wr)}finally{We(!1)}},[er]),ur=T$2(async(br,{reset:wr})=>{await fr(br.gifLink),wr()},[fr]),mr=T$2(()=>Xe?!qe&&!Fe?o("button",{onClick:ir,className:" m-auto flex items-center justify-center rounded-xl border-2 border-black px-6 py-2 font-bold shadow-[6px_6px_0_0_#000] transition hover:shadow-none focus:outline-none focus:ring ring-purple-500/50 active:bg-purple-200/50 max-w-xs",children:["Create account",o("span",{"aria-hidden":"true",className:"ml-1.5",role:"img",children:"\u{1F517}"})]}):o("div",{className:cl("w-full max-w-2xl m-auto"),children:o(GifLinkForm,{onSubmit:ur})}):o("button",{onClick:lr,className:" m-auto flex items-center justify-center rounded-xl border-2 border-black px-6 py-2 font-bold shadow-[6px_6px_0_0_#000] transition hover:shadow-none focus:outline-none focus:ring ring-purple-500/50 active:bg-purple-200/50 max-w-xs",children:"Connect Wallet"}),[Xe,Fe,ir,qe,ur,lr]);return o(p$1,{children:o("div",{className:"min-h-screen p-4 md:p-12 flex flex-col",children:[Fe&&o("div",{className:"fixed top-6 left-6 opacity-85 animate-in rounded-full fade-in shadow-xl flex justify-center items-center bg-white",children:o("svg",{className:"animate-spin -ml-1 h-8 w-8 text-purple-900",xmlns:"http://www.w3.org/2000/svg",fill:"none",viewBox:"0 0 24 24",children:[o("circle",{className:"opacity-25",cx:"12",cy:"12",r:"10",stroke:"currentColor",strokeWidth:"4"}),o("path",{className:"opacity-75",fill:"currentColor",d:"M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"})]})}),o("section",{className:cl("text-black flex justify-center transition-transform duration-700",{"translate-y-20":!qe}),children:o("div",{className:"w-full max-w-screen-xl py-32 lg:flex lg:items-center flex justify-center",children:o("div",{className:"max-w-3xl text-center flex flex-col justify-center items-center space-y-12 w-full",children:[o("div",{className:"flex flex-col justify-center items-center space-y-3",children:[o("h1",{className:"text-4xl sm:text-5xl font-extrabold text-center",children:o("span",{className:"text-center text-transparent bg-clip-text bg-gradient-to-r from-green-500 via-black  to-purple-600",children:"Solana Gif Portal"})}),o("p",{className:"max-w-xl sm:text-xl sm:leading-relaxed",children:["View your GIF collection in"," ",o("span",{className:"text-transparent bg-clip-text bg-gradient-to-r from-black  to-purple-800",children:"the metaverse"})," ","\u2728"]})]}),o("div",{className:cl("w-full",{"opacity-50 animate-pulse cursor-not-allowed":Fe}),children:mr()})]})})}),tr&&o("section",{className:"",children:o("div",{children:o("div",{className:"grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-6",children:Ke.reverse().map((br,wr)=>o("div",{children:o(ImagePreview,{item:br})},wr))})})}),o("div",{className:"absolute top-3 right-6 space-x-5",children:[o("a",{href:"https://github.com/maksim-romanov/solana-gif-portal",target:"_blank",className:"inline-block text-sm cursor-pointer text-transparent bg-clip-text bg-gradient-to-r from-green-500 to-purple-600 grayscale hover:grayscale-0 font-bold opacity-30 hover:opacity-100",rel:"noreferrer",children:"Github"}),o("a",{href:"https://t.me/romanovmaksim",target:"_blank",className:"inline-block text-sm cursor-pointer text-transparent bg-clip-text bg-gradient-to-r from-green-500 to-blue-400 grayscale hover:grayscale-0 font-bold opacity-30 hover:opacity-100",rel:"noreferrer",children:"Telegram"}),o("a",{href:"https://explorer.solana.com/address/DByFcag9yDLwRGnBCT8bJpJPM7akth4dpHXosf7eaB7s?cluster=devnet",target:"_blank",className:"inline-block text-sm cursor-pointer text-transparent bg-clip-text bg-gradient-to-r from-green-800 to-green-500 grayscale hover:grayscale-0 font-bold opacity-30 hover:opacity-100",rel:"noreferrer",children:"SOL Explorer"})]})]})})}P$2(o(App,{}),document.getElementById("app"));
